//go:build go1.22

// Package enrollmentv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package enrollmentv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/enrollment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseConsentsAuthorizationErrorsCode.
const (
	N422ResponseConsentsAuthorizationErrorsCodeCONTADEBITODIVERGENTECONSENTIMENTOVINCULO N422ResponseConsentsAuthorizationErrorsCode = "CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO"
	N422ResponseConsentsAuthorizationErrorsCodeERROIDEMPOTENCIA                          N422ResponseConsentsAuthorizationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseConsentsAuthorizationErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA      N422ResponseConsentsAuthorizationErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETROINVALIDO                         N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETRONAOINFORMADO                     N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseConsentsAuthorizationErrorsCodeRISCO                                     N422ResponseConsentsAuthorizationErrorsCode = "RISCO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSCONSENTIMENTOINVALIDO               N422ResponseConsentsAuthorizationErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSVINCULOINVALIDO                     N422ResponseConsentsAuthorizationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorCancelEnrollmentErrorsCode.
const (
	N422ResponseErrorCancelEnrollmentErrorsCodeERROIDEMPOTENCIA          N422ResponseErrorCancelEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREJEICAO            N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REJEICAO"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREVOGACAO           N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REVOGACAO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETROINVALIDO         N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETRONAOINFORMADO     N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCancelEnrollmentErrorsCodeREJEITADOOUTROSEMDETALHES N422ResponseErrorCancelEnrollmentErrorsCode = "REJEITADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeREVOGADOOUTROSEMDETALHES  N422ResponseErrorCancelEnrollmentErrorsCode = "REVOGADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeSTATUSINVALIDO            N422ResponseErrorCancelEnrollmentErrorsCode = "STATUS_INVALIDO"
)

// Defines values for N422ResponseErrorCreateEnrollmentErrorsCode.
const (
	N422ResponseErrorCreateEnrollmentErrorsCodeCONTAINVALIDA         N422ResponseErrorCreateEnrollmentErrorsCode = "CONTA_INVALIDA"
	N422ResponseErrorCreateEnrollmentErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorCreateEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETROINVALIDO     N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreateEnrollmentErrorsCodePERMISSOESINVALIDAS   N422ResponseErrorCreateEnrollmentErrorsCode = "PERMISSOES_INVALIDAS"
)

// Defines values for N422ResponseErrorFidoRegistrationErrorsCode.
const (
	N422ResponseErrorFidoRegistrationErrorsCodeCHALLENGEINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "CHALLENGE_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationErrorsCodeEXTENSIONINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "EXTENSION_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeORIGEMFIDOINVALIDA    N422ResponseErrorFidoRegistrationErrorsCode = "ORIGEM_FIDO_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationErrorsCodePUBLICKEYINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "PUBLIC_KEY_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeRPIDHASHINVALIDO      N422ResponseErrorFidoRegistrationErrorsCode = "RP_ID_HASH_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoRegistrationOptionsErrorsCode.
const (
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeRPINVALIDA            N422ResponseErrorFidoRegistrationOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoSignOptionsErrorsCode.
const (
	N422ResponseErrorFidoSignOptionsErrorsCodeERROIDEMPOTENCIA            N422ResponseErrorFidoSignOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETROINVALIDO           N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETRONAOINFORMADO       N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoSignOptionsErrorsCodeRPINVALIDA                  N422ResponseErrorFidoSignOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSCONSENTIMENTOINVALIDO N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSVINCULOINVALIDO       N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorRiskSignalsErrorsCode.
const (
	ERROIDEMPOTENCIA                     N422ResponseErrorRiskSignalsErrorsCode = "ERRO_IDEMPOTENCIA"
	FALTAMSINAISOBRIGATORIOSDAPLATAFORMA N422ResponseErrorRiskSignalsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	PARAMETROINVALIDO                    N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_INVALIDO"
	PARAMETRONAOINFORMADO                N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	STATUSVINCULOINVALIDO                N422ResponseErrorRiskSignalsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for ConsentAuthorizationDataRiskSignalsGeolocationType.
const (
	COARSE   ConsentAuthorizationDataRiskSignalsGeolocationType = "COARSE"
	FINE     ConsentAuthorizationDataRiskSignalsGeolocationType = "FINE"
	INFERRED ConsentAuthorizationDataRiskSignalsGeolocationType = "INFERRED"
)

// Defines values for EnrollmentFidoOptionsInputDataPlatform.
const (
	EnrollmentFidoOptionsInputDataPlatformANDROID       EnrollmentFidoOptionsInputDataPlatform = "ANDROID"
	EnrollmentFidoOptionsInputDataPlatformBROWSER       EnrollmentFidoOptionsInputDataPlatform = "BROWSER"
	EnrollmentFidoOptionsInputDataPlatformCROSSPLATFORM EnrollmentFidoOptionsInputDataPlatform = "CROSS_PLATFORM"
	EnrollmentFidoOptionsInputDataPlatformIOS           EnrollmentFidoOptionsInputDataPlatform = "IOS"
)

// Defines values for EnrollmentRejectionReason.
const (
	REJEITADODISPOSITIVOINCOMPATIVEL              EnrollmentRejectionReason = "REJEITADO_DISPOSITIVO_INCOMPATIVEL"
	REJEITADOFALHAFIDO                            EnrollmentRejectionReason = "REJEITADO_FALHA_FIDO"
	REJEITADOFALHAHYBRIDFLOW                      EnrollmentRejectionReason = "REJEITADO_FALHA_HYBRID_FLOW"
	REJEITADOFALHAINFRAESTRUTURA                  EnrollmentRejectionReason = "REJEITADO_FALHA_INFRAESTRUTURA"
	REJEITADOMANUALMENTE                          EnrollmentRejectionReason = "REJEITADO_MANUALMENTE"
	REJEITADOMAXIMOCHALLENGESATINGIDO             EnrollmentRejectionReason = "REJEITADO_MAXIMO_CHALLENGES_ATINGIDO"
	REJEITADOOUTRO                                EnrollmentRejectionReason = "REJEITADO_OUTRO"
	REJEITADOSEGURANCAINTERNA                     EnrollmentRejectionReason = "REJEITADO_SEGURANCA_INTERNA"
	REJEITADOTEMPOEXPIRADOACCOUNTHOLDERVALIDATION EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION"
	REJEITADOTEMPOEXPIRADOENROLLMENT              EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ENROLLMENT"
	REJEITADOTEMPOEXPIRADORISKSIGNALS             EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS"
)

// Defines values for EnrollmentRevocationReason.
const (
	REVOGADOFALHAINFRAESTRUTURA EnrollmentRevocationReason = "REVOGADO_FALHA_INFRAESTRUTURA"
	REVOGADOMANUALMENTE         EnrollmentRevocationReason = "REVOGADO_MANUALMENTE"
	REVOGADOOUTRO               EnrollmentRevocationReason = "REVOGADO_OUTRO"
	REVOGADOSEGURANCAINTERNA    EnrollmentRevocationReason = "REVOGADO_SEGURANCA_INTERNA"
	REVOGADOVALIDADEEXPIRADA    EnrollmentRevocationReason = "REVOGADO_VALIDADE_EXPIRADA"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumEnrollmentCancelledFrom.
const (
	DETENTORA  EnumEnrollmentCancelledFrom = "DETENTORA"
	INICIADORA EnumEnrollmentCancelledFrom = "INICIADORA"
)

// Defines values for EnumEnrollmentPermission.
const (
	PAYMENTSINITIATE EnumEnrollmentPermission = "PAYMENTS_INITIATE"
)

// Defines values for EnumEnrollmentStatus.
const (
	AUTHORISED                      EnumEnrollmentStatus = "AUTHORISED"
	AWAITINGACCOUNTHOLDERVALIDATION EnumEnrollmentStatus = "AWAITING_ACCOUNT_HOLDER_VALIDATION"
	AWAITINGENROLLMENT              EnumEnrollmentStatus = "AWAITING_ENROLLMENT"
	AWAITINGRISKSIGNALS             EnumEnrollmentStatus = "AWAITING_RISK_SIGNALS"
	REJECTED                        EnumEnrollmentStatus = "REJECTED"
	REVOKED                         EnumEnrollmentStatus = "REVOKED"
)

// Defines values for EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform.
const (
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformANDROID       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "ANDROID"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformBROWSER       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "BROWSER"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformCROSSPLATFORM EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "CROSS_PLATFORM"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformIOS           EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "IOS"
)

// N422ResponseConsentsAuthorization defines model for 422ResponseConsentsAuthorization.
type N422ResponseConsentsAuthorization struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseConsentsAuthorizationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento inválido.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Falta de sinais obrigatórios para a plataforma do usuário.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseConsentsAuthorizationErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseConsentsAuthorizationErrorsCode string

// N422ResponseErrorCancelEnrollment defines model for 422ResponseErrorCancelEnrollment.
type N422ResponseErrorCancelEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos no cancelamento do vínculo de conta:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCancelEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta deve estar associada a um motivo de rejeição.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta deve estar associada a um motivo de revogação.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_INVALIDO: Status inválido.
		// - MOTIVO_REJEICAO: Motivo de rejeição não especificado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - MOTIVO_REVOGACAO: Motivo de revogação não especificado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCancelEnrollmentErrorsCode Códigos de erros previstos no cancelamento do vínculo de conta:
// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCancelEnrollmentErrorsCode string

// N422ResponseErrorCreateEnrollment defines model for 422ResponseErrorCreateEnrollment.
type N422ResponseErrorCreateEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação do vínculo de conta:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCreateEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE" ou contêm valores não suportados para esta operação.
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - PERMISSOES_INVALIDAS: Permissões inválidas.
		// - CONTA_INVALIDA: Conta inválida.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCreateEnrollmentErrorsCode Códigos de erros previstos na criação do vínculo de conta:
// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCreateEnrollmentErrorsCode string

// N422ResponseErrorFidoRegistration defines model for 422ResponseErrorFidoRegistration.
type N422ResponseErrorFidoRegistration struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoRegistrationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_VINCULO_INVALIDO: Status inválido do vínculo de conta.
		// - ORIGEM_FIDO_INVALIDA: "Origin" não pode ser verificada.
		// - RP_INVALIDA: "RpIdHash" não pode ser verificado.
		// - CHALLENGE_INVALIDO: Challenge inválido.
		// - PUBLIC_KEY_INVALIDA: Chave pública inválida.
		// - EXTENSION_INVALIDA: Extensões inválidas.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationErrorsCode Códigos de erros previstos:
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationErrorsCode string

// N422ResponseErrorFidoRegistrationOptions defines model for 422ResponseErrorFidoRegistrationOptions.
type N422ResponseErrorFidoRegistrationOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoRegistrationOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationOptionsErrorsCode string

// N422ResponseErrorFidoSignOptions defines model for 422ResponseErrorFidoSignOptions.
type N422ResponseErrorFidoSignOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoSignOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento de pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoSignOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoSignOptionsErrorsCode string

// N422ResponseErrorRiskSignals defines model for 422ResponseErrorRiskSignals.
type N422ResponseErrorRiskSignals struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorRiskSignalsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorRiskSignalsErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorRiskSignalsErrorsCode string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentAuthorization defines model for ConsentAuthorization.
type ConsentAuthorization struct {
	// Data Objeto que contém sinais de risco e o id do vínculo de conta para avaliação da autorização de um consentimento de pagamento.
	Data struct {
		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// FidoAssertion Dados da asserção
		FidoAssertion struct {
			// ClientExtensionResults Estrutura para extensão de resultados
			ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

			// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública utilizada no processo de autenticação.
			ID string `json:"id"`

			// RawID Identificador da credencial. Para envio à detentora de conta, o valor deste atributo deve ser idêntico ao valor do atributo id.
			RawID string `json:"rawId"`

			// Response Traz as informações da resposta a asserção.
			Response struct {
				// AuthenticatorData Representa a estrutura de dados do autenticador. Deve ser enviado no formato base64url para a detentora de conta.
				AuthenticatorData string `json:"authenticatorData"`

				// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado no formato base64url para a detentora de conta.
				ClientDataJSON string `json:"clientDataJSON"`

				// Signature Sequência de bytes contendo a assinatura. Deve ser enviado no formato base64url para a detentora de conta.
				Signature string `json:"signature"`

				// UserHandle Nome de usuário que foi enviado durante a criação da credencial. Deve ser enviado no formato base64url para a detentora de conta.
				// Caso o autenticador FIDO2 não retorne este campo, a iniciadora deve enviar uma string vazia à detentora de conta.
				UserHandle string `json:"userHandle"`
			} `json:"response"`

			// Type Tipo da credencial.
			Type string `json:"type"`
		} `json:"fidoAssertion"`

		// RiskSignals Conjunto de sinais extraídos do dispositivo do usuário para ativação do consentimento de pagamento.
		// A obrigatoriedade das informações variam de acordo com a plataforma utilizada.
		RiskSignals struct {
			// AccountTenure Data de cadastro do cliente na iniciadora.
			AccountTenure timeutil.BrazilDate `json:"accountTenure"`

			// AntennaInformation Indica em qual antena o dispositivo está conectado.
			AntennaInformation *string `json:"antennaInformation,omitempty"`

			// DeviceID ID único do dispositivo gerado pela plataforma.
			//
			// Utiliza-se a propriedade do sistema que identifica a combinação de usuário logado, chave de assinatura do aplicativo e dispositivo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor/).
			DeviceID string `json:"deviceId"`

			// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/SystemClock#elapsedRealtime%28%29).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/kernel/kern/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

			// Geolocation Localização do usuário, obtida com seu consentimento.
			//
			// [Android] Informação obtida através do [link](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-abstract-tasklocation-getlastlocation) considerando as permissões necessárias.
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/corelocation/).
			//
			// [Restrição] A ITP deve solicitar ao usuário a permissão para compartilhamento de sua localização. Este campo poderá ser omitido caso o GPS esteja indisponível, isto é, sem sinal, ou em dispositivos sem o hardware necessário; ou caso o usuário negue o consentimento.
			Geolocation *struct {
				Latitude  *float32                                            `json:"latitude,omitempty"`
				Longitude *float32                                            `json:"longitude,omitempty"`
				Type      *ConsentAuthorizationDataRiskSignalsGeolocationType `json:"type,omitempty"`
			} `json:"geolocation,omitempty"`

			// Integrity Informa a integridade do dispositivo e app.
			//
			// [Android] Conforme documentação Play API Integrity, [link](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
			//
			// [iOS] Conforme documentação App Attest, [link](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity).
			Integrity *struct {
				// AppRecognitionVerdict Informa a integridade do app
				AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

				// DeviceRecognitionVerdict Informa a integridade do dispositivo
				DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
			} `json:"integrity,omitempty"`

			// IsCallInProgress Indica chamada ativa no momento do vínculo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/media/AudioManager#getMode()).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/callkit/).
			//
			// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
			IsCallInProgress *bool `json:"isCallInProgress,omitempty"`

			// IsCharging Indica se a bateria do dispositivo está sendo carregada.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/BatteryManager).
			//
			// [iOS] Informações obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620045-batterymonitoringenabled/).
			IsCharging *bool `json:"isCharging,omitempty"`

			// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
			IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

			// IsEmulated Indica se o dispositivo é emulado ou real.
			IsEmulated *bool `json:"isEmulated,omitempty"`

			// IsMockGPS Indica se o dispositivo está usando um GPS falso. Deve ser enviado sempre que exista o campo geolocation com tipo `COARSE` ou `FINE`.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/location/Location.html#isMock()) ou, para versões anteriores à 12, [link](https://developer.android.com/reference/android/location/Location.html#isFromMockProvider()).
			//
			// [iOS] Informação obtida através dos links:
			// sourceInformation, [link](https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation).
			// isSimulatedBySoftware, [link](https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware).
			IsMockGPS *bool `json:"isMockGPS,omitempty"`

			// IsMonkeyRunner Indica o uso do MonkeyRunner.
			IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

			// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

			// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
			IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

			// Language Indica o idioma do dispositivo no formato ISO 639-1.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/util/Locale#getLanguage()).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/foundation/locale/languagecode/).
			Language string `json:"language"`

			// OsVersion Versão do sistema operacional.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/Build.VERSION#RELEASE).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620043-systemversion/).
			OsVersion string `json:"osVersion"`

			// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
			//
			// [Android] O valor é inteiro, tipicamente entre 0 a 255, podendo a faixa de valores variar de acordo com o fabricante do celular. Referência no [link](https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS).
			//
			// [iOS] O valor é ponto flutuante entre “0.0” e “1.0”. Referência no [link](https://developer.apple.com/documentation/uikit/uiscreen/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

			// ScreenDimensions Dimensões que o aplicativo ocupa na tela do dispositivo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/view/WindowMetrics#getBounds()), ou, para versões anteriores à 11, [link](https://developer.android.com/reference/android/util/DisplayMetrics).
			//
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/metal/mtlrasterizationratemap/3088873-screensize/).
			ScreenDimensions struct {
				// Height Altura da tela, em pixels.
				Height int `json:"height"`

				// Width Largura da tela, em pixels.
				Width int `json:"width"`
			} `json:"screenDimensions"`

			// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]. O formato especificado permite a omissão da parte correspondente aos minutos, caso esta última tenha valor zero. Assim, ambos os valores '-03:00' e '-03' são válidos e representam o mesmo fuso horário.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/time/ZonedDateTime#getOffset()) ou, para versões anteriores à 8.0, [link](https://developer.android.com/reference/java/util/TimeZone#getOffset(long)).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/foundation/timezone/).
			UserTimeZoneOffset string `json:"userTimeZoneOffset"`
		} `json:"riskSignals"`
	} `json:"data"`
}

// ConsentAuthorizationDataRiskSignalsGeolocationType defines model for ConsentAuthorization.Data.RiskSignals.Geolocation.Type.
type ConsentAuthorizationDataRiskSignalsGeolocationType string

// CreateEnrollment defines model for CreateEnrollment.
type CreateEnrollment struct {
	// Data Objeto contendo as informações para criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser              `json:"loggedUser"`
		Permissions []enrollment.Permission `json:"permissions"`
	} `json:"data"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	// CACC - Current - Conta Corrente.
	// SVGS - Savings - Conta de Poupança.
	// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EnrollmentFidoOptionsInput defines model for EnrollmentFidoOptionsInput.
type EnrollmentFidoOptionsInput struct {
	// Data Objeto que contém as informações sobre a Relying Party e a plataforma sobre a qual o usuário está utilizando o serviço da iniciadora para utilização de FIDO2.
	Data struct {
		// Platform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
		// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
		Platform EnrollmentFidoOptionsInputDataPlatform `json:"platform"`

		// Rp Identificador único da Relying Party, que corresponde ao valor do CN do certificado de transporte da iniciadora.
		Rp string `json:"rp"`
	} `json:"data"`
}

// EnrollmentFidoOptionsInputDataPlatform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
type EnrollmentFidoOptionsInputDataPlatform string

// EnrollmentFidoRegistration Objeto que contém a resposta da criação de uma nova credencial FIDO2.
type EnrollmentFidoRegistration struct {
	Data struct {
		// AuthenticatorAttachment Indica a forma de comunicação com o autenticador.
		AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

		// ClientExtensionResults Extensões da credencial, específicas por plataforma
		ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

		// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública criada no processo de registro do dispositivo.
		ID string `json:"id"`

		// RawID Identificador da credencial. Para envio ao detentor, o valor deste atributo deve ser idêntico ao valor do atributo id.
		RawID    string `json:"rawId"`
		Response struct {
			// AttestationObject Agrega as informações da chave pública da credencial. Deve ser enviado em formato base64url para o detentor.
			AttestationObject string `json:"attestationObject"`

			// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado em formato base64url para o detentor.
			ClientDataJSON string `json:"clientDataJSON"`
		} `json:"response"`

		// Type Tipo da credencial
		Type *string `json:"type,omitempty"`
	} `json:"data"`
}

// EnrollmentFidoRegistrationOptions defines model for EnrollmentFidoRegistrationOptions.
type EnrollmentFidoRegistrationOptions struct {
	// Data Objeto que contém as informações necessárias para registro de uma nova credencial FIDO2.
	Data struct {
		// Attestation Indica o tipo de attestation que o autenticador pode utilizar.
		Attestation *string `json:"attestation,omitempty"`

		// AttestationFormats Indica as preferências de formato sobre o campo attestation.
		AttestationFormats *[]string `json:"attestationFormats,omitempty"`

		// AuthenticatorSelection Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
		AuthenticatorSelection *FidoAuthenticatorSelectionCriteria `json:"authenticatorSelection,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID       EnrollmentID                         `json:"enrollmentId"`
		ExcludeCredentials *[]FidoPublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions       *map[string]interface{}                  `json:"extensions,omitempty"`
		PubKeyCredParams []FidoPublicKeyCredentialCreationOptions `json:"pubKeyCredParams"`
		Rp               FidoRelyingParty                         `json:"rp"`

		// Timeout Timeout, em milissegundos, para registro da credencial FIDO2.
		Timeout *int     `json:"timeout,omitempty"`
		User    FidoUser `json:"user"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentFidoSignOptions defines model for EnrollmentFidoSignOptions.
type EnrollmentFidoSignOptions struct {
	// Data Objeto que contém as informações necessárias para assinatura com uma credencial FIDO2 previamente registrada.
	Data struct {
		AllowCredentials *[]FidoPublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions *map[string]interface{} `json:"extensions,omitempty"`

		// RpID Identificador da Relying Party.
		RpID *string `json:"rpId,omitempty"`

		// Timeout Expiração, em milissegundos, do challenge.
		Timeout          *int32  `json:"timeout,omitempty"`
		UserVerification *string `json:"userVerification,omitempty"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentRejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
//
// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
//
// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
//
// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
//
// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
//
// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
//
// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
//
// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
//
// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
//
// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRejectionReason string

// EnrollmentRevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
//
// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
//
// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
//
// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRevocationReason string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
// CACC - Current - Conta Corrente.
// SVGS - Savings - Conta de Poupança.
// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumEnrollmentCancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
//
//	INICIADORA - Vínculo de conta nos canais da iniciadora.
//
//	DETENTORA - Vínculo de conta nos canais da detentora.
type EnumEnrollmentCancelledFrom string

// EnumEnrollmentPermission Permissões atribuídas ao vínculo de conta:
//
// • PAYMENTS_INITIATE: Iniciação de pagamentos sem redirecionamento à detentora.
type EnumEnrollmentPermission string

// EnumEnrollmentStatus Status do vínculo de conta:
//
// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
//
// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
//
// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
//
// • AUTHORISED: Vínculo de conta pronto para uso.
//
// • REVOKED: Vínculo de conta revogado.
//
// • REJECTED: Vínculo de conta rejeitado.
type EnumEnrollmentStatus string

// FidoAuthenticatorSelectionCriteria Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
type FidoAuthenticatorSelectionCriteria struct {
	// AuthenticatorAttachment Indica os tipos de autenticadores suportados (ex: Sistema Operacional ou Cross-Platform como uma chave USB)
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

	// RequireResidentKey Indica o requisito de verificação do usuário.
	RequireResidentKey *bool `json:"requireResidentKey,omitempty"`

	// ResidentKey Indica o requisito de verificação do usuário.
	ResidentKey *string `json:"residentKey,omitempty"`

	// UserVerification Indica o tipo de "discoverability" da credencial.
	UserVerification *string `json:"userVerification,omitempty"`
}

// FidoPublicKeyCredentialCreationOptions defines model for FidoPublicKeyCredentialCreationOptions.
type FidoPublicKeyCredentialCreationOptions struct {
	// Alg Identificador do algoritmo (COSE)
	Alg int `json:"alg"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoPublicKeyCredentialDescriptor defines model for FidoPublicKeyCredentialDescriptor.
type FidoPublicKeyCredentialDescriptor struct {
	// ID Identificador único da credencial.
	ID string `json:"id"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoRelyingParty defines model for FidoRelyingParty.
type FidoRelyingParty struct {
	// ID Identificador único da Relying Party. Esse campo deve ser preenchido com o valor que é enviado na requisição no campo /data/rp.
	ID string `json:"id"`

	// Name Nome amigável da Relying Party para exibição aos usuários. Deve ser obtido através do Software Statement Assertion, atributo software_client_name.
	Name string `json:"name"`
}

// FidoUser defines model for FidoUser.
type FidoUser struct {
	// DisplayName Identificador do usuário para fins de apresentação. Deve ser formado pelo nome social, se existente, ou nome e sobrenome do cadastro do cliente no detentor de contas.
	DisplayName string `json:"displayName"`

	// ID Identificador único do usuário sob registro em formato base64. A conversão deste valor para o formato original (BufferSource ou ArrayBuffer) não deve ultrapassar 64 bytes.
	// O identificador único deve ser opaco, ou seja, não deve carregar dados pessoais sobre o usuário, por exemplo (não exaustivo) um UUID RFC4122 cumpre com os requisitos desse campo
	ID string `json:"id"`

	// Name Identificador do usuário human-readable.
	Name string `json:"name"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ResponseCreateEnrollment defines model for ResponseCreateEnrollment.
type ResponseCreateEnrollment struct {
	// Data Objeto contendo as informações de resposta da criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollment defines model for ResponseEnrollment.
type ResponseEnrollment struct {
	// Data Objeto que agrupa as informações de qual foi o usuário logado que solicitou o cancelamento do vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Cancellation   *struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`

			// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do vínculo de conta.
			// Pode estar ausente em cenários de processos automatizados realizarem o cancelamento do vínculo, por exemplo, por data de expiração.
			CancelledBy *struct {
				// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
				Document struct {
					// Identification Número do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Identification string `json:"identification"`

					// Rel Tipo do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Rel string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`

			// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
			//
			//   INICIADORA - Vínculo de conta nos canais da iniciadora.
			//
			//   DETENTORA - Vínculo de conta nos canais da detentora.
			CancelledFrom EnumEnrollmentCancelledFrom                 `json:"cancelledFrom"`
			Reason        ResponseEnrollment_Data_Cancellation_Reason `json:"reason"`

			// RejectedAt Instante de rejeição do vínculo de conta no ambiente da detentora.
			RejectedAt *timeutil.DateTime `json:"rejectedAt,omitempty"`
		} `json:"cancellation,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DailyLimit Limite diário cumulativo para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos para valores tais que, garantidamente, não serão autorizados.
		// Este campo só estará presente quando o usuário, durante a autorização do vínculo, definir um valor máximo diário diferente do seu limite Pix disponível para o dia.
		DailyLimit    *string `json:"dailyLimit,omitempty"`
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento via Pix.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM para o escopo do Pix.
			// CACC - Current - Conta Corrente.
			// SVGS - Savings - Conta de Poupança.
			// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountPaymentsType `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionLimit Valor máximo, por transação, admitido para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos de valores tais que, garantidamente, não serão autorizados.
		//
		// [Restrição] Campo de preenchimento obrigatório pelos participantes quando o campo `status` for preenchido com os valores `AUTHORISED` ou `AWAITING_ENROLLMENT`.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollmentDataCancellationReason0 Motivo da rejeição do vínculo de conta.
type ResponseEnrollmentDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// ResponseEnrollmentDataCancellationReason1 Motivo da revogação do vínculo de conta.
type ResponseEnrollmentDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// ResponseEnrollment_Data_Cancellation_Reason defines model for ResponseEnrollment.Data.Cancellation.Reason.
type ResponseEnrollment_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// RiskSignals defines model for RiskSignals.
type RiskSignals struct {
	// Data Informa a integridade do dispositivo e app
	Data map[string]any `json:"data"`
}

// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type ConsentIDType = string

// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type EnrollmentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ParameterConsentID defines model for consentId.
type ParameterConsentID = string

// XBcbNfc defines model for x-bcb-nfc.
type XBcbNfc = bool

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200EnrollmentsEnrollmentIDRead defines model for 200EnrollmentsEnrollmentIdRead.
type N200EnrollmentsEnrollmentIDRead = ResponseEnrollment

// N201EnrollmentFidoRegistrationOptions defines model for 201EnrollmentFidoRegistrationOptions.
type N201EnrollmentFidoRegistrationOptions = EnrollmentFidoRegistrationOptions

// N201EnrollmentFidoSignOptions defines model for 201EnrollmentFidoSignOptions.
type N201EnrollmentFidoSignOptions = EnrollmentFidoSignOptions

// N201EnrollmentsCreated defines model for 201EnrollmentsCreated.
type N201EnrollmentsCreated = ResponseCreateEnrollment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// ForbiddenEnrollments defines model for ForbiddenEnrollments.
type ForbiddenEnrollments = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// AuthorizeConsentParams defines parameters for AuthorizeConsent.
type AuthorizeConsentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`

	// XBcbNfc O campo representa uma transação iniciada via NFC. O envio desse campo é obrigatório nesse cenário. As detentoras devem armazenar a informação e correlacioná-la com o consentimento e o pagamento originado.
	XBcbNfc *XBcbNfc `json:"x-bcb-nfc,omitempty"`
}

// PostEnrollmentsParams defines parameters for PostEnrollments.
type PostEnrollmentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// GetEnrollmentParams defines parameters for GetEnrollment.
type GetEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// DeleteEnrollmentJSONBody defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody struct {
	Data struct {
		Cancellation struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`
			CancelledBy           *struct {
				Document struct {
					Identification string `json:"identification"`
					Rel            string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`
			Reason DeleteEnrollmentJSONBody_Data_Cancellation_Reason `json:"reason"`
		} `json:"cancellation"`
	} `json:"data"`
}

// DeleteEnrollmentParams defines parameters for DeleteEnrollment.
type DeleteEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason0 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason1 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// DeleteEnrollmentJSONBody_Data_Cancellation_Reason defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// EnrollmentRegisterFidoCredentialParams defines parameters for EnrollmentRegisterFidoCredential.
type EnrollmentRegisterFidoCredentialParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoRegistrationOptionsParams defines parameters for EnrollmentCreateFidoRegistrationOptions.
type EnrollmentCreateFidoRegistrationOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBody defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBody struct {
	Data struct {
		// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentIDType ConsentIDType                                          `json:"consentId"`
		Platform      EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform `json:"platform"`
		Rp            string                                                 `json:"rp"`
	} `json:"data"`
}

// EnrollmentCreateFidoSigningOptionsParams defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform string

// RiskSignalsParams defines parameters for RiskSignals.
type RiskSignalsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AuthorizeConsentJSONRequestBody defines body for AuthorizeConsent for application/json ContentType.
type AuthorizeConsentJSONRequestBody = ConsentAuthorization

// PostEnrollmentsJSONRequestBody defines body for PostEnrollments for application/json ContentType.
type PostEnrollmentsJSONRequestBody = CreateEnrollment

// DeleteEnrollmentJSONRequestBody defines body for DeleteEnrollment for application/json ContentType.
type DeleteEnrollmentJSONRequestBody DeleteEnrollmentJSONBody

// EnrollmentRegisterFidoCredentialJSONRequestBody defines body for EnrollmentRegisterFidoCredential for application/json ContentType.
type EnrollmentRegisterFidoCredentialJSONRequestBody = EnrollmentFidoRegistration

// EnrollmentCreateFidoRegistrationOptionsJSONRequestBody defines body for EnrollmentCreateFidoRegistrationOptions for application/json ContentType.
type EnrollmentCreateFidoRegistrationOptionsJSONRequestBody = EnrollmentFidoOptionsInput

// EnrollmentCreateFidoSigningOptionsJSONRequestBody defines body for EnrollmentCreateFidoSigningOptions for application/json ContentType.
type EnrollmentCreateFidoSigningOptionsJSONRequestBody EnrollmentCreateFidoSigningOptionsJSONBody

// RiskSignalsJSONRequestBody defines body for RiskSignals for application/json ContentType.
type RiskSignalsJSONRequestBody = RiskSignals

// AsResponseEnrollmentDataCancellationReason0 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason0
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason0() (ResponseEnrollmentDataCancellationReason0, error) {
	var body ResponseEnrollmentDataCancellationReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason0 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason0 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseEnrollmentDataCancellationReason1 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason1
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason1() (ResponseEnrollmentDataCancellationReason1, error) {
	var body ResponseEnrollmentDataCancellationReason1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason1 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason1 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponseEnrollment_Data_Cancellation_Reason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponseEnrollment_Data_Cancellation_Reason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var parameterConsentID ParameterConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &parameterConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeConsentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	// ------------- Optional header parameter "x-bcb-nfc" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-bcb-nfc")]; found {
		var XBcbNfc XBcbNfc
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-bcb-nfc", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-bcb-nfc", valueList[0], &XBcbNfc, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-bcb-nfc", Err: err})
			return
		}

		params.XBcbNfc = &XBcbNfc

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthorizeConsent(w, r, parameterConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostEnrollments operation middleware
func (siw *ServerInterfaceWrapper) PostEnrollments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEnrollmentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostEnrollments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEnrollment operation middleware
func (siw *ServerInterfaceWrapper) GetEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteEnrollment operation middleware
func (siw *ServerInterfaceWrapper) DeleteEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentRegisterFidoCredential operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentRegisterFidoCredentialParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentRegisterFidoCredential(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoRegistrationOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoRegistrationOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoSigningOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoSigningOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RiskSignals operation middleware
func (siw *ServerInterfaceWrapper) RiskSignals(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RiskSignalsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RiskSignals(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents/{consentId}/authorise", wrapper.AuthorizeConsent)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments", wrapper.PostEnrollments)
	m.HandleFunc("GET "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.GetEnrollment)
	m.HandleFunc("PATCH "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.DeleteEnrollment)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration", wrapper.EnrollmentRegisterFidoCredential)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration-options", wrapper.EnrollmentCreateFidoRegistrationOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-sign-options", wrapper.EnrollmentCreateFidoSigningOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/risk-signals", wrapper.RiskSignals)

	return m
}

type N200EnrollmentsEnrollmentIDReadJSONResponse ResponseEnrollment

type N201EnrollmentFidoRegistrationOptionsJSONResponse EnrollmentFidoRegistrationOptions

type N201EnrollmentFidoSignOptionsJSONResponse EnrollmentFidoSignOptions

type N201EnrollmentsCreatedJSONResponse ResponseCreateEnrollment

type N204EnrollmentsEnrollmentIDDeleteResponse struct {
}

type N204EnrollmentsFidoRegistrationResponse struct {
}

type N204EnrollmentsRiskSignalsResponse struct {
}

type N204PaymentsConsentsAuthorizedResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsAuthorizationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentCancelApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type AuthorizeConsentRequestObject struct {
	ParameterConsentID ParameterConsentID `json:"consentId"`
	Params             AuthorizeConsentParams
	Body               *AuthorizeConsentJSONRequestBody
}

type AuthorizeConsentResponseObject interface {
	VisitAuthorizeConsentResponse(w http.ResponseWriter) error
}

type AuthorizeConsent204Response = N204PaymentsConsentsAuthorizedResponse

func (response AuthorizeConsent204Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AuthorizeConsent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent400ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent401ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent403ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent404ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent405ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent406ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent415ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsAuthorizationApplicationJwtResponse
}

func (response AuthorizeConsent422ApplicationJwtResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AuthorizeConsent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent500ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent529ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AuthorizeConsentdefaultJSONResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostEnrollmentsRequestObject struct {
	Params PostEnrollmentsParams
	Body   *PostEnrollmentsJSONRequestBody
}

type PostEnrollmentsResponseObject interface {
	VisitPostEnrollmentsResponse(w http.ResponseWriter) error
}

type PostEnrollments201JSONResponse struct {
	N201EnrollmentsCreatedJSONResponse
}

func (response PostEnrollments201JSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments400ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments401ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments403ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments404ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments405ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments406ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments415ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentApplicationJwtResponse
}

func (response PostEnrollments422ApplicationJwtResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostEnrollments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments500ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments529ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollmentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PostEnrollmentsdefaultJSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       GetEnrollmentParams
}

type GetEnrollmentResponseObject interface {
	VisitGetEnrollmentResponse(w http.ResponseWriter) error
}

type GetEnrollment200JSONResponse struct {
	N200EnrollmentsEnrollmentIDReadJSONResponse
}

func (response GetEnrollment200JSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment400ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment401ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment403ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment404ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment405ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment406ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment500ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment529ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response GetEnrollmentdefaultJSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       DeleteEnrollmentParams
	Body         *DeleteEnrollmentJSONRequestBody
}

type DeleteEnrollmentResponseObject interface {
	VisitDeleteEnrollmentResponse(w http.ResponseWriter) error
}

type DeleteEnrollment204Response = N204EnrollmentsEnrollmentIDDeleteResponse

func (response DeleteEnrollment204Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment400ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment401ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment403ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment404ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment405ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment406ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentCancelApplicationJwtResponse
}

func (response DeleteEnrollment422ApplicationJwtResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment500ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment529ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response DeleteEnrollmentdefaultJSONResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentRegisterFidoCredentialRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentRegisterFidoCredentialParams
	Body         *EnrollmentRegisterFidoCredentialJSONRequestBody
}

type EnrollmentRegisterFidoCredentialResponseObject interface {
	VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error
}

type EnrollmentRegisterFidoCredential204Response = N204EnrollmentsFidoRegistrationResponse

func (response EnrollmentRegisterFidoCredential204Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse
}

func (response EnrollmentRegisterFidoCredential422ApplicationJwtResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredentialdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentRegisterFidoCredentialdefaultJSONResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoRegistrationOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoRegistrationOptionsParams
	Body         *EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
}

type EnrollmentCreateFidoRegistrationOptionsResponseObject interface {
	VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoRegistrationOptions201JSONResponse struct {
	N201EnrollmentFidoRegistrationOptionsJSONResponse
}

func (response EnrollmentCreateFidoRegistrationOptions201JSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoSigningOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoSigningOptionsParams
	Body         *EnrollmentCreateFidoSigningOptionsJSONRequestBody
}

type EnrollmentCreateFidoSigningOptionsResponseObject interface {
	VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoSigningOptions201JSONResponse struct {
	N201EnrollmentFidoSignOptionsJSONResponse
}

func (response EnrollmentCreateFidoSigningOptions201JSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoSigningOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RiskSignalsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       RiskSignalsParams
	Body         *RiskSignalsJSONRequestBody
}

type RiskSignalsResponseObject interface {
	VisitRiskSignalsResponse(w http.ResponseWriter) error
}

type RiskSignals204Response = N204EnrollmentsRiskSignalsResponse

func (response RiskSignals204Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RiskSignals400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response RiskSignals400ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals401ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response RiskSignals403ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response RiskSignals404ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals405ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response RiskSignals406ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response RiskSignals415ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse
}

func (response RiskSignals422ApplicationJwtResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RiskSignals500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response RiskSignals500ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals529ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignalsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response RiskSignalsdefaultJSONResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(ctx context.Context, request AuthorizeConsentRequestObject) (AuthorizeConsentResponseObject, error)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(ctx context.Context, request PostEnrollmentsRequestObject) (PostEnrollmentsResponseObject, error)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(ctx context.Context, request GetEnrollmentRequestObject) (GetEnrollmentResponseObject, error)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(ctx context.Context, request DeleteEnrollmentRequestObject) (DeleteEnrollmentResponseObject, error)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(ctx context.Context, request EnrollmentRegisterFidoCredentialRequestObject) (EnrollmentRegisterFidoCredentialResponseObject, error)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(ctx context.Context, request EnrollmentCreateFidoRegistrationOptionsRequestObject) (EnrollmentCreateFidoRegistrationOptionsResponseObject, error)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(ctx context.Context, request EnrollmentCreateFidoSigningOptionsRequestObject) (EnrollmentCreateFidoSigningOptionsResponseObject, error)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(ctx context.Context, request RiskSignalsRequestObject) (RiskSignalsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AuthorizeConsent operation middleware
func (sh *strictHandler) AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams) {
	var request AuthorizeConsentRequestObject

	request.ParameterConsentID = parameterConsentID
	request.Params = params

	var body AuthorizeConsentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthorizeConsent(ctx, request.(AuthorizeConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthorizeConsent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthorizeConsentResponseObject); ok {
		if err := validResponse.VisitAuthorizeConsentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostEnrollments operation middleware
func (sh *strictHandler) PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams) {
	var request PostEnrollmentsRequestObject

	request.Params = params

	var body PostEnrollmentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostEnrollments(ctx, request.(PostEnrollmentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostEnrollments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostEnrollmentsResponseObject); ok {
		if err := validResponse.VisitPostEnrollmentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetEnrollment operation middleware
func (sh *strictHandler) GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams) {
	var request GetEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetEnrollment(ctx, request.(GetEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetEnrollmentResponseObject); ok {
		if err := validResponse.VisitGetEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteEnrollment operation middleware
func (sh *strictHandler) DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams) {
	var request DeleteEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body DeleteEnrollmentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteEnrollment(ctx, request.(DeleteEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteEnrollmentResponseObject); ok {
		if err := validResponse.VisitDeleteEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentRegisterFidoCredential operation middleware
func (sh *strictHandler) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams) {
	var request EnrollmentRegisterFidoCredentialRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentRegisterFidoCredentialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentRegisterFidoCredential(ctx, request.(EnrollmentRegisterFidoCredentialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentRegisterFidoCredential")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentRegisterFidoCredentialResponseObject); ok {
		if err := validResponse.VisitEnrollmentRegisterFidoCredentialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams) {
	var request EnrollmentCreateFidoRegistrationOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoRegistrationOptions(ctx, request.(EnrollmentCreateFidoRegistrationOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoRegistrationOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoRegistrationOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoRegistrationOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams) {
	var request EnrollmentCreateFidoSigningOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoSigningOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoSigningOptions(ctx, request.(EnrollmentCreateFidoSigningOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoSigningOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoSigningOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoSigningOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RiskSignals operation middleware
func (sh *strictHandler) RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams) {
	var request RiskSignalsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body RiskSignalsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RiskSignals(ctx, request.(RiskSignalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RiskSignals")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RiskSignalsResponseObject); ok {
		if err := validResponse.VisitRiskSignalsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
