//go:build go1.22

// Package accountv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package accountv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for EnumAccountSubType.
const (
	CONJUNTASIMPLES   EnumAccountSubType = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA EnumAccountSubType = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        EnumAccountSubType = "INDIVIDUAL"
)

// Defines values for EnumAccountType.
const (
	CONTADEPOSITOAVISTA   EnumAccountType = "CONTA_DEPOSITO_A_VISTA"
	CONTAPAGAMENTOPREPAGA EnumAccountType = "CONTA_PAGAMENTO_PRE_PAGA"
	CONTAPOUPANCA         EnumAccountType = "CONTA_POUPANCA"
)

// Defines values for EnumCompletedAuthorisedPaymentIndicator.
const (
	LANCAMENTOFUTURO     EnumCompletedAuthorisedPaymentIndicator = "LANCAMENTO_FUTURO"
	TRANSACAOEFETIVADA   EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_EFETIVADA"
	TRANSACAOPROCESSANDO EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_PROCESSANDO"
)

// Defines values for EnumCreditDebitIndicator.
const (
	CREDITO EnumCreditDebitIndicator = "CREDITO"
	DEBITO  EnumCreditDebitIndicator = "DEBITO"
)

// Defines values for EnumPartiePersonType.
const (
	PESSOAJURIDICA EnumPartiePersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPartiePersonType = "PESSOA_NATURAL"
)

// Defines values for EnumTransactionTypes.
const (
	BOLETO                        EnumTransactionTypes = "BOLETO"
	CARTAO                        EnumTransactionTypes = "CARTAO"
	CONVENIOARRECADACAO           EnumTransactionTypes = "CONVENIO_ARRECADACAO"
	DEPOSITO                      EnumTransactionTypes = "DEPOSITO"
	DOC                           EnumTransactionTypes = "DOC"
	ENCARGOSJUROSCHEQUEESPECIAL   EnumTransactionTypes = "ENCARGOS_JUROS_CHEQUE_ESPECIAL"
	FOLHAPAGAMENTO                EnumTransactionTypes = "FOLHA_PAGAMENTO"
	OPERACAOCREDITO               EnumTransactionTypes = "OPERACAO_CREDITO"
	OUTROS                        EnumTransactionTypes = "OUTROS"
	PACOTETARIFASERVICOS          EnumTransactionTypes = "PACOTE_TARIFA_SERVICOS"
	PIX                           EnumTransactionTypes = "PIX"
	PORTABILIDADESALARIO          EnumTransactionTypes = "PORTABILIDADE_SALARIO"
	RENDIMENTOAPLICFINANCEIRA     EnumTransactionTypes = "RENDIMENTO_APLIC_FINANCEIRA"
	RESGATEAPLICFINANCEIRA        EnumTransactionTypes = "RESGATE_APLIC_FINANCEIRA"
	SAQUE                         EnumTransactionTypes = "SAQUE"
	TARIFASERVICOSAVULSOS         EnumTransactionTypes = "TARIFA_SERVICOS_AVULSOS"
	TED                           EnumTransactionTypes = "TED"
	TRANSFERENCIAMESMAINSTITUICAO EnumTransactionTypes = "TRANSFERENCIA_MESMA_INSTITUICAO"
)

// AccountBalancesData Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountBalancesData struct {
	// AutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AutomaticallyInvestedAmount AccountBalancesDataAutomaticallyInvestedAmount `json:"automaticallyInvestedAmount"`

	// AvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AvailableAmount AccountBalancesDataAvailableAmount `json:"availableAmount"`

	// BlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	BlockedAmount AccountBalancesDataBlockedAmount `json:"blockedAmount"`

	// UpdateDateTime Data e hora da última atualização do saldo. É esperado que a instituição informe a última vez que capturou o saldo para compartilhamento no Open Finance. Dessa forma, é possível que:
	// - Caso a instituição capture dados de forma síncrona essa informação seja de poucos momentos;
	// - Caso a instituição capture dados de forma assíncrona essa informação seja de horas ou dias no passado;
	// - Quando não existente uma data vinculada especificamente ao bloco, se assume a data e hora de atualização do cadastro como um todo.
	//
	// De toda forma, é preciso continuar respeitando o prazo máximo de tempestividade da API de Contas.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// AccountBalancesDataAutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAutomaticallyInvestedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataAvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAvailableAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataBlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataBlockedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountData defines model for AccountData.
type AccountData struct {
	// AccountID Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
	AccountID string `json:"accountId"`

	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de CONTA_PAGAMENTO_PRE_PAGA.
	BranchCode *string `json:"branchCode,omitempty"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj string `json:"companyCnpj"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountIdentificationData Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountIdentificationData struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré-paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	CompeCode string `json:"compeCode"`

	// Currency Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
	// Todos os saldos informados estão representados com a moeda vigente do Brasil
	Currency string `json:"currency"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
	Subtype EnumAccountSubType `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountOverdraftLimitsData Conjunto de informações da Conta de: depósito à vista
type AccountOverdraftLimitsData struct {
	// OverdraftContractedLimit Valor do limite contratado do cheque especial.
	OverdraftContractedLimit *AccountOverdraftLimitsDataOverdraftContractedLimit `json:"overdraftContractedLimit,omitempty"`

	// OverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
	OverdraftUsedLimit *AccountOverdraftLimitsDataOverdraftUsedLimit `json:"overdraftUsedLimit,omitempty"`

	// UnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
	UnarrangedOverdraftAmount *AccountOverdraftLimitsDataUnarrangedOverdraftAmount `json:"unarrangedOverdraftAmount,omitempty"`
}

// AccountOverdraftLimitsDataOverdraftContractedLimit Valor do limite contratado do cheque especial.
type AccountOverdraftLimitsDataOverdraftContractedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataOverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
type AccountOverdraftLimitsDataOverdraftUsedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataUnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
type AccountOverdraftLimitsDataUnarrangedOverdraftAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountTransactionsData defines model for AccountTransactionsData.
type AccountTransactionsData struct {
	// CompletedAuthorisedPaymentType Indicador da transação:
	//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
	//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
	//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
	CompletedAuthorisedPaymentType EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

	// CreditDebitType Indicador do tipo de lançamento:
	// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
	// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
	CreditDebitType EnumCreditDebitIndicator `json:"creditDebitType"`

	// PartieBranchCode Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	PartieBranchCode *string `json:"partieBranchCode,omitempty"`

	// PartieCheckDigit Dígito da conta da pessoa envolvida na transação
	PartieCheckDigit *string `json:"partieCheckDigit,omitempty"`

	// PartieCnpjCpf Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação). Com a IN BCB nº 371, a partir de 02/05/23, o envio das informações de identificação de contraparte tornou-se obrigatória para transações de pagamento. Para maiores detalhes, favor consultar a página `Orientações - Contas`.
	//
	// [Restrição] Quando o "type“ for preenchido com valor FOLHA_PAGAMENTO e a transmissora for a responsável pelo pagamento de salário (banco-folha), o partieCnpjCpf informado deve ser do empregador relacionado.
	PartieCnpjCpf *string `json:"partieCnpjCpf,omitempty"`

	// PartieCompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	PartieCompeCode *string `json:"partieCompeCode,omitempty"`

	// PartieNumber Número da conta da pessoa envolvida na transação
	PartieNumber *string `json:"partieNumber,omitempty"`

	// PartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
	// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
	// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
	PartiePersonType *EnumPartiePersonType `json:"partiePersonType,omitempty"`

	// TransactionAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	TransactionAmount AccountTransactionsDataAmount `json:"transactionAmount"`

	// TransactionDateTime Data e hora original da transação.
	TransactionDateTime string `json:"transactionDateTime"`

	// TransactionID Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
	// O ideal é que o `transactionId` seja imutável.
	// No entanto, o `transactionId` deve obedecer, no mínimo, as regras de imutabilidade propostas conforme tabela “Data de imutabilidade por tipo de transação” presente nas orientações desta API.
	TransactionID string `json:"transactionId"`

	// TransactionName Literal usada na instituição financeira para identificar a transação. A informação apresentada precisa ser a mesma utilizada nos canais eletrônicos da instituição (extrato). Em casos onde a descrição da transação é apresentada com múltiplas linhas, todas as linhas devem ser enviadas (concatenadas) neste atributo, não sendo obrigatória a concatenação das informações já enviadas em outros atributos (ex: valor, data) do mesmo endpoint.
	TransactionName string `json:"transactionName"`

	// Type O campo deve classificar a transação em um dos tipos descritos.
	// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
	// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
	// Por exemplo no caso de recebimento de pensão alimentícia.
	Type EnumTransactionTypes `json:"type"`
}

// AccountTransactionsDataAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountTransactionsDataAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// EnumAccountSubType Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
type EnumAccountSubType string

// EnumAccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type EnumAccountType string

// EnumCompletedAuthorisedPaymentIndicator Indicador da transação:
//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
type EnumCompletedAuthorisedPaymentIndicator string

// EnumCreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type EnumCreditDebitIndicator string

// EnumPartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
type EnumPartiePersonType string

// EnumTransactionTypes O campo deve classificar a transação em um dos tipos descritos.
// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
// Por exemplo no caso de recebimento de pensão alimentícia.
type EnumTransactionTypes string

// ResponseAccountBalances defines model for ResponseAccountBalances.
type ResponseAccountBalances struct {
	// Data Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountBalancesData `json:"data"`
	Links api.Links           `json:"links"`
	Meta  api.Meta            `json:"meta"`
}

// ResponseAccountIdentification defines model for ResponseAccountIdentification.
type ResponseAccountIdentification struct {
	// Data Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountIdentificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseAccountList defines model for ResponseAccountList.
type ResponseAccountList struct {
	// Data Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
	Data  []AccountData `json:"data"`
	Links api.Links     `json:"links"`
	Meta  api.Meta      `json:"meta"`
}

// ResponseAccountOverdraftLimits defines model for ResponseAccountOverdraftLimits.
type ResponseAccountOverdraftLimits struct {
	// Data Conjunto de informações da Conta de: depósito à vista
	Data  AccountOverdraftLimitsData `json:"data"`
	Links api.Links                  `json:"links"`
	Meta  api.Meta                   `json:"meta"`
}

// ResponseAccountTransactions defines model for ResponseAccountTransactions.
type ResponseAccountTransactions struct {
	// Data Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  []AccountTransactionsData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorMetaSingle defines model for ResponseErrorMetaSingle.
type ResponseErrorMetaSingle struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// Authorization defines model for Authorization.
type Authorization = string

// AccountID defines model for accountId.
type AccountID = string

// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type AccountType = EnumAccountType

// CreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type CreditDebitIndicator = EnumCreditDebitIndicator

// FromBookingDate defines model for fromBookingDate.
type FromBookingDate = timeutil.BrazilDate

// FromBookingDateMaxLimited defines model for fromBookingDateMaxLimited.
type FromBookingDateMaxLimited = timeutil.BrazilDate

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// ToBookingDate defines model for toBookingDate.
type ToBookingDate = timeutil.BrazilDate

// ToBookingDateMaxLimited defines model for toBookingDateMaxLimited.
type ToBookingDateMaxLimited = timeutil.BrazilDate

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorMetaSingle

// BadRequestWithAdditionalProperties defines model for BadRequestWithAdditionalProperties.
type BadRequestWithAdditionalProperties = ResponseError

// Default defines model for Default.
type Default = ResponseErrorMetaSingle

// DefaultWithAdditionalProperties defines model for DefaultWithAdditionalProperties.
type DefaultWithAdditionalProperties = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorMetaSingle

// ForbiddenWithAdditionalProperties defines model for ForbiddenWithAdditionalProperties.
type ForbiddenWithAdditionalProperties = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorMetaSingle

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorMetaSingle

// InternalServerErrorWithAdditionalProperties defines model for InternalServerErrorWithAdditionalProperties.
type InternalServerErrorWithAdditionalProperties = ResponseError

// Locked defines model for Locked.
type Locked = ResponseErrorMetaSingle

// LockedWithAdditionalProperties defines model for LockedWithAdditionalProperties.
type LockedWithAdditionalProperties = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorMetaSingle

// MethodNotAllowedWithAdditionalProperties defines model for MethodNotAllowedWithAdditionalProperties.
type MethodNotAllowedWithAdditionalProperties = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorMetaSingle

// NotAcceptableWithAdditionalProperties defines model for NotAcceptableWithAdditionalProperties.
type NotAcceptableWithAdditionalProperties = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseErrorMetaSingle

// NotFoundWithAdditionalProperties defines model for NotFoundWithAdditionalProperties.
type NotFoundWithAdditionalProperties = ResponseError

// OKResponseAccountBalances defines model for OKResponseAccountBalances.
type OKResponseAccountBalances = ResponseAccountBalances

// OKResponseAccountIdentification defines model for OKResponseAccountIdentification.
type OKResponseAccountIdentification = ResponseAccountIdentification

// OKResponseAccountList defines model for OKResponseAccountList.
type OKResponseAccountList = ResponseAccountList

// OKResponseAccountOverdraftLimits defines model for OKResponseAccountOverdraftLimits.
type OKResponseAccountOverdraftLimits = ResponseAccountOverdraftLimits

// OKResponseAccountTransactions defines model for OKResponseAccountTransactions.
type OKResponseAccountTransactions = ResponseAccountTransactions

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorMetaSingle

// SiteIsOverloadedWithAdditionalProperties defines model for SiteIsOverloadedWithAdditionalProperties.
type SiteIsOverloadedWithAdditionalProperties = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorMetaSingle

// TooManyRequestsWithAdditionalProperties defines model for TooManyRequestsWithAdditionalProperties.
type TooManyRequestsWithAdditionalProperties = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorMetaSingle

// UnauthorizedWithAdditionalProperties defines model for UnauthorizedWithAdditionalProperties.
type UnauthorizedWithAdditionalProperties = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorMetaSingle

// UnprocessableEntityWithAdditionalProperties defines model for UnprocessableEntityWithAdditionalProperties.
type UnprocessableEntityWithAdditionalProperties = ResponseError

// AccountsGetAccountsParams defines parameters for AccountsGetAccounts.
type AccountsGetAccountsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
	AccountType *AccountType `form:"accountType,omitempty" json:"accountType,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDParams defines parameters for AccountsGetAccountsAccountID.
type AccountsGetAccountsAccountIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDBalancesParams defines parameters for AccountsGetAccountsAccountIDBalances.
type AccountsGetAccountsAccountIDBalancesParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDOverdraftLimitsParams defines parameters for AccountsGetAccountsAccountIDOverdraftLimits.
type AccountsGetAccountsAccountIDOverdraftLimitsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsParams defines parameters for AccountsGetAccountsAccountIDTransactions.
type AccountsGetAccountsAccountIDTransactionsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDate `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDate `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsCurrentParams defines parameters for AccountsGetAccountsAccountIDTransactionsCurrent.
type AccountsGetAccountsAccountIDTransactionsCurrentParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDateMaxLimited `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDateMaxLimited `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountsGetAccounts operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "accountType" -------------

	err = runtime.BindQueryParameter("form", true, false, "accountType", r.URL.Query(), &params.AccountType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountType", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountID operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountID(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDBalancesParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDBalances(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDOverdraftLimitsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDOverdraftLimits(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactions(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsCurrentParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactionsCurrent(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/accounts", wrapper.AccountsGetAccounts)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}", wrapper.AccountsGetAccountsAccountID)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/balances", wrapper.AccountsGetAccountsAccountIDBalances)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/overdraft-limits", wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions", wrapper.AccountsGetAccountsAccountIDTransactions)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions-current", wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type DefaultWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type OKResponseAccountBalancesJSONResponse ResponseAccountBalances

type OKResponseAccountIdentificationJSONResponse ResponseAccountIdentification

type OKResponseAccountListJSONResponse ResponseAccountList

type OKResponseAccountOverdraftLimitsJSONResponse ResponseAccountOverdraftLimits

type OKResponseAccountTransactionsJSONResponse ResponseAccountTransactions

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type AccountsGetAccountsRequestObject struct {
	Params AccountsGetAccountsParams
}

type AccountsGetAccountsResponseObject interface {
	VisitAccountsGetAccountsResponse(w http.ResponseWriter) error
}

type AccountsGetAccounts200JSONResponse struct {
	OKResponseAccountListJSONResponse
}

func (response AccountsGetAccounts200JSONResponse) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDParams
}

type AccountsGetAccountsAccountIDResponseObject interface {
	VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountID200JSONResponse struct {
	OKResponseAccountIdentificationJSONResponse
}

func (response AccountsGetAccountsAccountID200JSONResponse) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDBalancesRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDBalancesParams
}

type AccountsGetAccountsAccountIDBalancesResponseObject interface {
	VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDBalances200JSONResponse struct {
	OKResponseAccountBalancesJSONResponse
}

func (response AccountsGetAccountsAccountIDBalances200JSONResponse) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDOverdraftLimitsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDOverdraftLimitsParams
}

type AccountsGetAccountsAccountIDOverdraftLimitsResponseObject interface {
	VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse struct {
	OKResponseAccountOverdraftLimitsJSONResponse
}

func (response AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsParams
}

type AccountsGetAccountsAccountIDTransactionsResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactions200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactions200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsCurrentRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsCurrentParams
}

type AccountsGetAccountsAccountIDTransactionsCurrentResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(ctx context.Context, request AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(ctx context.Context, request AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(ctx context.Context, request AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AccountsGetAccounts operation middleware
func (sh *strictHandler) AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams) {
	var request AccountsGetAccountsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccounts(ctx, request.(AccountsGetAccountsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccounts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountID operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams) {
	var request AccountsGetAccountsAccountIDRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountID(ctx, request.(AccountsGetAccountsAccountIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams) {
	var request AccountsGetAccountsAccountIDBalancesRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDBalances(ctx, request.(AccountsGetAccountsAccountIDBalancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDBalances")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDBalancesResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDBalancesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams) {
	var request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDOverdraftLimits(ctx, request.(AccountsGetAccountsAccountIDOverdraftLimitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDOverdraftLimits")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDOverdraftLimitsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams) {
	var request AccountsGetAccountsAccountIDTransactionsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactions(ctx, request.(AccountsGetAccountsAccountIDTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams) {
	var request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactionsCurrent(ctx, request.(AccountsGetAccountsAccountIDTransactionsCurrentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactionsCurrent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsCurrentResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AAD//2lt7QFv1QAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
