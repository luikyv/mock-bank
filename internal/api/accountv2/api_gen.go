//go:build go1.22

// Package accountv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package accountv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for EnumAccountSubType.
const (
	CONJUNTASIMPLES   EnumAccountSubType = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA EnumAccountSubType = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        EnumAccountSubType = "INDIVIDUAL"
)

// Defines values for EnumAccountType.
const (
	CONTADEPOSITOAVISTA   EnumAccountType = "CONTA_DEPOSITO_A_VISTA"
	CONTAPAGAMENTOPREPAGA EnumAccountType = "CONTA_PAGAMENTO_PRE_PAGA"
	CONTAPOUPANCA         EnumAccountType = "CONTA_POUPANCA"
)

// Defines values for EnumCompletedAuthorisedPaymentIndicator.
const (
	LANCAMENTOFUTURO     EnumCompletedAuthorisedPaymentIndicator = "LANCAMENTO_FUTURO"
	TRANSACAOEFETIVADA   EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_EFETIVADA"
	TRANSACAOPROCESSANDO EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_PROCESSANDO"
)

// Defines values for EnumCreditDebitIndicator.
const (
	CREDITO EnumCreditDebitIndicator = "CREDITO"
	DEBITO  EnumCreditDebitIndicator = "DEBITO"
)

// Defines values for EnumPartiePersonType.
const (
	PESSOAJURIDICA EnumPartiePersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPartiePersonType = "PESSOA_NATURAL"
)

// Defines values for EnumTransactionTypes.
const (
	BOLETO                        EnumTransactionTypes = "BOLETO"
	CARTAO                        EnumTransactionTypes = "CARTAO"
	CONVENIOARRECADACAO           EnumTransactionTypes = "CONVENIO_ARRECADACAO"
	DEPOSITO                      EnumTransactionTypes = "DEPOSITO"
	DOC                           EnumTransactionTypes = "DOC"
	ENCARGOSJUROSCHEQUEESPECIAL   EnumTransactionTypes = "ENCARGOS_JUROS_CHEQUE_ESPECIAL"
	FOLHAPAGAMENTO                EnumTransactionTypes = "FOLHA_PAGAMENTO"
	OPERACAOCREDITO               EnumTransactionTypes = "OPERACAO_CREDITO"
	OUTROS                        EnumTransactionTypes = "OUTROS"
	PACOTETARIFASERVICOS          EnumTransactionTypes = "PACOTE_TARIFA_SERVICOS"
	PIX                           EnumTransactionTypes = "PIX"
	PORTABILIDADESALARIO          EnumTransactionTypes = "PORTABILIDADE_SALARIO"
	RENDIMENTOAPLICFINANCEIRA     EnumTransactionTypes = "RENDIMENTO_APLIC_FINANCEIRA"
	RESGATEAPLICFINANCEIRA        EnumTransactionTypes = "RESGATE_APLIC_FINANCEIRA"
	SAQUE                         EnumTransactionTypes = "SAQUE"
	TARIFASERVICOSAVULSOS         EnumTransactionTypes = "TARIFA_SERVICOS_AVULSOS"
	TED                           EnumTransactionTypes = "TED"
	TRANSFERENCIAMESMAINSTITUICAO EnumTransactionTypes = "TRANSFERENCIA_MESMA_INSTITUICAO"
)

// AccountBalancesData Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountBalancesData struct {
	// AutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AutomaticallyInvestedAmount AccountBalancesDataAutomaticallyInvestedAmount `json:"automaticallyInvestedAmount"`

	// AvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AvailableAmount AccountBalancesDataAvailableAmount `json:"availableAmount"`

	// BlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	BlockedAmount AccountBalancesDataBlockedAmount `json:"blockedAmount"`

	// UpdateDateTime Data e hora da última atualização do saldo. É esperado que a instituição informe a última vez que capturou o saldo para compartilhamento no Open Finance. Dessa forma, é possível que:
	// - Caso a instituição capture dados de forma síncrona essa informação seja de poucos momentos;
	// - Caso a instituição capture dados de forma assíncrona essa informação seja de horas ou dias no passado;
	// - Quando não existente uma data vinculada especificamente ao bloco, se assume a data e hora de atualização do cadastro como um todo.
	//
	// De toda forma, é preciso continuar respeitando o prazo máximo de tempestividade da API de Contas.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// AccountBalancesDataAutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAutomaticallyInvestedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataAvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAvailableAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataBlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataBlockedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountData defines model for AccountData.
type AccountData struct {
	// AccountID Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
	AccountID string `json:"accountId"`

	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de CONTA_PAGAMENTO_PRE_PAGA.
	BranchCode *string `json:"branchCode,omitempty"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj string `json:"companyCnpj"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountIdentificationData Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountIdentificationData struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré-paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	CompeCode string `json:"compeCode"`

	// Currency Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
	// Todos os saldos informados estão representados com a moeda vigente do Brasil
	Currency string `json:"currency"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
	Subtype EnumAccountSubType `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountOverdraftLimitsData Conjunto de informações da Conta de: depósito à vista
type AccountOverdraftLimitsData struct {
	// OverdraftContractedLimit Valor do limite contratado do cheque especial.
	OverdraftContractedLimit *AccountOverdraftLimitsDataOverdraftContractedLimit `json:"overdraftContractedLimit,omitempty"`

	// OverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
	OverdraftUsedLimit *AccountOverdraftLimitsDataOverdraftUsedLimit `json:"overdraftUsedLimit,omitempty"`

	// UnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
	UnarrangedOverdraftAmount *AccountOverdraftLimitsDataUnarrangedOverdraftAmount `json:"unarrangedOverdraftAmount,omitempty"`
}

// AccountOverdraftLimitsDataOverdraftContractedLimit Valor do limite contratado do cheque especial.
type AccountOverdraftLimitsDataOverdraftContractedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataOverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
type AccountOverdraftLimitsDataOverdraftUsedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataUnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
type AccountOverdraftLimitsDataUnarrangedOverdraftAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountTransactionsData defines model for AccountTransactionsData.
type AccountTransactionsData struct {
	// CompletedAuthorisedPaymentType Indicador da transação:
	//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
	//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
	//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
	CompletedAuthorisedPaymentType EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

	// CreditDebitType Indicador do tipo de lançamento:
	// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
	// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
	CreditDebitType EnumCreditDebitIndicator `json:"creditDebitType"`

	// PartieBranchCode Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	PartieBranchCode *string `json:"partieBranchCode,omitempty"`

	// PartieCheckDigit Dígito da conta da pessoa envolvida na transação
	PartieCheckDigit *string `json:"partieCheckDigit,omitempty"`

	// PartieCnpjCpf Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação). Com a IN BCB nº 371, a partir de 02/05/23, o envio das informações de identificação de contraparte tornou-se obrigatória para transações de pagamento. Para maiores detalhes, favor consultar a página `Orientações - Contas`.
	//
	// [Restrição] Quando o "type“ for preenchido com valor FOLHA_PAGAMENTO e a transmissora for a responsável pelo pagamento de salário (banco-folha), o partieCnpjCpf informado deve ser do empregador relacionado.
	PartieCnpjCpf *string `json:"partieCnpjCpf,omitempty"`

	// PartieCompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	PartieCompeCode *string `json:"partieCompeCode,omitempty"`

	// PartieNumber Número da conta da pessoa envolvida na transação
	PartieNumber *string `json:"partieNumber,omitempty"`

	// PartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
	// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
	// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
	PartiePersonType *EnumPartiePersonType `json:"partiePersonType,omitempty"`

	// TransactionAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	TransactionAmount AccountTransactionsDataAmount `json:"transactionAmount"`

	// TransactionDateTime Data e hora original da transação.
	TransactionDateTime string `json:"transactionDateTime"`

	// TransactionID Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
	// O ideal é que o `transactionId` seja imutável.
	// No entanto, o `transactionId` deve obedecer, no mínimo, as regras de imutabilidade propostas conforme tabela “Data de imutabilidade por tipo de transação” presente nas orientações desta API.
	TransactionID string `json:"transactionId"`

	// TransactionName Literal usada na instituição financeira para identificar a transação. A informação apresentada precisa ser a mesma utilizada nos canais eletrônicos da instituição (extrato). Em casos onde a descrição da transação é apresentada com múltiplas linhas, todas as linhas devem ser enviadas (concatenadas) neste atributo, não sendo obrigatória a concatenação das informações já enviadas em outros atributos (ex: valor, data) do mesmo endpoint.
	TransactionName string `json:"transactionName"`

	// Type O campo deve classificar a transação em um dos tipos descritos.
	// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
	// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
	// Por exemplo no caso de recebimento de pensão alimentícia.
	Type EnumTransactionTypes `json:"type"`
}

// AccountTransactionsDataAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountTransactionsDataAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// EnumAccountSubType Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
type EnumAccountSubType string

// EnumAccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type EnumAccountType string

// EnumCompletedAuthorisedPaymentIndicator Indicador da transação:
//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
type EnumCompletedAuthorisedPaymentIndicator string

// EnumCreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type EnumCreditDebitIndicator string

// EnumPartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
type EnumPartiePersonType string

// EnumTransactionTypes O campo deve classificar a transação em um dos tipos descritos.
// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
// Por exemplo no caso de recebimento de pensão alimentícia.
type EnumTransactionTypes string

// ResponseAccountBalances defines model for ResponseAccountBalances.
type ResponseAccountBalances struct {
	// Data Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountBalancesData `json:"data"`
	Links api.Links           `json:"links"`
	Meta  api.Meta            `json:"meta"`
}

// ResponseAccountIdentification defines model for ResponseAccountIdentification.
type ResponseAccountIdentification struct {
	// Data Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountIdentificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseAccountList defines model for ResponseAccountList.
type ResponseAccountList struct {
	// Data Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
	Data  []AccountData `json:"data"`
	Links api.Links     `json:"links"`
	Meta  api.Meta      `json:"meta"`
}

// ResponseAccountOverdraftLimits defines model for ResponseAccountOverdraftLimits.
type ResponseAccountOverdraftLimits struct {
	// Data Conjunto de informações da Conta de: depósito à vista
	Data  AccountOverdraftLimitsData `json:"data"`
	Links api.Links                  `json:"links"`
	Meta  api.Meta                   `json:"meta"`
}

// ResponseAccountTransactions defines model for ResponseAccountTransactions.
type ResponseAccountTransactions struct {
	// Data Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  []AccountTransactionsData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorMetaSingle defines model for ResponseErrorMetaSingle.
type ResponseErrorMetaSingle struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// Authorization defines model for Authorization.
type Authorization = string

// AccountID defines model for accountId.
type AccountID = string

// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type AccountType = EnumAccountType

// CreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type CreditDebitIndicator = EnumCreditDebitIndicator

// FromBookingDate defines model for fromBookingDate.
type FromBookingDate = timeutil.BrazilDate

// FromBookingDateMaxLimited defines model for fromBookingDateMaxLimited.
type FromBookingDateMaxLimited = timeutil.BrazilDate

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// ToBookingDate defines model for toBookingDate.
type ToBookingDate = timeutil.BrazilDate

// ToBookingDateMaxLimited defines model for toBookingDateMaxLimited.
type ToBookingDateMaxLimited = timeutil.BrazilDate

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorMetaSingle

// BadRequestWithAdditionalProperties defines model for BadRequestWithAdditionalProperties.
type BadRequestWithAdditionalProperties = ResponseError

// Default defines model for Default.
type Default = ResponseErrorMetaSingle

// DefaultWithAdditionalProperties defines model for DefaultWithAdditionalProperties.
type DefaultWithAdditionalProperties = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorMetaSingle

// ForbiddenWithAdditionalProperties defines model for ForbiddenWithAdditionalProperties.
type ForbiddenWithAdditionalProperties = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorMetaSingle

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorMetaSingle

// InternalServerErrorWithAdditionalProperties defines model for InternalServerErrorWithAdditionalProperties.
type InternalServerErrorWithAdditionalProperties = ResponseError

// Locked defines model for Locked.
type Locked = ResponseErrorMetaSingle

// LockedWithAdditionalProperties defines model for LockedWithAdditionalProperties.
type LockedWithAdditionalProperties = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorMetaSingle

// MethodNotAllowedWithAdditionalProperties defines model for MethodNotAllowedWithAdditionalProperties.
type MethodNotAllowedWithAdditionalProperties = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorMetaSingle

// NotAcceptableWithAdditionalProperties defines model for NotAcceptableWithAdditionalProperties.
type NotAcceptableWithAdditionalProperties = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseErrorMetaSingle

// NotFoundWithAdditionalProperties defines model for NotFoundWithAdditionalProperties.
type NotFoundWithAdditionalProperties = ResponseError

// OKResponseAccountBalances defines model for OKResponseAccountBalances.
type OKResponseAccountBalances = ResponseAccountBalances

// OKResponseAccountIdentification defines model for OKResponseAccountIdentification.
type OKResponseAccountIdentification = ResponseAccountIdentification

// OKResponseAccountList defines model for OKResponseAccountList.
type OKResponseAccountList = ResponseAccountList

// OKResponseAccountOverdraftLimits defines model for OKResponseAccountOverdraftLimits.
type OKResponseAccountOverdraftLimits = ResponseAccountOverdraftLimits

// OKResponseAccountTransactions defines model for OKResponseAccountTransactions.
type OKResponseAccountTransactions = ResponseAccountTransactions

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorMetaSingle

// SiteIsOverloadedWithAdditionalProperties defines model for SiteIsOverloadedWithAdditionalProperties.
type SiteIsOverloadedWithAdditionalProperties = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorMetaSingle

// TooManyRequestsWithAdditionalProperties defines model for TooManyRequestsWithAdditionalProperties.
type TooManyRequestsWithAdditionalProperties = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorMetaSingle

// UnauthorizedWithAdditionalProperties defines model for UnauthorizedWithAdditionalProperties.
type UnauthorizedWithAdditionalProperties = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorMetaSingle

// UnprocessableEntityWithAdditionalProperties defines model for UnprocessableEntityWithAdditionalProperties.
type UnprocessableEntityWithAdditionalProperties = ResponseError

// AccountsGetAccountsParams defines parameters for AccountsGetAccounts.
type AccountsGetAccountsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
	AccountType *AccountType `form:"accountType,omitempty" json:"accountType,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDParams defines parameters for AccountsGetAccountsAccountID.
type AccountsGetAccountsAccountIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDBalancesParams defines parameters for AccountsGetAccountsAccountIDBalances.
type AccountsGetAccountsAccountIDBalancesParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDOverdraftLimitsParams defines parameters for AccountsGetAccountsAccountIDOverdraftLimits.
type AccountsGetAccountsAccountIDOverdraftLimitsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsParams defines parameters for AccountsGetAccountsAccountIDTransactions.
type AccountsGetAccountsAccountIDTransactionsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDate `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDate `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsCurrentParams defines parameters for AccountsGetAccountsAccountIDTransactionsCurrent.
type AccountsGetAccountsAccountIDTransactionsCurrentParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDateMaxLimited `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDateMaxLimited `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountsGetAccounts operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "accountType" -------------

	err = runtime.BindQueryParameter("form", true, false, "accountType", r.URL.Query(), &params.AccountType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountType", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountID operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountID(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDBalancesParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDBalances(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDOverdraftLimitsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDOverdraftLimits(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactions(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsCurrentParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactionsCurrent(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/accounts", wrapper.AccountsGetAccounts)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}", wrapper.AccountsGetAccountsAccountID)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/balances", wrapper.AccountsGetAccountsAccountIDBalances)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/overdraft-limits", wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions", wrapper.AccountsGetAccountsAccountIDTransactions)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions-current", wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type DefaultWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type OKResponseAccountBalancesJSONResponse ResponseAccountBalances

type OKResponseAccountIdentificationJSONResponse ResponseAccountIdentification

type OKResponseAccountListJSONResponse ResponseAccountList

type OKResponseAccountOverdraftLimitsJSONResponse ResponseAccountOverdraftLimits

type OKResponseAccountTransactionsJSONResponse ResponseAccountTransactions

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type AccountsGetAccountsRequestObject struct {
	Params AccountsGetAccountsParams
}

type AccountsGetAccountsResponseObject interface {
	VisitAccountsGetAccountsResponse(w http.ResponseWriter) error
}

type AccountsGetAccounts200JSONResponse struct {
	OKResponseAccountListJSONResponse
}

func (response AccountsGetAccounts200JSONResponse) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDParams
}

type AccountsGetAccountsAccountIDResponseObject interface {
	VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountID200JSONResponse struct {
	OKResponseAccountIdentificationJSONResponse
}

func (response AccountsGetAccountsAccountID200JSONResponse) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDBalancesRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDBalancesParams
}

type AccountsGetAccountsAccountIDBalancesResponseObject interface {
	VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDBalances200JSONResponse struct {
	OKResponseAccountBalancesJSONResponse
}

func (response AccountsGetAccountsAccountIDBalances200JSONResponse) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDOverdraftLimitsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDOverdraftLimitsParams
}

type AccountsGetAccountsAccountIDOverdraftLimitsResponseObject interface {
	VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse struct {
	OKResponseAccountOverdraftLimitsJSONResponse
}

func (response AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsParams
}

type AccountsGetAccountsAccountIDTransactionsResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactions200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactions200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsCurrentRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsCurrentParams
}

type AccountsGetAccountsAccountIDTransactionsCurrentResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(ctx context.Context, request AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(ctx context.Context, request AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(ctx context.Context, request AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AccountsGetAccounts operation middleware
func (sh *strictHandler) AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams) {
	var request AccountsGetAccountsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccounts(ctx, request.(AccountsGetAccountsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccounts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountID operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams) {
	var request AccountsGetAccountsAccountIDRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountID(ctx, request.(AccountsGetAccountsAccountIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams) {
	var request AccountsGetAccountsAccountIDBalancesRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDBalances(ctx, request.(AccountsGetAccountsAccountIDBalancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDBalances")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDBalancesResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDBalancesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams) {
	var request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDOverdraftLimits(ctx, request.(AccountsGetAccountsAccountIDOverdraftLimitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDOverdraftLimits")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDOverdraftLimitsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams) {
	var request AccountsGetAccountsAccountIDTransactionsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactions(ctx, request.(AccountsGetAccountsAccountIDTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams) {
	var request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactionsCurrent(ctx, request.(AccountsGetAccountsAccountIDTransactionsCurrentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactionsCurrent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsCurrentResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8erJ1f8PAAD//5jksAKH1QAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
