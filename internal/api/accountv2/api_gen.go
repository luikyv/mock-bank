//go:build go1.22

// Package accountv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package accountv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for EnumAccountSubType.
const (
	CONJUNTASIMPLES   EnumAccountSubType = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA EnumAccountSubType = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        EnumAccountSubType = "INDIVIDUAL"
)

// Defines values for EnumAccountType.
const (
	CONTADEPOSITOAVISTA   EnumAccountType = "CONTA_DEPOSITO_A_VISTA"
	CONTAPAGAMENTOPREPAGA EnumAccountType = "CONTA_PAGAMENTO_PRE_PAGA"
	CONTAPOUPANCA         EnumAccountType = "CONTA_POUPANCA"
)

// Defines values for EnumCompletedAuthorisedPaymentIndicator.
const (
	LANCAMENTOFUTURO     EnumCompletedAuthorisedPaymentIndicator = "LANCAMENTO_FUTURO"
	TRANSACAOEFETIVADA   EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_EFETIVADA"
	TRANSACAOPROCESSANDO EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_PROCESSANDO"
)

// Defines values for EnumCreditDebitIndicator.
const (
	CREDITO EnumCreditDebitIndicator = "CREDITO"
	DEBITO  EnumCreditDebitIndicator = "DEBITO"
)

// Defines values for EnumPartiePersonType.
const (
	PESSOAJURIDICA EnumPartiePersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPartiePersonType = "PESSOA_NATURAL"
)

// Defines values for EnumTransactionTypes.
const (
	BOLETO                        EnumTransactionTypes = "BOLETO"
	CARTAO                        EnumTransactionTypes = "CARTAO"
	CONVENIOARRECADACAO           EnumTransactionTypes = "CONVENIO_ARRECADACAO"
	DEPOSITO                      EnumTransactionTypes = "DEPOSITO"
	DOC                           EnumTransactionTypes = "DOC"
	ENCARGOSJUROSCHEQUEESPECIAL   EnumTransactionTypes = "ENCARGOS_JUROS_CHEQUE_ESPECIAL"
	FOLHAPAGAMENTO                EnumTransactionTypes = "FOLHA_PAGAMENTO"
	OPERACAOCREDITO               EnumTransactionTypes = "OPERACAO_CREDITO"
	OUTROS                        EnumTransactionTypes = "OUTROS"
	PACOTETARIFASERVICOS          EnumTransactionTypes = "PACOTE_TARIFA_SERVICOS"
	PIX                           EnumTransactionTypes = "PIX"
	PORTABILIDADESALARIO          EnumTransactionTypes = "PORTABILIDADE_SALARIO"
	RENDIMENTOAPLICFINANCEIRA     EnumTransactionTypes = "RENDIMENTO_APLIC_FINANCEIRA"
	RESGATEAPLICFINANCEIRA        EnumTransactionTypes = "RESGATE_APLIC_FINANCEIRA"
	SAQUE                         EnumTransactionTypes = "SAQUE"
	TARIFASERVICOSAVULSOS         EnumTransactionTypes = "TARIFA_SERVICOS_AVULSOS"
	TED                           EnumTransactionTypes = "TED"
	TRANSFERENCIAMESMAINSTITUICAO EnumTransactionTypes = "TRANSFERENCIA_MESMA_INSTITUICAO"
)

// AccountBalancesData Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountBalancesData struct {
	// AutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AutomaticallyInvestedAmount AccountBalancesDataAutomaticallyInvestedAmount `json:"automaticallyInvestedAmount"`

	// AvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AvailableAmount AccountBalancesDataAvailableAmount `json:"availableAmount"`

	// BlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	BlockedAmount AccountBalancesDataBlockedAmount `json:"blockedAmount"`

	// UpdateDateTime Data e hora da última atualização do saldo. É esperado que a instituição informe a última vez que capturou o saldo para compartilhamento no Open Finance. Dessa forma, é possível que:
	// - Caso a instituição capture dados de forma síncrona essa informação seja de poucos momentos;
	// - Caso a instituição capture dados de forma assíncrona essa informação seja de horas ou dias no passado;
	// - Quando não existente uma data vinculada especificamente ao bloco, se assume a data e hora de atualização do cadastro como um todo.
	//
	// De toda forma, é preciso continuar respeitando o prazo máximo de tempestividade da API de Contas.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// AccountBalancesDataAutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAutomaticallyInvestedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataAvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAvailableAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataBlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataBlockedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountData defines model for AccountData.
type AccountData struct {
	// AccountID Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
	AccountID string `json:"accountId"`

	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de CONTA_PAGAMENTO_PRE_PAGA.
	BranchCode *string `json:"branchCode,omitempty"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj string `json:"companyCnpj"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountIdentificationData Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountIdentificationData struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré-paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	CompeCode string `json:"compeCode"`

	// Currency Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
	// Todos os saldos informados estão representados com a moeda vigente do Brasil
	Currency string `json:"currency"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
	Subtype EnumAccountSubType `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountOverdraftLimitsData Conjunto de informações da Conta de: depósito à vista
type AccountOverdraftLimitsData struct {
	// OverdraftContractedLimit Valor do limite contratado do cheque especial.
	OverdraftContractedLimit *AccountOverdraftLimitsDataOverdraftContractedLimit `json:"overdraftContractedLimit,omitempty"`

	// OverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
	OverdraftUsedLimit *AccountOverdraftLimitsDataOverdraftUsedLimit `json:"overdraftUsedLimit,omitempty"`

	// UnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
	UnarrangedOverdraftAmount *AccountOverdraftLimitsDataUnarrangedOverdraftAmount `json:"unarrangedOverdraftAmount,omitempty"`
}

// AccountOverdraftLimitsDataOverdraftContractedLimit Valor do limite contratado do cheque especial.
type AccountOverdraftLimitsDataOverdraftContractedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataOverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
type AccountOverdraftLimitsDataOverdraftUsedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataUnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
type AccountOverdraftLimitsDataUnarrangedOverdraftAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountTransactionsData defines model for AccountTransactionsData.
type AccountTransactionsData struct {
	// CompletedAuthorisedPaymentType Indicador da transação:
	//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
	//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
	//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
	CompletedAuthorisedPaymentType EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

	// CreditDebitType Indicador do tipo de lançamento:
	// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
	// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
	CreditDebitType EnumCreditDebitIndicator `json:"creditDebitType"`

	// PartieBranchCode Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	PartieBranchCode *string `json:"partieBranchCode,omitempty"`

	// PartieCheckDigit Dígito da conta da pessoa envolvida na transação
	PartieCheckDigit *string `json:"partieCheckDigit,omitempty"`

	// PartieCnpjCpf Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação). Com a IN BCB nº 371, a partir de 02/05/23, o envio das informações de identificação de contraparte tornou-se obrigatória para transações de pagamento. Para maiores detalhes, favor consultar a página `Orientações - Contas`.
	//
	// [Restrição] Quando o "type“ for preenchido com valor FOLHA_PAGAMENTO e a transmissora for a responsável pelo pagamento de salário (banco-folha), o partieCnpjCpf informado deve ser do empregador relacionado.
	PartieCnpjCpf *string `json:"partieCnpjCpf,omitempty"`

	// PartieCompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	PartieCompeCode *string `json:"partieCompeCode,omitempty"`

	// PartieNumber Número da conta da pessoa envolvida na transação
	PartieNumber *string `json:"partieNumber,omitempty"`

	// PartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
	// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
	// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
	PartiePersonType *EnumPartiePersonType `json:"partiePersonType,omitempty"`

	// TransactionAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	TransactionAmount AccountTransactionsDataAmount `json:"transactionAmount"`

	// TransactionDateTime Data e hora original da transação.
	TransactionDateTime string `json:"transactionDateTime"`

	// TransactionID Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
	// O ideal é que o `transactionId` seja imutável.
	// No entanto, o `transactionId` deve obedecer, no mínimo, as regras de imutabilidade propostas conforme tabela “Data de imutabilidade por tipo de transação” presente nas orientações desta API.
	TransactionID string `json:"transactionId"`

	// TransactionName Literal usada na instituição financeira para identificar a transação. A informação apresentada precisa ser a mesma utilizada nos canais eletrônicos da instituição (extrato). Em casos onde a descrição da transação é apresentada com múltiplas linhas, todas as linhas devem ser enviadas (concatenadas) neste atributo, não sendo obrigatória a concatenação das informações já enviadas em outros atributos (ex: valor, data) do mesmo endpoint.
	TransactionName string `json:"transactionName"`

	// Type O campo deve classificar a transação em um dos tipos descritos.
	// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
	// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
	// Por exemplo no caso de recebimento de pensão alimentícia.
	Type EnumTransactionTypes `json:"type"`
}

// AccountTransactionsDataAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountTransactionsDataAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// EnumAccountSubType Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
type EnumAccountSubType string

// EnumAccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type EnumAccountType string

// EnumCompletedAuthorisedPaymentIndicator Indicador da transação:
//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
type EnumCompletedAuthorisedPaymentIndicator string

// EnumCreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type EnumCreditDebitIndicator string

// EnumPartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
type EnumPartiePersonType string

// EnumTransactionTypes O campo deve classificar a transação em um dos tipos descritos.
// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
// Por exemplo no caso de recebimento de pensão alimentícia.
type EnumTransactionTypes string

// ResponseAccountBalances defines model for ResponseAccountBalances.
type ResponseAccountBalances struct {
	// Data Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountBalancesData `json:"data"`
	Links api.Links           `json:"links"`
	Meta  api.Meta            `json:"meta"`
}

// ResponseAccountIdentification defines model for ResponseAccountIdentification.
type ResponseAccountIdentification struct {
	// Data Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountIdentificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseAccountList defines model for ResponseAccountList.
type ResponseAccountList struct {
	// Data Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
	Data  []AccountData `json:"data"`
	Links api.Links     `json:"links"`
	Meta  api.Meta      `json:"meta"`
}

// ResponseAccountOverdraftLimits defines model for ResponseAccountOverdraftLimits.
type ResponseAccountOverdraftLimits struct {
	// Data Conjunto de informações da Conta de: depósito à vista
	Data  AccountOverdraftLimitsData `json:"data"`
	Links api.Links                  `json:"links"`
	Meta  api.Meta                   `json:"meta"`
}

// ResponseAccountTransactions defines model for ResponseAccountTransactions.
type ResponseAccountTransactions struct {
	// Data Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  []AccountTransactionsData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorMetaSingle defines model for ResponseErrorMetaSingle.
type ResponseErrorMetaSingle struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// Authorization defines model for Authorization.
type Authorization = string

// AccountID defines model for accountId.
type AccountID = string

// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type AccountType = EnumAccountType

// CreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type CreditDebitIndicator = EnumCreditDebitIndicator

// FromBookingDate defines model for fromBookingDate.
type FromBookingDate = timeutil.BrazilDate

// FromBookingDateMaxLimited defines model for fromBookingDateMaxLimited.
type FromBookingDateMaxLimited = timeutil.BrazilDate

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// ToBookingDate defines model for toBookingDate.
type ToBookingDate = timeutil.BrazilDate

// ToBookingDateMaxLimited defines model for toBookingDateMaxLimited.
type ToBookingDateMaxLimited = timeutil.BrazilDate

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorMetaSingle

// BadRequestWithAdditionalProperties defines model for BadRequestWithAdditionalProperties.
type BadRequestWithAdditionalProperties = ResponseError

// Default defines model for Default.
type Default = ResponseErrorMetaSingle

// DefaultWithAdditionalProperties defines model for DefaultWithAdditionalProperties.
type DefaultWithAdditionalProperties = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorMetaSingle

// ForbiddenWithAdditionalProperties defines model for ForbiddenWithAdditionalProperties.
type ForbiddenWithAdditionalProperties = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorMetaSingle

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorMetaSingle

// InternalServerErrorWithAdditionalProperties defines model for InternalServerErrorWithAdditionalProperties.
type InternalServerErrorWithAdditionalProperties = ResponseError

// Locked defines model for Locked.
type Locked = ResponseErrorMetaSingle

// LockedWithAdditionalProperties defines model for LockedWithAdditionalProperties.
type LockedWithAdditionalProperties = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorMetaSingle

// MethodNotAllowedWithAdditionalProperties defines model for MethodNotAllowedWithAdditionalProperties.
type MethodNotAllowedWithAdditionalProperties = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorMetaSingle

// NotAcceptableWithAdditionalProperties defines model for NotAcceptableWithAdditionalProperties.
type NotAcceptableWithAdditionalProperties = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseErrorMetaSingle

// NotFoundWithAdditionalProperties defines model for NotFoundWithAdditionalProperties.
type NotFoundWithAdditionalProperties = ResponseError

// OKResponseAccountBalances defines model for OKResponseAccountBalances.
type OKResponseAccountBalances = ResponseAccountBalances

// OKResponseAccountIdentification defines model for OKResponseAccountIdentification.
type OKResponseAccountIdentification = ResponseAccountIdentification

// OKResponseAccountList defines model for OKResponseAccountList.
type OKResponseAccountList = ResponseAccountList

// OKResponseAccountOverdraftLimits defines model for OKResponseAccountOverdraftLimits.
type OKResponseAccountOverdraftLimits = ResponseAccountOverdraftLimits

// OKResponseAccountTransactions defines model for OKResponseAccountTransactions.
type OKResponseAccountTransactions = ResponseAccountTransactions

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorMetaSingle

// SiteIsOverloadedWithAdditionalProperties defines model for SiteIsOverloadedWithAdditionalProperties.
type SiteIsOverloadedWithAdditionalProperties = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorMetaSingle

// TooManyRequestsWithAdditionalProperties defines model for TooManyRequestsWithAdditionalProperties.
type TooManyRequestsWithAdditionalProperties = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorMetaSingle

// UnauthorizedWithAdditionalProperties defines model for UnauthorizedWithAdditionalProperties.
type UnauthorizedWithAdditionalProperties = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorMetaSingle

// UnprocessableEntityWithAdditionalProperties defines model for UnprocessableEntityWithAdditionalProperties.
type UnprocessableEntityWithAdditionalProperties = ResponseError

// AccountsGetAccountsParams defines parameters for AccountsGetAccounts.
type AccountsGetAccountsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
	AccountType *AccountType `form:"accountType,omitempty" json:"accountType,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDParams defines parameters for AccountsGetAccountsAccountID.
type AccountsGetAccountsAccountIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDBalancesParams defines parameters for AccountsGetAccountsAccountIDBalances.
type AccountsGetAccountsAccountIDBalancesParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDOverdraftLimitsParams defines parameters for AccountsGetAccountsAccountIDOverdraftLimits.
type AccountsGetAccountsAccountIDOverdraftLimitsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsParams defines parameters for AccountsGetAccountsAccountIDTransactions.
type AccountsGetAccountsAccountIDTransactionsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDate `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDate `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsCurrentParams defines parameters for AccountsGetAccountsAccountIDTransactionsCurrent.
type AccountsGetAccountsAccountIDTransactionsCurrentParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDateMaxLimited `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDateMaxLimited `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountsGetAccounts operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "accountType" -------------

	err = runtime.BindQueryParameter("form", true, false, "accountType", r.URL.Query(), &params.AccountType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountType", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountID operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountID(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDBalancesParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDBalances(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDOverdraftLimitsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDOverdraftLimits(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactions(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsCurrentParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactionsCurrent(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/accounts", wrapper.AccountsGetAccounts)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}", wrapper.AccountsGetAccountsAccountID)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/balances", wrapper.AccountsGetAccountsAccountIDBalances)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/overdraft-limits", wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions", wrapper.AccountsGetAccountsAccountIDTransactions)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions-current", wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type DefaultWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type OKResponseAccountBalancesJSONResponse ResponseAccountBalances

type OKResponseAccountIdentificationJSONResponse ResponseAccountIdentification

type OKResponseAccountListJSONResponse ResponseAccountList

type OKResponseAccountOverdraftLimitsJSONResponse ResponseAccountOverdraftLimits

type OKResponseAccountTransactionsJSONResponse ResponseAccountTransactions

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type AccountsGetAccountsRequestObject struct {
	Params AccountsGetAccountsParams
}

type AccountsGetAccountsResponseObject interface {
	VisitAccountsGetAccountsResponse(w http.ResponseWriter) error
}

type AccountsGetAccounts200JSONResponse struct {
	OKResponseAccountListJSONResponse
}

func (response AccountsGetAccounts200JSONResponse) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDParams
}

type AccountsGetAccountsAccountIDResponseObject interface {
	VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountID200JSONResponse struct {
	OKResponseAccountIdentificationJSONResponse
}

func (response AccountsGetAccountsAccountID200JSONResponse) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDBalancesRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDBalancesParams
}

type AccountsGetAccountsAccountIDBalancesResponseObject interface {
	VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDBalances200JSONResponse struct {
	OKResponseAccountBalancesJSONResponse
}

func (response AccountsGetAccountsAccountIDBalances200JSONResponse) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDOverdraftLimitsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDOverdraftLimitsParams
}

type AccountsGetAccountsAccountIDOverdraftLimitsResponseObject interface {
	VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse struct {
	OKResponseAccountOverdraftLimitsJSONResponse
}

func (response AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsParams
}

type AccountsGetAccountsAccountIDTransactionsResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactions200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactions200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsCurrentRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsCurrentParams
}

type AccountsGetAccountsAccountIDTransactionsCurrentResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(ctx context.Context, request AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(ctx context.Context, request AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(ctx context.Context, request AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AccountsGetAccounts operation middleware
func (sh *strictHandler) AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams) {
	var request AccountsGetAccountsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccounts(ctx, request.(AccountsGetAccountsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccounts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountID operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams) {
	var request AccountsGetAccountsAccountIDRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountID(ctx, request.(AccountsGetAccountsAccountIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams) {
	var request AccountsGetAccountsAccountIDBalancesRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDBalances(ctx, request.(AccountsGetAccountsAccountIDBalancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDBalances")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDBalancesResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDBalancesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams) {
	var request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDOverdraftLimits(ctx, request.(AccountsGetAccountsAccountIDOverdraftLimitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDOverdraftLimits")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDOverdraftLimitsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams) {
	var request AccountsGetAccountsAccountIDTransactionsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactions(ctx, request.(AccountsGetAccountsAccountIDTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams) {
	var request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactionsCurrent(ctx, request.(AccountsGetAccountsAccountIDTransactionsCurrentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactionsCurrent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsCurrentResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6snV/w8AAP//A8jAnnbVAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
