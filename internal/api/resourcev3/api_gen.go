//go:build go1.22

// Package resourcev3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package resourcev3

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for ResponseResourceListDataStatus.
const (
	AVAILABLE              ResponseResourceListDataStatus = "AVAILABLE"
	PENDINGAUTHORISATION   ResponseResourceListDataStatus = "PENDING_AUTHORISATION"
	TEMPORARILYUNAVAILABLE ResponseResourceListDataStatus = "TEMPORARILY_UNAVAILABLE"
	UNAVAILABLE            ResponseResourceListDataStatus = "UNAVAILABLE"
)

// Defines values for ResponseResourceListDataType.
const (
	ACCOUNT                    ResponseResourceListDataType = "ACCOUNT"
	BANKFIXEDINCOME            ResponseResourceListDataType = "BANK_FIXED_INCOME"
	CREDITCARDACCOUNT          ResponseResourceListDataType = "CREDIT_CARD_ACCOUNT"
	CREDITFIXEDINCOME          ResponseResourceListDataType = "CREDIT_FIXED_INCOME"
	EXCHANGE                   ResponseResourceListDataType = "EXCHANGE"
	FINANCING                  ResponseResourceListDataType = "FINANCING"
	FUND                       ResponseResourceListDataType = "FUND"
	INVOICEFINANCING           ResponseResourceListDataType = "INVOICE_FINANCING"
	LOAN                       ResponseResourceListDataType = "LOAN"
	TREASURETITLE              ResponseResourceListDataType = "TREASURE_TITLE"
	UNARRANGEDACCOUNTOVERDRAFT ResponseResourceListDataType = "UNARRANGED_ACCOUNT_OVERDRAFT"
	VARIABLEINCOME             ResponseResourceListDataType = "VARIABLE_INCOME"
)

// ResponseErrorWithAbleAdditionalProperties defines model for ResponseErrorWithAbleAdditionalProperties.
type ResponseErrorWithAbleAdditionalProperties struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseResourceList defines model for ResponseResourceList.
type ResponseResourceList struct {
	// Data Lista de recursos e seus respectivos status.
	Data []struct {
		// ResourceID Identifica o recurso reportado pelo participante do Open Finance, no caso de:
		// - Contas de depósito à vista, de poupança ou de pagamento pré-paga : corresponde ao accountId;
		// - Conta de pagamento pós-paga: corresponde ao  creditCardAccountId;
		// - Empréstimos, Financiamentos, Direitos creditórios descontados e Adiantamento a depositantes: corresponde ao contractId
		// - Renda Fixa Bancária, Renda Fixa Crédito, Renda Variável, Título do Tesouro Direto e Fundo de Investimento: corresponde ao investmentId;
		// - Câmbio: corresponde ao operationId.
		ResourceID string `json:"resourceId"`

		// Status Tipo de status de recurso (vide Enum):
		// Available - Disponível
		// Unavailable - Indisponível
		// Temporarily Unavailable - Temporariamente Indisponível
		// Pending Authorisation - Pendente de Autorização
		Status ResponseResourceListDataStatus `json:"status"`

		// Type Tipo de recurso (vide Enum):
		//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
		//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
		//   - Loan - Empréstimo
		//   - Financing - Financiamento
		//   - Unarranged Account Overdraft - Cheque Especial
		//   - Invoice Financing - Financiamento de Fatura
		//   - Bank Fixed Income - Renda Fixa Bancária
		//   - Credit Fixed Income - Renda Fixa Crédito
		//   - Variabel Income - Renda Variável
		//   - Treasure Title - Título do Tesouro Direto
		//   - Fund - Fundo de Investimento
		//   - Exchange - Câmbio
		Type ResponseResourceListDataType `json:"type"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseResourceListDataStatus Tipo de status de recurso (vide Enum):
// Available - Disponível
// Unavailable - Indisponível
// Temporarily Unavailable - Temporariamente Indisponível
// Pending Authorisation - Pendente de Autorização
type ResponseResourceListDataStatus string

// ResponseResourceListDataType Tipo de recurso (vide Enum):
//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
//   - Loan - Empréstimo
//   - Financing - Financiamento
//   - Unarranged Account Overdraft - Cheque Especial
//   - Invoice Financing - Financiamento de Fatura
//   - Bank Fixed Income - Renda Fixa Bancária
//   - Credit Fixed Income - Renda Fixa Crédito
//   - Variabel Income - Renda Variável
//   - Treasure Title - Título do Tesouro Direto
//   - Fund - Fundo de Investimento
//   - Exchange - Câmbio
type ResponseResourceListDataType string

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorWithAbleAdditionalProperties

// Default defines model for Default.
type Default = ResponseErrorWithAbleAdditionalProperties

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorWithAbleAdditionalProperties

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorWithAbleAdditionalProperties

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorWithAbleAdditionalProperties

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorWithAbleAdditionalProperties

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorWithAbleAdditionalProperties

// NotFound defines model for NotFound.
type NotFound = ResponseErrorWithAbleAdditionalProperties

// OKResponseResourceList defines model for OKResponseResourceList.
type OKResponseResourceList = ResponseResourceList

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorWithAbleAdditionalProperties

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorWithAbleAdditionalProperties

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorWithAbleAdditionalProperties

// ResourcesGetResourcesParams defines parameters for ResourcesGetResources.
type ResourcesGetResourcesParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	// A transmissora deve considerar entrada como 25, caso seja informado algum valor menor pela receptora.
	// Enquanto houver mais que 25 registros a enviar, a transmissora deve considerar o mínimo por página como 25.
	// Somente a última página retornada (ou primeira, no caso de página única) pode conter menos de 25 registros.
	// Mais informações, acesse Especificações de APIs > Padrões > Paginação.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ResourcesGetResources operation middleware
func (siw *ServerInterfaceWrapper) ResourcesGetResources(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "resources"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ResourcesGetResourcesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResourcesGetResources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/resources", wrapper.ResourcesGetResources)

	return m
}

type N202ResponseResourceResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type OKResponseResourceListJSONResponse ResponseResourceList

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ResourcesGetResourcesRequestObject struct {
	Params ResourcesGetResourcesParams
}

type ResourcesGetResourcesResponseObject interface {
	VisitResourcesGetResourcesResponse(w http.ResponseWriter) error
}

type ResourcesGetResources200JSONResponse struct {
	OKResponseResourceListJSONResponse
}

func (response ResourcesGetResources200JSONResponse) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources202Response = N202ResponseResourceResponse

func (response ResourcesGetResources202Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.WriteHeader(202)
	return nil
}

type ResourcesGetResources400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources400ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources401ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources403ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources404ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources405ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources406ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources429ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources500ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources504ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources529ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorWithAbleAdditionalProperties
	StatusCode int
}

func (response ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(ctx context.Context, request ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ResourcesGetResources operation middleware
func (sh *strictHandler) ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams) {
	var request ResourcesGetResourcesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResourcesGetResources(ctx, request.(ResourcesGetResourcesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResourcesGetResources")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResourcesGetResourcesResponseObject); ok {
		if err := validResponse.VisitResourcesGetResourcesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
