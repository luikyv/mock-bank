//go:build go1.22

// Package resourcev3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package resourcev3

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for ResponseResourceListDataStatus.
const (
	AVAILABLE              ResponseResourceListDataStatus = "AVAILABLE"
	PENDINGAUTHORISATION   ResponseResourceListDataStatus = "PENDING_AUTHORISATION"
	TEMPORARILYUNAVAILABLE ResponseResourceListDataStatus = "TEMPORARILY_UNAVAILABLE"
	UNAVAILABLE            ResponseResourceListDataStatus = "UNAVAILABLE"
)

// Defines values for ResponseResourceListDataType.
const (
	ACCOUNT                    ResponseResourceListDataType = "ACCOUNT"
	BANKFIXEDINCOME            ResponseResourceListDataType = "BANK_FIXED_INCOME"
	CREDITCARDACCOUNT          ResponseResourceListDataType = "CREDIT_CARD_ACCOUNT"
	CREDITFIXEDINCOME          ResponseResourceListDataType = "CREDIT_FIXED_INCOME"
	EXCHANGE                   ResponseResourceListDataType = "EXCHANGE"
	FINANCING                  ResponseResourceListDataType = "FINANCING"
	FUND                       ResponseResourceListDataType = "FUND"
	INVOICEFINANCING           ResponseResourceListDataType = "INVOICE_FINANCING"
	LOAN                       ResponseResourceListDataType = "LOAN"
	TREASURETITLE              ResponseResourceListDataType = "TREASURE_TITLE"
	UNARRANGEDACCOUNTOVERDRAFT ResponseResourceListDataType = "UNARRANGED_ACCOUNT_OVERDRAFT"
	VARIABLEINCOME             ResponseResourceListDataType = "VARIABLE_INCOME"
)

// ResponseErrorWithAbleAdditionalProperties defines model for ResponseErrorWithAbleAdditionalProperties.
type ResponseErrorWithAbleAdditionalProperties struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseResourceList defines model for ResponseResourceList.
type ResponseResourceList struct {
	// Data Lista de recursos e seus respectivos status.
	Data []struct {
		// ResourceID Identifica o recurso reportado pelo participante do Open Finance, no caso de:
		// - Contas de depósito à vista, de poupança ou de pagamento pré-paga : corresponde ao accountId;
		// - Conta de pagamento pós-paga: corresponde ao  creditCardAccountId;
		// - Empréstimos, Financiamentos, Direitos creditórios descontados e Adiantamento a depositantes: corresponde ao contractId
		// - Renda Fixa Bancária, Renda Fixa Crédito, Renda Variável, Título do Tesouro Direto e Fundo de Investimento: corresponde ao investmentId;
		// - Câmbio: corresponde ao operationId.
		ResourceID string `json:"resourceId"`

		// Status Tipo de status de recurso (vide Enum):
		// Available - Disponível
		// Unavailable - Indisponível
		// Temporarily Unavailable - Temporariamente Indisponível
		// Pending Authorisation - Pendente de Autorização
		Status ResponseResourceListDataStatus `json:"status"`

		// Type Tipo de recurso (vide Enum):
		//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
		//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
		//   - Loan - Empréstimo
		//   - Financing - Financiamento
		//   - Unarranged Account Overdraft - Cheque Especial
		//   - Invoice Financing - Financiamento de Fatura
		//   - Bank Fixed Income - Renda Fixa Bancária
		//   - Credit Fixed Income - Renda Fixa Crédito
		//   - Variabel Income - Renda Variável
		//   - Treasure Title - Título do Tesouro Direto
		//   - Fund - Fundo de Investimento
		//   - Exchange - Câmbio
		Type ResponseResourceListDataType `json:"type"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseResourceListDataStatus Tipo de status de recurso (vide Enum):
// Available - Disponível
// Unavailable - Indisponível
// Temporarily Unavailable - Temporariamente Indisponível
// Pending Authorisation - Pendente de Autorização
type ResponseResourceListDataStatus string

// ResponseResourceListDataType Tipo de recurso (vide Enum):
//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
//   - Loan - Empréstimo
//   - Financing - Financiamento
//   - Unarranged Account Overdraft - Cheque Especial
//   - Invoice Financing - Financiamento de Fatura
//   - Bank Fixed Income - Renda Fixa Bancária
//   - Credit Fixed Income - Renda Fixa Crédito
//   - Variabel Income - Renda Variável
//   - Treasure Title - Título do Tesouro Direto
//   - Fund - Fundo de Investimento
//   - Exchange - Câmbio
type ResponseResourceListDataType string

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorWithAbleAdditionalProperties

// Default defines model for Default.
type Default = ResponseErrorWithAbleAdditionalProperties

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorWithAbleAdditionalProperties

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorWithAbleAdditionalProperties

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorWithAbleAdditionalProperties

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorWithAbleAdditionalProperties

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorWithAbleAdditionalProperties

// NotFound defines model for NotFound.
type NotFound = ResponseErrorWithAbleAdditionalProperties

// OKResponseResourceList defines model for OKResponseResourceList.
type OKResponseResourceList = ResponseResourceList

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorWithAbleAdditionalProperties

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorWithAbleAdditionalProperties

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorWithAbleAdditionalProperties

// ResourcesGetResourcesParams defines parameters for ResourcesGetResources.
type ResourcesGetResourcesParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	// A transmissora deve considerar entrada como 25, caso seja informado algum valor menor pela receptora.
	// Enquanto houver mais que 25 registros a enviar, a transmissora deve considerar o mínimo por página como 25.
	// Somente a última página retornada (ou primeira, no caso de página única) pode conter menos de 25 registros.
	// Mais informações, acesse Especificações de APIs > Padrões > Paginação.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ResourcesGetResources operation middleware
func (siw *ServerInterfaceWrapper) ResourcesGetResources(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "resources"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ResourcesGetResourcesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResourcesGetResources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/resources", wrapper.ResourcesGetResources)

	return m
}

type N202ResponseResourceResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type OKResponseResourceListJSONResponse ResponseResourceList

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ResourcesGetResourcesRequestObject struct {
	Params ResourcesGetResourcesParams
}

type ResourcesGetResourcesResponseObject interface {
	VisitResourcesGetResourcesResponse(w http.ResponseWriter) error
}

type ResourcesGetResources200JSONResponse struct {
	OKResponseResourceListJSONResponse
}

func (response ResourcesGetResources200JSONResponse) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources202Response = N202ResponseResourceResponse

func (response ResourcesGetResources202Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.WriteHeader(202)
	return nil
}

type ResourcesGetResources400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources400ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources401ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources403ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources404ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources405ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources406ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources429ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources500ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources504ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources529ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorWithAbleAdditionalProperties
	StatusCode int
}

func (response ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(ctx context.Context, request ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ResourcesGetResources operation middleware
func (sh *strictHandler) ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams) {
	var request ResourcesGetResourcesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResourcesGetResources(ctx, request.(ResourcesGetResourcesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResourcesGetResources")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResourcesGetResourcesResponseObject); ok {
		if err := validResponse.VisitResourcesGetResourcesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
