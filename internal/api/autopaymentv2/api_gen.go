//go:build go1.22

// Package autopaymentv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package autopaymentv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/autopayment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreatePixRecurringPaymentErrorsCode.
const (
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOPENDENTEAUTORIZACAO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHEPAGAMENTOINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeERROIDEMPOTENCIA                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO                        N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOVALOREXCEDIDO                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeNAOINFORMADO                              N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTODIVERGENTECONSENTIMENTO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADOSPI                      N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_SPI"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETROINVALIDO                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeSALDOINSUFICIENTE                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "SALDO_INSUFICIENTE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORACIMALIMITE                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_ACIMA_LIMITE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORINVALIDO                             N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_INVALIDO"
)

// Defines values for N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode.
const (
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodeCANCELAMENTOFORAPERIODOPERMITIDO N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "CANCELAMENTO_FORA_PERIODO_PERMITIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePAGAMENTONAOPERMITECANCELAMENTO  N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETROINVALIDO                N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETRONAOINFORMADO            N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorRecurringConsentsErrorsCode.
const (
	N422ResponseErrorRecurringConsentsErrorsCodeCAMPONAOPERMITIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "CAMPO_NAO_PERMITIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeCONSENTIMENTONAOPERMITECANCELAMENTO N422ResponseErrorRecurringConsentsErrorsCode = "CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorRecurringConsentsErrorsCodeDETALHEEDICAOINVALIDO               N422ResponseErrorRecurringConsentsErrorsCode = "DETALHE_EDICAO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeFALTAMSINAISOBRIGATORIOSPLATAFORMA  N422ResponseErrorRecurringConsentsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETROINVALIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETRONAOINFORMADO               N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorRecurringConsentsErrorsCodePERMISSAOINSUFICIENTE               N422ResponseErrorRecurringConsentsErrorsCode = "PERMISSAO_INSUFICIENTE"
)

// Defines values for AutomaticAutomaticInterval.
const (
	AutomaticAutomaticIntervalANUAL      AutomaticAutomaticInterval = "ANUAL"
	AutomaticAutomaticIntervalMENSAL     AutomaticAutomaticInterval = "MENSAL"
	AutomaticAutomaticIntervalSEMANAL    AutomaticAutomaticInterval = "SEMANAL"
	AutomaticAutomaticIntervalSEMESTRAL  AutomaticAutomaticInterval = "SEMESTRAL"
	AutomaticAutomaticIntervalTRIMESTRAL AutomaticAutomaticInterval = "TRIMESTRAL"
)

// Defines values for AutomaticRequestAutomaticInterval.
const (
	AutomaticRequestAutomaticIntervalANUAL      AutomaticRequestAutomaticInterval = "ANUAL"
	AutomaticRequestAutomaticIntervalMENSAL     AutomaticRequestAutomaticInterval = "MENSAL"
	AutomaticRequestAutomaticIntervalSEMANAL    AutomaticRequestAutomaticInterval = "SEMANAL"
	AutomaticRequestAutomaticIntervalSEMESTRAL  AutomaticRequestAutomaticInterval = "SEMESTRAL"
	AutomaticRequestAutomaticIntervalTRIMESTRAL AutomaticRequestAutomaticInterval = "TRIMESTRAL"
)

// Defines values for ConsentRejectionRejectionRejectedBy.
const (
	ConsentRejectionRejectionRejectedByDETENTORA  ConsentRejectionRejectionRejectedBy = "DETENTORA"
	ConsentRejectionRejectionRejectedByINICIADORA ConsentRejectionRejectionRejectedBy = "INICIADORA"
	ConsentRejectionRejectionRejectedByUSUARIO    ConsentRejectionRejectionRejectedBy = "USUARIO"
)

// Defines values for ConsentRejectionRejectionRejectedFrom.
const (
	ConsentRejectionRejectionRejectedFromDETENTORA  ConsentRejectionRejectionRejectedFrom = "DETENTORA"
	ConsentRejectionRejectionRejectedFromINICIADORA ConsentRejectionRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ConsentRejectionStatus.
const (
	ConsentRejectionStatusREJECTED ConsentRejectionStatus = "REJECTED"
)

// Defines values for ConsentRejectionReasonCode.
const (
	ConsentRejectionReasonCodeAUTENTICACAODIVERGENTE    ConsentRejectionReasonCode = "AUTENTICACAO_DIVERGENTE"
	ConsentRejectionReasonCodeCONTANAOPERMITEPAGAMENTO  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
	ConsentRejectionReasonCodeCONTASORIGEMDESTINOIGUAIS ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	ConsentRejectionReasonCodeFALHAINFRAESTRUTURA       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
	ConsentRejectionReasonCodeNAOINFORMADO              ConsentRejectionReasonCode = "NAO_INFORMADO"
	ConsentRejectionReasonCodeREJEITADOUSUARIO          ConsentRejectionReasonCode = "REJEITADO_USUARIO"
	ConsentRejectionReasonCodeSALDOINSUFICIENTE         ConsentRejectionReasonCode = "SALDO_INSUFICIENTE"
	ConsentRejectionReasonCodeTEMPOEXPIRADOAUTORIZACAO  ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
	ConsentRejectionReasonCodeVALORACIMALIMITE          ConsentRejectionReasonCode = "VALOR_ACIMA_LIMITE"
)

// Defines values for ConsentRevocationRevocationRevokedBy.
const (
	ConsentRevocationRevocationRevokedByDETENTORA  ConsentRevocationRevocationRevokedBy = "DETENTORA"
	ConsentRevocationRevocationRevokedByINICIADORA ConsentRevocationRevocationRevokedBy = "INICIADORA"
	ConsentRevocationRevocationRevokedByUSUARIO    ConsentRevocationRevocationRevokedBy = "USUARIO"
)

// Defines values for ConsentRevocationRevocationRevokedFrom.
const (
	ConsentRevocationRevocationRevokedFromDETENTORA  ConsentRevocationRevocationRevokedFrom = "DETENTORA"
	ConsentRevocationRevocationRevokedFromINICIADORA ConsentRevocationRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ConsentRevocationStatus.
const (
	REVOKED ConsentRevocationStatus = "REVOKED"
)

// Defines values for ConsentRevokedReasonCode.
const (
	ConsentRevokedReasonCodeNAOINFORMADO      ConsentRevokedReasonCode = "NAO_INFORMADO"
	ConsentRevokedReasonCodeREVOGADORECEBEDOR ConsentRevokedReasonCode = "REVOGADO_RECEBEDOR"
	ConsentRevokedReasonCodeREVOGADOUSUARIO   ConsentRevokedReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ContractDebtorDocumentRel.
const (
	ContractDebtorDocumentRelCNPJ ContractDebtorDocumentRel = "CNPJ"
	ContractDebtorDocumentRelCPF  ContractDebtorDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataAuthorisationFlow.
const (
	CreateRecurringPixPaymentDataAuthorisationFlowCIBAFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowFIDOFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowHYBRIDFLOW CreateRecurringPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for CreateRecurringPixPaymentDataDocumentRel.
const (
	CreateRecurringPixPaymentDataDocumentRelCNPJ CreateRecurringPixPaymentDataDocumentRel = "CNPJ"
	CreateRecurringPixPaymentDataDocumentRelCPF  CreateRecurringPixPaymentDataDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataLocalInstrument.
const (
	CreateRecurringPixPaymentDataLocalInstrumentDICT CreateRecurringPixPaymentDataLocalInstrument = "DICT"
	CreateRecurringPixPaymentDataLocalInstrumentINIC CreateRecurringPixPaymentDataLocalInstrument = "INIC"
	CreateRecurringPixPaymentDataLocalInstrumentMANU CreateRecurringPixPaymentDataLocalInstrument = "MANU"
)

// Defines values for EnumAccountTypeConsents.
const (
	EnumAccountTypeConsentsCACC EnumAccountTypeConsents = "CACC"
	EnumAccountTypeConsentsSVGS EnumAccountTypeConsents = "SVGS"
	EnumAccountTypeConsentsTRAN EnumAccountTypeConsents = "TRAN"
)

// Defines values for EnumAccountTypePayments.
const (
	EnumAccountTypePaymentsCACC EnumAccountTypePayments = "CACC"
	EnumAccountTypePaymentsSVGS EnumAccountTypePayments = "SVGS"
	EnumAccountTypePaymentsTRAN EnumAccountTypePayments = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	EnumAuthorisationStatusTypeAUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	EnumAuthorisationStatusTypeAWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	EnumAuthorisationStatusTypeCONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	EnumAuthorisationStatusTypePARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	EnumAuthorisationStatusTypeREJECTED              EnumAuthorisationStatusType = "REJECTED"
	EnumAuthorisationStatusTypeREVOKED               EnumAuthorisationStatusType = "REVOKED"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	EnumPaymentCancellationFromTypeDETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	EnumPaymentCancellationFromTypeINICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOPENDENCIA   EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonCode.
const (
	EnumRejectionReasonCodeCONSENTIMENTOINVALIDO                     EnumRejectionReasonCode = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeCONSENTIMENTOREVOGADO                     EnumRejectionReasonCode = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeFORAPRAZOPERMITIDO                        EnumRejectionReasonCode = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeNAOINFORMADO                              EnumRejectionReasonCode = "NAO_INFORMADO"
	EnumRejectionReasonCodePAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodePAGAMENTORECUSADODETENTORA                EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodePAGAMENTORECUSADOSPI                      EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeSALDOINSUFICIENTE                         EnumRejectionReasonCode = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeVALORACIMALIMITE                          EnumRejectionReasonCode = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeVALORINVALIDO                             EnumRejectionReasonCode = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonCodeGet.
const (
	EnumRejectionReasonCodeGetCONSENTIMENTOINVALIDO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeGetCONSENTIMENTOREVOGADO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeGetDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeGetDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeGetFORAPRAZOPERMITIDO                        EnumRejectionReasonCodeGet = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCodeGet = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCodeGet = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCodeGet = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCodeGet = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCodeGet = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetNAOINFORMADO                              EnumRejectionReasonCodeGet = "NAO_INFORMADO"
	EnumRejectionReasonCodeGetPAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCodeGet = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADODETENTORA                EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADOSPI                      EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeGetSALDOINSUFICIENTE                         EnumRejectionReasonCodeGet = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeGetTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCodeGet = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeGetVALORACIMALIMITE                          EnumRejectionReasonCodeGet = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeGetVALORINVALIDO                             EnumRejectionReasonCodeGet = "VALOR_INVALIDO"
)

// Defines values for PatchPixPaymentDataCancellationCancelledByDocumentRel.
const (
	PatchPixPaymentDataCancellationCancelledByDocumentRelCNPJ PatchPixPaymentDataCancellationCancelledByDocumentRel = "CNPJ"
	PatchPixPaymentDataCancellationCancelledByDocumentRelCPF  PatchPixPaymentDataCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for PixPaymentCancellationCancelledByDocumentRel.
const (
	PixPaymentCancellationCancelledByDocumentRelCNPJ PixPaymentCancellationCancelledByDocumentRel = "CNPJ"
	PixPaymentCancellationCancelledByDocumentRelCPF  PixPaymentCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for RejectionRejectedBy.
const (
	RejectionRejectedByDETENTORA  RejectionRejectedBy = "DETENTORA"
	RejectionRejectedByINICIADORA RejectionRejectedBy = "INICIADORA"
	RejectionRejectedByUSUARIO    RejectionRejectedBy = "USUARIO"
)

// Defines values for RejectionRejectedFrom.
const (
	RejectionRejectedFromDETENTORA  RejectionRejectedFrom = "DETENTORA"
	RejectionRejectedFromINICIADORA RejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseErrorCreateConsentErrorsCode.
const (
	ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA       ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO    ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA            ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	ResponseErrorCreateConsentErrorsCodeFUNCIONALIDADENAOHABILITADA ResponseErrorCreateConsentErrorsCode = "FUNCIONALIDADE_NAO_HABILITADA"
	ResponseErrorCreateConsentErrorsCodeNAOINFORMADO                ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO           ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO       ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationReasonCode.
const (
	ResponsePostRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponsePostRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedBy.
const (
	ResponsePostRecurringConsentDataRevocationRevokedByDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedByINICIADORA ResponsePostRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponsePostRecurringConsentDataRevocationRevokedByUSUARIO    ResponsePostRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedFrom.
const (
	ResponsePostRecurringConsentDataRevocationRevokedFromDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedFromINICIADORA ResponsePostRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentDataRevocationReasonCode.
const (
	ResponseRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedBy.
const (
	ResponseRecurringConsentDataRevocationRevokedByDETENTORA  ResponseRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedByINICIADORA ResponseRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentDataRevocationRevokedByUSUARIO    ResponseRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedFrom.
const (
	ResponseRecurringConsentDataRevocationRevokedFromDETENTORA  ResponseRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedFromINICIADORA ResponseRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedBy.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedByDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByUSUARIO    ResponseRecurringConsentPatchDataRejectionRejectedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedFrom.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedFromDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedFrom = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedFromINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationReasonCode.
const (
	NAOINFORMADO      ResponseRecurringConsentPatchDataRevocationReasonCode = "NAO_INFORMADO"
	REVOGADORECEBEDOR ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	REVOGADOUSUARIO   ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedBy.
const (
	ResponseRecurringConsentPatchDataRevocationRevokedByDETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByINICIADORA ResponseRecurringConsentPatchDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByUSUARIO    ResponseRecurringConsentPatchDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedFrom.
const (
	DETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedFrom = "DETENTORA"
	INICIADORA ResponseRecurringConsentPatchDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringPaymentsDataPatchAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataPatchAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataPatchAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataPatchDocumentRel.
const (
	ResponseRecurringPaymentsDataPatchDocumentRelCNPJ ResponseRecurringPaymentsDataPatchDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataPatchDocumentRelCPF  ResponseRecurringPaymentsDataPatchDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataPatchLocalInstrument.
const (
	ResponseRecurringPaymentsDataPatchLocalInstrumentDICT ResponseRecurringPaymentsDataPatchLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataPatchLocalInstrumentINIC ResponseRecurringPaymentsDataPatchLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataPatchLocalInstrumentMANU ResponseRecurringPaymentsDataPatchLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsDataReadAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataReadAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataReadAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataReadDocumentRel.
const (
	ResponseRecurringPaymentsDataReadDocumentRelCNPJ ResponseRecurringPaymentsDataReadDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataReadDocumentRelCPF  ResponseRecurringPaymentsDataReadDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataReadLocalInstrument.
const (
	ResponseRecurringPaymentsDataReadLocalInstrumentDICT ResponseRecurringPaymentsDataReadLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataReadLocalInstrumentINIC ResponseRecurringPaymentsDataReadLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataReadLocalInstrumentMANU ResponseRecurringPaymentsDataReadLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsPostDataAuthorisationFlow.
const (
	ResponseRecurringPaymentsPostDataAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsPostDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsPostDataDocumentRel.
const (
	ResponseRecurringPaymentsPostDataDocumentRelCNPJ ResponseRecurringPaymentsPostDataDocumentRel = "CNPJ"
	ResponseRecurringPaymentsPostDataDocumentRelCPF  ResponseRecurringPaymentsPostDataDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsPostDataLocalInstrument.
const (
	ResponseRecurringPaymentsPostDataLocalInstrumentDICT ResponseRecurringPaymentsPostDataLocalInstrument = "DICT"
	ResponseRecurringPaymentsPostDataLocalInstrumentINIC ResponseRecurringPaymentsPostDataLocalInstrument = "INIC"
	ResponseRecurringPaymentsPostDataLocalInstrumentMANU ResponseRecurringPaymentsPostDataLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPixDataDocumentRel.
const (
	ResponseRecurringPixDataDocumentRelCNPJ ResponseRecurringPixDataDocumentRel = "CNPJ"
	ResponseRecurringPixDataDocumentRelCPF  ResponseRecurringPixDataDocumentRel = "CPF"
)

// N422ResponseErrorCreatePixRecurringPayment defines model for 422ResponseErrorCreatePixRecurringPayment.
type N422ResponseErrorCreatePixRecurringPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Code N422ResponseErrorCreatePixRecurringPaymentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: Limite de transação excedido.
		// - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
		// - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
		// - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
type N422ResponseErrorCreatePixRecurringPaymentErrorsCode string

// N422ResponseErrorCreateRecurringPaymentsPaymentID defines model for 422ResponseErrorCreateRecurringPaymentsPaymentId.
type N422ResponseErrorCreateRecurringPaymentsPaymentID struct {
	Errors []struct {
		// Code - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Code N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode `json:"code"`

		// Detail - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
type N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode string

// N422ResponseErrorRecurringConsents defines model for 422ResponseErrorRecurringConsents.
type N422ResponseErrorRecurringConsents struct {
	Errors []struct {
		Code N422ResponseErrorRecurringConsentsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED")
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED").
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorRecurringConsentsErrorsCode defines model for 422ResponseErrorRecurringConsents.Errors.Code.
type N422ResponseErrorRecurringConsentsErrorsCode string

// Automatic defines model for Automatic.
type Automatic struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"automatic"`
}

// AutomaticAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticAutomaticInterval string

// AutomaticRequest defines model for AutomaticRequest.
type AutomaticRequest struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticRequestAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`
	} `json:"automatic"`
}

// AutomaticRequestAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticRequestAutomaticInterval string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
//
// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentEdition defines model for ConsentEdition.
type ConsentEdition = autopayment.ConsentEdition

// ConsentRejection defines model for ConsentRejection.
type ConsentRejection struct {
	// Rejection Objeto contendo as informações de rejeição dos consentimentos.
	Rejection struct {
		// Reason Informações sobre o motivo da rejeição
		Reason ConsentRejectionReason `json:"reason"`

		// RejectedBy Ator responsável pela solicitação rejeição
		RejectedBy ConsentRejectionRejectionRejectedBy `json:"rejectedBy"`

		// RejectedFrom Canal onde iniciou-se o processo de rejeição
		// - INICIADORA
		// - DETENTORA
		RejectedFrom ConsentRejectionRejectionRejectedFrom `json:"rejectedFrom"`
	} `json:"rejection"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRejectionStatus `json:"status,omitempty"`
}

// ConsentRejectionRejectionRejectedBy Ator responsável pela solicitação rejeição
type ConsentRejectionRejectionRejectedBy string

// ConsentRejectionRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ConsentRejectionRejectionRejectedFrom string

// ConsentRejectionStatus Estado atual do consentimento de longa duração
type ConsentRejectionStatus string

// ConsentRejectionReason Informações sobre o motivo da rejeição
type ConsentRejectionReason struct {
	// Code Código indicador do motivo de rejeição.
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - AUTENTICACAO_DIVERGENTE
	Code ConsentRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de rejeição indicado no campo `/data/rejection/reason/code`
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento];
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento;
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento;
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento;
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido para permitir a realização de transações pelo cliente;
	// - AUTENTICACAO_DIVERGENTE : Usuário autenticado no detentor diverge do usuário autenticado no iniciador;
	Detail string `json:"detail"`
}

// ConsentRejectionReasonCode Código indicador do motivo de rejeição.
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - AUTENTICACAO_DIVERGENTE
type ConsentRejectionReasonCode string

// ConsentRevocation defines model for ConsentRevocation.
type ConsentRevocation struct {
	// Revocation Objeto contendo as informações de revogação dos consentimentos de longa duração.
	Revocation struct {
		// Reason Informações sobre o motivo da revogação
		Reason ConsentRevokedReason `json:"reason"`

		// RevokedBy Quem iniciou a solicitação de revogação
		// - INICIADORA
		// - USUARIO
		// - DETENTORA
		RevokedBy ConsentRevocationRevocationRevokedBy `json:"revokedBy"`

		// RevokedFrom Canal onde iniciou-se o processo de revogação
		// - INICIADORA
		// - DETENTORA
		RevokedFrom ConsentRevocationRevocationRevokedFrom `json:"revokedFrom"`
	} `json:"revocation"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRevocationStatus `json:"status,omitempty"`
}

// ConsentRevocationRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ConsentRevocationRevocationRevokedBy string

// ConsentRevocationRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ConsentRevocationRevocationRevokedFrom string

// ConsentRevocationStatus Estado atual do consentimento de longa duração
type ConsentRevocationStatus string

// ConsentRevokedReason Informações sobre o motivo da revogação
type ConsentRevokedReason struct {
	// Code Código indicador do motivo de revogação.
	// - REVOGADO_RECEBEDOR
	// - REVOGADO_USUARIO
	// - NAO_INFORMADO
	Code ConsentRevokedReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
	// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
	Detail string `json:"detail"`
}

// ConsentRevokedReasonCode Código indicador do motivo de revogação.
// - REVOGADO_RECEBEDOR
// - REVOGADO_USUARIO
// - NAO_INFORMADO
type ConsentRevokedReasonCode string

// ContractDebtor Informações sobre o cliente devedor do contrato.
type ContractDebtor struct {
	Document struct {
		// Identification Número do documento de identificação oficial do cliente devedor do contrato.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do cliente devedor do contrato.
		Rel ContractDebtorDocumentRel `json:"rel"`
	} `json:"document"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular devedor do contrato.
	Name string `json:"name"`
}

// ContractDebtorDocumentRel Tipo do documento de identificação oficial do cliente devedor do contrato.
type ContractDebtorDocumentRel string

// CreateRecurringConsent defines model for CreateRecurringConsent.
type CreateRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Creditors      Creditors       `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration autopayment.Configuration `json:"recurringConfiguration"`
	} `json:"data"`
}

// CreateRecurringPixPayment defines model for CreateRecurringPixPayment.
type CreateRecurringPixPayment struct {
	// Data Objeto contendo dados do pagamento e do recebedor (creditor).
	Data CreateRecurringPixPaymentData `json:"data"`
}

// CreateRecurringPixPaymentData Objeto contendo dados do pagamento e do recebedor (creditor).
type CreateRecurringPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *CreateRecurringPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	//
	// [Restrição] - Se /data/paymentReference = "zero", as informações da conta de crédito enviadas (/data/creditorAccount) devem ser iguais as presentes na conta de crédito informada na criação do consentimento(`/data/recurringConfiguration/automatic/firstPayment/creditorAccount`)
	CreditorAccount struct {
		// AccountType Tipos de contas usadas para pagamento via Pix.
		// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
		// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
		// Segue descrição de cada valor do ENUM para o escopo do Pix.
		//
		// - CACC - Current - Conta Corrente.
		// - SVGS - Savings - Conta de Poupança.
		// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
		AccountType EnumAccountTypePayments `json:"accountType"`

		// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
		Ispb string `json:"ispb"`

		// Issuer Código da Agência emissora da conta sem dígito.
		// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
		// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
		//
		// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
		Issuer *string `json:"issuer,omitempty"`

		// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
		// se houver valor alfanumérico, este deve ser convertido para 0.
		Number string `json:"number"`
	} `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel CreateRecurringPixPaymentDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
	//
	// - "E" - fixo (1 caractere);
	// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
	// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
	// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
	//
	// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
	//
	// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
	EndToEndID EndToEndIDPost `json:"endToEndId"`

	// IbgeTownCode O campo ibgeTownCode no arranjo Pix tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do Pix.
	//
	// Caso a informação referente ao município não seja enviada, o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument CreateRecurringPixPaymentDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
	//
	// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
	RiskSignals *RiskSignalsPayments `json:"riskSignals,omitempty"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// CreateRecurringPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreateRecurringPixPaymentDataAuthorisationFlow string

// CreateRecurringPixPaymentDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type CreateRecurringPixPaymentDataDocumentRel string

// CreateRecurringPixPaymentDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type CreateRecurringPixPaymentDataLocalInstrument string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
// [Restrição]
// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountConsent Recebe os dados de conta do usuário recebedor.
type CreditorAccountConsent struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountPostPixPaymentsResponse Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccountPostPixPaymentsResponse struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Creditors defines model for Creditors.
type Creditors = []struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// Day Configurar limite transacional diário determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
type Day struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um dia.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado diariamente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
//
// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
type EndToEndID = string

// EndToEndIDPost Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// - "E" - fixo (1 caractere);
// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
//
// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
type EndToEndIDPost = string

// EnumAccountTypeConsents Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypeConsents string

// EnumAccountTypePayments Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypePayments string

// EnumAuthorisationStatusType Status atual do consentimento recorrente de acordo com a máquina de estados
// - AWAITING_AUTHORISATION - Aguardando autorização
// - PARTIALLY_ACCEPTED - Parcialmente aceito
// - AUTHORISED - Autorizado
// - REJECTED - Rejeitado
// - REVOKED - Revogado
// - CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Estado para qual o pagamento deverá transitar
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual do pagamento. O estado evolui na seguinte ordem:
// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
// Em caso insucesso:
// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonCode Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
// - CONSENTIMENTO_REVOGADO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCode string

// EnumRejectionReasonCodeGet Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
// - CONSENTIMENTO_REVOGADO
// - LIMITE_TENTATIVAS_EXCEDIDO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCodeGet string

// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
//
// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
type FirstPayment struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// CreditorAccount Recebe os dados de conta do usuário recebedor.
	CreditorAccount CreditorAccountConsent `json:"creditorAccount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date Define a data alvo da liquidação do pagamento.
	// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
	Date timeutil.BrazilDate `json:"date"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// Month Configurar limite transacional mensal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Month struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um mês.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado mensalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Informações gerais sobre o cancelamento.
	Cancellation struct {
		// CancelledBy Informações gerais sobre o usuário que solicitou o cancelamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica
				Identification string `json:"identification"`

				// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
				Rel PatchPixPaymentDataCancellationCancelledByDocumentRel `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Estado para qual o pagamento deverá transitar
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PatchPixPaymentDataCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PatchPixPaymentDataCancellationCancelledByDocumentRel string

// PatchRecurringConsent defines model for PatchRecurringConsent.
type PatchRecurringConsent struct {
	// Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
	Data PatchRecurringConsent_Data `json:"data"`
}

// PatchRecurringConsent_Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
type PatchRecurringConsent_Data struct {
	union json.RawMessage
}

// PaymentPix Objeto contendo as informações do pagamento.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'. Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
type PeriodicLimits struct {
	// Day Configurar limite transacional diário determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
	Day *Day `json:"day,omitempty"`

	// Month Configurar limite transacional mensal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Month *Month `json:"month,omitempty"`

	// Week Configurar limite transacional semanal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Week *Week `json:"week,omitempty"`

	// Year Configurar limite transacional anual determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Year *Year `json:"year,omitempty"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Identification string `json:"identification"`

			// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Rel PixPaymentCancellationCancelledByDocumentRel `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PixPaymentCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PixPaymentCancellationCancelledByDocumentRel string

// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
type RecurringConfiguration = autopayment.Configuration

// Rejection Objeto contendo as informações de rejeição dos consentimentos.
//
// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
type Rejection struct {
	// Reason Informações sobre o motivo da rejeição
	Reason *ConsentRejectionReason `json:"reason,omitempty"`

	// RejectedAt Data e hora em que o consentimento foi rejeitado
	RejectedAt timeutil.DateTime `json:"rejectedAt"`

	// RejectedBy Quem iniciou a solicitação de rejeição
	// - INICIADORA
	// - USUARIO
	// - DETENTORA
	RejectedBy RejectionRejectedBy `json:"rejectedBy"`

	// RejectedFrom Canal onde iniciou-se o processo de rejeição
	// - INICIADORA
	// - DETENTORA
	RejectedFrom RejectionRejectedFrom `json:"rejectedFrom"`
}

// RejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type RejectionRejectedBy string

// RejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type RejectionRejectedFrom string

// RejectionReason Objeto contendo o motivo de rejeição assíncrono
type RejectionReason struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração
	// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio.
	Detail string `json:"detail"`
}

// RejectionReasonGet Objeto contendo o motivo de rejeição assíncrono
type RejectionReasonGet struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
	// - CONSENTIMENTO_REVOGADO
	// - LIMITE_TENTATIVAS_EXCEDIDO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCodeGet `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - LIMITE_PERIODO_VALOR_EXCEDIDO – A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO – A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio
	Detail string `json:"detail"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsent defines model for ResponseErrorCreateConsent.
type ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// - DATA_PAGAMENTO_INVALIDA
		// - DETALHE_PAGAMENTO_INVALIDO
		// - PARAMETRO_NAO_INFORMADO
		// - PARAMETRO_INVALIDO
		// - ERRO_IDEMPOTENCIA
		// - NAO_INFORMADO
		// - FUNCIONALIDADE_NAO_HABILITADA
		Code ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - NAO_INFORMADO: Não informado.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// - DATA_PAGAMENTO_INVALIDA
// - DETALHE_PAGAMENTO_INVALIDO
// - PARAMETRO_NAO_INFORMADO
// - PARAMETRO_INVALIDO
// - ERRO_IDEMPOTENCIA
// - NAO_INFORMADO
// - FUNCIONALIDADE_NAO_HABILITADA
type ResponseErrorCreateConsentErrorsCode string

// ResponsePostRecurringConsent defines model for ResponsePostRecurringConsent.
type ResponsePostRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponsePostRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponsePostRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePostRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponsePostRecurringConsentDataRevocationReasonCode string

// ResponsePostRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedBy string

// ResponsePostRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsent defines model for ResponseRecurringConsent.
type ResponseRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// IbgeTownCode Campo utilizado pela iniciadora para cálculo do dia útil de liquidação do pagamento (vide especificação do endToEndId) baseado no município de cadastro do usuário pagador no detentor.
			//
			// [Restrições]
			// Campo de preenchimento obrigatório quando o oneOf utilizado do recurringConfiguration for “automatic”, e o consentimento passar pelo estado AUTHORISED.
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentDataRevocationReasonCode string

// ResponseRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedBy string

// ResponseRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsentPatch defines model for ResponseRecurringConsentPatch.
type ResponseRecurringConsentPatch struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser *LoggedUser `json:"loggedUser,omitempty"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *struct {
			// Reason Informações sobre o motivo da rejeição
			Reason *ConsentRejectionReason `json:"reason,omitempty"`

			// RejectedAt Data e hora em que o consentimento foi rejeitado
			RejectedAt timeutil.DateTime `json:"rejectedAt"`

			// RejectedBy Quem iniciou a solicitação de rejeição
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RejectedBy ResponseRecurringConsentPatchDataRejectionRejectedBy `json:"rejectedBy"`

			// RejectedFrom Canal onde iniciou-se o processo de rejeição
			// - INICIADORA
			// - DETENTORA
			RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom `json:"rejectedFrom"`
		} `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentPatchDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentPatchDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentPatchDataRejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedBy string

// ResponseRecurringConsentPatchDataRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedFrom string

// ResponseRecurringConsentPatchDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentPatchDataRevocationReasonCode string

// ResponseRecurringConsentPatchDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedBy string

// ResponseRecurringConsentPatchDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedFrom string

// ResponseRecurringPaymentsDataPatch defines model for ResponseRecurringPaymentsDataPatch.
type ResponseRecurringPaymentsDataPatch struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataPatchAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataPatchDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataPatchLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataPatchAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataPatchAuthorisationFlow string

// ResponseRecurringPaymentsDataPatchDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataPatchDocumentRel string

// ResponseRecurringPaymentsDataPatchLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataPatchLocalInstrument string

// ResponseRecurringPaymentsDataRead defines model for ResponseRecurringPaymentsDataRead.
type ResponseRecurringPaymentsDataRead struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataReadAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataReadLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataReadAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataReadAuthorisationFlow string

// ResponseRecurringPaymentsDataReadDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataReadDocumentRel string

// ResponseRecurringPaymentsDataReadLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataReadLocalInstrument string

// ResponseRecurringPaymentsIDPatch defines model for ResponseRecurringPaymentsIdPatch.
type ResponseRecurringPaymentsIDPatch struct {
	Data  ResponseRecurringPaymentsDataPatch `json:"data"`
	Links api.Links                          `json:"links"`
	Meta  api.Meta                           `json:"meta"`
}

// ResponseRecurringPaymentsIDPost defines model for ResponseRecurringPaymentsIdPost.
type ResponseRecurringPaymentsIDPost struct {
	Data  ResponseRecurringPaymentsPostData `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsIDRead defines model for ResponseRecurringPaymentsIdRead.
type ResponseRecurringPaymentsIDRead struct {
	Data  ResponseRecurringPaymentsDataRead `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsPostData defines model for ResponseRecurringPaymentsPostData.
type ResponseRecurringPaymentsPostData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsPostDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccountPostPixPaymentsResponse `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsPostDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsPostDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsPostDataAuthorisationFlow string

// ResponseRecurringPaymentsPostDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsPostDataDocumentRel string

// ResponseRecurringPaymentsPostDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsPostDataLocalInstrument string

// ResponseRecurringPixData defines model for ResponseRecurringPixData.
type ResponseRecurringPixData = []struct {
	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento.
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa natural ou jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPixDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReasonGet `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPixDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPixDataDocumentRel string

// ResponseRecurringPixPayment defines model for ResponseRecurringPixPayment.
type ResponseRecurringPixPayment struct {
	Data  ResponseRecurringPixData `json:"data"`
	Links api.Links                `json:"links"`
	Meta  api.Meta                 `json:"meta"`
}

// RiskSignalsConsentEdition Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
// Só estará presente após a primeira edição do consentimento de longa duração.
// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
type RiskSignalsConsentEdition = map[string]any

// RiskSignalsConsents Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
type RiskSignalsConsents = map[string]any

// RiskSignalsPayments Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
type RiskSignalsPayments = map[string]any

// Sweeping defines model for Sweeping.
type Sweeping struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime timeutil.DateTime `json:"startDateTime"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"sweeping"`
}

// SweepingRequest defines model for SweepingRequest.
type SweepingRequest struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime *timeutil.DateTime `json:"startDateTime,omitempty"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"sweeping"`
}

// Vrp defines model for Vrp.
type Vrp struct {
	// Vrp Definição da configuração de recorrência para realização de transações de valores variáveis
	Vrp struct {
		// GlobalLimits Limite transacional máximo para pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
		GlobalLimits *struct {
			// QuantityLimit Quantidade máxima de ocorrência  de pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED"
			QuantityLimit *int `json:"quantityLimit,omitempty"`

			// TransactionLimit Valor transacional máximo para pagamentos sob este consentimento, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
			TransactionLimit *string `json:"transactionLimit,omitempty"`
		} `json:"globalLimits,omitempty"`

		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *struct {
			// Day Configurar limite transacional diário determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
			Day *Day `json:"day,omitempty"`

			// Month Configurar limite transacional mensal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Month *Month `json:"month,omitempty"`

			// Week Configurar limite transacional semanal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Week *Week `json:"week,omitempty"`

			// Year Configurar limite transacional anual determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Year *Year `json:"year,omitempty"`
		} `json:"periodicLimits,omitempty"`

		// TransactionLimit Limite máximo de valor permitido para cada transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"vrp"`
}

// Week Configurar limite transacional semanal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Week struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante uma semana.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado semanalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// Year Configurar limite transacional anual determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Year struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um ano.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado por um ano, a partir da data definida no campo `/data/startDateTime`.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
// O recurringPaymentId deve ser diferente do endToEndId.
// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
//
// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
type OriginalRecurringPaymentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// EndDate defines model for endDate.
type EndDate = string

// ParameterOriginalRecurringPaymentId defines model for originalRecurringPaymentId.
type ParameterOriginalRecurringPaymentId = string

// PathRecurringConsentID defines model for pathRecurringConsentId.
type PathRecurringConsentID = string

// PathRecurringPaymentID defines model for pathRecurringPaymentId.
type PathRecurringPaymentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// StartDate defines model for startDate.
type StartDate = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200RecurringPaymentsIDPatch defines model for 200RecurringPaymentsIdPatch.
type N200RecurringPaymentsIDPatch = ResponseRecurringPaymentsIDPatch

// N200RecurringPaymentsIDRead defines model for 200RecurringPaymentsIdRead.
type N200RecurringPaymentsIDRead = ResponseRecurringPaymentsIDRead

// N200RecurringPixPaymentRead defines model for 200RecurringPixPaymentRead.
type N200RecurringPixPaymentRead = ResponseRecurringPixPayment

// N201RecurringPaymentsIDPost defines model for 201RecurringPaymentsIdPost.
type N201RecurringPaymentsIDPost = ResponseRecurringPaymentsIDPost

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPaymentsConsents defines model for BadRequestPaymentsConsents.
type BadRequestPaymentsConsents = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// RecurringConsentsConsentID defines model for RecurringConsentsConsentId.
type RecurringConsentsConsentID = ResponseRecurringConsent

// RecurringConsentsConsentIDPatch defines model for RecurringConsentsConsentIdPatch.
type RecurringConsentsConsentIDPatch = ResponseRecurringConsentPatch

// RecurringConsentsPost defines model for RecurringConsentsPost.
type RecurringConsentsPost = ResponsePostRecurringConsent

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// AutomaticPaymentsGetPixRecurringPaymentsParams defines parameters for AutomaticPaymentsGetPixRecurringPayments.
type AutomaticPaymentsGetPixRecurringPaymentsParams struct {
	// RecurringConsentID O `recurringConsentId` é o identificador único do consentimento de longa duração e deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independe da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição detentora (bancoex).
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	RecurringConsentID RecurringConsentID `form:"recurringConsentId" json:"recurringConsentId"`

	// StartDate Data inicial de corte da ocorrência do pagamento ligada ao consentimento de longa duração.
	StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Data final de corte para recuperação da ocorrência do pagamento ligada ao consentimento de longa duração.
	EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`

	// ParameterOriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// Código ou identificador único criado pela instituição detentora da conta para representar a iniciação de pagamento.
	// Caso informado, devem ser retornados todos os pagamentos associados ao identificador informado, sendo eles o pagamento original (dono do identificador) e as novas tentativas que enviaram o identificador na sua requisição, indicando que representam nova tentativa.
	ParameterOriginalRecurringPaymentID *ParameterOriginalRecurringPaymentId `form:"originalRecurringPaymentId,omitempty" json:"originalRecurringPaymentId,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPostPixRecurringPaymentsParams defines parameters for AutomaticPaymentsPostPixRecurringPayments.
type AutomaticPaymentsPostPixRecurringPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsGetPixRecurringPaymentsPaymentID.
type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsParams defines parameters for AutomaticPaymentsPostRecurringConsents.
type AutomaticPaymentsPostRecurringConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsGetRecurringConsentsConsentID.
type AutomaticPaymentsGetRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsPatchRecurringConsentsConsentID.
type AutomaticPaymentsPatchRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody defines body for AutomaticPaymentsPostPixRecurringPayments for application/json ContentType.
type AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody = CreateRecurringPixPayment

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody defines body for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID for application/json ContentType.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// AutomaticPaymentsPostRecurringConsentsJSONRequestBody defines body for AutomaticPaymentsPostRecurringConsents for application/json ContentType.
type AutomaticPaymentsPostRecurringConsentsJSONRequestBody = CreateRecurringConsent

// AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody defines body for AutomaticPaymentsPatchRecurringConsentsConsentID for application/json ContentType.
type AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody = PatchRecurringConsent

// AsConsentEdition returns the union data inside the PatchRecurringConsent_Data as a ConsentEdition
func (t PatchRecurringConsent_Data) AsConsentEdition() (ConsentEdition, error) {
	var body ConsentEdition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentEdition overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentEdition
func (t *PatchRecurringConsent_Data) FromConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentEdition performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentEdition
func (t *PatchRecurringConsent_Data) MergeConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRevocation returns the union data inside the PatchRecurringConsent_Data as a ConsentRevocation
func (t PatchRecurringConsent_Data) AsConsentRevocation() (ConsentRevocation, error) {
	var body ConsentRevocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRevocation overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) FromConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRevocation performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) MergeConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRejection returns the union data inside the PatchRecurringConsent_Data as a ConsentRejection
func (t PatchRecurringConsent_Data) AsConsentRejection() (ConsentRejection, error) {
	var body ConsentRejection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRejection overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRejection
func (t *PatchRecurringConsent_Data) FromConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRejection performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRejection
func (t *PatchRecurringConsent_Data) MergeConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchRecurringConsent_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchRecurringConsent_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsParams

	// ------------- Required query parameter "recurringConsentId" -------------

	if paramValue := r.URL.Query().Get("recurringConsentId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "recurringConsentId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "recurringConsentId", r.URL.Query(), &params.RecurringConsentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
		return
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
		return
	}

	// ------------- Optional query parameter "originalRecurringPaymentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "originalRecurringPaymentId", r.URL.Query(), &params.ParameterOriginalRecurringPaymentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "recurring-consent:recurringConsentId", "recurring-payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "recurring-payments", "enrollment:enrollmentId", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostPixRecurringPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostRecurringConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostRecurringConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsGetPixRecurringPayments)
	m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsPostPixRecurringPayments)
	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)
	m.HandleFunc("POST "+options.BaseURL+"/recurring-consents", wrapper.AutomaticPaymentsPostRecurringConsents)
	m.HandleFunc("GET "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)

	return m
}

type N200RecurringPaymentsIDPatchJSONResponse ResponseRecurringPaymentsIDPatch

type N200RecurringPaymentsIDReadJSONResponse ResponseRecurringPaymentsIDRead

type N200RecurringPixPaymentReadJSONResponse ResponseRecurringPixPayment

type N201RecurringPaymentsIDPostJSONResponse ResponseRecurringPaymentsIDPost

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type RecurringConsentsConsentIDJSONResponse ResponseRecurringConsent

type RecurringConsentsConsentIDPatchJSONResponse ResponseRecurringConsentPatch

type RecurringConsentsPostJSONResponse ResponsePostRecurringConsent

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixRecurringPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type AutomaticPaymentsGetPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsGetPixRecurringPaymentsParams
}

type AutomaticPaymentsGetPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPayments200JSONResponse struct {
	N200RecurringPixPaymentReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPayments200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsPostPixRecurringPaymentsParams
	Body   *AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
}

type AutomaticPaymentsPostPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPayments201JSONResponse struct {
	N201RecurringPaymentsIDPostJSONResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments201JSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams
	Body               *AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostRecurringConsentsRequestObject struct {
	Params AutomaticPaymentsPostRecurringConsentsParams
	Body   *AutomaticPaymentsPostRecurringConsentsJSONRequestBody
}

type AutomaticPaymentsPostRecurringConsentsResponseObject interface {
	VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostRecurringConsents201JSONResponse struct {
	RecurringConsentsPostJSONResponse
}

func (response AutomaticPaymentsPostRecurringConsents201JSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse struct {
	UnprocessableConsentsApplicationJwtResponse
}

func (response AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsGetRecurringConsentsConsentIDParams
}

type AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDJSONResponse
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsPatchRecurringConsentsConsentIDParams
	Body               *AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(ctx context.Context, request AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPayments(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams) {
	var request AutomaticPaymentsPostPixRecurringPaymentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostPixRecurringPayments(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	var body AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (sh *strictHandler) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams) {
	var request AutomaticPaymentsPostRecurringConsentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostRecurringConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostRecurringConsents(ctx, request.(AutomaticPaymentsPostRecurringConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostRecurringConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostRecurringConsentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostRecurringConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	var body AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9W28bR7Y/+lVqczIIlSEpkpJ8kRHM0CSdMH9LYkjKmcT0Xyl1l6hyuruYqm5Fdmwg",
	"r+f5AAfnYQaY7HkIvAE/HMx/Hxzk5QCH3ySf5KBWVXVXX3iRLdnJpIONPTK7u66rVq3Lb631fcVh/pwF",
	"JAhFZf/7yhxz7JOQcPhXJwrPGafPcUhZIH9wiXA4nat/Vrr4lCx+wt45Q59OJkM0xy5f/JM10JBwn4YE",
	"fRsRhAVyOHFJ4FBMBRLkKfbRGeMBcaiLBXLJnAQuCVyGXIZCOmfIJYgTJ+KCIcE86tAQu6xSq1DZ6TnB",
	"LuGVWiXAPqnsZ8ZYq3DybUQ5cSv7IY9IrSKcc+JjOXgfXz4kwSw8r+y3m7t3ahWfBuaHVq0yx2FIuOzi",
	"8XT63XT6xXQqnnxUqVXCZ3PZkQg5DWaVly9rlb8OXOLPWUgC59n/IM82WBnCBQuwR59jlzXQwCVBSM+o",
	"g13G5XTNNBc/Lf7JELl0vEjQC4bkdiARzRkPMUcYUdXv4r/kajaWLcllnSbjq39Dnm26LLvN7KLk504C",
	"t4dDkp9zD4cYndEAe3JGDuMhUeOXezknXE/OxYg5jHM1B7nnczzDPglChjw6wy5GmCGHBUKukfrdJchj",
	"wQwjN9LNxHP/NiL8WTJ1M7olE2xlJti0t/1/VqdT9/vdl1v1autxs95+8qL558et+t0nW/XqzuNm68mL",
	"x632k8fN+t3kyQeF9ME4ncmFGEkqlr8O8TM5k4FbRCr+nMFJcVgQLl75iCFn8S+XzhhiEWJyz21iwSgk",
	"QYhDeoGR6UcuULKKsq0zSXtRA02DbtJWuqXFzwF1GHI4xXITiIcRDURIw4jqnSKyJ8ax7FQODpv9nHMi",
	"d0eRZEAdavbWGgb0jQVDNDhj3McuqyGXXBAfCcIRJyHjAXaZQCGT/5+J5FOBsBDMofAYZ1fAak8A2yAe",
	"Ecgmo3hZqi4LgK2kWthCwJUCdoFFspgC1o0EF1SywNy6B/Icyrl/G1GhFqiGaOBSB8sxyG+TdfGh8aTt",
	"xjRYQq8rKMUmYXKJ/bknP5j8dT46OL57/PlkdHTwxflXj9qX4+PWg2P8/LPxQc+r1NLk3lzO5f7nY1x/",
	"3ql/Jek5+XM6rT/5vlm7e/dlAWnXKpf1GavrsQ/NXXG0fBIvocfz+ElXneuig3CEvua5175Gi1e5vdCU",
	"665nE4gAzfHFj0B1kY+OR4eojo4DKokIjYhgEXcIOsQ+aSA0DY7hlZpsWb4hvz+jAXWZpIDHowfdO63d",
	"1pPqeRjOxf72dsiYJxqUhGcNxmfb56HvbfMzR760JYcue8z2NQ0M/ydcjmU0QHUgoMUrhENOT6PFa1de",
	"faeIwVOgA4KmlYgH0woislW5B2KOHQIzImJOnMXrM+owOXQfzmVIgvhYyuYZvDoN5BUsm6DZW8hcuvK2",
	"okJSL0FEErm6oiUb8JgDt5hiwnLB5FZRl3A4BhgpUkERD/ZPceAwcrnfbfV6Ozut9o4cmbzdiD/39N1W",
	"uOUh8ZnYnwZ1xJJ5ViMebKnf0gOPeYVkFcmyuMvZWVWPbKtR1J61lkg+4EBpScPVeD5bsAADxY8WPy3+",
	"mwjkSyHHJSH2zrEUbwQ75QQB/xQhj+INidsTFleUL0VeCB9emdwsJiOPXMJj8ku8sZi0d2sF/5B7vIqH",
	"7LReWs+rW3+qTaf1xv7Hf7n3wcl/fPThH6fT7T//4cmfiq/QFNdYcX0Osrcjs0QN+zpaszY2391oba6b",
	"t76sFW1UySVLLllyyZvhkhlR7DfJJkWIebhCH1PSuaWR3az6lQzn/Spgl91IhMwn/FgQ3pmRICy4OUB4",
	"RwxFgvA6li9pBhCJaPEjpwxFIZXHeIWi7eh+6kkjlTe5MNaaHC4f4DntROH5is0mfnYCHpuxSOl2i5+9",
	"kPoYXZDnwPuYpg2X8QYaxaqLi+V2Y4dxuDgkj5QH7HZ7Z/0Bky9tNfqKc+2jcRTUUKuJxmSO2s3WbdS6",
	"u7+7s7/TQseT7vIlPcNzWsdReF53VxBS+25qMeU/bUI6YMGLSURefEHcF5Pz6MUDTl+McfhiHAVbNSTJ",
	"rP0SVT/DwYsH5PTFAeYvOnP+4gA/e/FZFLz4LPJedKLZizGZvzhywheH7OJFjzhbSNGn/n4/9T+o+snB",
	"5MXxpLuMJOUGGrIczDuuy4kQRRe8vEU4WfzE0GAoD2i8m4IgIkJ6QTjCYYQ9H+4ej82w3it7T9cscEy4",
	"dF7Heiw3R7iDICQcO3KKRUKNFCeOBz2gtN1Wu72W0uRLWygSeuJMXtSDnuZynHhGrglCTkBnJyJE8i8x",
	"l5ytgZTVxSVoRhIhSCr/DLFTTmc4XPxLLrk2i+hFxajqeJQE4RaSx0yQCF1gD8SCCwJ30y8//E3ejPJa",
	"Y7/88Hf1vXWnCsIvCN9CAUNOYiN09dBEiOXQBEOBHBGIIJw45FRKViySBHDGePJT5Ov+aXCx+NGjLqsh",
	"uzsYlpwhCHV652myF3XqwqqEjAeLH+seiG9mJJqiwH4pQhxGAjnMJWi32Wygjr0o0A12cIg5YnpE8Rhd",
	"a0CNdVSZHtvK+zcxibi375w5u2SvvnPbwfVdF+/UsXvWrt89bd5pn57dbbfvNCu1CsgfYWW/EkXQtEXh",
	"O6vub3nf4PpZp/7gyfd3Xtbtf+5e5Z+tdqHYD3K/IkvgBu1mM6v3iIE7xKFzLh87TEqscJ3h+dyjDti9",
	"t58KZaBP1ucDTs4q+5U/bCcG/m31VGyPdIdLO4JhZW8Yl0kpbKnBDw3pJWKnIZXvSdoRkUOEYI3Ky9qS",
	"WY0Idt/FpKCfm50TvdTd3fCc4n5uYj6tIoJgInwnhCf7ufY53cfuSLH/NXO4h5xzzAUJP47Cs/qdq0+p",
	"zznjRRPopIzG6IxR5GNP2bBxDTGfhhS0QlBqQyZSN5CoqWsgkIL6M49hV14EOOT4YvEK1iX5LsDoePQw",
	"M2+zwlqrEb+bdZDL8IDxU+q6JHhvsz5CIfuGBFJbR0Q4bC5lNBBSQrjSIx+jOfMWr0OpjLhSiphFHAeL",
	"nzAs0QVlHnaxnMwnOCTf4WcT6hMWhV/Q8LzjulT2g70hZ3PCQ0p+NfsbmE3GIQlcCmKAMROEREpfHgUn",
	"MREhPiUecajL5DRBVgywNwZRSXX33nYPdkruEiKcM0l9M7ULUq7pDAdyCwOGfOpwJqRwRxc/wSwOSHjO",
	"3EMWdjyPfUfc90iAYC/xqcs4eKTksZEMEoQ1Y8ySfDPykb94FTLXiJ/K76x2Rc7Eccg8xKceeY80lvaU",
	"y0HQ4BwMdZY8rUaKXHpGOOhI4Gekc3WR+IvXLsVoDiAFuDXgHMrGnkba3uFgKYYSToTdCkHHkwf1O3o9",
	"HrAoeJ/7msdIqH0jl1SEBCjTnEEqRWUf9HvYzaw/TqQszjdz1esuCudy+lSyQ9WvvAKE8fJqeyEodrZJ",
	"CsyiSyUCHIXMX/wYUkdJAcune8Nyte5nqVD9zid+I9KcbPTXsM1jGpKBOLogXMoH75XnCn2zLX5Utm0H",
	"c07ATkNQykclT6c8yAKEoDmjQl+aNJiB1m+uSX/x4yX1YQUmwzGaeewUezUUEHnWfaadXC9rleMAa0jU",
	"e1yBbsq4gSM5AuroOeNIbjHZjq0WklcpMSn+Sc1kzhlcVace2UR+/S58wyl0OcEhWUG6YzKLKJcUyziV",
	"fFRTrDabEhA61ScxzKkzHNQQlYJfq7EjxZ4TZfU4MbKDFPYigUR0SkMSiNyU+0FIw2drWdRVZr3bbqcm",
	"nmMQ1zN5IEoSuHNG5XoWz0uqshtNTZt6YOuH8emHy22ukYYODhziqSewGpHvY/4MUCrrP6hVLrAXgVgj",
	"xTwuKvuP5aBcgLl0Pukc9A8nRyeHnaOTYX90MJj0T7qdw27/oXpQkQsWYurB0U/4kzr/WrTSJrRvI5Ie",
	"CEsNpVGpVUIagl3rrZt6+aRW8UkIRKGNoD0cEqlAVPYr7Wa7VW/u1dutSfPO/k5zv9n8Su7+y9ob0pI6",
	"RDnV3gIDXQdpsQ3oKjuGq5HYGHuu1NJEdEYdOSiSpqiC5ysJaNx52Ds6GRyOjx8MuoP+4aRvE0xHQ+sE",
	"qEAswC7Wu8qEiCgS0FvSl8HggYOZ27g3m3byY3xP5FC0GxsI9vIOPCUAFFbmAR8LvSyL/+UqW7vZeVAt",
	"L+Q1svgH8hb/mmlNOiCzxb8cyoTlrAYsY6qrRiWZImz/5vPY/74yT+ndZu+/r0i2L/IvKIrIQUAVRBPk",
	"H9kEkP8FFdqW4XCaYGeXCUMABMhT2j7qK1O+JLE3JCvZ8qPOw6PRSac7OOicPBxIDriPHmFPqvWCxEb/",
	"yAs5nmMhMCpU79HjIIs3qKqhsUjyLuxtbQcMYc5x8JQ9UWPSehpH8fDi2YccByJmGcRjSLlniDXmweGj",
	"zsNB72gfHelRAsbTKEuLV8gIIdAbQ5+PUJeBvVHjTKExNWnJ/gdHvaMT1Xb/r91+D9ruJGMxto8503Sq",
	"R+1iJd6ZxdJQew6YcHAIpURfeQLIpUNcWjyCz487h5NBr9Prv9kwMPo2wkFIXeyS1FjwyrFgGEv36HDc",
	"P5wM1L2YLHE39Vki31VJfGsBQnyroJVh/7AnSfakczw5Gg2+6nQ7uRZVqEAIEiWA/mNS8MG/PfewQNhb",
	"/ATgkKru8pcf/jbsjCaDzsOHX550ut3+cNLv/fLD39Uohp1R56A/Gan7fXD44Gh00JGTGWK++E+5Knol",
	"0wSRfJZM3/oinju8nGn50G4OZ52ESgsKse7GSB+9waP+6BNYodTC7SNtIrehHC69IHymblB4aF5JbSz0",
	"0OtPOg8/7Z8kPSUT6gFEh6TbTk8t+WzU7x6PO72jk15/In8YdeSKmK+0ksM2nG3c2Hg4KGwmYGhMRUh8",
	"aGKYYMcHgQhxEC7+MyBMoOp4OFD73B/Jver1D4ZHk/5hd9DZR5K/Z2IqrJOmzvjkaNJ5mF5x68A9VEwu",
	"ZCH24uOab2PUORxLel7ajuFNLk6d4ISh8oSjusRwEMbtt+2xyw3oTAaPOuNUJ0kLFu4d+J5Hv42oi2Mh",
	"K9luYyfDmsVq7pxnUA+ORp2T4ajzlZGSdafnjCv8AkBR+OI1U27hvLk4EWTxjARuPAAvwaWlSDaeZYrL",
	"z5NT+DhgPjlxWVVsnTjYn8s/nsgbiHAw/MHUcQatnzYyBNrO6NLnxNc+8YJQgyToAmmpXCQzgr6Clf0o",
	"XBoJIr+y/7hYZMzfwfGPZvqVWmXlRZV/XnCNVGqVYv6ee1DEsiu1yhKOmnpitZl/aR3Lq9Qqy7lWqoU8",
	"Typ+PB4OKrVKjkUk67WeGeTeXXPok/cLDmulVik6TtbE87RfeVKzUBGFJJSL5zBqSA5PZqlcKemZKUdI",
	"GiOWRCxxon0GpTxayqOlPFrKo6U8+k7l0SVyJBwWkjBB5T0oXv9Sci0l1zeQXGPB43oNmrmg/U2hx7Et",
	"NCvaTBavw8hj6QgWLdbE4kttqYSjb+tSvinlm1K+KeWbUr75TdrbHibiRFZMypz/QnnkYZE0soFIMYlv",
	"0DPYC4bmHD9na0WDw/T1aygCZ67eIq9f+grd27tS8E4SfvFY+a7MrRpbDp7En7HTp8QBp6yPLwfK/6WC",
	"tPQ/knQy8sJ5Bm9qdySklTAP57RxIH+vJT/XqS8vZpWhSE6kMqPheXTacJi/7UX0m2cX2z5zvqmf4uCb",
	"baoRpNt4Tk2ERTIP7aQrGviVPdrX5QG0T+IylIF9KjeCA6TAAMD/rdZOFIHqyy0l9SbxZspPCllo7MY0",
	"8WL0FAeKuWhEbywzLuXYR8ISckXC4rVzl50SlzjER1h5fuOMSFJWU7HHePUl0vFmka/wRDqtDEjPGTC5",
	"QUZy7FtjSNtgN8J9bLCky8yey6ykKSveRoPY2KpXktmviMziPb4GyND1a0klqfwOSOUdSwM7v21pII+V",
	"fPPr31wyafl05UVzMLRf0HeI/Hs87uQcPUaY7PcG3U7q2nnQeTjpHJyMB4edwfjk6P5o8ElH6n9H45Ph",
	"w86kA3T7VndW8VDfoesJoby2u5yHHZnDk8uUkzpJWWtIhgFZGvcUdvX4oN+bVuS5n1ZG/c/63Yn895bi",
	"erkF2kdHVbGFjKXPiumQ/wJLCXFpxsyg0qEQF94TigsVEkROrVc2qSIdHs85u4CwboFIdgXiIYDtJ+bK",
	"kIwgpcNkyA4MJbbxMG6oeM253Hdg81ggTmYc8oTGgD4NCA0hiZ9hp0rr2oS4gecLGmCa5cHaqDr3cIiB",
	"BafSL1gcWpu0BJJ7EGGlj4Jp59/5ntnskvk1G21/zZyhUbKGkjX8e7OGUv68ivzZiULm45A6eTES24+y",
	"4tMZDZIgJIcFZ3QWWSkRObHyfymPj5V4NwmpE5VaTngNQo6dsEdOQxWUvSoeoJt++2Ut/n6DPI4qSpDj",
	"kGVstCla/Gu/2Wzu3GndutVutu42b7dvtfb27j679fRWJr/L3mapGr9v1Xb2ihPfnlEe51JYN/MH9rvw",
	"7SVxOz6LitKQPQLn1Bm9VHHH7FQF/9eQgwVDc05I4JxDZp8kv7COVs4GSlr7aDztREDTohaHA4voqeSf",
	"AmGEvTDJlRlxDI4edEFnSXK4tPsCTYNp8HhE5LLAZ09Q/9LxIuUj0lcuZFb65Ye/bbs4xNt2Vj1FiBB2",
	"ExPwto8vqR/5jzCn+NQjapl++eHvGbbTasr/Gq12JsNxOg3YbjoLGOSTa9Vat15Opw2Vpmtrq3B74ZBe",
	"YG/JeZLrMiecMpc62oNnsAUpR26hpxQ8xf2DzmHnofzzoH84Vn91Do/VH+P+QX88Gal/TEaD+F82JFS1",
	"UKlVVAOVWgW+r9Qq8eeVWiX5OgMHjD/Pz12MSMifqaB54i7NlCcg92ZsUUk5gFW+JyLP7hl+TrjtF0mB",
	"EqrkMuTYpXjLyh6aXOWW9xqu8BizMaSXDZsgzrAnSDyZU8Y8ggPN7vP0tOzYmaBaa1KM38QhvMCcLn68",
	"IFTcyCGyOMyyo3NzZ8enweYrHieKTcuJMfnI5RmnchjKBYUMppDfhfIk61m8ewAkSCWQd/G3EfFwxm9d",
	"jdd1GdfZqiHikUSONjlxaXAmjz9HmKE5FWz9PKbBYQoOkBARCrCwB6Yj3y/ii6Cmcr09xSpL7dsRg1zQ",
	"QyU525RrVvB1oIPKY6I3uIylAJ8bZsWcQL4Nh4yX5zZN8lUijOSqmIg5HAvqnPqE8ky2U0gKbCUQSJLi",
	"psSiBqQ4jtP0yk2ATgg6ZxwnfCuRwBV9PR496NZ3dnbuJgkM5XdS6PmG8CSNocucOJWhfH2rhgTx55zo",
	"jJs672hym1CfPGcBQceTbvV40oUftDKwld2edrO9owI57aR3OpfmdSdbraWEZTksOfbGfY6fU08ngn1b",
	"udm0CjpAJMjRBeEux2cheOEVcZzhyAtNksBlt1cRU1HHUKqTuVXXgKo5X7yqG90XVZ1zAoUiYOuxt2Uq",
	"Q6QKZKSFgYQv6QsluTZB3YbTxpkbKQ0p3ko1m+wVl1OEYqHaEmNqWWE9f80XrWXh6cvrJpkhJNrISjXG",
	"SsRWajOlNlNqM6U2U2ozpTZTajOlNlNqM6U28/vTZq5Pkr9+qf1+JGhAhFA5lQpS9hseUZ0TIRhGTyO+",
	"eC1v1i1dSE8Nuy7iCgW5WJSBnUI+wZI18lfKULMbHbpkZ+gXJFXu4iodQTL9yEfdw+FnBfNQpJhWGlzm",
	"RMW5f5LyOMXFUg8XP/tEpb81jcBpSL5TY2VnumILQ3IGHuYoO7JGmoGl/stwsTTfAq61+3IJoyoQFydQ",
	"jvW6RyzXOz3O9DAfd+pfPfl+d2mVrISGM4uuZrGW8uNNLCJ87Q7vq8zK+X0+fY8HA5UnozwZ7+1kOJy4",
	"NMziG1eneLVDoRKlqmqa2gJejz76aKQUJhB3JlLbPCNaehFQo82jKrhq/6OP4ItWAw3lu1phE2Zdzxav",
	"BXXwdoDDiGNvH00DVEc9VaCEUChZOydSZI18lZtTa2XP7iFyT719hLrDBwkCIinuwpBPhA/b/rWSXj02",
	"mxH3WBC+bZZuO73yX6sZtpeMN6YDPVKQbc8XP8bGR/mRFTgoiSwkgSgadlVsqQObGbqC9HCEYfgYcUyf",
	"yznAu3FwplHT9MzSbG7N7NL7N6SXqJNY3syW1VEnvfIp9btoG5KzVbAZSvpNaCp3sAp4lCo2k6XZvq8U",
	"Y7CDQCOaepLOkv7lSH2QbOeepHTraMdVkt2UBoimQb6HeJj5PqS8z/FzsG4xYB8Ad4duz3AQYkHxkr4y",
	"svMB5g5DnSBkASCj0H1Os/i8VjtTgk2yGFx/vvihvvg/Fv9nffF/L/6f+uL/rTX+sj+Nms32rY/+dCL/",
	"2HHg/5Pq1n/8eXs6nU4/+ON06n6I6k/+tKQAVh6YswqLQy7nVOmCSY7K4qJnSouJa59lS9ddyENDL7Gq",
	"s064CT9uoN+OTlRw70OVKCIE0cc2KRilT3QNrajnLVfFMSUpJWcgl5KrmAwKHD/XdgipYJrEBzSQLXCf",
	"Bthl9xCL7sG41EhMp9aQDGXXoEKC0s1rqGfKdvcQQ64i5VQ+BbmJceKF+HQs/iFQe2d/7+7+3l0kV6hI",
	"U8wnMM3ojHW5rFmA6tvqkZPqn/flo+nUfdF+3Gy1d55s7avf2ju7e/L33L+/2lj5jMn/mh1pydW1gQyr",
	"GeJNqHZaYnCLy68p84eFCU1DJbM2/RoE4YZxbgHDdeMGyKXjRQKgpjm7ZCzfbMt74pcf/v7exdy14ntS",
	"hG2p5Jth96282Nu6QbH3qjMwYTHDB5YI+u5E3GJrZEHGXs3gRAjMEOU9k8wqHCKMdzftPRDaSgevNHKU",
	"9n68or96h0Oeg5gr6JouQ5axx6dyMZiBeKrspLwSleX8XnwVxrJiLW7KzY7NFvpiS/xF2qUQS+TTyqbO",
	"xyLXxbTSeKcelJdFBzB/0Kj4ZkxnAfbE2kINyasZ20zOgBorqLmznb5c5ZLNlUe7kWnzGmDeSeMwQt3B",
	"iMiBFJqUuP3o6iVT5OfW/Zg6VOCgyx1yTrAu9LIG8pAa+Eh9BYsufyLu/QL7VyeE6p8QN6lOCiQgSad3",
	"T4ac8goPDgfdQaensnQej487o4FOealzd6acwKm3C64vNcYHnPlFDDyQilVg6gqyqA4AIZ1TnmXWdRrU",
	"UdKdDmdRY1o+gSXDtjORrr7grGXOzKdmtrDoElOxGAV6roAaURCSk4+uyRf5Ts3MBCql5xL/utlU6JIR",
	"L6G0Ate9TfqqaDxDPgvphc7LZu1YAeBnRfJ9ycoTuI5p0iaCfGIhHVb0aUf+NOr0x5PR8eRY0cekfzA8",
	"Oun/dTgYdXpHdo4l+VSu22AiH2gq12Fpk8745Gg0+KR/cNLrjyeDw6OTwSfHncE4fp4KV4tD9IuTkRUn",
	"EgOsxrGkwUEXcuQkiY5SO55Ny1s000qtsnyilVolN0+VQnjpNM3j4llWaldIjLxkimn6LfzyCpHKKltT",
	"lhBTrMPQVc7CFh+JbXWWtyV9fv3G2avuLaPGffS4l6rNg76VDOAMe+dYyeNnHEt5KpI6HqJSYjqlHoAi",
	"Y4aoxJ8n91aTdjaYEIw4LEIYhOBMbfp5pMUiKc1wH+pP3ys8HKkUELC0EP+XTUqW4Wj31p2pfVSUqnDx",
	"CtGZXKDFP4yJDcR8lo15jHP3wSxiEfHemqO6tFewJM4Zeiywhzll2zS4kD1Dq9t2lsttFknt98lVRlSU",
	"qvD6MjXeW5az8GjTTIVvnHrw3gp+hvZRbMqIa5Cpo2gOkMncllJWM+/GOuq9XCzk1cnybcKji2MgV8Q+",
	"xhfrBUvMEllZ0H72JtLnBZvhZeJngVjReFtx9IJ9Q1xbGIUfimTRzyPiG/kOZWXQzNjzIp51NW8g7b21",
	"uAqzeBtpddVc3o24ajYiPZ33Iaw+OvofeVlV/bjJNPSBWHOkEjJ8A0k13q3rk1TjJhvqGn109Im8RUf9",
	"bv9+v3c0Sv1qUXdGqM0sZLoNEOrSTeRKOOSWPdfEtYhYCb2vkLHMXqaErMbbSVnZBUjJJwbgCeMDtpMy",
	"xhVKKfk1yog8xsm5YaPK4vNOr5lMKMUmp8GArV1yQTJhEo33a3dfM7I3QphU/7yvre0vNNhk6+bM7usm",
	"YJnZawp0cl3W9tpNO9nXbclQXvKYzxn6PMKcCB+/L4e3vXqwKLU1yLN0tlFTjTZH8JKzvZmsVmBvX1Fe",
	"WXLVC+pG2CtwTrjKXoo9fbaLz17P7K2FF9d+8Kw2qNmmynDPEfZmkY+tKfyTIexSUFO8XMbsNOwBKsLb",
	"DDJ7MJtXyUiUB/ytklIzuNksbGqlgBu/CBeiZKUdxyn2v+jdlosod3zxypc7mWEICUiEQLp/4htnhg5N",
	"qCsYAUaDyRCFRC6bwzyiJK9i+gnTiW90Y+D3x0IHGYDzxeR9V4EvhZSXXK+qijWDSdU0sqCOxsTUMNBj",
	"Ar1vMBnWiihnzolDBeaLH7UPhVthYKt1MrUWBwDuEiTGRIEMsLQ75hIdc3aFjgqEPaz2eAJ0t5pC+kHk",
	"d5LXk5rNtQoV89PNzp+KyRmMh/dRNRenWJzi+z7HgnqEcia2FAnxkDp0DnOWXw0HqGp9ajnxqJ0dfAsJ",
	"KFSuUDCBuphzGYYAJXHr9p30qb2Tck7dScMiIdzxTrEfmwoRFYEcjDjtYtQxMYLEp0LoVKLGNuIjd/F6",
	"RhWVVONXF6+AguckcON4DOUOxghLxYUEriZ3LNViDfyrQczN4udTjzoMER/NiLwECbwUR3Do0wZ14uOw",
	"M4cvXkkGUUPTIGCIXBLuLF6rpFdIvgYQQaGqxFq+zloSABS46mj6i39dEACWgV2FAtwCb10NeW8ClQSZ",
	"RRQsfCGds4RR7KNup9tFVWUM6/WHR+PB5Oikc/JoMJ50thBB40efjM3z4dHxsHPY7eRwPa3bt3dzmNjl",
	"8a868nUJljeI/NMiYlh+UAIjPhqKUJYofREV8kJAkymaQReEx+erKsDoRRC5pCKkfEvupCDonEUXhGtL",
	"GfbOcBD5i1ecOoCn0mIcjM5hwYXkHMZg1lx2du428yintWvWbm4CLJaMJl7IWop9FUk1v2MgHyqKbioE",
	"8mVnC9iFIjAtqk4TYMi0YpluQfllATk6WwcYmFa20hA7ZadfcmWZe7VE4d08Cm/V3f8wefO9A5WAzKDE",
	"/aoR5xI/vKyt/mD8HSFzGsw2ff8Rn0NR+ytAPay1um6kR4ZPWjtr6wBLt249cE2qfRvojUN6ubRAvVEd",
	"16ghxc1JLn0No+ptpL66+Ro7ZGkQSRF27pxxKmBpH3jsu2UnA8qj6btcs3JztybaFEcMnXmRymmRFvDj",
	"22puhU5RK0drAccfE9Qd3O9I6evBoHdUi2WOvIzViK+HBDsmJYKnECIsQJQOZOfPPIbdGhLRKYEFJHVh",
	"VOwlI09mu3iFGPr0y/ujQe/kwcOjL9JlMKwHlVpFDtz8LQev/k4ZfNMf5CQwJ5g/HQQ0pLjQVAhBKa4F",
	"IE7HpblESrlKhzgHN3UYb5haE8u9Myb8gi5+gr8HlpUjyCdgqOw1b93Z27nVbjabrZ29N44VMzR5fYq7",
	"8T67DJ2SgJxRh8K9vW2HfWRJDHRnJQRoBjUyEcLoYzStPCecTSu1AiXf6tnoG4kiX00DpfUkt0A4UxmH",
	"6SzCVCoyMX1C+cB8m4mlXT7mdIn0Uf164zQBSZaa7AC/3rpWtduUASrV7lLtLtXu9652x3zwKor3v7/e",
	"7RamGlGadl5oEZAbxpSszOvUqxXd+k6BqlugFsr/K0jjYV+1zX+DHIW2r3KVIzTl0KPZOyGRdNOllfPS",
	"7g14QHNxtcZbxyIrxBZNAwPwKojQVTA6CPSQrNXEcsQJ8gOMSIjnWi5YJgGgqhylGj1EhxYEbEFtUTQN",
	"Po9w4KYLBch7gQiBVUquWjI6TkLGg9irYHwRUEPCxwFk2xGL14HDWYBrqtLEp5PJEO2222iTOqFZDrHG",
	"VWxzidb78xxn8hQUbvtSD3IukcE1uZRJ4E5YP3BVqsXVopp5c8jAglChpzMyYd8F3UJMzZHWrOy3Mona",
	"UEj8OPQfuuSh5praUKk1SfcgCkz9CYUblF+2GrcatwCpgwONZZLKRxwulPFx6kw+oZRMkB8F1Fm8ntN8",
	"SBOuIYaG42H6sGIhIp9KVh5XYoArj/jojHBdl0KE2AUpnagO6Fz+I2BJpK+6IES4+CfLQh73dprNVjMj",
	"JN5Oke/tnLZ0u1gq8JiDvUEgQr6EXfZjo62pfYEMBK6g3jv48DqHx6iOBoG80OANs+zEmBSKBAqAyA26",
	"k2WfOuf4gsh9M8g6eBHi9xUNFJklYoBChJbps8KyS/sFENt4qtoBaxlDzB2eUgohpwInFxQbeT84B3zt",
	"ErtzmtPaCcSW1JRPG6axbZhW3lvJnWOt7Jcf/l5soXY3i22bVrZqJl8HQ/7iVSipE/bYTh6RNljIx5Va",
	"RW5npQYQxwygUT3IUaMpiJ8t97qe6az48qU8CxulWdXfDOml9VGstefPRmo3JS9Rht4VxiQFwIEdTOWN",
	"c0l2M3XgZvoeXR9Eqa9Unrks06WYlpe/Bp5YR0OV68462PtoDGIlSlfFVneWVQUHTkUsHdgWgV9++Hts",
	"ZsMWy5aCrZZyz+gllh8/J5yp2O86GhMfB9jbN+oYhk+++CCIfPWo/gEOWE0hc5Nf7SjXlCYj1GN5vwSs",
	"gfqXxJ97bB9NK1/sNevtZnsXojXr6IAEQvZ7LAg6+MBf/JdI9SR/SHcCv4D6w6gwOpBIdXHQvGt3MZHL",
	"LEJIknMMsj1Bn38Q6l9Jqr/4V420RAwlP7kwG1RtIYx2pRqJUB19BhKUZCQHmC9+Yvvo8xY0iarksiGH",
	"83lLj8Z80jnlVIqLn0XBuXy/nXm/nXn/s8g7lx2MSUj8Uy4/2cl8spP55CgKo1MYVY88Nx/tZj7atT4C",
	"Esiu0geCFKyR+TFZoviXZIWAcz6N1+apnCoiqK0f6Bm5enD5xdRrM86s5bi1ZG2SaY4zyzlup6bZkTed",
	"orcv1aw021WHN0uuX8aEJHvTDyQjeQCqHRP78ol8VnSajf3RvBMfM/scmIfmKNgEbJ7ZNGxtt9Vu8jSe",
	"sHmqpxxPJouZlapo7pKYc3ZZEGjQBfnAwS6W/blwxEGekFqa5N9aoLPSAh3Zdhv5uUgKt+2jkHjkjAWk",
	"hkjdx9SrIWd+tu0E86dSFFfiCPaI4uygiB0m2S7Mx8ghXgyazEAswWvgAlar32jd2jUJtVR36osQcl4p",
	"bZ2hS/3fX/T/Ni4vL6uNy8stRFSCFxUuf/s2cjDHTkg4EZmBdYcPoGUrD60ejiSzViu2TYKTHc0ZiEjK",
	"XLb4SfKzYTqvh/IWLG9xd32LqQFmF7YYnHp8POiBAdEoj3KrrQTQZsVSV1OAAXOw22q3E8hByJgnErCB",
	"ARrIl7aKPUcZmRmuRaNoA8WxCATUWnzLAckmE0ksbcUdWOkLUgD4xIh/AXkZqKtCwKB1Q+7Vb5UGvm6U",
	"kmaSNrTkmLHaN1BHa6dzbfXTtRNWNS6nvhxjkc73kmlHCatJzgiV4eGXH/4mBUoQIHItwOTld7mkDmoJ",
	"cyaAdrvV2mm1d9uVqyBQeQYSvL7iwOLnQFfIXBc3A5YXdz0YOPZo4gak0zMHLvLR8egQ1dFxQOWs0YgI",
	"FnGHoEPsE5V6WL5hHY8kw4U6Endau621R0K+tCWlftlhtqtpYKZPuBzKaIDqoB4tXulE24vXrpzDqTy9",
	"owECoZugaSXiwbSCIJVcgH0i5tghMCGr0GhNC4o0CElgBdESaOwQMFxKps7Y8CAPS8QFaNZCquHyGgAJ",
	"ARwYCqKPFUEb26pcsq7JRgJAbiOhRjzYP8WBw8jlfrfV6+3stNo7ikqJvoFhF7/O08vXKCQ+3Mp1KZGa",
	"mVYjHmyp39JDtzRB6/Wci0Pp0MZ5U9WDK2wxVbg1NuglTVfjGUnGl7aT+ljKtBAJBG5IFUACDEke3nhL",
	"4taE5ZGUL0VeqIDIVyW4AhbZF6FJ5bJ4tUbh0twwTu1iGEgOnpDiYbFfPR/Gs3crZVuRFGEV/Ej+nE7r",
	"T75v1nZaL63n1a0/1abTemP/47/c++DkPz768I/T6faf//DkT0usiT4NQxw45L0g/ImfUlLlZWRhytOy",
	"VIbNWmgBKYiFGP11ODlq7uzVm812461iAd4sbY3tMNZWJ7l6gzVm+wnHISRZU6kuc8zF8gnAWtumbXUu",
	"wWFFgxA7oZZUtMUwrkLAQI7hCCPGpfBp83zJifpCZLbIxGgvfkxtQgouQxDAxTxlXZOth6mcrjVzMuBz",
	"6mLDYrFRaQ0OQnmy4YxLToBT4QtHwhI1E3OQCTgIyaWKHRrSyyQhnDx/4SV1UbV/8Ajdatebe1tILP7J",
	"9h/KZRPIp8HiZ+FEHhbgDPgQf4gw+vD5h8i8gGn6hY55oaf1buQSh0qupZ434fndD9f6eW00Uq6UtZzQ",
	"4meXJWwkFmBAftm37J/GrL2U2jISS3J471mm0LdsRdtJ17dS0IDho4wbUyaJE3VJtQSHi1eovWfvf8qB",
	"K1BVMr4XnfpXLyRrzLm3r1Br6YrVlbIFfhPfRS2pW6BMgnm8UBYflTeSrw8ie/cAJISydG2SstkWOxVg",
	"JMDHr4RO7VOWnOCCcEg/2m40G02oGBJBiSJeA+t6yDgkbRDChAkBbC2FiyDeUvvkvwH+B02DEgJUQoBK",
	"CFAJAdoUApS5C6yA4mz9Ibl8Vq7+okjPVE2rMoixZKUlKy2DGH8vQYwZTjpkIkwCWsRIZTsl707YLqXZ",
	"kgWXLLiUZn+P0uy1l5+6cvWpKxSfulLtqRspPbVR5ak3Lzz1PutObVJ26kpVp26k6JQzP+sG86erXLax",
	"HKDbI8EF8yQbRkEa+i/vTc1J4RBLxiIphkWwqrWc1VixAiIc5p2nigrI4wXNKZJT8R9JTGgGj6Gtr3mU",
	"xRJQhWpX7nNhw7tv2nAWjHzn9q1dyaOazdbO7atg6k3hkxcroznLemHvq15YrTInXLBgU4HWoGeTj7LX",
	"jdVeLT6TeoufXLU6WQ8XgcAMdJkbJpq+4qnJtxEX0cqU2zaurWXVvjTLZHGiLCyvhYAJE2IDR1ug6teK",
	"cYfPHspxfC0J4mvL/aJ+tcN2E2lFFLGwVHNFaXbja0JPPJ+wWXFcw6uhjDVJ8mbJ8dN0DaN2XIrd3gF5",
	"G89UCozshNYVqVEOZGtLXKg/ZhxMjXdXFbyoIErv5vO9oWnQycZ7w84yO9d5/st0VreQ4+d0o6xuGkWO",
	"rRpP2SRzKmsczUbFaVmlgXo6yyOcj5q+TPTXcDkmADViRpaGMrkqC5CvgOxMhBgmy4sCSMrsbKVWXWrV",
	"pWHzd2TY7KciK6+AP1II05qBQa+o65eJWzOYn4Jv8um2ayA5EEAIhAxE3acQtYvTqYFMRGX6dHSyAUo5",
	"UEkcsWSHBBldW+14PFzXvlKgNws4nlE+a+n7R6s4UAhVXuEhDmYEwVUmBba4eBdKwCI1ozNJ/Rky2ulr",
	"DYq3KEwTESHoTYASnZHAhSs1yex2Ri8Zau3tN5voeNKtKZAYJEjNJWBVUSmQ8hyRMyK5WgyrbDZlC0Ql",
	"fpOjtFPHyctn8dqjuKZXLW4JxlUzwKskvhqgO1igdus8B8q529xtNu/cudNutndb7fZea0+KYa32zp3b",
	"O63bmVOz006dGvnPlGLSf7JVNXeP+Wv35Va1CYkCXqiMAvE/H7fqJpXAzuNmvfVkq9p+3KzvPHnxuNlS",
	"D6CRvfhvGwvUWhKTnYlH3oizBUnMRRyiYYIvnj179uzgwHU//dT3v0n+Q9WdtoWFuoemFQcL2bK8PugF",
	"mVZqSF6eaPGqZvK9yVvRy0HaELERcFu6Wu++sqVMK/1pBdUVZVVbSZdbgPgyo0T1vGyqSDRUsNAZ4aCk",
	"9i16t27AfSMC5aQZKk+sUnALX6CBfqV6x8aGWbgwtXswXHsx0S8//O9wzmo6DaVchUg21LJXFtZDXqig",
	"h8UHAY6Xi5GITqWMooXxPKQyFontcj46qJZTxmko28M1OUOI4xXm4DNdHjduFjMkEpnObq9mBXrGGT0k",
	"B1c8QmM7VSQNd0kgUn2LuKqQ/WNNmzBN3RFL7KgpLXbN7krGGvkYhcwjfPGfQHxKM4Pxt9qw7CLmF2dR",
	"GHHJzfS/oXYQFJj2ESeewQtbe6DYlo6BtYpWJUsG4xwPB7D59umRey/It5EWFQGdhjeYFqq2WisgiJJD",
	"bHfqX20rBCKKD7sJz9A4eBU5hn754W82Rf7yw9+hqGjHlSp1ks/N6h622A5EKjgstYIn8SmRZCafUjs6",
	"fZ6q1tz3LAnH3Po5kZWTOQHBB+LSsfdtRDhiUSj3TorJOltegt4eDwe/B+5frBEWZulIRHOBIoFjW0kK",
	"j33AXAibkppEyA1cnoqYWwiFgxwRwTwdGbHbuL23UzOp1IOQ+HMPJCrd2QUNJK935embBokrmvnUoZ7O",
	"1cKgRLwCZOrviI98RuQ4IcoymBHKgX2oJsDEI+ZMx7nAq4jIC2fxvwLIHoOmwZjMALmeqk8HpyEOmegf",
	"Hh/o0HDQWOqoG0EuUvkX9NTVuUlVwK7UWupojC9oMBPxO1JGY9Ec6hKr+OdR5xBCSLUVKZjpnUp9EkuY",
	"c754VZdbkU42IEdUqVVkp5VaRbaZyYOinq+jjNgJ/2aUgS4o1jLwDRPIu6SPjakjviGFw+bMzrDyb0cy",
	"duDQGEpnGctUmmzUs2Xls5J0vhmHEdzJ30Y0UIoA1OAS4ET7ojOYDA4/OekcTz49Gg3GncngSC5GZxZh",
	"7qpANTu/KGRy6Iwmg87Dh1+edLrd/nDS76G6lDscij2lf4FQwXQFP2gX3unollxm6kF21ccjqLIX/w4F",
	"veDnCygvr0svjo8P4GfJbyOfuuniYMVTqdQq+eGqMqJ6XLqcqS53m1QTMx2md3FpL4X7qs9/FwcO8TwV",
	"FsaZX7y3KtVHNlutsqEqTzHV4oAq9MmoJQZKlVV2Yt3wj3RirjkTYvH6glAB0n5SHA52zVC1/nyZ8wIF",
	"4IcAlpPSmGWTcS25t2gxjem/SiW71QX4lmyDKvBWvBFHmdg/u8y7zuMDcQs665hxeiwpLSYQVlIa8DVV",
	"F68oVR8RUqHjEHPPYgk3U9swvc2Q9QFpnpAyx3yMhr3DT2p60O4SO5tcZdTtHHb7Dzu9o5Nh/7DXP+wO",
	"OlsryKfg9SW7TgLthZD85gLM+oKGkZ6KHF+6vc4n/cOeyh3zRi2Ou5/2Mhw5N1R5ros6zLLqog83Ja1V",
	"/FuXPzQoDC9FAcZjrq3DmOdmkx/mmnENU97WrAgC/upacU446qr0XN9G4EvUCcz8FJp8CfTGGvSwPx4f",
	"dU4OO5PjUeehZMbqh8+OR4PeoJs5ybm3V01tg2WOr0lL1j7S1x8iF8yLKNCQNqUrdRLi7UbdRz1UHRGH",
	"0AvibqXTgkkG8G1EBS2Ip1dcWUU/whkTkSrlmeYONeRLxkADFwM6RyVNMNGQ8qxCajcK7AOs/Lo4hohO",
	"famRafOBbR9oKLnosIuqmhwLRm4Hl0L8pIlXlwM3Jy03cruGblzz+YxZZZ7lR9VOtzvckvTD9X2OUXX0",
	"WXeylZm9Sk3T7Q6rqOM4ZB4SF3UjETKfcDTk7Ix6JDPykEmBUwqt2rSv1yogcpDawvF08SM6Yxz78cVo",
	"xGLbn5hfCGVwnXOQ9WBd7Zjk3EKjaqC8b0Klr0riUEExThu/WYR0NlElGulvrPeV2BwYOFXqc53Fpzvs",
	"oWqyVB7BkDlgqOwhBduczFeuiSIaEmWmnZuYTZWgNYTEN6Ul4kBhoWhFf+fi1H6rCqWfdSfy8DwlTijH",
	"tpQA1WExpJLZKGPDUBYFuQjjrrUIYxKGHoFEIV0FwiEu6pFTyYRQnMG8vrpzbRJf37m8rVB1SAKXBrMV",
	"q81JqDLs+HPGYwxC0bkDS32w+NGjgjQUTE8QhOeebHYtYlHpN91Pe6g6ds6JG21y1uWMtT8hfcJth3sK",
	"qEQD/cq+ta9aWFbdpRI1JGzQJgi77mz3UU9fwVIG73aH8D9DkLw/g/x9cpvlPdE7/ERqU91PMwK4frDq",
	"Zlh6J5BYHjqjgZS+oDB7auBy5RQcwYi4CM8X/xIbloCL773BXzPDHvx12ajVQYll0u7qIsFZ7IBdOfcp",
	"oeYmOLBKEpufMzdhOhmHQrLJR5gXlDY2kmujuOh8cZ345FeTC7CgLPFmOXftt0b97vFYSmdW9evC5+Ph",
	"wKiOcVOpoTzoPPy0Iwcz6vTHk9GxlDvMV4XPBt3h0mfD8TBdk7nwrdSYJ4PJ8cPOaNDr9Pong0M50MF4",
	"YhZULeLJsD8aHPWOTtRK9v/a7ff08DMvfH7cOZyotgreUp9Pjiadh+nFXfHyqHM4htr7xR/sI5MmOp3K",
	"GkVeyDGY9qXimoDH1MtzxlPoV6tfOffOZPCoM051YrBekARNJzAVWf9ICo0GNn6d7Bf4XkiDmUqOlSUI",
	"U6UZtuxIbuSo85UU/UcHg4leFpPdMh5fioyW574syjMjSHJoE4isQQHGuWVS8Gl1+L5O5ZPJsOM0A8of",
	"0Uqtkj+h8Y9mwLmi37XK+uOZeil/Oosfj4eDSq2y7AQuezSAK2P9+Vv2kj2oYr5QqVWWH8tKrbLyVOaf",
	"FxzK5KX1ZzL37pojmbxfcJRyczakL1ergPKVzWUJ4VsP83SfvvwKiXHTu/ATEpbX4e/jOrymC2+jW/VX",
	"ex2uvqCWH+7y+noP19fSK+R93mvXckNtcgfeyPW19IZaea+9/+vrgZWXvAgQdkYDasImNPYll0O5gRb/",
	"G6iVkCXS5CpN2Ygxwi4RGiQjTCW8TQNOVMggFix2QSjrU2zJxbEfVzeC41zHvopLgXBFbS0wleNSVe23",
	"qZifoo/RNVR4g6a2ahbOUPkyZpjjIKRcGzpWlaEzo5eDjyO0lgUr5kvQbOuQIpU6Ph9G4BfHdTwqugYc",
	"5qO2XH2cZJLLQYlvMkClsI7hmpqhRZlmZEPgeHeerUT4K99/YGDbgsyiAGQ0Fwr+j4/qu+3WbUDFCfIU",
	"19CH90cPP2xMgwlzmUBWcSGfBQQga0wkQXgAQFC1DEx+QYiWUg5v6PtC2cvkjqtwiux63x89zOCP8mFw",
	"T77fWQIEWlKMS5mXNL4Xe0rwTKmqmfCUI3QWiSUA3MR7l3ENJ8EuBHG9xrF5SgusibMmtn4VV3b+nZTw",
	"+nfKfjoax9lP3yr5aXi1WMzCKMxQxV9qqomZQ80wyDznKYpaeJiqmp3ekmOz4tW0u3ILdoQEqihPXRDk",
	"AWYkH4YwSIUuxOuZr7tm13m78YpshpIay6qKZfa2ON75xuqGFQ9PlQdbyjUN0/zgukqFZYtTr8qUecAC",
	"OaIrRvH6UI7i1x7E+55ieP3Ff4kUAew030UUr9qTX0MU7xCHzvnbFmDPNHK1sutFH+dG4VgolHVFKmeE",
	"Y5oYtjLosXy2C4MouP/sii3HJwhcawrOBHj7VJcrmfCqmGnZootTGWEs3vbG3d8ApzeiAvjL41RAKwoy",
	"bngj7F53VUlyc1NaXmPyHd8TmTdt8i46fsqAdQUpaQkgLNuvbreWPrpLGcAoUwFiOSNanT8pH5xv28tr",
	"iAPw1igXxI0N5iLt9JYjh8p/lf3HazRJ9VnfpTCkl7WNXh+RC6a3fOMvtAOh8vLJFZhrXKPvDZbOVuV+",
	"+waCG9Tr0W9Drc9QTaLBmKUpJCHCKXOpA8JOQbwH/K5iN4yEQwWY/uPqrOtlz/wlqfLVrDoXPZXZxjdS",
	"8ap3lej8slb5jpBv1r38hXznZa3yjGC+7t0v5TvFklUs0nRXCi8FiVLiKz+urQuFJHKq+aqLXxV/kkRs",
	"GVcYR8QjKPH3ASYqK/YfxfWtrIFr7FAqY4NODresaIxGhNuukW7nsFuYjjm+pjrhshrwKsxV4TOXBwhY",
	"ZZuSamaKCT0ePejWd3Z27ialdCTjDDl2viE8KajjMicuqiNf36rF4c3Hk25Rmfi9ers1ad7Z32nuN5tf",
	"Za1NdXmn5PMnvJ3JaVL98758NJ26L9qPm632zpOtffVbe2d3T/6e+/dXG9upejgkEzXqa7VSbShsA4vU",
	"xViU9ehKtL/m5ioFcNwoJfCbtNTEZP6AM/8NZes4nAo6xkKRyhs0ZAUELVUOOmElfTjjPrOTKZruqNAT",
	"tiwOzOQ1YgaAPYtL+8Epo/GdN+fMjVR1IjsHVBIMCLabzcT0jnHLrZW3x98RMleUvPrFR3xeeZlbjzRH",
	"xVHIdPGcRnp13p6zWm3DziYawluqSQXqUKF1cNMC3jqMKxvUaYSCaRymCAV6cwxzM+rPqkmK7NXpUXj9",
	"daJFHLqWHqaN5Wfl5f82Liq1D0V3/+cR8RUwnUUoFxxoE6cp1KUCI+W/jsfHndHAAH4M6GpZrKV++02j",
	"Ls0kDGfPcjgpcUN9bT0Zk3+EqYCE9DnLz2WDCSwZto2TWX3hWfuQmU/qrBRz+vTpWp/PuhC3iLAQi9eB",
	"w1nAipQBHSiw7rIrii94Wau4JMTUK/J9htg7J4ll+IpQy2JE5D7qxLn9PGJEVp1vRIiIIoE9lyERSdkG",
	"lHsdaotVtixLVr1XDK/cR48gig4BLSktK0HeJcA7IkJ8CoNwGXqccxNW1TBZpBTDre0gRpI/0fkZdKlE",
	"FA8vPoAZz4oX57y8lwd/JnDBGIciW1m8QheLHz3qMpW6OoVn21eRQpxINoNdtm3vyspSaXE88r3NMKb7",
	"qGfEeQt9RC8IVxFISgoxr6Tugnvr8Kn76HEq+UOalpxI4Cf3lmNY99FjQ5MuQYRzliizsLMmjcXidUBB",
	"EJJkj4ad7rjRbLZV08XAvX3UTd+9gd4KVCV+rKlTSRb3VgFm900gVuRjdIa9c6gcX5zmc2Dn6kTV8XCw",
	"ou1Bd1jUNkaD4IxjKXdEUuSHGuqq+PxQZb3EAlUH3eGKplMww+JOaKYThoZcRdNCgqGxQaOl0mVUh+Oh",
	"ctJzXY8qc5JX4xn3IavRupGsIPucEKdUpYgLJu6thgvv6/QfEEesIvkCzZchYyjo3N3hg21Vr359Ve61",
	"IGfJJm2LcJyQSWdj0lGtaM6oiJmcZEo+CVVmjXz+Xgh0vHSIa8Jf1uM/rzSMVD0Beyx45Vhw40po7KXg",
	"amiOJOx95rHTguQoDaT++50HOcmOUjkn8AW2y4KjyM9sWWJKVMlYGsuA5rLpGMEGAbTGsJ0JmA+Sech9",
	"s9LXqSmZw9tYDV1XU+GL/5T0Jm9y5pMTl1XF1glYVqti64nGZclbSufGDNgFTtY3HfxpMiW59Dnxdc7Q",
	"5CnjdCZZv1oR7J2zyOTUE/bOMChIvqKfxmrQvS3HpHwCyVytOgSnxCUOkaoqV0UzXIICMlv8y6EsX2i8",
	"uXtnc2hY1gwiBcdYbtxA7i2M3Hnfoq8cVCn9ltJvKf2W0m8p/a4RRyGD6q9CIr3qSN5KKH2HGsE7FoLf",
	"p/R7owLpuxKtS+H3tyL8vnPZVxWL7XPOeB6XJy/qTInDYpF2CehKX/UA1li8PoM001BXYM4ooJPsme7t",
	"XSX+Y7konAgpHpktXl8QDw72eeTjIA4qyo7rbVa9Vglp6BXlqlu8DiPvbcZxlTUp3nw1tJVE4ONLU1xs",
	"Z02pMZ8UATUPSIgzF3aMbkKLf6DOcGDYCWRXKvACfhsREcbOqZWuPFVdRUReiH87gKD36JzLeYjSa73O",
	"yT2nDbm/1+HTntP8cDSLWcucupzgkCxFEL8dpxKGVcWZqdWNYFXmIsX1xVS+rXwuMbGvrXa9zqSTvzE6",
	"6zIYQL7izkF/Mjo6Kci1YR7ZH/RH8ode/2B4NIHsn4V5Oh4cH3YHR4cwiF4f2v60c3/wcDDp9NKOySUj",
	"Xx2CDomLi8ademK9nht1QTKElWPOeEqXDvqNbpCEM4PqBNw6W9XUKLaxgr+/cuelkh5mpBijs8Z1dYCl",
	"pN+xbDAN3cEKeWSYlbJAvnqiZB8jgSz+UWh/U60v2cflTafAIYEqu6RlnlyTVxxoSlRS7BYnG8Sxi4Xu",
	"IkdOSvchi5+VVAvRWTPio6rjYepDsPOWsZFozUO/bYvzUsJHjtTONbLNn7NQF+ioXtb1DyRwntW/Ic+2",
	"9GCu2wykm115HPYzhaZMok6FwCNSn0dWCoaACIGRH+fpz0LSH+QJ8XGS1V9vk4jUnOBmvzkxKitGysMY",
	"L2dt6bnUlrq3OJUbnDdjgU2Z3mJT1BWO1JscnGw/BYdA3qFpul1Bo9nub5Tg0HqKSzbi/YrHm0rHvzL5",
	"achEeJMxWFcSjMA0eEHdCHsFcUeuirTC3ntJdJC1saXrUdPgHGt8qjpBb5W/AOviGcTtbKj3rIAw4rhE",
	"xSosp6rZlbqmdXhHusU4k7vay6ToRHESjjfSh6yor98rZPI0ElRywz5Ewq9zDN5Pv62y4sD5eGvqgQpj",
	"rIGOfYzUUqiypNbXN6Fm6xOrIuR0IFPilKM+ec4CIpXw6vGkCz9o0W+rDNN5mzAdkyRq0zRKQilLN14R",
	"HKztqiDhYDLMFudecvGEuLiurqrlnaoVrvPVbFArXAopIYlzYrBIeXXHxJib9ZjA9D2YDGtFV86cE4cK",
	"KHAKmbtpkpxibVZu6O4AkpYJEruaQUdY2h2T8q8XEo6v0FH6tvhvIp7InvVuZm4KkkqdqIvVppInphbV",
	"VIZhEdIOF1gu7ZBNLpV7ZZ3zss55Wee8rHNu6pz/u1c5J5dzyt9ecoMlcAm9xNyU2YmtAL9WSQ7lRbkl",
	"mamys1VVieUOZ4qbo+q0EqflnFYsMylAOCCAEE0rK9N6TitbKJ3HUO1R8aVpbnZVg/YfQpUi39+7C7Pb",
	"ukYl6fconnqpbHqrbn4r7x6cyGVxqqvaWBLdmmlP7v3ALQhqT4kKpo7yeviM1rjWmkpMpJyLVblmI3tF",
	"PjoeHaI6Og6opCOonxpxh6BD7BN5/OVzyzmqBFCVXlCe8zut3dYVjrl8fUve7rLjbJdmEQiXAxoNUB3Y",
	"lZQFQk5Po8VrFxJ7IgZPYeUJmlYiHkwrCDK1BdgnYo4dAtOyzLw1zVMkqQTxAiluKF8FrhD5WZwrMWAx",
	"NCcc6pJL+QoqTZO4dJiLkcecBAramAZdk8MYLF2Gg0Y82D/FgcPI5X631evt7LTaOyrHMbkk/tzTG/l1",
	"nmS+RiHxwRcoxWqWTLQa8WDL/JoeveV2sD7Iw+XgzjWyWVUPcEmbKcu5rvNtN16N57WVLSngQ6VLsG6D",
	"8qQgxsoFb1dRihsTVhJA46cHrevNSS+PCN+7leKOcousGtjJn9Np/cn3zdpO66X1vLr1p9p0Wm/sf/yX",
	"ex+c/MdHH/5xOt3+8x+e/OmD5UGhG/GSOImT/CrOAfWGAdtJLqt3H7EN1WTXBWyvyqaXrTyB7QmtgMYv",
	"qZcBaNIMhD3fpHFcZ93HBrR3koQHxz8lKepTbuSC51fyIKfh+DZSOtlWM6skkffXRkoxtLOtVntbLs/X",
	"jXXuGrysmOs9U6DYXoV9dJS3IsD4IErbNnQXo8Xza5RqMimzuWGjWcEp1dZTAvlX1hk03il4Ts7rm7dM",
	"PaDAoKXA+DaZB2AX3izxQHIa0XvPPQDTeJvUA9ZkMrOJ/de64DW60QwEZj/Sk7LPy9slq1xWdz5u5Hgu",
	"z8hbaddQEDO+LAE4r/xrvyEvSamIvg1fiYCIrsU7G1PPkgyJaBocZYueZz+KS4mkHN3ZzjgiLuSykW1q",
	"Z0qcCBW0pSTixC7wHlfGz1ct0fIkSPO+KQ+hJw0GDzN1deEXMlozBDmqjjWgxb+knhhHMCQlZiA3FJh6",
	"cGLqKd3PNwgKzlk7ljDTlIWmZqUCjr2FBZ7ppeaZoovAo8E3oghG8xAeXBeO5v3AdQBlY+aoh7AKu1Pi",
	"dn5tuJ35nLML7PUiOBP5SY7i/L+GWao4LoPthc/j9S2ME7PrglS1/5RFW+oiUMGbaNgZTQadhw+/POl0",
	"u/3hpN9roE6mdSnC6LoIOFy8kkQAtupzyD9JcQL0qynbAHQLO1Ar8jYov6/Olpa3QUyDog1eiWy1dj+3",
	"EsaBbFYAu2xLbvXSBchfD7v1Vrve3isoEfSbrwlU4sdK/FiJHyvxYyV+rMSPlfixm8GPnc7IhH2nck8u",
	"SXhsJeBXck5crU1VO1z86DmRx4zAtfg5pF4uhD8VNFK9oG6eT6qw6QnrB+7A3UKnWBDtOvCjgDqL13MF",
	"XHAkhWr/Xm6Pg1Sgfn7nNvEhxbulkBXJ/F2GipU8MEv88sPfYpTGLz/8vYbyV4m9y1rGWy467O00m61m",
	"Bg93OyUX3M7VnLu9DA1X4gRLnGCJEyxxgiVOsMQJljjBEidY4gRLnGCJEyxxgiVOsMQJljjBEidY4gRL",
	"nGCJE/x14AQ5Fd+M6SzA3loPxCh51bbrlkjDEmlYIg1LpGGJNCyRhiXScBnScIhD57yEG5ZwwxJuWMIN",
	"S7hhCTcs4YYl3LCEG5ZwwxJuWKarK2FoJQythKEBDG0alEC0EohWAtFKIFoJRCuBaCUQrQSi/ZqAaG+C",
	"KIvLmb97QNln/e5kPaJspRlAtZ2poZ6sy1vicLQ1urww3waIo/bhzZA4hjjfOwxHTeJtcDjxOcvPZYMJ",
	"XAMAJ96HzHxSZ2UZoq1ErZao1RK1WqJWS9RqiVotUaslarVErZao1RK1WqJWf/eo1RKo+o6AqkP8TJ5r",
	"IdnMErQqtq/CBx77blkeH4cFMb7Tyukjz1timeSIoTMvulTu2pSoHrO3xBguWVtsEC9Cuo0J6g7udxCL",
	"0INB76i2QrltxE4mGG2gSp+H4GNS8E8iFa05fuYx7NaQiE4J6N9EilJqZEtGnsx28Qox9OmX90eD3smD",
	"h0dfNFJylPWgUqvIgZu/5eDV3ymhKv1BTiR0cOAQz9vI6zGkl3qzu/ZXspVg/nQQ0JDikBUhBA6Hn0n+",
	"PTD8OwWLkAyculjhGc7xKfVoaLk55MpaTHpsSli7RLenHgXAiNMgr73mrTt7O7fazWaztbOXRQDnEhO1",
	"lvi63xAzl6ZBg5ebBu9YNJsG1yqcNevN26VwdjXUnIWA2wQ7Z15/WVPA5SXklqczAa4+IzvltYDVu1/f",
	"QetBkzv1VrPeahaAq+2z1fw3wFrnwIurtq6Xell+zZzIJ0Wox7QRE1K2qVez3jfXtm+5Bi+jJNSccTP5",
	"tNgefGjQN3Z/UtXPwC3ZmWSpXrrzudT/MQpwGHEMaKenEV+8dqmDlVagEDdxYEGiHxiDb+SDhRneI8KA",
	"E8G7R0I8V2ZETpdBJ6qJ9xHK/KNffvibsmPG0t0vP/x9Sw7mcwUshLuZSzYKjnCAdiJOZhzX7LAGA0dM",
	"KS/yDeTjgFCOkVi8DhzOAlxDhHOGPp1Mhmi33UZ1NOx80jnoH06OTnqDR/3RJ/3DSf+ke3Q47h9OBvAg",
	"CypK/Ze/j2xgURpZVP3zPtxQrZcv9E21tcTrWGAqntD5lTY+pGHk4dXbbokk3eEDKYocDj9LSx7wy1oU",
	"VJpu1QwK4U9x3sX1xpf4TQCGONgbgNO5+Dz246sWYcX2kDGBFSSGBIxt5/AY1dEgkPwW3vBxIOncJchV",
	"oMMijBuYxwbdybJPnXN8QaQQY+xq8KJcbc3okwNZNWS/paJ3cMgitEy+EpY0oYQskKz0NcGTqWq3UHKf",
	"xFfMKQmIpA9lEJDKMCcXFBsIanBOHOqyJZis9FG2cApIHjeAZWbwKynQFrZBWwpdnc1jWYzeco2cvhrG",
	"Na1s1RCekwALxJC/eBUyl6k9trR+lhbD5eNKrSK3s1ID42bGlKke5M4n43RGA+xltaf1VL3iy5eSVTwz",
	"1L1SglevDeml9dGInBFOAqdA0MhEem3u/9MAm7kl42c3U0efpRk1q6HlcWPAtzXP5hlurDCmjnbm9fqT",
	"zsNP+ycJhx4cPuo8HPSOQAGsoyGnPqHcOtj7UhE8YzwlUKmj4VkHyIVTEV8/Z5SLUK8qJFTVK4NjJVHJ",
	"XVoIO6OXWH78nHD2yw9/b6gAAR8H2Ns3CGEMn3zxQRD56lH9AxywmrLMJ78inoQcpsC1Qj0OGMIBa6C+",
	"whrto2nli71mvd1s74LTtY4OSCBkv8eCoIMP/MV/iVRP8od0J/ALqCyMCgPMFakuDpp37S4mcplFyKEb",
	"ED0J+vyDUP9KUv3Fv2qnJWIo+cmF2aBqC2G0K9UShOroM7iiJSM5wHzxE9tHn7egSVQllw05nM9bejTm",
	"k84pp1Ie+SwKzuX77cz77cz7n0XeuexgTELin3L5yU7mk53MJ0dRGJ3CqHrkufloN/PRrvURkEB2lT4Q",
	"pGCNzI/JEsW/JCsEnPNpvDZP5VQRQW39QM/I1YPLL6Zem3FmLcetJWuTTHOcWc5xOzXNjrzpFL19qWal",
	"2a46vFly/TImJNmbfiAZyQPQPJjYl0/ks6LTPK3IQzatmHfiY2afA/PQHAWbgM0zm4at7bbaTZ7GEzZP",
	"9ZTjyWQRaVJTyl0Sc84uCzyNXZAPdGppKdMGTMkTUg2Q/BuCdywxoYGO7FAC+bmKbgKU3T4KiUfOWEBq",
	"iNR9TL0acuZn204wfyplPSWOYI8ozg6S/qHm71Jz1B8jh3ggLSYyf6wGgC3MhViqfqN1a7fVQENJg6o7",
	"9UVIwJ6nthRd6v/+ov+3cXl5WW1cXm4hsKypoGqGbt9GDubYCQknIjOw7vBBKuYoGY4ks1YrDpcBrxWa",
	"MxCRVATH4ifJz4bKvh83CNar5S3urm8xNcDswhatHEPHx4MexLQY7URutYXNNSuWupo0WHK31W4nhqKQ",
	"MU8kJiJjHpIvgcY0JnZIeArbkcTeXRCpvFEXrK9AoDH56VCujKANd6lR/+A9uwV9N6YNHnIwfRFi/Z66",
	"/hevEJtrk7CjrK+repKiWLGRd934avGw1PTcfCTLiqgD+DAWCzJ9KRH1KY6D8gAF/MsPf5NiJIgNuRZg",
	"DPK7II7qT1FITrNst1utnVZ7t125SmKD64Or3yw2fRpcEZy+hOhXQdKnwXvEpE+D3woovQiSfv2A9LeF",
	"o0+Dd4lHX0VtBUyjL6TaDAd+8WrTSg/KxhYrtTmfWoqhxc6grAW/kADeJ0q+SA8uRmiyKEMPmhUlt+bK",
	"rCPxZaatH0ax4SvYVQMdWUchHuPXCUN2KSjPKnz368RI9bW+zIjy56UHng2LTpx/AY6JTR4bg6NdwVDJ",
	"GQkjyU4zGz3563x0cHz3+PPJ6Ojgi/OvHrUvx8etB8f4+Wfjg56XFUNXhjWu2Py7d1+uDn8YbRQvUBgo",
	"4NMwxIFD3kt6IeKnDBhSMLLyAaTl7MzSW55NKaSHGI3Gk6Pmzl692Ww33ioR0ebwM02s1wY8SyhuOeis",
	"9G3+fnyb2rItSWawxvc04TiEtFYq9VVOwLEcWzFrNP4ZJRxAoDYNQuyEWhsajodWHhB5HGeQxAIjxqWC",
	"m+bikhWLzFHXll3Jg+3DnAKaSMLinHjKgi9bhwGdEY0vr5nrGT6nLjZSHja3i0liohI4gKAhxRGchtUJ",
	"S51NTM4m6UhILkMQdYb00oDPlBAQXlIXVfsHj9Ctdr25t4XE4p9s/6FcNoF8Gix+Fk7kYQEerQ/xhwij",
	"D59/iMwLmKZf6JgXetq2h1ziUCk6qedNeH73w7XpDWwcj0sQdhiP8wDAhBY/q1pVsdaT15j2ZSfa1WJw",
	"h0uJLqMmJXfBPYSmgfa6vGUr2iWzvpWCBoxMx7jxmmgyh9XQmdraezYZpPIXCFSVV++LTv2rF5J55LhX",
	"v9ls7txp3brVbrbuNm+3b7X29u4+u/X0Vppb7ewtu9m/b9V29jZIW1AgsaWcczWDByjA2q2F6qVgRIlX",
	"w3Kn5x16VwapjQh2S4xaiVErMWolRq2U40qMWolRKzFqJUatxKiVGLUSo1Zi1EqMWolRKzFqJUatxKiV",
	"GLUSo1Zi1EqMWolRKzFqJUatxKiVGLUSo1Zi1EqMWolRKzFqpW+zxKiVGLUSo1Zi1EqM2nVj1AbumqK/",
	"q4WUtenZykx26zeAifCa1182KfegXP71y1+M0Hxr8odmy+Vfs/wxoZYQ2RIiW0JkS4hsCZF9K4is5KfJ",
	"kROG75bI2RI5WyJnS+RsiZwtkbMlcrZEzpbI2RI5WyJnS+RsiZwtkbMlcrZEzl4LcvaNQKZyblLmeTOw",
	"6dsidasbQnW3UlhdLTnmwLodrf5cEZ1bYmhLDG2JoS0xtCWGtsTQlhjaEkNbYmhLDG2JoS0xtCWGtsTQ",
	"lhjaG8TQZqEWeQ+f5XzfDNZGLw2ajYbEF3lYW4kLKq/GN8OQlPCd9wbfeQMAzjuB1WyKrihRI+8RNVL6",
	"6Us/femnL/30pZ++9NMv9dOXLrPSZVa6zEqXWekyK11mvyKX2SckLL1mpdesNA2WXrPSa1Z6zUqv2e/G",
	"a1aQaabIKGryTHCOny3ziA0TQ+V15NjQLrYytYb2QVLxzZjOAuwJrSL2XVrM/Mc0UNoX4lQ4JkfGEoFW",
	"2IZbkecysbBn4MexgpS2R0htSDPKOWduFCre2bFD8Y4MpHp1eN12HKg3raBI2BF6Km/z4l+IiBDLeyTO",
	"rYHni38JSAkBBiOMiEuXhAa7BHksmGHkRlzr7/JGUENzCcw0oxVqM4vVppC/Lf7TJyFnItdHDZFLRzY3",
	"TwcGxA2QS8eLBMQx5uDbcYDyttSOlTE552bCypk9IUHElwmUbhz7oVbBoyoNiaEGl3FwsGQde795Tx4O",
	"QhIEeKUWo+NkQdqWOrz8RG6VS8WcCRrSC0jgsvhR7ixxIENMiv93ieepayh89jAk+98jv0s/bn8E/91q",
	"In/o0I/bt3eRP8HOx3sfffRRC/l9zM+c4OO7e60m8u/jwBUfP27feaL+/o664fnH7dbu7d07O7d2byP/",
	"wHE+vt3eRf5B4HwsP+l483P8kAWzjx8NHh3pf4/PGQ/ND65iC9gben4gPv7+JfK7YiaX4uMg8ryXNVQ8",
	"8BaMu9lS49651VLj3pGTSca9mx73JsNu7tjDngwO7o8648HD1NjtX9dNoEhJc8kFdUihNbVnmVDtvU0C",
	"ZTCaezjEQCtKzuoELmfUfYIGtvjKTkMq9dCQ44vFKzj0jyXftpQockE8eUobWLUARMuNF25b/7o95+yC",
	"uoRvj0kY0mAmGmPJCckfOoe90dGgdzLoaTsWPRq/zSjmc4/AGMztrhhsRL+h4XZE1bJtt261m829u3Ua",
	"22PPGL8ggcv4dk7saer/6nu7pzt1ctu5XYd/yv+3e+v07My9e7toi4iH54K4UgAZ08Ah9xkLl57KOVht",
	"sNJ9JXOsEh/51KNCkFkUuExsFR5Vj87iTE43vYlMbI+fiZD4XY853/xBz29EsCd50R/bd/7Yvnuju/gN",
	"4QHx4H+2twpT9Ps6kK/gRouvcbBx+xjJrnA+v5bU/OTdrlcTrIJHY0UU8b1Bg/DWbrLpkinPCJe7PiNM",
	"6hnFLPihbUOXS2AMRzWzPlJ/ESRKX67XtL2iMWNsplfWbGqyzfJX9UL8cOaLbTOb7QeRIO5D/a+hPtBd",
	"uGL/MI9OPerU8akIpXJRD7H4xnxYn5HQwyI0/4Z8DJbrQGujQoDWGhCHCCEXBYubpCWHcRJPrYiYOmgw",
	"GWo9S/uUwAYQ2/pwPO5/arFHivmYh9Q7T5ACIsq6TozdVkcFMjc20zJthdDxdZ8MxyajGg3g6AeL1xfE",
	"qyEqQoYWr1QspaAB9mqSTolvcwgBTxk6x9z9DnNiLS27B9Grqpt4QgGZgRkuLTzqmXkkBNHNxSbPQ1o8",
	"83BIw8gtkMy6jHGXBNjFSL+k0TBGPCOB5nwem2kbdSKupaQ1Fp16JDl2QeSfqlMnxdsNutdv0eDaB6B+",
	"KMYHEeQTBwdU+CxtiZc3sjHeIM04YjpJ5dLoHnVG4z4ktjvsQzaNB/3RqN+zNCdLl87pUsCfOA2fLUV6",
	"acfhjFMXuyQrOkhtY95AKkZX8yHbU2pOlprM0MPPUGc4QAPTLaqjmH2tuXY0B5p7+Nl2POxtdkH4BSXf",
	"/fnc+3ge1k/5lhkNPRovH0lnPkedMCQiRMBGrsAflKTgnBPnm22pe516VJzTYHbyjEX8BM/nJ+IkHt9W",
	"kb4yn4+Iw2YBCHePCHepE15h/fF8nrb4P+x8eTLqd48+ORx81e8tFwrfqldr11O9P55Op5WDfn8yPun1",
	"Hw26/ZPB4aT/yWgw+VI+eVLZjA5FF3seDWZDzmacCLFUHnLOsQ8+EEh9EzDks9jdYdix8US/A9HHJy7F",
	"253IpewAB3hG+B9mJDxgLqlu3ajI42DPk6Lr1vKKRIJqE6gyfugbw7ovUNUwOm32jcAEfsaEIJqzu2yr",
	"hhjyieRRtudQG0EUx9f7ecqYR3CgN/Qc85nc8GU7KQjC6BSHBML4i2RYIQVv5GDOyUw5Gt+NMHsftP5n",
	"ekOLt1GKJDelgOzu1U/VEHwW0JDJc0MCfOoR12ghRSveIxeS8PrqzVXrXrTYUq1gkH4OuUSQ4IJ5F+Bg",
	"XNJb3488HF6ln8UrRORHLnjUOcHesrYPmPPNJ8PxVacQCRAcIx8kpDPsCdbIm+0sBy25pCJMPBqWiA7y",
	"dihvaXXDqsS3h/13Q4Ox/Gmk6sZ56Ht/UAtT3dpCLKop+euCcCUe40AeJEgQuPgHarVr1973A8582b+R",
	"8K/E4AQCu+4+Uognyx5Ve0sR3fHiP3fu3Grdae7UVR806WOrgagYU02x95+N2VkoJd/r6zvXpR7M7ToV",
	"wnR8+kzojlec4gMWfEOejaIgIHzpAZDCOeiJ9tvLTtOIsZC4PWAwmx8p8K1rd5E2/vm2YuMS9MsPf+OM",
	"hcoue2M6d6yGLFO+Y2FEnnhSvAbH4rTLgoA44dU5Y2z1RBixCEzI1jsXFKPj8f3ixfdwMIvwjKzYSOpS",
	"5ucuwCBJ6zMYH6FbO3frrZvlPU/xBd6WSw8H3yNSjnmoh58+6vXrl2bOWBS46k/Qdci2WTmHuSRz6VkZ",
	"AcUjwkWhRUU+0LaUAhp7d6JERD238ag/Gg+ODv8w6j/sd8b9G17MQpFipy7ARHehFmzpkgqHExLc53R2",
	"HgarBHGGtBDpEnTKqXcOInhIvCwtZ9baJLxdvAIVg3JWkxdtnF+TBCEnqIkwau/t1cAMooCkZ5hegifH",
	"JMK9wJxC7qy0j/8Mn3LqYI2M0xm2GggiQBRyQp6u67NXw7L+Ydwd9fuHJ/dHg08+nRz2x2N7k605Q4Ir",
	"dOZFYYST6f7yw9+ajeYvP/wdwd8t+PsKY/7V20WXG0gUwfWoTwJJmAUEp56BlKPgYHjuAdzhgiHmRHOM",
	"gk0I74YO+QUl321/QQOXfXdAQk4dITnnfcnQRHVLak/rZLXWG8tqwK57VMw9/Ex3fsO8xSch9rb90ONY",
	"yEk8h585lgQy395p3rlz5/ZOXe2poM9j1p02gZwTyV7yO93xwkgBZuV21qROMqeXxBONzWzs4H8rsK5j",
	"PnuLdjM4BT1401sRRCEShE+oT74CV/2ZIMv9OwqbCB7/GJJwJoW7c8aV2JORDFLOAc3xtKRwPOkiBt3t",
	"o//v/zo/f7zv+08a6Kg4353S+aUSzmKZDjDKoUaeiTnTKH/MANEVhUzoiDYi9abFz15IfUhFfI41i3tO",
	"OGugjhR6awj7p0wgK3f5h/Xmzn6z+SEi8OeHgBlDF4sfPYCcEQsd7cdmh9RyvAMhKKQ+2ZZb5xqckDzR",
	"ah83Ub7uNJq1N5e+DN1YfXosmN2sNcmSvwxudYmEkAXtGHezLYwVHgBLGC5g+rUMjCN3qtLICR/PH6sR",
	"PcHBs2JUkPi94YFuAA1Uwm1+NXCbG0R6/OZQDdfgce+pWgMk5167iv+v9HSWns7S03nDns6b92a+Iwel",
	"FHRfB07ksffrs3uXLrvSVbW5q+rfyiHwe7LLX69p+h1ZZeXl0c/gwmITXmKvjPzETGtMs0SZZmmgkPvk",
	"XlFb9GicaafY9NlsyAZbjebNWAyLZ19apN6jRepqZoUMuyo4C0t0j1+RRcJUp/z1WiTG3xEyp8EM6dSQ",
	"YnObhNCf5k0SRSKhMWDkl2KUpGFKcKUEJCJ7hQTx0f/P3tctt5Fjab4KgjMXVJmiJEpylVWxsZumaBen",
	"bZFDUe7usRwyxIQoyPnDAjJpuToc4b3c672tjmj3XlR4IuqqYp6Ab+In2cA5QCaQmfyRLZfV07yzxfw5",
	"eQCc//MdM0l49gu1d1+ZIz07oeFXMseZDYlNmDGEP4XyT+a8p8L3k8mTeMwXwFy2C1W1pn0Yo6d0xKQE",
	"xBIannODrZL7YO5GaBgvSjht7n4ek4X4RNmjNWXkeQplS+ugJjmNYHjLiMpYIhbTfAL0wGHFUBg0LHFO",
	"ZcLECHWFsjs3JSaWYIZIJj3yln719UE8jlPFaaQoI9g8qagVrEb4f8bO9wm//gN7M2BjLhNxA1xVJyJH",
	"83GJ7qxSx+ufky50k4Q2MIVBuyshxrysHOfyEhH0DHDMy8Nue/hSmdsvu0fd9sv1wlsLX1CPZWlTpfNx",
	"OuYnC1oEE/hSgvYTZOw68ryOPN+JfrovXOfmpwL8IxcE+8s0nq3D4Osw+DoMvg6Dr8Pg6zD4Ogz+j1kX",
	"fxN7YR2TX8fkbxaTv6P27jo9sE4PfPmqw7IRtCzqbwLpZfA3af1ShJG94BHP7P8yfwUbxcI0AkDk3oWC",
	"tBMDVOKKKFe2PJNlwgSPfT56wkOeLMVy7btXI4irSBaEHPP/HZBKKNdiyeGUkQmVEvAtlXGma4G/Ap7r",
	"Z6G5VtqxDIxRCIFCXsEZXg0yMHMuCQy7+DHlEp+gLFeDIK25hHiOyn7NH4vHCU1cFOsWXjw18dcMTM0J",
	"GFdg0O5ubu+vhEH7Twk6Gyc08IIgfs18L4T5aWUzAtbATNrHHU0THo25WXEZh1aYNIl9dXhlHho1XS56",
	"A4alI6NOurDUqPaDmsZ1wm0AW02mEwi7FQbFM3tQfMTGObas3u/5qAQDbG6HTq3hShCua+60CrDSDxxI",
	"7z13u8B+2Wns3H97etpU/2693aierGSBnIIAWsZuBKRRVNsf42CWm9EAAGGIrqINp4Q8zLIX9nSxK0pC",
	"yjWEOtwaKJpYNW+lmeNzxRAeaC5JVRz9cixNJetNmfAFvUgsnl7QNEhqB4lIWWOBuV9KXeq9GKcVEhPZ",
	"QyZi9mGTTkQ8VTu2PrpkyEAltmmwoeSeTAsA+dR5kJ311PmlzPePpbo5S2M7zMSvKfoZBUuizJCijqu0",
	"CexHZHq9yrAy5sBAfbZM1lbB2ipYWwVrq2BtFaytgrtiFbz9LAX3TEzKSm2Kf/xsfVY0BZzzUEACmL2f",
	"Mi5Lqm0cxOc0yBVbIdCCRoreUximcjaObXzoVjo4uAJyEkhAo1qB8azITk8rOa21e0fHJ087h6e1sg6G",
	"xCNP3szZ1P8OP0PiBgmEbRVbHCvaSrdJrr0drXFuViRr1WO5Cqth0hkQXIASv+0V+J2EVlUmrWxyVe1M",
	"afOLS6hemDAx+xXzPgkTIY/KEVUz3qO0yXz6Zpl1d4hzDcI4wsjkomufwkVvG7XXjL1advEf1TVvG7U3",
	"jIpl1/5ZXVPJt+X7TJ9ps7eMmMhHm6ygEr7q5iiIXyVMqyTvHzXPi0UOWqwK44E5Jw4HpwYr7J151qs2",
	"VGNdHdxQBmXIoliSNASgrxEmCOovHYmGlX3F1Xu5YQ27yyeWyIos+uryUX93UV+Y9adSSwVdgWbSD2lo",
	"5so2i+Iu5BEP0xDGk3266HMNQGtZEJROrQvkFb+yZPqzPp832ldQarjeVVW7Cma+ujvqd9lSSlfg25U1",
	"CvjTQhlePtZJwgxTqMxwinQdV/7lV96KiyeJF8vr1VcoO1zZ2rMP9qjsOC1NQoTUGpT4TCkx73HdAigo",
	"ocFlnDbJaeRZ1zuXZTfPPtg4C/nV9W6UCOpzSj6++79mji8lQ3NBg0y5X6xY2jDGr0+zXg170HgaUuu4",
	"Ucd4VuR+1dmVp1GPlGc1zZldmc9v+gqTK5cOSK0agaMY1s0bI3TS+wLOmzpRU+rulYD/mHK/ipJ8i2UY",
	"MqgC7tJMzbeNmlSLyZM3xzB4GCTnURwNmM8FGyUeToRFLKh2jLWXF0H82rT8lH91/ngigtpBzUTm1E+S",
	"iSkTTc2ArSR+xSJI4MYTfDuLRByAujzI/6nEQq2vYY308RHZkMiM/WlIBDZQZEXuVvlOHjupNWqRmGyO",
	"MjiZWrsMgG97LUw9GFiiRHBmSMYTFnE/j6WrRadZxEZPQbLKxvKDrzc5llRMRJzEoxjGg+sB1LAT8fHq",
	"RdmR25xkDWe1jmJabGP86xlO2HA0+xsUaHqmL4uYXrUm6CHF+BWXx5bg6qKWekBP7Y1W5QZxxfejIL2O",
	"CVxephU5ZvUiTWIcqaj+IKw1aBIItAtkF34hRBbcVSFMsV+t5Kg8cgNKLL7o5v0KG0Jv4oOqsetmi8A4",
	"QHw0/zKT1+/yHsWBJW3B4NNpIG9njxrVJHCwRjRigbNjCQM24s/ZtQ6fJZgfExaBjWnf6FyVvVviNgiZ",
	"DBc18MV+cch4LC0i1f9yTDGItYSxzwLTkWdOyKiKb/lev3Pr/Raq4C9ioD2Gsa6gUELK1SPHySYE+i8U",
	"Lf9LHaVzGr3i0fhcNGMxVjqBhup5j+MpExE1fUu9CYvIIx4p5pGHgkoegLnXsVNR/8VkrVFLHdqtV2ye",
	"w31NnYXg8RYVjDq1vVtY+e3UoPW7amm77vHrVzcNNwji+snZ+ykLwEeYcnque0mpxIK9PMK6Wisyqff5",
	"tf0XwsiwkIvsRgkL+FhpVrlhTNoKrll9qErgKTOXSsypSVeuTASbcplQqUw1ey/F5wk4frMPynYrBAbz",
	"7LEDT84ifxLzKFHv8EHuwaBc9+YIel69fhcsx38hPcG1wf5fTJ5Gm+Rlu3c09F4qLhsLd/Y3aVvXyFdt",
	"Xss87QL+2YhPlBko52yo7+EVfe/xsLfsFfmxLzJthffoscBwhGRuaUsz8ieSaRiTqMC1ojhCFxxS9Fwp",
	"ZJAJpCwPCCPFJ1nbDP0ahtS6T5T4SKkVHql6uHYpYNEw3SrQQKCEKzlhtYj4zNiBPI70t8rUTfqqxw1N",
	"di7PzCqOMzxZ0qR5ULZSKcE/U9bhOOVFxQ39JCxgI46OjGRohXpwW5LC8sVknHJs0WTjVIDIwQ1Y2IHQ",
	"RsQhfC6AqaUVmY8lsEkOs1yM+hQ31V04CAfEK+TCqSQjUAEjriiAdj8qrbgDeqyujYO2uHvE8vVGd9GH",
	"kBOMKK4qFbAupwmPrpRQueAh1HGzlIz4KMAQsJ6PbbqDWEKDS+09qkV+Hs7e/5jyCNisVsWPZV4soDbY",
	"BR4RLaJpEqilpVEzYsnWa/6Kb8mJUhlbvUdbEzpmcmvnwXd7O9v3976FUa2bpJ3z54B4Lr/qjkl5Nop9",
	"tpExMSrxrSrbETpusQlHKdvCHtSaOyvpuVQnAQ6WY1bmLWpgOV8IJi915Y0lZJvkKUXEU+7MRLFhSAMe",
	"vSLPn/eHLyrVI/6X02BzLKjP4Igea0eT9EV8wQMoQiddc1KZkORQ0IuE7JJNMvvfgoHuPbQ1JNmsetfc",
	"q+vOSm585pp/19re39n5bnurP7ynyLinybiHZNwrfPI9r9+9Zz75nv7kezvN7Xv2J9+DT763+y/fNlvN",
	"VnPzmIkp92Ox6bNNZ2NsaKEwYGMtOKgQNLoCwNHTyCuJPGYaZlA+umaDV1TweVR1rOQvSMCKF6n/PqTR",
	"KCZtFiWCBg04ubm9ySKl8vTe1ruEnlN+HR8Qcho9d26GpwHz8qV5/fp183x03hzH0+a5wKY8HkCYVq8Y",
	"F3Rrwq//Zxj7NPDOmUji/yHYOA3g4+iIxmcTfm34lUtbFJFvgpj6EpoK8wn4y1jUIHDA8F5s9YwkHesS",
	"p0TQCzamIUmgvXSCCCwG5MOOvbkG+9yaBd2nuuBBc2o7QsSINZoJvYt+hgaT+czUZopUUsJ8XEMtfcmk",
	"cXcGK5i9rvYiOBbS7IB+LBJcabePTS9PW+2WOGCI9K/oU+K0V2F9QAzQ1XKPO0OitsJW2TbY+ks5RvmW",
	"sEW3mO9MJ4pkkaG2WGqOjtTfzsB4IsxkHGNBQsaNyhsLGiVnyjEBqBM+MUapVgrgR0GzREziiRWhQGgU",
	"ePSURyNszSuZqfXLN+eC+0T5aBtNxSxYXzaFqpMp/SkPI3MLSbpYtDKFzCn3qbAwW7Tnn7mMymZKmJK0",
	"NCboQ3d9o6oFj1PCtPK4pNDCOWVirH0CZcMmsYiAJ0yImPwwHPbJ3va2WXoPCkfzLRQCvM0koIQGs1+o",
	"DyAlmUFG3auNTszCJxLtCEyBbEHJoM7q6AU1pU05FxhhoQYKuJy9P+eBU5iCcSaI51vcMcQ/A+YZchYh",
	"L1tWzGKkaPVkvZo68SSKw9hHWX9WybZyutkhXKnWSTJyQdWhdFyocsxMU2bDE5VFTKPki+kIOuw1dKwE",
	"y1FGMvs8ZD73KZlySdXHT2IBrxZk9rcqSUaLdoc9HhZJ9ZVVzUVuDdOrFORYVAF8jQ3SKKHgxHjB7AN0",
	"z8lYo71nDI8RHj9Rn5awyOfZAEJbWrsbqQGMQHGVeZjKCVHio973hu0fyFYpXGeLqCxg93ZDu0BkRAUd",
	"JUzMfpVZia/OVMSCM+zy1ukM2TCmrltQmqVipM7FGBJt05GVAlKHOr25YFc3yELVhqkcvYiCJLGPowL0",
	"/sVubkFDElKB7jiKQysTo5yuhIbnkOxz7oyQbCjQo0HCBBV1yDGjiWuKYlON/qBu3Ghkz8pmzsCdm4Fi",
	"nkSNGOqnCtgkkLt2OYpFgViNHYtIiwj6E3CRXU+4mGfEsy1IU06dxK5Tb2jK3AJ1lPJUu2wQVNC5yNMD",
	"g0HsuOvNck5Df64lMMzNWWpQ5h855yNuQvMVxLOvaDiHer1mZSoaJKQ6Mq18OmvxgL5D8OUYhnFGLAK5",
	"A+HRfD9YxqfPMdJZYY/G4GtNZu/H2hF83pkrsjfJ8+NnL+YZg5/pRny7893e9v6Db7/dUB94vPCYQd4x",
	"zxBMuSXkSR1gGHDTZ2f7ptKmUHOujq2xC9y2EBPoz1ozOE6xVrZjAMUcWhYXBQVIQcnHEViMJh8S5Ah2",
	"Vi48FoQF+oRPlIKSOPAA2wXUz3pfm6YTwWSlRi6m76xIE6rZJYB9Yxb51I+dzLspApHEV/9pPWiQ3W0S",
	"p2R3x0BTkXD2nxDzUpeYGKZuBdDzKKMYYklsBP2z6nqlPvJVBdNMA+tREgu1kYtBPupmnbElIE+1W6l8",
	"3B2KGAxRQUARq0RMhNWkeOxHKs19zJxMEdb8ZJsFlxEbNKC+B77MosGaMoPwgT5sXuCCWocGrLRbM23J",
	"FksC65qWQqa9VKsNpe88hnHtKwllpcOcqcJ5DYOmSI/mj0kYw2o96g28s/7A+4/eWb8zeNoddg97ygSO",
	"Yh10Yg1duyFHwqqGpqmkzSrjDmGpKLmiEVoU7kea/WZtZCVoze6U+sWwIo3qmGBpGslpzZ4zIiE+iTVF",
	"BtpzGSboaW2jYU5naNkkesZbwhxEyGWaMU9vqo9t7R7sPzjYf3BJ6ifD9kbV2VZ/yi2UK6WHwVqdm85w",
	"7KCpLSUgHOsalwvrZYyByrQqM/VgWehRHzNxoIjcaZJvvnGkUuTG7JaOaCH1s37veFglzs82vvmGkNOI",
	"kJ3mDvnmGzdWjPkiLs01hJym29ut+yySk+93muqWI1cjo7NmQpIm2q1zg5l2KYQDTWsFZFOMKN0yKZg6",
	"u24qXqYXfMR1HbvPiKQBoEkCJy2BsHUexD+mjPoUUZ8qqG6Vqc68P2dhHecXVlrrphKRfraT5q9M0zC6",
	"Rb75pg0IqmpXK59WsMDU5ElI1Zhqk4qwSDkJChwaMWFkbMMJMDTI1eukYcVqNuYsZ6u5k58Q3Pzt/KEH",
	"+rdSg5v14szpMeywg0WH7QHZRO+9HfuM7G3vkHr36Jn3pHt41n7S7RwNN76fQ1irSJiHHzhUH3hAnjGB",
	"VoF0f7EqwAz0DNJXouPkyDsZ/tAbdP+jcziXit0iFXb8i2bBvIxTsnCFNJdE0mg76RCG1X82aduk/tA7",
	"PDvuPj7yhieDzlza9kpLF1AeSrU3RrAiNKH5zdntobk9W3tFNWqFOk19sLsahNOEMHKV8I3CNDbNSF1Q",
	"N0Kid+Ez5q5txcvN+hLBUtwtVwkvrNJu6YnZgdotHSjJo8TEpdXxCWd/j3QI1phT4CxqgRXbb2q1yCY5",
	"ifTepecBIx0oACZ1nRPSLWE+15XNyhNwseSS2YdRpHYkxoQ3DtSZq1q5XRC7xzm5+eEs8GkX5G3HREq0",
	"5+L4uvbOKzrLrlOMbnPuP5F63xt4TzvDQe/syOuddY8e9QZPvcPe3GXbBUH6CHo8bW0pZn8PmTKubWKs",
	"P9svjc+Zz0YA1n1hP8iaQUhtyvT69+ZI9l2QrMf5Yi/gpRJ2Bg02U/HOyc0MRqsoVJuosw/6BGRWL8aG",
	"3JKmzCaipH7oDb2zvvfYe9o5GmYf4i3grhJ6lttaTaRTTJ/x2Crc1RwGnWIyMdC6OfttxGNSP+wMvSc/",
	"dMqk9RaStksOWUh5QV1q/2SCtjCacYYUKlFNyVROlE0MATVBU59tHJD6qltOybmuz8JJnKAlYDPjcvbe",
	"iR1roCrEsfbBDclvJEXVngnkemegttph52m/N+wctbuLV2mfPEojlAPYBABcuIRskzL9D4hXZfshiLyy",
	"J0fKoDAY6SRSIodATgofV390ctTu9o5gvxx24HT+4D3sPukOvUMPT8Jp1FJGYtWasGs2ShP4MAtDS4u2",
	"rLV19ms0EnFUYU0WYt3gq2MIyy0KK7T7OjnezO6DrMmKMYWlcrq1vQ16pvcHRKxHFTTo/FunPewcEvQH",
	"oT1iwKiMI8u8xkSikQ4tEMFuJP4TWFVpVbVAaD9SSkNbk4IymYhUmQQHpAd6PyU0GJv0BraQQyDe2jau",
	"PUWzaPICP6D+yHvyg6eO1cDrHA8HJ8OTgVdpP7RAlA8hg+GzYpEpeF3K/uvlYY4I4wXRBRchRPcKYcoM",
	"WgDujlNSH6rjdNb5U7878A57Z97JUBlbXtvrzSVplwy0/1zoFHJIKcgbdLkBbWRJQURdbRV1iHpnJ8cn",
	"3qA7n5I98hQKJfHoxoKPWbilfBoeQZ2LcUJ81FjFtiZIBo3YuX4xpJew8tLWEaUOjjoUih2f9Qbdx52n",
	"Z4ed42H3qHfWfXzidY/n0rpPDI6woUqrqgpCMUCmi+ELVX1FOkDwYLjCUhdzybhPjpWDZhdNu9oVSXEY",
	"gOFAcOwIunt5usvOpuWUHXtPDpXmOD551G0rm7Azl6BviWmXdZMwNlUmSp0GiaAQLSSxSf85ZVjPo4J7",
	"vxVl9Q1bEFt8UUgILWlUtwEZSP2Z96Q3OPPa3afe2ZOu4vjcz/qOeIUqddCA6jnOMclq2TFCU52hg/0A",
	"jTV4ele525L5DFurIKNb8n3r3smwczTsttWZJ2eH3WedweN8xU6j3d9HhTU+SYfZhQS3rsU2SzrsWe8P",
	"WoVNNSx7tQ77DI+kafQVeiBVjF+B2weVWg9dlSNqWaIHbmD9E03FuZZi4eUtMmBThGeHk5WNL3HORD7U",
	"RMdv47RIE7Vj6hTWYzxXobDrA8VmZZBnAljQJN5QuuZZ77FSNYNOu/Owc9gbzKV9t0C7Tik4lJs0w3y6",
	"l5Ca0WNUn7Yj95YGG3Ppu0mOs0NnIozVJTF5lHEPNtudC37twYa9g8GvPdjMXzv4tQfb8m4Gv/bAPvvk",
	"4Bfc/rWCX/jyzwp+lXixb6IGVn+pZQNaxo6cF5YZxZHPf2Kh7nxc1gOdBRGUfveG3WdeKVCzVxHzvpMh",
	"ugqWKvfQis/NWcjWbUbnJFbCfGpwDqm5U8G5PYhnWaG5uYQDu7+y61BBVOuLug+krl1LaK2jwYblT3wx",
	"T6LiK0HIx6JstqnPw48zMBxZDDSr+iugzemsHtSeWnxHipZEGZGaPXKMorXtNpbYHC8EHnSZDkwVDA0u",
	"iO7VIBc4vezju58NxNPHd39tqP9ri/vju7+qJYA/YBjptAbu77HyXMrx0fmk73+FACm++T45LMdArRB2",
	"sUunqPjcigj0KK3yP5lfVjAp8xBy7tudObzbWED2t2TARjgb1PXXXEmVY/9z6OSquMGmZNBpnxwrM/ew",
	"o5RTb+BtNLRWc4orstIMhJhLJV3E4u9uMTBPbykuj5Q9yIvNcvZEMTnWoxbc1oRuJBMaJbO/R0wpmeN+",
	"d6OSeeqHRW/d2b47QXlN0Y4W10ZoXY+Yb4rsDTjaAXkU8xxk00hvA0qcQ4G54TyEzHFhjDK0NV0HHlW0",
	"lFoyECXxWb8z6PYOe2coEjt/ancOly3wjtFD2NyBKQL9dbTwdZ59Dbij5+hGGXi8NFdP81GZFhebFD/l",
	"30+8oyEmKuzvWfBBu6SAmMEiX7f2uRHcg8KFLFSCuu8Nhl3vyZM/n3ntdqc/RCFOxykVPo6UNAX/qCuz",
	"7gBp2gNkUcL3O0eHILwqg9RV37BnFgWRJLPtpnz2+QrKwmPNbYcMCMFA0JlFs60KSi4ov6YWhLZ+sbpF",
	"SZpFI1RWWk/cksPe0HviynBrWefzY9/wo9Cd9PvzJUf2y3Al85q4eZyKbsKigXd0rHbIXDYt2jj3LUYJ",
	"ljlaMpNKBZ9BQ/7m15VK/XKosavZe53mt8qbDPG5q7Yaod8qZwJaI7EmMpOOSsw4QEZYVWhraVOWe6Gf",
	"kNX0xWkuOnNxa+p2Yz0ilo7AHFpYUlevKqnEsr/9yohW1gjmyOWzm3aCnRFGFt2UB772f+fAV3Wca/+u",
	"xrn23TiXZsAXDXTB7rh/e0kHq7T6lhMOt78tPy0t8W/tIakPIKvO/I3lGfbbCMbcv/3sxH04BJt3KUF5",
	"H7b/5n+/GEPhG3fJ5u1FGPyV4goFCvbI5u/jmhfeu6/ee2cd83lU3yebd9UvL1D6Ldn88r5v4Z3fkU3S",
	"UYq8VNlTBJw87nfzYp80pADoWFERZBvp7u2V1TwLqXuwMnXddv9zqOu2+9XFRmfddn8ueTvbS+gL0ygr",
	"asD2mf5xn/huMveGRC9/5pwv6R/3l6Ru4Zt25n9TVV3Xah+gh4pUV4QVtZ8rFCu/JT9zc79D6aI7Hnut",
	"Jnw3U6L/0JGf4mft5Z/1DxX3qf4apQuHPEkDqseMd9XWkbqBB+I8SrLkQ5RBOVsTWGLS7j/aah/1/22V",
	"9qem6QB0PGVo9otg9DZ+uZIEg0wMKOkATtrDzvZOg4zoOauehROmPhh9BlM4LvZYgtkMj1PGmkBLuT7s",
	"Dk+eeANkWfdI7fPu8XChgbijtHG7AAqBlSIHpGebEjKhU2pnYMo4D9g7z7MnFI+aKRCZT823+Z5cOewl",
	"/xuEvebx47ucH+uw13w2PbiLIa+iK7b9jxjumvs1O3eqJGQuma2vmlar7P9XahQ9PeWSL4IrRTgAD3AF",
	"GRlTJXTAkcZC78RWd+qshwYh3wry+cVxbn4O8rPo3QC25XizOv7iBJ6sI5E5ZsV+5EJAqmFw64N4RAO1",
	"GwUQDngSfJzSgFBy2G0P1d7uHnXbTafZpd877JAUJzR6/S7oLsQufgbAVGpB1M2ecr4KAHE5rlSknMBM",
	"t9vCLJv/gTDE/DwFzEr89pBFJrZ6oPbbph098Z07Mnfe3Iv1N+NUWayUbDcgcRSDItUAWWaGBGBamlo2",
	"UxcT5lGhVMYAZTJVR33JFiI8nNBRwgCFYRRLMx8fT8sm6b2OmFBWOZcJH8nm8YQ3Hym6n1LxignZ9CaT",
	"gGO5MPxdNv0H2yvf/TQNmIejzm924/GIhiETn3RvL7lk4hOIPYleRfFr5zPh9FaPxGJkJGYffA6AwPas",
	"WVij4prw0rHuQHN5SBIx+08JWGwyV7ayiMe1+Hnq89rV1JQm3x4YfJF5w2xNbPm9joHP3m8GlslTECdu",
	"o/0q5DaRXqOx8WjSRAD2N5n9zWAGZhQeVJlAGM3X+Aw88vmU+5ltnw/aKj7LwmLNZTlgprBMqRaBJR2C",
	"ZQUobYZB4YNC1h0wVjiThba4mW8QNTIIKJhWwrK8tXkqoqsZjQ+4HT0ymr0PQPL5seVu8tlvPqDnczmJ",
	"o9mvUxYAYp8BF2BTlg8NsjBYQhoxLhC0VnKfCQRqsSCOGoRds3ASxAgnY8NpPBRUzn4NOD1wFvmQ4xX1",
	"znXzgAz+lexsbze2tzcOcO6JJnqEeIs022PWBrIUjeKIMKwwIwJ4iWDLj6aSbG8fbG9fahw+iVgel03S",
	"B28ePgagttIwN10NCVwoivcVwZBQ24FHIUYM5REM9FGnJbso5ziXc+YjJ7pfi9PNKNbHANtjfE6/d3h3",
	"rCen5bxrbhvu9TIcQX0RVZb8mBE3ipBPGIODqFc3ZLNfgFXqozR/YBxQyKOxsiG1WWQuQZ4BwvHs/Tn1",
	"45uwrwUkK3dAMesXunkBs4gYcs389qPagvo3m8FGIFnPBBYO/pXs4s3w3xgiQoFFosvKpyySDie3c1ba",
	"GzHE62YfyIgGGuzStxAXaUyg4gOXywFYKvAEY1aIpORiVhXYowkBHDAzqEkvGfBo17rAIPPg79Ub0Vy+",
	"fC/qXhaJ8Fk+4j65fPNgyFrGtv3tih2Ig9gycZvxSjPoCqRKFet89hMLz8WNdlO2cLjuIRWzX+IGgQyM",
	"+nnf+fkqjS7VfjY/t9y7JUuAAGSknP1Wtd00tpfN2uKWo5HZbh0pmcw0Ob1KfaocnDETgLstqgRcNiW9",
	"YQx9de4yTEFw9ynADYaKx2Db2bk5aSm9TD+QtvqvXqHZB7AaM50CfxEs3+KZZkS0Rg0EZiNAYThSKt2J",
	"Bn2TDE3RuQUEZeV3rYlbDKNWcUra3lHbQsrJ5Hb2FbGt03JOlsBvtIF2DAg6tBSidACnXDg+HCEjTyNA",
	"7bmcvceXGMsir6IAMPmbP1in4pTkRWetO+w3MjRk4s8+nHNI0NlOXJM84iNK1CqKcbwQotnEcEQ2KV6R",
	"cZUGY+XdlOab2HChuRBquAEsOHFRPF3I5djMacnMmSieloIphXBlBZ7skW4LzYMWtALyrvy26klnFqCW",
	"BdnndOllfqcVEysF1us4gu3ju58XwoxlMGVbXA5YIt54oxGbJMz/+O6vCBf68d3PQ5Gyj+/+ulE9kVKd",
	"A01QnA91y5AFDcyeWRF3WJ0HPtmmZAbWGwFD7EiMnvxn4LqLF7AQrV4bjr9JZv/HXY88g1VcCADQLqx7",
	"9TOR1hCikXYApfC8ivCPZavncIWlZG4RXtKpTjEDfOwsLWAPA7pa4QMaOdvitPJrGtZBtwEIdfQDkQ31",
	"YJ7CTpo/UlLtmQjTy0ICvGGtUQv4iEUSpn7puT/ehI4umbIUSqN8Xr9+3aTwczMW4y19r9x60m13jo47",
	"m+qet41awhMY6lc940h5yOUBBrVGbcqExIk/reYOPimesIhOeO2gttvcBoImNLmEuUtzqoNgJDqrmCf6",
	"dPYhiY3XfJ7KERWV+GiYbLhKtRiw54mYlITE4I2yostd0zBBRePsKrETS4k+UXbQcnAeHs1+hdBeNpR0",
	"gzCt6Oss8uEvGl1cE63hd+3IOFR8haWBmQVtilOtACdBcQTmomWLY9bmMUv6/Lq4dWDoPMbemZC1g+fV",
	"s63zS7aceXi1t42lN1y3U5nEIRMnkglP+e8r3fWITrh6l2LUyjeYV3Unnu8LJuXKd3ajhAmcWtv1V7mr",
	"YhrdCndlu2GVi/U2WeXSBdNm375o1PTgLBxr1trenjfDPLtuq7W9nT+LX+vHDRhVn1nbW+URD6kPEw1l",
	"grfsLL/lJDLDZJh+z+7ymx7F4pz7Povwjr3ldxzFyaM4jfQr9pff8JQll7F/FCdeEMSvDW33V3oT6nV6",
	"HqiFrO2vwrkuVlYExzAXriNELPDeFb7tMU3Ya/pmyEMWp8kfeXLp+T5PoMCxn8+PVo9rPVj+uGOesK7s",
	"TZkIYurjl/vsgqZBYqbQqRN98JcazaO8W1dSCea/1HAm/rKJ+QP9Nv2hb0tj4joIQKTcCWXhN525riC0",
	"5s5BfF41xe+FOhMyDUMq3tQOag9B+roaoxwnrNIXYNkXc9jNWqOW0DG8PDtDmY6svXjbqE1iuUyPFYzq",
	"BfP+yQDBTXE4bPH8N5erhn4s17rhNnXDn3TbGYtGb/7A3mgRDKLwYey/ubWD0xaMJqxCTlcdoj6OwCnt",
	"rsL0U7tOpM+vcRTrjykXzK8dJCJlb0vqZGcVdbJT2l5dX228tTr5HHWy12qtwgYLkADxCCqO+1o7fWHt",
	"VDFJ+rmZp7zivONGtTZrLBtpXvmeSS7m540kL0wRL+jNtuB0sWpapgnfNmo36R+5DQ/QIe7TfCZD0OFa",
	"QX6iglSu/pdxVTLdsnZV1q7KP42r8llCGCJvo8uyVO1IyeyxWnp6iG6iwVSRHgpfLOnAcpEERiaZAFY2",
	"SDhR8pgnqb74gJxGHs78wIEkMsW+zfpx+4fDDZi0l0NaR7P3AZeM1PuHR483mvPnWJ0zfJIP43Nd/kwp",
	"N/FsQ8j/iyGn1AS4OV3eUlU7Dc92UlKKyi1FDYk1Yi6FXB/FSLVT6cfDCZv9Qgux8EbxAzAOrYdWkNMI",
	"GiB148Neq6V7RADZKy8ZtIFQ1ad0nuAP1idBMB4cxb1Wq0FocawZuaA/MQxkOvQ87gxJVKogn+rGV+Gy",
	"Uc8mYwFrwCJAMsM3JZR5qBXpej5gMtGx+Bekn6d67JHs9Y/vfq7Oo3x899es4u/ju5+zrApkTTCzYecg",
	"dC4jT6FkpYhWn6S7NKfK+HFKY52sRnnIjpuWyMpFWgfb26T+Q1WlywZhBo0IHmlXmMy9xcf0N1UCmMci",
	"G3zkM8IuWMKnFR6d+hqNPWeG74xM6/dKuZgGwYlHExZR6XAWCoWNPMjn0Tmff7lSpLqvpNHa7vo97a67",
	"E9Iwi78gkOEp+WLjZ+f9lYNsDtoqcYtPti2ByLVx+ZUCFxn31wbq3TNQ24Vai5JyzG0IS8GvFCgoQ1sr",
	"Ztw0lL68K88Kp78sx2BeKkNIG4beH73usHv0+EzDdxx7w27vaMWI+6Dw6HW4/R8s3K7X7Sax9hIEPBXz",
	"w++3FHov7bNPjLqbvZtt17Uy+3RlZjNxrcbuoBrD0HbVcZ2fFq7WYu08el6txSoHNNxSsdNiVbdSBLwk",
	"PwyRazfsVtwwq37ok8Lfc9dnHf5eh7//WcLfq1TgWIJ4bsjbka5mcHdDo1FAwTUM4ReriNcDQk6jHbJJ",
	"uhXi2RmEcpCNA7eC1nGjBGWTha0zD8TBqfkeWr0xNFdoMLDaKT6++9m4K4huk9cjG9AN+T1O887rnXJX",
	"rVgsW5ywpiP/EAjOBnkj0bpT0G2gw06f2W/Xpp+nDpH+hAsT4fQZOY0KfqTDvg092183lIfQaBHLpvMF",
	"c2iZzH6ThEnJ7G63rKsEnVn1LMUQjc8WO7OoBcvAztzhNjlbDZqGHml+yaiPDZNev9sgyey3CR9Bmbfd",
	"4w8wRDxhIdmF7onW3I3EfK73G/RyZrMbsiL1CcVCZY4Qn/pyAk06WTl9Nbn2uMTnAY9evaibivF4wqIL",
	"LPQ+hzrvJk0CKiWnUTNiydZr/opvyQkdMbnVe7Q1oWMmt+63vtt5sH///v4GbtacGqegWseXWZiHpyss",
	"sdLw90ICgDA5ioNLbg9/ByyGK5YAv+emFJC6HhR2g1MGC2EGx4+EEgKxkFsRDdlpDTMe/CcqZu+JelfI",
	"XOwuFuaDNVjAzPh67BB+08xOv/uNmGkyiCkXAFx5096SC37NfC+M0yiBoy4Yi0aKIxvZULUMp8TaShXN",
	"B0tfFdJrHqbhMyq4UqHZS/PPs1mSsAhAxXT3dRqSCZdZq49pCMT9KBM+wfYye/DUzZkR8qiSQpstjQyL",
	"IZy9R5mU9XQWQWvy2f6V3Tn12+LgRgGKJWRRjFAPhtYiizI+28yH/QTqC3ubAUEG4LomXMyLUDAAr4Ep",
	"9jR0SmBdgQqZokksMRkFwhBarHRKChhFG5ATdvr85gjb02h3geK8YjzXsPr7LingZikHO++yKzV+FYeB",
	"QMsrwnhlLV1qC+TD1Uwj5+iShpAdzBLi8N1hPGWCVMZ1DF7c6kmvtav1u7ladyzjdaeCip/ldK5zY18v",
	"N7ZOjN1d11XPjDa+ZOZK3tx5RbrUoqEmcD9DLSdXistnpC9iPwUZUOr3pBPePKfRKG6O4rB5LsCc3zyn",
	"0SsejXObJK/HnbZAaM5/2Q9xGAfG+6l63+XNX/giY8UcR10WpSEjY+19Fn2GWsO0wVZwtfxpK70gN2Sq",
	"np7lL9++ePv/AwAA//8XQ4dXO4MDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
