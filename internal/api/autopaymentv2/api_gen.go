//go:build go1.22

// Package autopaymentv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package autopaymentv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/autopayment"
	"github.com/luiky/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreatePixRecurringPaymentErrorsCode.
const (
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOPENDENTEAUTORIZACAO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHEPAGAMENTOINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeERROIDEMPOTENCIA                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO                        N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOVALOREXCEDIDO                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeNAOINFORMADO                              N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTODIVERGENTECONSENTIMENTO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADOSPI                      N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_SPI"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETROINVALIDO                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeSALDOINSUFICIENTE                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "SALDO_INSUFICIENTE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORACIMALIMITE                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_ACIMA_LIMITE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORINVALIDO                             N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_INVALIDO"
)

// Defines values for N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode.
const (
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodeCANCELAMENTOFORAPERIODOPERMITIDO N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "CANCELAMENTO_FORA_PERIODO_PERMITIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePAGAMENTONAOPERMITECANCELAMENTO  N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETROINVALIDO                N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETRONAOINFORMADO            N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorRecurringConsentsErrorsCode.
const (
	N422ResponseErrorRecurringConsentsErrorsCodeCAMPONAOPERMITIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "CAMPO_NAO_PERMITIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeCONSENTIMENTONAOPERMITECANCELAMENTO N422ResponseErrorRecurringConsentsErrorsCode = "CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorRecurringConsentsErrorsCodeDETALHEEDICAOINVALIDO               N422ResponseErrorRecurringConsentsErrorsCode = "DETALHE_EDICAO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeFALTAMSINAISOBRIGATORIOSPLATAFORMA  N422ResponseErrorRecurringConsentsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETROINVALIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETRONAOINFORMADO               N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorRecurringConsentsErrorsCodePERMISSAOINSUFICIENTE               N422ResponseErrorRecurringConsentsErrorsCode = "PERMISSAO_INSUFICIENTE"
)

// Defines values for AutomaticAutomaticInterval.
const (
	AutomaticAutomaticIntervalANUAL      AutomaticAutomaticInterval = "ANUAL"
	AutomaticAutomaticIntervalMENSAL     AutomaticAutomaticInterval = "MENSAL"
	AutomaticAutomaticIntervalSEMANAL    AutomaticAutomaticInterval = "SEMANAL"
	AutomaticAutomaticIntervalSEMESTRAL  AutomaticAutomaticInterval = "SEMESTRAL"
	AutomaticAutomaticIntervalTRIMESTRAL AutomaticAutomaticInterval = "TRIMESTRAL"
)

// Defines values for AutomaticRequestAutomaticInterval.
const (
	AutomaticRequestAutomaticIntervalANUAL      AutomaticRequestAutomaticInterval = "ANUAL"
	AutomaticRequestAutomaticIntervalMENSAL     AutomaticRequestAutomaticInterval = "MENSAL"
	AutomaticRequestAutomaticIntervalSEMANAL    AutomaticRequestAutomaticInterval = "SEMANAL"
	AutomaticRequestAutomaticIntervalSEMESTRAL  AutomaticRequestAutomaticInterval = "SEMESTRAL"
	AutomaticRequestAutomaticIntervalTRIMESTRAL AutomaticRequestAutomaticInterval = "TRIMESTRAL"
)

// Defines values for ConsentEditionLoggedUserDocumentRel.
const (
	ConsentEditionLoggedUserDocumentRelCPF ConsentEditionLoggedUserDocumentRel = "CPF"
)

// Defines values for ConsentRejectionRejectionRejectedBy.
const (
	ConsentRejectionRejectionRejectedByDETENTORA  ConsentRejectionRejectionRejectedBy = "DETENTORA"
	ConsentRejectionRejectionRejectedByINICIADORA ConsentRejectionRejectionRejectedBy = "INICIADORA"
	ConsentRejectionRejectionRejectedByUSUARIO    ConsentRejectionRejectionRejectedBy = "USUARIO"
)

// Defines values for ConsentRejectionRejectionRejectedFrom.
const (
	ConsentRejectionRejectionRejectedFromDETENTORA  ConsentRejectionRejectionRejectedFrom = "DETENTORA"
	ConsentRejectionRejectionRejectedFromINICIADORA ConsentRejectionRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ConsentRejectionStatus.
const (
	ConsentRejectionStatusREJECTED ConsentRejectionStatus = "REJECTED"
)

// Defines values for ConsentRejectionReasonCode.
const (
	ConsentRejectionReasonCodeAUTENTICACAODIVERGENTE    ConsentRejectionReasonCode = "AUTENTICACAO_DIVERGENTE"
	ConsentRejectionReasonCodeCONTANAOPERMITEPAGAMENTO  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
	ConsentRejectionReasonCodeCONTASORIGEMDESTINOIGUAIS ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	ConsentRejectionReasonCodeFALHAINFRAESTRUTURA       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
	ConsentRejectionReasonCodeNAOINFORMADO              ConsentRejectionReasonCode = "NAO_INFORMADO"
	ConsentRejectionReasonCodeREJEITADOUSUARIO          ConsentRejectionReasonCode = "REJEITADO_USUARIO"
	ConsentRejectionReasonCodeSALDOINSUFICIENTE         ConsentRejectionReasonCode = "SALDO_INSUFICIENTE"
	ConsentRejectionReasonCodeTEMPOEXPIRADOAUTORIZACAO  ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
	ConsentRejectionReasonCodeVALORACIMALIMITE          ConsentRejectionReasonCode = "VALOR_ACIMA_LIMITE"
)

// Defines values for ConsentRevocationRevocationRevokedBy.
const (
	ConsentRevocationRevocationRevokedByDETENTORA  ConsentRevocationRevocationRevokedBy = "DETENTORA"
	ConsentRevocationRevocationRevokedByINICIADORA ConsentRevocationRevocationRevokedBy = "INICIADORA"
	ConsentRevocationRevocationRevokedByUSUARIO    ConsentRevocationRevocationRevokedBy = "USUARIO"
)

// Defines values for ConsentRevocationRevocationRevokedFrom.
const (
	ConsentRevocationRevocationRevokedFromDETENTORA  ConsentRevocationRevocationRevokedFrom = "DETENTORA"
	ConsentRevocationRevocationRevokedFromINICIADORA ConsentRevocationRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ConsentRevocationStatus.
const (
	REVOKED ConsentRevocationStatus = "REVOKED"
)

// Defines values for ConsentRevokedReasonCode.
const (
	ConsentRevokedReasonCodeNAOINFORMADO      ConsentRevokedReasonCode = "NAO_INFORMADO"
	ConsentRevokedReasonCodeREVOGADORECEBEDOR ConsentRevokedReasonCode = "REVOGADO_RECEBEDOR"
	ConsentRevokedReasonCodeREVOGADOUSUARIO   ConsentRevokedReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ContractDebtorDocumentRel.
const (
	ContractDebtorDocumentRelCNPJ ContractDebtorDocumentRel = "CNPJ"
	ContractDebtorDocumentRelCPF  ContractDebtorDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataAuthorisationFlow.
const (
	CreateRecurringPixPaymentDataAuthorisationFlowCIBAFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowFIDOFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowHYBRIDFLOW CreateRecurringPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for CreateRecurringPixPaymentDataDocumentRel.
const (
	CreateRecurringPixPaymentDataDocumentRelCNPJ CreateRecurringPixPaymentDataDocumentRel = "CNPJ"
	CreateRecurringPixPaymentDataDocumentRelCPF  CreateRecurringPixPaymentDataDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataLocalInstrument.
const (
	CreateRecurringPixPaymentDataLocalInstrumentDICT CreateRecurringPixPaymentDataLocalInstrument = "DICT"
	CreateRecurringPixPaymentDataLocalInstrumentINIC CreateRecurringPixPaymentDataLocalInstrument = "INIC"
	CreateRecurringPixPaymentDataLocalInstrumentMANU CreateRecurringPixPaymentDataLocalInstrument = "MANU"
)

// Defines values for EnumAccountTypeConsents.
const (
	EnumAccountTypeConsentsCACC EnumAccountTypeConsents = "CACC"
	EnumAccountTypeConsentsSVGS EnumAccountTypeConsents = "SVGS"
	EnumAccountTypeConsentsTRAN EnumAccountTypeConsents = "TRAN"
)

// Defines values for EnumAccountTypePayments.
const (
	EnumAccountTypePaymentsCACC EnumAccountTypePayments = "CACC"
	EnumAccountTypePaymentsSVGS EnumAccountTypePayments = "SVGS"
	EnumAccountTypePaymentsTRAN EnumAccountTypePayments = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	EnumAuthorisationStatusTypeAUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	EnumAuthorisationStatusTypeAWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	EnumAuthorisationStatusTypeCONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	EnumAuthorisationStatusTypePARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	EnumAuthorisationStatusTypeREJECTED              EnumAuthorisationStatusType = "REJECTED"
	EnumAuthorisationStatusTypeREVOKED               EnumAuthorisationStatusType = "REVOKED"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	EnumPaymentCancellationFromTypeDETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	EnumPaymentCancellationFromTypeINICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOPENDENCIA   EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonCode.
const (
	EnumRejectionReasonCodeCONSENTIMENTOINVALIDO                     EnumRejectionReasonCode = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeCONSENTIMENTOREVOGADO                     EnumRejectionReasonCode = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeFORAPRAZOPERMITIDO                        EnumRejectionReasonCode = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeNAOINFORMADO                              EnumRejectionReasonCode = "NAO_INFORMADO"
	EnumRejectionReasonCodePAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodePAGAMENTORECUSADODETENTORA                EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodePAGAMENTORECUSADOSPI                      EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeSALDOINSUFICIENTE                         EnumRejectionReasonCode = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeVALORACIMALIMITE                          EnumRejectionReasonCode = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeVALORINVALIDO                             EnumRejectionReasonCode = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonCodeGet.
const (
	EnumRejectionReasonCodeGetCONSENTIMENTOINVALIDO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeGetCONSENTIMENTOREVOGADO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeGetDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeGetDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeGetFORAPRAZOPERMITIDO                        EnumRejectionReasonCodeGet = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCodeGet = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCodeGet = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCodeGet = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCodeGet = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCodeGet = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetNAOINFORMADO                              EnumRejectionReasonCodeGet = "NAO_INFORMADO"
	EnumRejectionReasonCodeGetPAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCodeGet = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADODETENTORA                EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADOSPI                      EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeGetSALDOINSUFICIENTE                         EnumRejectionReasonCodeGet = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeGetTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCodeGet = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeGetVALORACIMALIMITE                          EnumRejectionReasonCodeGet = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeGetVALORINVALIDO                             EnumRejectionReasonCodeGet = "VALOR_INVALIDO"
)

// Defines values for PatchPixPaymentDataCancellationCancelledByDocumentRel.
const (
	PatchPixPaymentDataCancellationCancelledByDocumentRelCNPJ PatchPixPaymentDataCancellationCancelledByDocumentRel = "CNPJ"
	PatchPixPaymentDataCancellationCancelledByDocumentRelCPF  PatchPixPaymentDataCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for PixPaymentCancellationCancelledByDocumentRel.
const (
	PixPaymentCancellationCancelledByDocumentRelCNPJ PixPaymentCancellationCancelledByDocumentRel = "CNPJ"
	PixPaymentCancellationCancelledByDocumentRelCPF  PixPaymentCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for RejectionRejectedBy.
const (
	RejectionRejectedByDETENTORA  RejectionRejectedBy = "DETENTORA"
	RejectionRejectedByINICIADORA RejectionRejectedBy = "INICIADORA"
	RejectionRejectedByUSUARIO    RejectionRejectedBy = "USUARIO"
)

// Defines values for RejectionRejectedFrom.
const (
	RejectionRejectedFromDETENTORA  RejectionRejectedFrom = "DETENTORA"
	RejectionRejectedFromINICIADORA RejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseErrorCreateConsentErrorsCode.
const (
	ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA       ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO    ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA            ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	ResponseErrorCreateConsentErrorsCodeFUNCIONALIDADENAOHABILITADA ResponseErrorCreateConsentErrorsCode = "FUNCIONALIDADE_NAO_HABILITADA"
	ResponseErrorCreateConsentErrorsCodeNAOINFORMADO                ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO           ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO       ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationReasonCode.
const (
	ResponsePostRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponsePostRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedBy.
const (
	ResponsePostRecurringConsentDataRevocationRevokedByDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedByINICIADORA ResponsePostRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponsePostRecurringConsentDataRevocationRevokedByUSUARIO    ResponsePostRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedFrom.
const (
	ResponsePostRecurringConsentDataRevocationRevokedFromDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedFromINICIADORA ResponsePostRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentDataRevocationReasonCode.
const (
	ResponseRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedBy.
const (
	ResponseRecurringConsentDataRevocationRevokedByDETENTORA  ResponseRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedByINICIADORA ResponseRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentDataRevocationRevokedByUSUARIO    ResponseRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedFrom.
const (
	ResponseRecurringConsentDataRevocationRevokedFromDETENTORA  ResponseRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedFromINICIADORA ResponseRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedBy.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedByDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByUSUARIO    ResponseRecurringConsentPatchDataRejectionRejectedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedFrom.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedFromDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedFrom = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedFromINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationReasonCode.
const (
	NAOINFORMADO      ResponseRecurringConsentPatchDataRevocationReasonCode = "NAO_INFORMADO"
	REVOGADORECEBEDOR ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	REVOGADOUSUARIO   ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedBy.
const (
	ResponseRecurringConsentPatchDataRevocationRevokedByDETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByINICIADORA ResponseRecurringConsentPatchDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByUSUARIO    ResponseRecurringConsentPatchDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedFrom.
const (
	DETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedFrom = "DETENTORA"
	INICIADORA ResponseRecurringConsentPatchDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringPaymentsDataPatchAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataPatchAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataPatchAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataPatchDocumentRel.
const (
	ResponseRecurringPaymentsDataPatchDocumentRelCNPJ ResponseRecurringPaymentsDataPatchDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataPatchDocumentRelCPF  ResponseRecurringPaymentsDataPatchDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataPatchLocalInstrument.
const (
	ResponseRecurringPaymentsDataPatchLocalInstrumentDICT ResponseRecurringPaymentsDataPatchLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataPatchLocalInstrumentINIC ResponseRecurringPaymentsDataPatchLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataPatchLocalInstrumentMANU ResponseRecurringPaymentsDataPatchLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsDataReadAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataReadAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataReadAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataReadDocumentRel.
const (
	ResponseRecurringPaymentsDataReadDocumentRelCNPJ ResponseRecurringPaymentsDataReadDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataReadDocumentRelCPF  ResponseRecurringPaymentsDataReadDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataReadLocalInstrument.
const (
	ResponseRecurringPaymentsDataReadLocalInstrumentDICT ResponseRecurringPaymentsDataReadLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataReadLocalInstrumentINIC ResponseRecurringPaymentsDataReadLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataReadLocalInstrumentMANU ResponseRecurringPaymentsDataReadLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsPostDataAuthorisationFlow.
const (
	ResponseRecurringPaymentsPostDataAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsPostDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsPostDataDocumentRel.
const (
	ResponseRecurringPaymentsPostDataDocumentRelCNPJ ResponseRecurringPaymentsPostDataDocumentRel = "CNPJ"
	ResponseRecurringPaymentsPostDataDocumentRelCPF  ResponseRecurringPaymentsPostDataDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsPostDataLocalInstrument.
const (
	ResponseRecurringPaymentsPostDataLocalInstrumentDICT ResponseRecurringPaymentsPostDataLocalInstrument = "DICT"
	ResponseRecurringPaymentsPostDataLocalInstrumentINIC ResponseRecurringPaymentsPostDataLocalInstrument = "INIC"
	ResponseRecurringPaymentsPostDataLocalInstrumentMANU ResponseRecurringPaymentsPostDataLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPixDataDocumentRel.
const (
	CNPJ ResponseRecurringPixDataDocumentRel = "CNPJ"
	CPF  ResponseRecurringPixDataDocumentRel = "CPF"
)

// Defines values for RiskSignalsConsentEditionGeolocationType.
const (
	RiskSignalsConsentEditionGeolocationTypeCOARSE   RiskSignalsConsentEditionGeolocationType = "COARSE"
	RiskSignalsConsentEditionGeolocationTypeFINE     RiskSignalsConsentEditionGeolocationType = "FINE"
	RiskSignalsConsentEditionGeolocationTypeINFERRED RiskSignalsConsentEditionGeolocationType = "INFERRED"
)

// Defines values for RiskSignalsConsentsGeolocationType.
const (
	RiskSignalsConsentsGeolocationTypeCOARSE   RiskSignalsConsentsGeolocationType = "COARSE"
	RiskSignalsConsentsGeolocationTypeFINE     RiskSignalsConsentsGeolocationType = "FINE"
	RiskSignalsConsentsGeolocationTypeINFERRED RiskSignalsConsentsGeolocationType = "INFERRED"
)

// Defines values for RiskSignalsPaymentsManualGeolocationType.
const (
	COARSE   RiskSignalsPaymentsManualGeolocationType = "COARSE"
	FINE     RiskSignalsPaymentsManualGeolocationType = "FINE"
	INFERRED RiskSignalsPaymentsManualGeolocationType = "INFERRED"
)

// N422ResponseErrorCreatePixRecurringPayment defines model for 422ResponseErrorCreatePixRecurringPayment.
type N422ResponseErrorCreatePixRecurringPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Code N422ResponseErrorCreatePixRecurringPaymentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: Limite de transação excedido.
		// - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
		// - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
		// - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
type N422ResponseErrorCreatePixRecurringPaymentErrorsCode string

// N422ResponseErrorCreateRecurringPaymentsPaymentID defines model for 422ResponseErrorCreateRecurringPaymentsPaymentId.
type N422ResponseErrorCreateRecurringPaymentsPaymentID struct {
	Errors []struct {
		// Code - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Code N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode `json:"code"`

		// Detail - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
type N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode string

// N422ResponseErrorRecurringConsents defines model for 422ResponseErrorRecurringConsents.
type N422ResponseErrorRecurringConsents struct {
	Errors []struct {
		Code N422ResponseErrorRecurringConsentsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED")
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED").
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorRecurringConsentsErrorsCode defines model for 422ResponseErrorRecurringConsents.Errors.Code.
type N422ResponseErrorRecurringConsentsErrorsCode string

// Automatic defines model for Automatic.
type Automatic struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"automatic"`
}

// AutomaticAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticAutomaticInterval string

// AutomaticRequest defines model for AutomaticRequest.
type AutomaticRequest struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticRequestAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`
	} `json:"automatic"`
}

// AutomaticRequestAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticRequestAutomaticInterval string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
//
// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentEdition defines model for ConsentEdition.
type ConsentEdition struct {
	// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
	//
	// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
	BusinessEntity *struct {
		Document struct {
			// Identification Número do documento de identificação oficial do titular pessoa jurídica.
			Identification string `json:"identification"`

			// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"businessEntity,omitempty"`
	Creditors []struct {
		// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
		// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
		Name *string `json:"name,omitempty"`
	} `json:"creditors"`

	// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
	//
	// [Restrição] Caso esse campo não seja enviado, a instituição detentora deve considerar a extensão do prazo para um período indeterminado; ou;
	//
	// Caso enviado, esse campo deve ser, no mínimo, D, sendo D o dia da requisição e o horário deve ser às 23:59:59 (UTC).
	ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

	// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
	//
	// [Restrição] Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
	LoggedUser *struct {
		Document struct {
			// Identification Número do documento de identificação oficial do usuário logado na instituição iniciadora.
			Identification string `json:"identification"`

			// Rel Tipo do documento de identificação oficial do usuário logado na instituição iniciadora.
			Rel ConsentEditionLoggedUserDocumentRel `json:"rel"`
		} `json:"document"`
	} `json:"loggedUser,omitempty"`

	// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
	RecurringConfiguration *struct {
		// Automatic Definição da configuração de recorrência para pagamentos automáticos
		Automatic *struct {
			// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
			//
			// [Restrição]
			// Caso esse campo não seja enviado, a instituição detentora deve considerar o valor máximo do pagamento variável como indefinido;
			//
			// Caso informado, o valor desse campo não deve ser inferior ao valor definido no campo "/data/recurringConfiguration/automatic/minimumVariableAmount".
			MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`
		} `json:"automatic,omitempty"`
	} `json:"recurringConfiguration,omitempty"`

	// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
	//
	// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
	// Só estará presente após a primeira edição do consentimento de longa duração.
	// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
	RiskSignals *RiskSignalsConsentEdition `json:"riskSignals,omitempty"`
}

// ConsentEditionLoggedUserDocumentRel Tipo do documento de identificação oficial do usuário logado na instituição iniciadora.
type ConsentEditionLoggedUserDocumentRel string

// ConsentRejection defines model for ConsentRejection.
type ConsentRejection struct {
	// Rejection Objeto contendo as informações de rejeição dos consentimentos.
	Rejection *struct {
		// Reason Informações sobre o motivo da rejeição
		Reason ConsentRejectionReason `json:"reason"`

		// RejectedBy Ator responsável pela solicitação rejeição
		RejectedBy ConsentRejectionRejectionRejectedBy `json:"rejectedBy"`

		// RejectedFrom Canal onde iniciou-se o processo de rejeição
		// - INICIADORA
		// - DETENTORA
		RejectedFrom ConsentRejectionRejectionRejectedFrom `json:"rejectedFrom"`
	} `json:"rejection,omitempty"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRejectionStatus `json:"status,omitempty"`
}

// ConsentRejectionRejectionRejectedBy Ator responsável pela solicitação rejeição
type ConsentRejectionRejectionRejectedBy string

// ConsentRejectionRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ConsentRejectionRejectionRejectedFrom string

// ConsentRejectionStatus Estado atual do consentimento de longa duração
type ConsentRejectionStatus string

// ConsentRejectionReason Informações sobre o motivo da rejeição
type ConsentRejectionReason struct {
	// Code Código indicador do motivo de rejeição.
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - AUTENTICACAO_DIVERGENTE
	Code ConsentRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de rejeição indicado no campo `/data/rejection/reason/code`
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento];
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento;
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento;
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento;
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido para permitir a realização de transações pelo cliente;
	// - AUTENTICACAO_DIVERGENTE : Usuário autenticado no detentor diverge do usuário autenticado no iniciador;
	Detail string `json:"detail"`
}

// ConsentRejectionReasonCode Código indicador do motivo de rejeição.
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - AUTENTICACAO_DIVERGENTE
type ConsentRejectionReasonCode string

// ConsentRevocation defines model for ConsentRevocation.
type ConsentRevocation struct {
	// Revocation Objeto contendo as informações de revogação dos consentimentos de longa duração.
	Revocation *struct {
		// Reason Informações sobre o motivo da revogação
		Reason ConsentRevokedReason `json:"reason"`

		// RevokedBy Quem iniciou a solicitação de revogação
		// - INICIADORA
		// - USUARIO
		// - DETENTORA
		RevokedBy ConsentRevocationRevocationRevokedBy `json:"revokedBy"`

		// RevokedFrom Canal onde iniciou-se o processo de revogação
		// - INICIADORA
		// - DETENTORA
		RevokedFrom ConsentRevocationRevocationRevokedFrom `json:"revokedFrom"`
	} `json:"revocation,omitempty"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRevocationStatus `json:"status,omitempty"`
}

// ConsentRevocationRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ConsentRevocationRevocationRevokedBy string

// ConsentRevocationRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ConsentRevocationRevocationRevokedFrom string

// ConsentRevocationStatus Estado atual do consentimento de longa duração
type ConsentRevocationStatus string

// ConsentRevokedReason Informações sobre o motivo da revogação
type ConsentRevokedReason struct {
	// Code Código indicador do motivo de revogação.
	// - REVOGADO_RECEBEDOR
	// - REVOGADO_USUARIO
	// - NAO_INFORMADO
	Code ConsentRevokedReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
	// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
	Detail string `json:"detail"`
}

// ConsentRevokedReasonCode Código indicador do motivo de revogação.
// - REVOGADO_RECEBEDOR
// - REVOGADO_USUARIO
// - NAO_INFORMADO
type ConsentRevokedReasonCode string

// ContractDebtor Informações sobre o cliente devedor do contrato.
type ContractDebtor struct {
	Document struct {
		// Identification Número do documento de identificação oficial do cliente devedor do contrato.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do cliente devedor do contrato.
		Rel ContractDebtorDocumentRel `json:"rel"`
	} `json:"document"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular devedor do contrato.
	Name string `json:"name"`
}

// ContractDebtorDocumentRel Tipo do documento de identificação oficial do cliente devedor do contrato.
type ContractDebtorDocumentRel string

// CreateRecurringConsent defines model for CreateRecurringConsent.
type CreateRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Creditors      Creditors       `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration autopayment.Configuration `json:"recurringConfiguration"`
	} `json:"data"`
}

// CreateRecurringPixPayment defines model for CreateRecurringPixPayment.
type CreateRecurringPixPayment struct {
	// Data Objeto contendo dados do pagamento e do recebedor (creditor).
	Data CreateRecurringPixPaymentData `json:"data"`
}

// CreateRecurringPixPaymentData Objeto contendo dados do pagamento e do recebedor (creditor).
type CreateRecurringPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *CreateRecurringPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	//
	// [Restrição] - Se /data/paymentReference = "zero", as informações da conta de crédito enviadas (/data/creditorAccount) devem ser iguais as presentes na conta de crédito informada na criação do consentimento(`/data/recurringConfiguration/automatic/firstPayment/creditorAccount`)
	CreditorAccount struct {
		// AccountType Tipos de contas usadas para pagamento via Pix.
		// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
		// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
		// Segue descrição de cada valor do ENUM para o escopo do Pix.
		//
		// - CACC - Current - Conta Corrente.
		// - SVGS - Savings - Conta de Poupança.
		// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
		AccountType EnumAccountTypePayments `json:"accountType"`

		// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
		Ispb string `json:"ispb"`

		// Issuer Código da Agência emissora da conta sem dígito.
		// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
		// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
		//
		// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
		Issuer *string `json:"issuer,omitempty"`

		// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
		// se houver valor alfanumérico, este deve ser convertido para 0.
		Number string `json:"number"`
	} `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel CreateRecurringPixPaymentDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
	//
	// - "E" - fixo (1 caractere);
	// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
	// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
	// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
	//
	// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
	//
	// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
	EndToEndID EndToEndIDPost `json:"endToEndId"`

	// IbgeTownCode O campo ibgeTownCode no arranjo Pix tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do Pix.
	//
	// Caso a informação referente ao município não seja enviada, o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument CreateRecurringPixPaymentDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
	//
	// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
	RiskSignals *RiskSignalsPayments `json:"riskSignals,omitempty"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// CreateRecurringPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreateRecurringPixPaymentDataAuthorisationFlow string

// CreateRecurringPixPaymentDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type CreateRecurringPixPaymentDataDocumentRel string

// CreateRecurringPixPaymentDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type CreateRecurringPixPaymentDataLocalInstrument string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
// [Restrição]
// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountConsent Recebe os dados de conta do usuário recebedor.
type CreditorAccountConsent struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountPostPixPaymentsResponse Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccountPostPixPaymentsResponse struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Creditors defines model for Creditors.
type Creditors = []struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// Day Configurar limite transacional diário determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
type Day struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um dia.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado diariamente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
//
// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
type EndToEndID = string

// EndToEndIDPost Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// - "E" - fixo (1 caractere);
// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
//
// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
type EndToEndIDPost = string

// EnumAccountTypeConsents Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypeConsents string

// EnumAccountTypePayments Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypePayments string

// EnumAuthorisationStatusType Status atual do consentimento recorrente de acordo com a máquina de estados
// - AWAITING_AUTHORISATION - Aguardando autorização
// - PARTIALLY_ACCEPTED - Parcialmente aceito
// - AUTHORISED - Autorizado
// - REJECTED - Rejeitado
// - REVOKED - Revogado
// - CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Estado para qual o pagamento deverá transitar
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual do pagamento. O estado evolui na seguinte ordem:
// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
// Em caso insucesso:
// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonCode Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
// - CONSENTIMENTO_REVOGADO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCode string

// EnumRejectionReasonCodeGet Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
// - CONSENTIMENTO_REVOGADO
// - LIMITE_TENTATIVAS_EXCEDIDO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCodeGet string

// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
//
// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
type FirstPayment struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// CreditorAccount Recebe os dados de conta do usuário recebedor.
	CreditorAccount CreditorAccountConsent `json:"creditorAccount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date Define a data alvo da liquidação do pagamento.
	// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
	Date timeutil.BrazilDate `json:"date"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// Month Configurar limite transacional mensal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Month struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um mês.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado mensalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Informações gerais sobre o cancelamento.
	Cancellation struct {
		// CancelledBy Informações gerais sobre o usuário que solicitou o cancelamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica
				Identification string `json:"identification"`

				// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
				Rel PatchPixPaymentDataCancellationCancelledByDocumentRel `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Estado para qual o pagamento deverá transitar
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PatchPixPaymentDataCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PatchPixPaymentDataCancellationCancelledByDocumentRel string

// PatchRecurringConsent defines model for PatchRecurringConsent.
type PatchRecurringConsent struct {
	// Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
	Data PatchRecurringConsent_Data `json:"data"`
}

// PatchRecurringConsent_Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
type PatchRecurringConsent_Data struct {
	union json.RawMessage
}

// PaymentPix Objeto contendo as informações do pagamento.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'. Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
type PeriodicLimits struct {
	// Day Configurar limite transacional diário determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
	Day *Day `json:"day,omitempty"`

	// Month Configurar limite transacional mensal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Month *Month `json:"month,omitempty"`

	// Week Configurar limite transacional semanal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Week *Week `json:"week,omitempty"`

	// Year Configurar limite transacional anual determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Year *Year `json:"year,omitempty"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Identification string `json:"identification"`

			// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Rel PixPaymentCancellationCancelledByDocumentRel `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PixPaymentCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PixPaymentCancellationCancelledByDocumentRel string

// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
type RecurringConfiguration = autopayment.Configuration

// Rejection Objeto contendo as informações de rejeição dos consentimentos.
//
// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
type Rejection struct {
	// Reason Informações sobre o motivo da rejeição
	Reason *ConsentRejectionReason `json:"reason,omitempty"`

	// RejectedAt Data e hora em que o consentimento foi rejeitado
	RejectedAt timeutil.DateTime `json:"rejectedAt"`

	// RejectedBy Quem iniciou a solicitação de rejeição
	// - INICIADORA
	// - USUARIO
	// - DETENTORA
	RejectedBy RejectionRejectedBy `json:"rejectedBy"`

	// RejectedFrom Canal onde iniciou-se o processo de rejeição
	// - INICIADORA
	// - DETENTORA
	RejectedFrom RejectionRejectedFrom `json:"rejectedFrom"`
}

// RejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type RejectionRejectedBy string

// RejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type RejectionRejectedFrom string

// RejectionReason Objeto contendo o motivo de rejeição assíncrono
type RejectionReason struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração
	// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio.
	Detail string `json:"detail"`
}

// RejectionReasonGet Objeto contendo o motivo de rejeição assíncrono
type RejectionReasonGet struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
	// - CONSENTIMENTO_REVOGADO
	// - LIMITE_TENTATIVAS_EXCEDIDO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCodeGet `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - LIMITE_PERIODO_VALOR_EXCEDIDO – A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO – A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio
	Detail string `json:"detail"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsent defines model for ResponseErrorCreateConsent.
type ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// - DATA_PAGAMENTO_INVALIDA
		// - DETALHE_PAGAMENTO_INVALIDO
		// - PARAMETRO_NAO_INFORMADO
		// - PARAMETRO_INVALIDO
		// - ERRO_IDEMPOTENCIA
		// - NAO_INFORMADO
		// - FUNCIONALIDADE_NAO_HABILITADA
		Code ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - NAO_INFORMADO: Não informado.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// - DATA_PAGAMENTO_INVALIDA
// - DETALHE_PAGAMENTO_INVALIDO
// - PARAMETRO_NAO_INFORMADO
// - PARAMETRO_INVALIDO
// - ERRO_IDEMPOTENCIA
// - NAO_INFORMADO
// - FUNCIONALIDADE_NAO_HABILITADA
type ResponseErrorCreateConsentErrorsCode string

// ResponsePostRecurringConsent defines model for ResponsePostRecurringConsent.
type ResponsePostRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponsePostRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponsePostRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePostRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponsePostRecurringConsentDataRevocationReasonCode string

// ResponsePostRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedBy string

// ResponsePostRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsent defines model for ResponseRecurringConsent.
type ResponseRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// IbgeTownCode Campo utilizado pela iniciadora para cálculo do dia útil de liquidação do pagamento (vide especificação do endToEndId) baseado no município de cadastro do usuário pagador no detentor.
			//
			// [Restrições]
			// Campo de preenchimento obrigatório quando o oneOf utilizado do recurringConfiguration for “automatic”, e o consentimento passar pelo estado AUTHORISED.
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentDataRevocationReasonCode string

// ResponseRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedBy string

// ResponseRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsentPatch defines model for ResponseRecurringConsentPatch.
type ResponseRecurringConsentPatch struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser *LoggedUser `json:"loggedUser,omitempty"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *struct {
			// Reason Informações sobre o motivo da rejeição
			Reason *ConsentRejectionReason `json:"reason,omitempty"`

			// RejectedAt Data e hora em que o consentimento foi rejeitado
			RejectedAt timeutil.DateTime `json:"rejectedAt"`

			// RejectedBy Quem iniciou a solicitação de rejeição
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RejectedBy ResponseRecurringConsentPatchDataRejectionRejectedBy `json:"rejectedBy"`

			// RejectedFrom Canal onde iniciou-se o processo de rejeição
			// - INICIADORA
			// - DETENTORA
			RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom `json:"rejectedFrom"`
		} `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentPatchDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentPatchDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentPatchDataRejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedBy string

// ResponseRecurringConsentPatchDataRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedFrom string

// ResponseRecurringConsentPatchDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentPatchDataRevocationReasonCode string

// ResponseRecurringConsentPatchDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedBy string

// ResponseRecurringConsentPatchDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedFrom string

// ResponseRecurringPaymentsDataPatch defines model for ResponseRecurringPaymentsDataPatch.
type ResponseRecurringPaymentsDataPatch struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataPatchAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date string `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataPatchDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataPatchLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataPatchAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataPatchAuthorisationFlow string

// ResponseRecurringPaymentsDataPatchDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataPatchDocumentRel string

// ResponseRecurringPaymentsDataPatchLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataPatchLocalInstrument string

// ResponseRecurringPaymentsDataRead defines model for ResponseRecurringPaymentsDataRead.
type ResponseRecurringPaymentsDataRead struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataReadAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date string `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataReadLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataReadAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataReadAuthorisationFlow string

// ResponseRecurringPaymentsDataReadDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataReadDocumentRel string

// ResponseRecurringPaymentsDataReadLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataReadLocalInstrument string

// ResponseRecurringPaymentsIDPatch defines model for ResponseRecurringPaymentsIdPatch.
type ResponseRecurringPaymentsIDPatch struct {
	Data  ResponseRecurringPaymentsDataPatch `json:"data"`
	Links api.Links                          `json:"links"`
	Meta  api.Meta                           `json:"meta"`
}

// ResponseRecurringPaymentsIDPost defines model for ResponseRecurringPaymentsIdPost.
type ResponseRecurringPaymentsIDPost struct {
	Data  ResponseRecurringPaymentsPostData `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsIDRead defines model for ResponseRecurringPaymentsIdRead.
type ResponseRecurringPaymentsIDRead struct {
	Data  ResponseRecurringPaymentsDataRead `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsPostData defines model for ResponseRecurringPaymentsPostData.
type ResponseRecurringPaymentsPostData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsPostDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccountPostPixPaymentsResponse `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date string `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsPostDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsPostDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsPostDataAuthorisationFlow string

// ResponseRecurringPaymentsPostDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsPostDataDocumentRel string

// ResponseRecurringPaymentsPostDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsPostDataLocalInstrument string

// ResponseRecurringPixData defines model for ResponseRecurringPixData.
type ResponseRecurringPixData = []struct {
	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date string `json:"date"`

	// Document Informações do documento.
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa natural ou jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPixDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReasonGet `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPixDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPixDataDocumentRel string

// ResponseRecurringPixPayment defines model for ResponseRecurringPixPayment.
type ResponseRecurringPixPayment struct {
	Data  ResponseRecurringPixData `json:"data"`
	Links api.Links                `json:"links"`
	Meta  api.Meta                 `json:"meta"`
}

// RiskSignalsConsentEdition Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
// Só estará presente após a primeira edição do consentimento de longa duração.
// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
type RiskSignalsConsentEdition struct {
	// AccountTenure Data de cadastro do cliente na iniciadora.
	AccountTenure timeutil.BrazilDate `json:"accountTenure"`

	// AntennaInformation Indica em qual antena o dispositivo está conectado.
	AntennaInformation *string `json:"antennaInformation,omitempty"`

	// DeviceID ID único do dispositivo gerado pela plataforma.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
	//
	// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor/).
	DeviceID string `json:"deviceId"`

	// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/SystemClock#elapsedRealtime%28%29).
	//
	// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/kernel/kern/).
	//
	// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo for Android ou iOS.
	ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

	// Geolocation Localização do usuário, obtida com seu consentimento.
	//
	// [Android] Informação obtida através do [link](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-abstract-tasklocation-getlastlocation) considerando as permissões necessárias.
	//
	// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/corelocation/).
	//
	// [Restrição] A ITP deve solicitar ao usuário a permissão para compartilhamento de sua localização.
	// Este campo poderá ser omitido caso o GPS esteja indisponível, isto é, sem sinal, ou em dispositivos sem o hardware necessário; ou caso o usuário negue o consentimento para coleta do dado.
	Geolocation *struct {
		// Latitude Coordenada latitudial do cliente enquanto logado na iniciadora
		Latitude *float64 `json:"latitude,omitempty"`

		// Longitude Coordenada longitudinal do cliente enquanto logado na iniciadora
		Longitude *float64 `json:"longitude,omitempty"`

		// Type Tipo de mecanismo utilizado na geração da geolocalização
		Type *RiskSignalsConsentEditionGeolocationType `json:"type,omitempty"`
	} `json:"geolocation,omitempty"`

	// Integrity Informa a integridade do dispositivo e app.
	// No Android, conforme documentação Play API Integrity - [Android](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
	// No iOS, conforme documentação App Attest [iOS](https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity)
	Integrity *struct {
		// AppRecognitionVerdict Informa a integridade do app
		AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

		// DeviceRecognitionVerdict Informa a integridade do dispositivo
		DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
	} `json:"integrity,omitempty"`

	// IsCallingProgress Indica chamada ativa no momento da solicitação.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/media/AudioManager#getMode()).
	//
	// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/callkit/).
	//
	// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado.
	IsCallingProgress *bool `json:"isCallingProgress,omitempty"`

	// IsCharging Indica se a bateria do dispositivo está sendo carregada.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/BatteryManager).
	//
	// [iOS] Informações obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620045-batterymonitoringenabled/).
	IsCharging *bool `json:"isCharging,omitempty"`

	// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
	IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

	// IsEmulated Indica se o dispositivo é emulado ou real.
	IsEmulated *bool `json:"isEmulated,omitempty"`

	// IsMockGPS Indica se o dispositivo está usando um GPS falso. Deve ser enviado sempre que exista o campo geolocation com tipo COARSE ou FINE.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/location/Location.html#isMock()) ou, para versões anteriores à 12, [link](https://developer.android.com/reference/android/location/Location.html#isFromMockProvider()).
	//
	// [iOS] Informação obtida através dos links: sourceInformation, [link](https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation). isSimulatedBySoftware, [link](https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware).
	IsMockGPS *bool `json:"isMockGPS,omitempty"`

	// IsMonkeyRunner Indica o uso do MonkeyRunner.
	IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

	// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
	//
	// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário for Android ou iOS.
	IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

	// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
	IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

	// Language Indica o idioma do dispositivo no formato ISO 639-1.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/util/Locale#getLanguage()).
	//
	// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/foundation/locale/languagecode/).
	Language string `json:"language"`

	// OsVersion Versão do sistema operacional.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/Build.VERSION#RELEASE).
	//
	// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620043-systemversion/).
	OsVersion string `json:"osVersion"`

	// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
	//
	// [Android] O valor é inteiro, tipicamente entre 0 a 255, podendo a faixa de valores variar de acordo com o fabricante do celular. Referência no [link](https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS).
	//
	// [iOS] O valor é ponto flutuante entre “0.0” e “1.0”. Referência no [link](https://developer.apple.com/documentation/kernel/kern/).
	//
	// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo for Android ou iOS.
	ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

	// ScreenDimensions Dimensões que o aplicativo ocupa na tela do dispositivo.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/view/WindowMetrics#getBounds()), ou, para versões anteriores à 11, [link](https://developer.android.com/reference/android/util/DisplayMetrics).
	//
	// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/metal/mtlrasterizationratemap/3088873-screensize/).
	ScreenDimensions struct {
		// Height Altura da tela, em pixels.
		Height int64 `json:"height"`

		// Width Largura da tela, em pixels.
		Width int64 `json:"width"`
	} `json:"screenDimensions"`

	// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]. O formato especificado permite a omissão da parte correspondente aos minutos, caso esta última tenha valor zero. Assim, ambos os valores '-03:00' e '-03' são válidos e representam o mesmo fuso horário.
	//
	// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/time/ZonedDateTime#getOffset()) ou, para versões anteriores à 8.0, [link](https://developer.android.com/reference/java/util/TimeZone#getOffset(long)).
	//
	// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/foundation/timezone/).
	UserTimeZoneOffset string `json:"userTimeZoneOffset"`
}

// RiskSignalsConsentEditionGeolocationType Tipo de mecanismo utilizado na geração da geolocalização
type RiskSignalsConsentEditionGeolocationType string

// RiskSignalsConsents Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
type RiskSignalsConsents struct {
	// AccountTenure Data de cadastro do cliente na iniciadora.
	AccountTenure timeutil.BrazilDate `json:"accountTenure"`

	// AntennaInformation Indica em qual antena o dispositivo está conectado.
	AntennaInformation *string `json:"antennaInformation,omitempty"`

	// DeviceID ID único do dispositivo gerado pela plataforma.
	DeviceID string `json:"deviceId"`

	// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
	ElapsedTimeSinceBoot int64 `json:"elapsedTimeSinceBoot"`

	// Geolocation Dados de geolocalização do cliente enquanto logado na iniciadora
	Geolocation *struct {
		// Latitude Coordenada latitudial do cliente enquanto logado na iniciadora
		Latitude *float64 `json:"latitude,omitempty"`

		// Longitude Coordenada longitudinal do cliente enquanto logado na iniciadora
		Longitude *float64 `json:"longitude,omitempty"`

		// Type Tipo de mecanismo utilizado na geração da geolocalização
		Type *RiskSignalsConsentsGeolocationType `json:"type,omitempty"`
	} `json:"geolocation,omitempty"`

	// Integrity Informa a integridade do dispositivo e app.
	// No Android, conforme documentação Play API Integrity - [Android](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
	// No iOS, conforme documentação App Attest [iOS](https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity)
	Integrity *struct {
		// AppRecognitionVerdict Informa a integridade do app
		AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

		// DeviceRecognitionVerdict Informa a integridade do dispositivo
		DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
	} `json:"integrity,omitempty"`

	// IsCallingProgress Indica chamada ativa no momento do vínculo.
	//
	// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
	IsCallingProgress *bool `json:"isCallingProgress,omitempty"`

	// IsCharging Indica se a bateria do dispositivo está sendo carregada.
	IsCharging *bool `json:"isCharging,omitempty"`

	// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
	IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

	// IsEmulated Indica se o dispositivo é emulado ou real.
	IsEmulated *bool `json:"isEmulated,omitempty"`

	// IsMockGPS Indica se o dispositivo está usando um GPS falso.
	IsMockGPS *bool `json:"isMockGPS,omitempty"`

	// IsMonkeyRunner Indica o uso do MonkeyRunner.
	IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

	// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
	IsRootedDevice bool `json:"isRootedDevice"`

	// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
	IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

	// Language Indica o idioma do dispositivo no formato ISO 639-1.
	Language string `json:"language"`

	// OsVersion Versão do sistema operacional.
	OsVersion string `json:"osVersion"`

	// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
	// Em dispositivos Android o valor é um inteiro, entre 0 e 255, inclusive;
	// Em dispositivos iOS o valor é um ponto flutuante entre 0.0 e 1.0.
	ScreenBrightness float64 `json:"screenBrightness"`

	// ScreenDimensions Dimensões da tela do dispositivo
	ScreenDimensions struct {
		// Height Altura da tela, em pixels.
		Height int64 `json:"height"`

		// Width Largura da tela, em pixels.
		Width int64 `json:"width"`
	} `json:"screenDimensions"`

	// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]
	UserTimeZoneOffset string `json:"userTimeZoneOffset"`
}

// RiskSignalsConsentsGeolocationType Tipo de mecanismo utilizado na geração da geolocalização
type RiskSignalsConsentsGeolocationType string

// RiskSignalsPayments Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
type RiskSignalsPayments struct {
	// Automatic Representa a coleta de sinais de risco sem a presença do usuário
	//
	// [Restrição] Obrigatório de ser enviado quando a transação não ocorrer na presença do usuário
	Automatic *struct {
		// LastLoginDateTime Caso o usuário pagador tenha acesso ao ambiente da iniciadora de pagamentos, utilizar data e hora da última interação do cliente com seu aplicativo/sistema.
		// Para casos onde a iniciadora de pagamentos presta serviços a um terceiro, deve-se enviar o horário que o pagador logou na aplicação do terceiro.
		LastLoginDateTime timeutil.DateTime `json:"lastLoginDateTime"`

		// PixKeyRegistrationDateTime Data e hora de cadastro da chave Pix do recebedor na iniciadora
		//
		// [Restrição] Campo obrigatório a ser enviado, caso o valor do campo `/data/localInstrument` seja igual a `DICT` ou `INIC`.
		PixKeyRegistrationDateTime *timeutil.DateTime `json:"pixKeyRegistrationDateTime,omitempty"`
	} `json:"automatic,omitempty"`

	// Manual Representa a coleta de sinais de risco com a presença do usuário
	//
	// [Restrição] Obrigatório de ser enviado quando a transação ocorrer na presença do usuário
	Manual *struct {
		// AccountTenure Data de cadastro do cliente na iniciadora.
		AccountTenure timeutil.BrazilDate `json:"accountTenure"`

		// AntennaInformation Indica em qual antena o dispositivo está conectado.
		AntennaInformation *string `json:"antennaInformation,omitempty"`

		// DeviceID ID único do dispositivo gerado pela plataforma.
		DeviceID string `json:"deviceId"`

		// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
		//
		// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante o pagamento for Android ou iOS.
		ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

		// Geolocation Dados de geolocalização do cliente enquanto logado na iniciadora
		Geolocation *struct {
			// Latitude Coordenada latitudial do cliente enquanto logado na iniciadora
			Latitude *float64 `json:"latitude,omitempty"`

			// Longitude Coordenada longitudinal do cliente enquanto logado na iniciadora
			Longitude *float64 `json:"longitude,omitempty"`

			// Type Tipo de mecanismo utilizado na geração da geolocalização
			Type *RiskSignalsPaymentsManualGeolocationType `json:"type,omitempty"`
		} `json:"geolocation,omitempty"`

		// Integrity Informa a integridade do dispositivo e app.
		// No Android, conforme documentação Play API Integrity - [Android](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
		// No iOS, conforme documentação App Attest [iOS](https://developer.apple.com/documentation/devicecheck/establishing_your_app_s_integrity)
		Integrity *struct {
			// AppRecognitionVerdict Informa a integridade do app
			AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

			// DeviceRecognitionVerdict Informa a integridade do dispositivo
			DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
		} `json:"integrity,omitempty"`

		// IsCallingProgress Indica chamada ativa no momento do vínculo.
		//
		// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
		IsCallingProgress *bool `json:"isCallingProgress,omitempty"`

		// IsCharging Indica se a bateria do dispositivo está sendo carregada.
		IsCharging *bool `json:"isCharging,omitempty"`

		// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
		IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

		// IsEmulated Indica se o dispositivo é emulado ou real.
		IsEmulated *bool `json:"isEmulated,omitempty"`

		// IsMockGPS Indica se o dispositivo está usando um GPS falso.
		IsMockGPS *bool `json:"isMockGPS,omitempty"`

		// IsMonkeyRunner Indica o uso do MonkeyRunner.
		IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

		// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
		//
		// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante o pagamento for Android ou iOS.
		IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

		// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
		IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

		// Language Indica o idioma do dispositivo no formato ISO 639-1.
		Language string `json:"language"`

		// OsVersion Versão do sistema operacional.
		OsVersion string `json:"osVersion"`

		// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
		// Em dispositivos Android o valor é um inteiro, entre 0 e 255, inclusive;
		// Em dispositivos iOS o valor é um ponto flutuante entre 0.0 e 1.0.
		//
		// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante o pagamento for Android ou iOS.
		ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

		// ScreenDimensions Dimensões da tela do dispositivo
		ScreenDimensions struct {
			// Height Altura da tela, em pixels.
			Height int64 `json:"height"`

			// Width Largura da tela, em pixels.
			Width int64 `json:"width"`
		} `json:"screenDimensions"`

		// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]
		UserTimeZoneOffset string `json:"userTimeZoneOffset"`
	} `json:"manual,omitempty"`
}

// RiskSignalsPaymentsManualGeolocationType Tipo de mecanismo utilizado na geração da geolocalização
type RiskSignalsPaymentsManualGeolocationType string

// Sweeping defines model for Sweeping.
type Sweeping struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime timeutil.DateTime `json:"startDateTime"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"sweeping"`
}

// SweepingRequest defines model for SweepingRequest.
type SweepingRequest struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime *timeutil.DateTime `json:"startDateTime,omitempty"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"sweeping"`
}

// Vrp defines model for Vrp.
type Vrp struct {
	// Vrp Definição da configuração de recorrência para realização de transações de valores variáveis
	Vrp struct {
		// GlobalLimits Limite transacional máximo para pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
		GlobalLimits *struct {
			// QuantityLimit Quantidade máxima de ocorrência  de pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED"
			QuantityLimit *int `json:"quantityLimit,omitempty"`

			// TransactionLimit Valor transacional máximo para pagamentos sob este consentimento, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
			TransactionLimit *string `json:"transactionLimit,omitempty"`
		} `json:"globalLimits,omitempty"`

		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *struct {
			// Day Configurar limite transacional diário determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
			Day *Day `json:"day,omitempty"`

			// Month Configurar limite transacional mensal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Month *Month `json:"month,omitempty"`

			// Week Configurar limite transacional semanal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Week *Week `json:"week,omitempty"`

			// Year Configurar limite transacional anual determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Year *Year `json:"year,omitempty"`
		} `json:"periodicLimits,omitempty"`

		// TransactionLimit Limite máximo de valor permitido para cada transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"vrp"`
}

// Week Configurar limite transacional semanal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Week struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante uma semana.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado semanalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// Year Configurar limite transacional anual determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Year struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um ano.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado por um ano, a partir da data definida no campo `/data/startDateTime`.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
// O recurringPaymentId deve ser diferente do endToEndId.
// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
//
// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
type OriginalRecurringPaymentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// EndDate defines model for endDate.
type EndDate = string

// ParameterOriginalRecurringPaymentId defines model for originalRecurringPaymentId.
type ParameterOriginalRecurringPaymentId = string

// PathRecurringConsentID defines model for pathRecurringConsentId.
type PathRecurringConsentID = string

// PathRecurringPaymentID defines model for pathRecurringPaymentId.
type PathRecurringPaymentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// StartDate defines model for startDate.
type StartDate = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPaymentsConsents defines model for BadRequestPaymentsConsents.
type BadRequestPaymentsConsents = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// RecurringConsentsConsentID defines model for RecurringConsentsConsentId.
type RecurringConsentsConsentID = ResponseRecurringConsent

// RecurringConsentsPost defines model for RecurringConsentsPost.
type RecurringConsentsPost = ResponsePostRecurringConsent

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// AutomaticPaymentsGetPixRecurringPaymentsParams defines parameters for AutomaticPaymentsGetPixRecurringPayments.
type AutomaticPaymentsGetPixRecurringPaymentsParams struct {
	// RecurringConsentID O `recurringConsentId` é o identificador único do consentimento de longa duração e deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independe da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição detentora (bancoex).
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	RecurringConsentID RecurringConsentID `form:"recurringConsentId" json:"recurringConsentId"`

	// StartDate Data inicial de corte da ocorrência do pagamento ligada ao consentimento de longa duração.
	StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Data final de corte para recuperação da ocorrência do pagamento ligada ao consentimento de longa duração.
	EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`

	// ParameterOriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// Código ou identificador único criado pela instituição detentora da conta para representar a iniciação de pagamento.
	// Caso informado, devem ser retornados todos os pagamentos associados ao identificador informado, sendo eles o pagamento original (dono do identificador) e as novas tentativas que enviaram o identificador na sua requisição, indicando que representam nova tentativa.
	ParameterOriginalRecurringPaymentID *ParameterOriginalRecurringPaymentId `form:"originalRecurringPaymentId,omitempty" json:"originalRecurringPaymentId,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPostPixRecurringPaymentsParams defines parameters for AutomaticPaymentsPostPixRecurringPayments.
type AutomaticPaymentsPostPixRecurringPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsGetPixRecurringPaymentsPaymentID.
type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsParams defines parameters for AutomaticPaymentsPostRecurringConsents.
type AutomaticPaymentsPostRecurringConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsGetRecurringConsentsConsentID.
type AutomaticPaymentsGetRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsPatchRecurringConsentsConsentID.
type AutomaticPaymentsPatchRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsJSONRequestBody defines body for AutomaticPaymentsPostRecurringConsents for application/json ContentType.
type AutomaticPaymentsPostRecurringConsentsJSONRequestBody = CreateRecurringConsent

// AsConsentEdition returns the union data inside the PatchRecurringConsent_Data as a ConsentEdition
func (t PatchRecurringConsent_Data) AsConsentEdition() (ConsentEdition, error) {
	var body ConsentEdition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentEdition overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentEdition
func (t *PatchRecurringConsent_Data) FromConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentEdition performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentEdition
func (t *PatchRecurringConsent_Data) MergeConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRevocation returns the union data inside the PatchRecurringConsent_Data as a ConsentRevocation
func (t PatchRecurringConsent_Data) AsConsentRevocation() (ConsentRevocation, error) {
	var body ConsentRevocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRevocation overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) FromConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRevocation performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) MergeConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRejection returns the union data inside the PatchRecurringConsent_Data as a ConsentRejection
func (t PatchRecurringConsent_Data) AsConsentRejection() (ConsentRejection, error) {
	var body ConsentRejection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRejection overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRejection
func (t *PatchRecurringConsent_Data) FromConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRejection performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRejection
func (t *PatchRecurringConsent_Data) MergeConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchRecurringConsent_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchRecurringConsent_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsParams

	// ------------- Required query parameter "recurringConsentId" -------------

	if paramValue := r.URL.Query().Get("recurringConsentId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "recurringConsentId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "recurringConsentId", r.URL.Query(), &params.RecurringConsentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
		return
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
		return
	}

	// ------------- Optional query parameter "originalRecurringPaymentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "originalRecurringPaymentId", r.URL.Query(), &params.ParameterOriginalRecurringPaymentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "recurring-consent:recurringConsentId", "recurring-payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "recurring-payments", "enrollment:enrollmentId", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostPixRecurringPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostRecurringConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostRecurringConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsGetPixRecurringPayments)
	m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsPostPixRecurringPayments)
	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)
	m.HandleFunc("POST "+options.BaseURL+"/recurring-consents", wrapper.AutomaticPaymentsPostRecurringConsents)
	m.HandleFunc("GET "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)

	return m
}

type N200RecurringPaymentsIDPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200RecurringPaymentsIDReadApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200RecurringPixPaymentReadApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N201RecurringPaymentsIDPostApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type RecurringConsentsConsentIDJSONResponse ResponseRecurringConsent

type RecurringConsentsConsentIDPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type RecurringConsentsPostJSONResponse ResponsePostRecurringConsent

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixRecurringPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type AutomaticPaymentsGetPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsGetPixRecurringPaymentsParams
}

type AutomaticPaymentsGetPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPayments200ApplicationJwtResponse struct {
	N200RecurringPixPaymentReadApplicationJwtResponse
}

func (response AutomaticPaymentsGetPixRecurringPayments200ApplicationJwtResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsPostPixRecurringPaymentsParams
	Body   io.Reader
}

type AutomaticPaymentsPostPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPayments201ApplicationJwtResponse struct {
	N201RecurringPaymentsIDPostApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments201ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(201)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID200ApplicationJwtResponse struct {
	N200RecurringPaymentsIDReadApplicationJwtResponse
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID200ApplicationJwtResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams
	Body               io.Reader
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200ApplicationJwtResponse struct {
	N200RecurringPaymentsIDPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostRecurringConsentsRequestObject struct {
	Params AutomaticPaymentsPostRecurringConsentsParams
	Body   *AutomaticPaymentsPostRecurringConsentsJSONRequestBody
}

type AutomaticPaymentsPostRecurringConsentsResponseObject interface {
	VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostRecurringConsents201JSONResponse struct {
	RecurringConsentsPostJSONResponse
}

func (response AutomaticPaymentsPostRecurringConsents201JSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse struct {
	UnprocessableConsentsApplicationJwtResponse
}

func (response AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsGetRecurringConsentsConsentIDParams
}

type AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDJSONResponse
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsPatchRecurringConsentsConsentIDParams
	Body               io.Reader
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchRecurringConsentsConsentID200ApplicationJwtResponse struct {
	RecurringConsentsConsentIDPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID200ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(ctx context.Context, request AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPayments(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams) {
	var request AutomaticPaymentsPostPixRecurringPaymentsRequestObject

	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostPixRecurringPayments(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (sh *strictHandler) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams) {
	var request AutomaticPaymentsPostRecurringConsentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostRecurringConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostRecurringConsents(ctx, request.(AutomaticPaymentsPostRecurringConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostRecurringConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostRecurringConsentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostRecurringConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
