//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/autopayment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreatePixRecurringPaymentErrorsCode.
const (
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOPENDENTEAUTORIZACAO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHEPAGAMENTOINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeERROIDEMPOTENCIA                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO                        N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOVALOREXCEDIDO                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeNAOINFORMADO                              N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTODIVERGENTECONSENTIMENTO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADOSPI                      N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_SPI"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETROINVALIDO                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeSALDOINSUFICIENTE                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "SALDO_INSUFICIENTE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORACIMALIMITE                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_ACIMA_LIMITE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORINVALIDO                             N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_INVALIDO"
)

// Defines values for N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode.
const (
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodeCANCELAMENTOFORAPERIODOPERMITIDO N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "CANCELAMENTO_FORA_PERIODO_PERMITIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePAGAMENTONAOPERMITECANCELAMENTO  N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETROINVALIDO                N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETRONAOINFORMADO            N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode.
const (
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO        N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO     N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeERROIDEMPOTENCIA             N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeFALHAINFRAESTRUTURADETENTORA N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "FALHA_INFRAESTRUTURA_DETENTORA"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO           N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO     N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodeNAOPERMITIDO                 N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "NAO_PERMITIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA   N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodePARAMETROINVALIDO            N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO        N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorRecurringConsentsErrorsCode.
const (
	N422ResponseErrorRecurringConsentsErrorsCodeCAMPONAOPERMITIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "CAMPO_NAO_PERMITIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeCONSENTIMENTONAOPERMITECANCELAMENTO N422ResponseErrorRecurringConsentsErrorsCode = "CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorRecurringConsentsErrorsCodeDETALHEEDICAOINVALIDO               N422ResponseErrorRecurringConsentsErrorsCode = "DETALHE_EDICAO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeFALTAMSINAISOBRIGATORIOSPLATAFORMA  N422ResponseErrorRecurringConsentsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETROINVALIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETRONAOINFORMADO               N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorRecurringConsentsErrorsCodePERMISSAOINSUFICIENTE               N422ResponseErrorRecurringConsentsErrorsCode = "PERMISSAO_INSUFICIENTE"
)

// Defines values for AutomaticAutomaticInterval.
const (
	AutomaticAutomaticIntervalANUAL      AutomaticAutomaticInterval = "ANUAL"
	AutomaticAutomaticIntervalMENSAL     AutomaticAutomaticInterval = "MENSAL"
	AutomaticAutomaticIntervalSEMANAL    AutomaticAutomaticInterval = "SEMANAL"
	AutomaticAutomaticIntervalSEMESTRAL  AutomaticAutomaticInterval = "SEMESTRAL"
	AutomaticAutomaticIntervalTRIMESTRAL AutomaticAutomaticInterval = "TRIMESTRAL"
)

// Defines values for AutomaticRequestAutomaticInterval.
const (
	AutomaticRequestAutomaticIntervalANUAL      AutomaticRequestAutomaticInterval = "ANUAL"
	AutomaticRequestAutomaticIntervalMENSAL     AutomaticRequestAutomaticInterval = "MENSAL"
	AutomaticRequestAutomaticIntervalSEMANAL    AutomaticRequestAutomaticInterval = "SEMANAL"
	AutomaticRequestAutomaticIntervalSEMESTRAL  AutomaticRequestAutomaticInterval = "SEMESTRAL"
	AutomaticRequestAutomaticIntervalTRIMESTRAL AutomaticRequestAutomaticInterval = "TRIMESTRAL"
)

// Defines values for ConsentRejectionRejectionRejectedBy.
const (
	ConsentRejectionRejectionRejectedByDETENTORA  ConsentRejectionRejectionRejectedBy = "DETENTORA"
	ConsentRejectionRejectionRejectedByINICIADORA ConsentRejectionRejectionRejectedBy = "INICIADORA"
	ConsentRejectionRejectionRejectedByUSUARIO    ConsentRejectionRejectionRejectedBy = "USUARIO"
)

// Defines values for ConsentRejectionRejectionRejectedFrom.
const (
	ConsentRejectionRejectionRejectedFromDETENTORA  ConsentRejectionRejectionRejectedFrom = "DETENTORA"
	ConsentRejectionRejectionRejectedFromINICIADORA ConsentRejectionRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ConsentRejectionStatus.
const (
	ConsentRejectionStatusREJECTED ConsentRejectionStatus = "REJECTED"
)

// Defines values for ConsentRejectionReasonCode.
const (
	ConsentRejectionReasonCodeAUTENTICACAODIVERGENTE    ConsentRejectionReasonCode = "AUTENTICACAO_DIVERGENTE"
	ConsentRejectionReasonCodeCONTANAOPERMITEPAGAMENTO  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
	ConsentRejectionReasonCodeCONTASORIGEMDESTINOIGUAIS ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	ConsentRejectionReasonCodeFALHAINFRAESTRUTURA       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
	ConsentRejectionReasonCodeNAOINFORMADO              ConsentRejectionReasonCode = "NAO_INFORMADO"
	ConsentRejectionReasonCodeREJEITADOUSUARIO          ConsentRejectionReasonCode = "REJEITADO_USUARIO"
	ConsentRejectionReasonCodeTEMPOEXPIRADOAUTORIZACAO  ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
)

// Defines values for ConsentRevocationRevocationRevokedBy.
const (
	ConsentRevocationRevocationRevokedByDETENTORA  ConsentRevocationRevocationRevokedBy = "DETENTORA"
	ConsentRevocationRevocationRevokedByINICIADORA ConsentRevocationRevocationRevokedBy = "INICIADORA"
	ConsentRevocationRevocationRevokedByUSUARIO    ConsentRevocationRevocationRevokedBy = "USUARIO"
)

// Defines values for ConsentRevocationRevocationRevokedFrom.
const (
	ConsentRevocationRevocationRevokedFromDETENTORA  ConsentRevocationRevocationRevokedFrom = "DETENTORA"
	ConsentRevocationRevocationRevokedFromINICIADORA ConsentRevocationRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ConsentRevocationStatus.
const (
	REVOKED ConsentRevocationStatus = "REVOKED"
)

// Defines values for ConsentRevokedReasonCode.
const (
	ConsentRevokedReasonCodeNAOINFORMADO      ConsentRevokedReasonCode = "NAO_INFORMADO"
	ConsentRevokedReasonCodeREVOGADORECEBEDOR ConsentRevokedReasonCode = "REVOGADO_RECEBEDOR"
	ConsentRevokedReasonCodeREVOGADOUSUARIO   ConsentRevokedReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ContractDebtorDocumentRel.
const (
	ContractDebtorDocumentRelCNPJ ContractDebtorDocumentRel = "CNPJ"
	ContractDebtorDocumentRelCPF  ContractDebtorDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataAuthorisationFlow.
const (
	CreateRecurringPixPaymentDataAuthorisationFlowCIBAFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowFIDOFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowHYBRIDFLOW CreateRecurringPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for CreateRecurringPixPaymentDataDocumentRel.
const (
	CreateRecurringPixPaymentDataDocumentRelCNPJ CreateRecurringPixPaymentDataDocumentRel = "CNPJ"
	CreateRecurringPixPaymentDataDocumentRelCPF  CreateRecurringPixPaymentDataDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataLocalInstrument.
const (
	CreateRecurringPixPaymentDataLocalInstrumentAUTO CreateRecurringPixPaymentDataLocalInstrument = "AUTO"
	CreateRecurringPixPaymentDataLocalInstrumentDICT CreateRecurringPixPaymentDataLocalInstrument = "DICT"
	CreateRecurringPixPaymentDataLocalInstrumentINIC CreateRecurringPixPaymentDataLocalInstrument = "INIC"
	CreateRecurringPixPaymentDataLocalInstrumentMANU CreateRecurringPixPaymentDataLocalInstrument = "MANU"
)

// Defines values for EnumAccountTypeConsents.
const (
	EnumAccountTypeConsentsCACC EnumAccountTypeConsents = "CACC"
	EnumAccountTypeConsentsSVGS EnumAccountTypeConsents = "SVGS"
	EnumAccountTypeConsentsTRAN EnumAccountTypeConsents = "TRAN"
)

// Defines values for EnumAccountTypePayments.
const (
	EnumAccountTypePaymentsCACC EnumAccountTypePayments = "CACC"
	EnumAccountTypePaymentsSVGS EnumAccountTypePayments = "SVGS"
	EnumAccountTypePaymentsTRAN EnumAccountTypePayments = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	EnumAuthorisationStatusTypeAUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	EnumAuthorisationStatusTypeAWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	EnumAuthorisationStatusTypeCONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	EnumAuthorisationStatusTypePARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	EnumAuthorisationStatusTypeREJECTED              EnumAuthorisationStatusType = "REJECTED"
	EnumAuthorisationStatusTypeREVOKED               EnumAuthorisationStatusType = "REVOKED"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	EnumPaymentCancellationFromTypeDETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	EnumPaymentCancellationFromTypeINICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOPENDENCIA   EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonCode.
const (
	EnumRejectionReasonCodeCONSENTIMENTOINVALIDO                     EnumRejectionReasonCode = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeCONSENTIMENTOREVOGADO                     EnumRejectionReasonCode = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeFORAPRAZOPERMITIDO                        EnumRejectionReasonCode = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeNAOINFORMADO                              EnumRejectionReasonCode = "NAO_INFORMADO"
	EnumRejectionReasonCodePAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodePAGAMENTORECUSADODETENTORA                EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodePAGAMENTORECUSADOSPI                      EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeSALDOINSUFICIENTE                         EnumRejectionReasonCode = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeVALORACIMALIMITE                          EnumRejectionReasonCode = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeVALORINVALIDO                             EnumRejectionReasonCode = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonCodeGet.
const (
	EnumRejectionReasonCodeGetCONSENTIMENTOINVALIDO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeGetCONSENTIMENTOREVOGADO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeGetDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeGetDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeGetFORAPRAZOPERMITIDO                        EnumRejectionReasonCodeGet = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCodeGet = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCodeGet = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCodeGet = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCodeGet = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCodeGet = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetNAOINFORMADO                              EnumRejectionReasonCodeGet = "NAO_INFORMADO"
	EnumRejectionReasonCodeGetPAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCodeGet = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADODETENTORA                EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADOSPI                      EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeGetSALDOINSUFICIENTE                         EnumRejectionReasonCodeGet = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeGetTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCodeGet = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeGetVALORACIMALIMITE                          EnumRejectionReasonCodeGet = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeGetVALORINVALIDO                             EnumRejectionReasonCodeGet = "VALOR_INVALIDO"
)

// Defines values for PatchPixPaymentDataCancellationCancelledByDocumentRel.
const (
	PatchPixPaymentDataCancellationCancelledByDocumentRelCNPJ PatchPixPaymentDataCancellationCancelledByDocumentRel = "CNPJ"
	PatchPixPaymentDataCancellationCancelledByDocumentRelCPF  PatchPixPaymentDataCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for PixPaymentCancellationCancelledByDocumentRel.
const (
	PixPaymentCancellationCancelledByDocumentRelCNPJ PixPaymentCancellationCancelledByDocumentRel = "CNPJ"
	PixPaymentCancellationCancelledByDocumentRelCPF  PixPaymentCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for RejectionRejectedBy.
const (
	RejectionRejectedByDETENTORA  RejectionRejectedBy = "DETENTORA"
	RejectionRejectedByINICIADORA RejectionRejectedBy = "INICIADORA"
	RejectionRejectedByUSUARIO    RejectionRejectedBy = "USUARIO"
)

// Defines values for RejectionRejectedFrom.
const (
	RejectionRejectedFromDETENTORA  RejectionRejectedFrom = "DETENTORA"
	RejectionRejectedFromINICIADORA RejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseErrorCreateConsentErrorsCode.
const (
	ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA       ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO    ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA            ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	ResponseErrorCreateConsentErrorsCodeFUNCIONALIDADENAOHABILITADA ResponseErrorCreateConsentErrorsCode = "FUNCIONALIDADE_NAO_HABILITADA"
	ResponseErrorCreateConsentErrorsCodeNAOINFORMADO                ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO           ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO       ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationReasonCode.
const (
	ResponsePostRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponsePostRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedBy.
const (
	ResponsePostRecurringConsentDataRevocationRevokedByDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedByINICIADORA ResponsePostRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponsePostRecurringConsentDataRevocationRevokedByUSUARIO    ResponsePostRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedFrom.
const (
	ResponsePostRecurringConsentDataRevocationRevokedFromDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedFromINICIADORA ResponsePostRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentDataRevocationReasonCode.
const (
	ResponseRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedBy.
const (
	ResponseRecurringConsentDataRevocationRevokedByDETENTORA  ResponseRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedByINICIADORA ResponseRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentDataRevocationRevokedByUSUARIO    ResponseRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedFrom.
const (
	ResponseRecurringConsentDataRevocationRevokedFromDETENTORA  ResponseRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedFromINICIADORA ResponseRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedBy.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedByDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByUSUARIO    ResponseRecurringConsentPatchDataRejectionRejectedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedFrom.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedFromDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedFrom = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedFromINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationReasonCode.
const (
	ResponseRecurringConsentPatchDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentPatchDataRevocationReasonCode = "NAO_INFORMADO"
	ResponseRecurringConsentPatchDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponseRecurringConsentPatchDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedBy.
const (
	ResponseRecurringConsentPatchDataRevocationRevokedByDETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByINICIADORA ResponseRecurringConsentPatchDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByUSUARIO    ResponseRecurringConsentPatchDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedFrom.
const (
	DETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedFrom = "DETENTORA"
	INICIADORA ResponseRecurringConsentPatchDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringPaymentsDataPatchAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataPatchAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataPatchAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataPatchDocumentRel.
const (
	ResponseRecurringPaymentsDataPatchDocumentRelCNPJ ResponseRecurringPaymentsDataPatchDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataPatchDocumentRelCPF  ResponseRecurringPaymentsDataPatchDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataPatchLocalInstrument.
const (
	ResponseRecurringPaymentsDataPatchLocalInstrumentAUTO ResponseRecurringPaymentsDataPatchLocalInstrument = "AUTO"
	ResponseRecurringPaymentsDataPatchLocalInstrumentDICT ResponseRecurringPaymentsDataPatchLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataPatchLocalInstrumentINIC ResponseRecurringPaymentsDataPatchLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataPatchLocalInstrumentMANU ResponseRecurringPaymentsDataPatchLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsDataReadAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataReadAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataReadAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataReadDocumentRel.
const (
	ResponseRecurringPaymentsDataReadDocumentRelCNPJ ResponseRecurringPaymentsDataReadDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataReadDocumentRelCPF  ResponseRecurringPaymentsDataReadDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataReadLocalInstrument.
const (
	ResponseRecurringPaymentsDataReadLocalInstrumentAUTO ResponseRecurringPaymentsDataReadLocalInstrument = "AUTO"
	ResponseRecurringPaymentsDataReadLocalInstrumentDICT ResponseRecurringPaymentsDataReadLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataReadLocalInstrumentINIC ResponseRecurringPaymentsDataReadLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataReadLocalInstrumentMANU ResponseRecurringPaymentsDataReadLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsPostDataAuthorisationFlow.
const (
	ResponseRecurringPaymentsPostDataAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsPostDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsPostDataDocumentRel.
const (
	ResponseRecurringPaymentsPostDataDocumentRelCNPJ ResponseRecurringPaymentsPostDataDocumentRel = "CNPJ"
	ResponseRecurringPaymentsPostDataDocumentRelCPF  ResponseRecurringPaymentsPostDataDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsPostDataLocalInstrument.
const (
	ResponseRecurringPaymentsPostDataLocalInstrumentAUTO ResponseRecurringPaymentsPostDataLocalInstrument = "AUTO"
	ResponseRecurringPaymentsPostDataLocalInstrumentDICT ResponseRecurringPaymentsPostDataLocalInstrument = "DICT"
	ResponseRecurringPaymentsPostDataLocalInstrumentINIC ResponseRecurringPaymentsPostDataLocalInstrument = "INIC"
	ResponseRecurringPaymentsPostDataLocalInstrumentMANU ResponseRecurringPaymentsPostDataLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPixDataDocumentRel.
const (
	ResponseRecurringPixDataDocumentRelCNPJ ResponseRecurringPixDataDocumentRel = "CNPJ"
	ResponseRecurringPixDataDocumentRelCPF  ResponseRecurringPixDataDocumentRel = "CPF"
)

// N422ResponseErrorCreatePixRecurringPayment defines model for 422ResponseErrorCreatePixRecurringPayment.
type N422ResponseErrorCreatePixRecurringPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Code N422ResponseErrorCreatePixRecurringPaymentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: Limite de transação excedido.
		// - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
		// - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
		// - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
type N422ResponseErrorCreatePixRecurringPaymentErrorsCode string

// N422ResponseErrorCreateRecurringPaymentsPaymentID defines model for 422ResponseErrorCreateRecurringPaymentsPaymentId.
type N422ResponseErrorCreateRecurringPaymentsPaymentID struct {
	Errors []struct {
		// Code - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Code N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode `json:"code"`

		// Detail - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
type N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode string

// N422ResponseErrorCreateRetryPixRecurringPayment defines model for 422ResponseErrorCreateRetryPixRecurringPayment.
type N422ResponseErrorCreateRetryPixRecurringPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - FALHA_INFRAESTRUTURA_DETENTORA - Ocorreu uma falha de infraestrutura interna na detentora durante o processamento do pagamento.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		// - NAO_PERMITIDO: Valida se o valor do originalRecurringPaymentId aponta para um pagamento de Pix Automático
		Code N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - FALHA_INFRAESTRUTURA_DETENTORA - Ocorreu uma falha de infraestrutura interna na detentora durante o processamento do pagamento.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		// - NAO_PERMITIDO: Valida se o valor do originalRecurringPaymentId aponta para um pagamento de Pix Automático
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - FALHA_INFRAESTRUTURA_DETENTORA - Ocorreu uma falha de infraestrutura interna na detentora durante o processamento do pagamento.
		// - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
		// - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
		// - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
		// - NAO_PERMITIDO: Valida se o valor do originalRecurringPaymentId aponta para um pagamento de Pix Automático
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - FALHA_INFRAESTRUTURA_DETENTORA - Ocorreu uma falha de infraestrutura interna na detentora durante o processamento do pagamento.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
// - NAO_PERMITIDO: Valida se o valor do originalRecurringPaymentId aponta para um pagamento de Pix Automático
type N422ResponseErrorCreateRetryPixRecurringPaymentErrorsCode string

// N422ResponseErrorRecurringConsents defines model for 422ResponseErrorRecurringConsents.
type N422ResponseErrorRecurringConsents struct {
	Errors []struct {
		Code N422ResponseErrorRecurringConsentsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED")
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED").
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorRecurringConsentsErrorsCode defines model for 422ResponseErrorRecurringConsents.Errors.Code.
type N422ResponseErrorRecurringConsentsErrorsCode string

// Automatic defines model for Automatic.
type Automatic struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato. Pode possuir titularidade diferente do usuário pagador descrito nos objetos "/data/loggedUser" e "/data/businessEntity".
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para o início do ciclo de cobrança dos pagamentos associados à recorrência. Trata-se de uma string com data conforme especificação RFC-3339, seguindo o horário de Brasília (UTC-3). O pagamento inicial avulso, declarado no objeto firstPayment do consentimento, não está sujeito a essa data.
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"automatic"`
}

// AutomaticAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticAutomaticInterval string

// AutomaticRequest defines model for AutomaticRequest.
type AutomaticRequest struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato. Pode possuir titularidade diferente do usuário pagador descrito nos objetos "/data/loggedUser" e "/data/businessEntity".
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticRequestAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para o início do ciclo de cobrança dos pagamentos associados à recorrência. Trata-se de uma string com data conforme especificação RFC-3339, seguindo o horário de Brasília (UTC-3). O pagamento inicial avulso, declarado no objeto firstPayment do consentimento, não está sujeito a essa data.
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`
	} `json:"automatic"`
}

// AutomaticRequestAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticRequestAutomaticInterval string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
//
// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentEdition defines model for ConsentEdition.
type ConsentEdition = autopayment.ConsentEdition

// ConsentRejection defines model for ConsentRejection.
type ConsentRejection struct {
	// Rejection Objeto contendo as informações de rejeição dos consentimentos.
	Rejection struct {
		// Reason Informações sobre o motivo da rejeição
		Reason ConsentRejectionReason `json:"reason"`

		// RejectedBy Ator responsável pela solicitação rejeição
		RejectedBy ConsentRejectionRejectionRejectedBy `json:"rejectedBy"`

		// RejectedFrom Canal onde iniciou-se o processo de rejeição
		// - INICIADORA
		// - DETENTORA
		RejectedFrom ConsentRejectionRejectionRejectedFrom `json:"rejectedFrom"`
	} `json:"rejection"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRejectionStatus `json:"status,omitempty"`
}

// ConsentRejectionRejectionRejectedBy Ator responsável pela solicitação rejeição
type ConsentRejectionRejectionRejectedBy string

// ConsentRejectionRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ConsentRejectionRejectionRejectedFrom string

// ConsentRejectionStatus Estado atual do consentimento de longa duração
type ConsentRejectionStatus string

// ConsentRejectionReason Informações sobre o motivo da rejeição
type ConsentRejectionReason struct {
	// Code Código indicador do motivo de rejeição.
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - AUTENTICACAO_DIVERGENTE
	Code ConsentRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de rejeição indicado no campo `/data/rejection/reason/code`
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento];
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento;
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento;
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento;
	// - AUTENTICACAO_DIVERGENTE : Usuário autenticado no detentor diverge do usuário autenticado no iniciador;
	Detail string `json:"detail"`
}

// ConsentRejectionReasonCode Código indicador do motivo de rejeição.
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - AUTENTICACAO_DIVERGENTE
type ConsentRejectionReasonCode string

// ConsentRevocation defines model for ConsentRevocation.
type ConsentRevocation struct {
	// Revocation Objeto contendo as informações de revogação dos consentimentos de longa duração.
	Revocation struct {
		// Reason Informações sobre o motivo da revogação
		Reason ConsentRevokedReason `json:"reason"`

		// RevokedBy Quem iniciou a solicitação de revogação
		// - INICIADORA
		// - USUARIO
		// - DETENTORA
		RevokedBy ConsentRevocationRevocationRevokedBy `json:"revokedBy"`

		// RevokedFrom Canal onde iniciou-se o processo de revogação
		// - INICIADORA
		// - DETENTORA
		RevokedFrom ConsentRevocationRevocationRevokedFrom `json:"revokedFrom"`
	} `json:"revocation"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRevocationStatus `json:"status,omitempty"`
}

// ConsentRevocationRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ConsentRevocationRevocationRevokedBy string

// ConsentRevocationRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ConsentRevocationRevocationRevokedFrom string

// ConsentRevocationStatus Estado atual do consentimento de longa duração
type ConsentRevocationStatus string

// ConsentRevokedReason Informações sobre o motivo da revogação
type ConsentRevokedReason struct {
	// Code Código indicador do motivo de revogação.
	// - REVOGADO_RECEBEDOR
	// - REVOGADO_USUARIO
	// - NAO_INFORMADO
	Code ConsentRevokedReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
	// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
	Detail string `json:"detail"`
}

// ConsentRevokedReasonCode Código indicador do motivo de revogação.
// - REVOGADO_RECEBEDOR
// - REVOGADO_USUARIO
// - NAO_INFORMADO
type ConsentRevokedReasonCode string

// ContractDebtor Informações sobre o cliente devedor do contrato. Pode possuir titularidade diferente do usuário pagador descrito nos objetos "/data/loggedUser" e "/data/businessEntity".
type ContractDebtor struct {
	Document struct {
		// Identification Número do documento de identificação oficial do cliente devedor do contrato.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do cliente devedor do contrato.
		Rel ContractDebtorDocumentRel `json:"rel"`
	} `json:"document"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular devedor do contrato.
	Name string `json:"name"`
}

// ContractDebtorDocumentRel Tipo do documento de identificação oficial do cliente devedor do contrato.
type ContractDebtorDocumentRel string

// CreateRecurringConsent defines model for CreateRecurringConsent.
type CreateRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Creditors      Creditors       `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration autopayment.Configuration `json:"recurringConfiguration"`
	} `json:"data"`
}

// CreateRecurringPixPayment defines model for CreateRecurringPixPayment.
type CreateRecurringPixPayment struct {
	// Data Objeto contendo dados do pagamento e do recebedor (creditor).
	Data CreateRecurringPixPaymentData `json:"data"`
}

// CreateRecurringPixPaymentData Objeto contendo dados do pagamento e do recebedor (creditor).
type CreateRecurringPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *CreateRecurringPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	//
	// [Restrição] - Se /data/paymentReference = "zero", as informações da conta de crédito enviadas (/data/creditorAccount) devem ser iguais as presentes na conta de crédito informada na criação do consentimento(`/data/recurringConfiguration/automatic/firstPayment/creditorAccount`)
	CreditorAccount struct {
		// AccountType Tipos de contas usadas para pagamento via Pix.
		// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
		// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
		// Segue descrição de cada valor do ENUM para o escopo do Pix.
		//
		// - CACC - Current - Conta Corrente.
		// - SVGS - Savings - Conta de Poupança.
		// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
		AccountType EnumAccountTypePayments `json:"accountType"`

		// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
		Ispb string `json:"ispb"`

		// Issuer Código da Agência emissora da conta sem dígito.
		// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
		// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
		//
		// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
		Issuer *string `json:"issuer,omitempty"`

		// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
		// se houver valor alfanumérico, este deve ser convertido para 0.
		Number string `json:"number"`
	} `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel CreateRecurringPixPaymentDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
	//
	// - "E" - fixo (1 caractere);
	// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
	// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
	// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
	//
	// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
	//
	// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
	EndToEndID EndToEndIDPost `json:"endToEndId"`

	// IbgeTownCode O campo ibgeTownCode no arranjo Pix tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do Pix.
	//
	// Caso a informação referente ao município não seja enviada, o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
	//
	// [Restrição]
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
	LocalInstrument CreateRecurringPixPaymentDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	// - O preenchimento deve seguir a seguinte lógica:
	//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
	//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
	//     - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
	//     - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
	//     - Exemplos:
	//       - 1: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Semanal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1W
	//         - Segundo ciclo: 30-07-2025/P1W
	//         - Terceiro ciclo: 06-07-2025/P1W
	//       - 2: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Mensal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1M
	//         - Segundo ciclo: 23-08-2025/P1M
	//         - Terceiro ciclo: 23-09-2025/P1M
	PaymentReference *PaymentReference `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
	//
	// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
	RiskSignals *RiskSignalsPayments `json:"riskSignals,omitempty"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
	// - AUTO – O campo transactionIdentification não deve ser preenchido.
	TransactionIdentification *TransactionIdentification `json:"transactionIdentification,omitempty"`
}

// CreateRecurringPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreateRecurringPixPaymentDataAuthorisationFlow string

// CreateRecurringPixPaymentDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type CreateRecurringPixPaymentDataDocumentRel string

// CreateRecurringPixPaymentDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
//
// [Restrição]
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
type CreateRecurringPixPaymentDataLocalInstrument string

// CreateRecurringRetryPixPayment defines model for CreateRecurringRetryPixPayment.
type CreateRecurringRetryPixPayment struct {
	// Data Objeto contendo dados da nova tentativa de pagamento.
	Data CreateRecurringRetryPixPaymentData `json:"data"`
}

// CreateRecurringRetryPixPaymentData Objeto contendo dados da nova tentativa de pagamento.
type CreateRecurringRetryPixPaymentData struct {
	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
	//
	// - "E" - fixo (1 caractere);
	// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
	// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
	// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
	//
	// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
	//
	// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
	EndToEndID EndToEndIDPost `json:"endToEndId"`
}

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
// [Restrição]
// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountConsent Recebe os dados de conta do usuário recebedor.
type CreditorAccountConsent struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountPostPixPaymentsResponse Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccountPostPixPaymentsResponse struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Creditors defines model for Creditors.
type Creditors = []struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// Day Configurar limite transacional diário determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
type Day struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um dia.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado diariamente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
//
// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
type EndToEndID = string

// EndToEndIDPost Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// - "E" - fixo (1 caractere);
// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
//
// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
type EndToEndIDPost = string

// EnumAccountTypeConsents Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypeConsents string

// EnumAccountTypePayments Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypePayments string

// EnumAuthorisationStatusType Status atual do consentimento recorrente de acordo com a máquina de estados
// - AWAITING_AUTHORISATION - Aguardando autorização
// - PARTIALLY_ACCEPTED - Parcialmente aceito
// - AUTHORISED - Autorizado
// - REJECTED - Rejeitado
// - REVOKED - Revogado
// - CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Estado para qual o pagamento deverá transitar
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual do pagamento. O estado evolui na seguinte ordem:
// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
// Em caso insucesso:
// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonCode Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
// - CONSENTIMENTO_REVOGADO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCode string

// EnumRejectionReasonCodeGet Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
// - CONSENTIMENTO_REVOGADO
// - LIMITE_TENTATIVAS_EXCEDIDO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCodeGet string

// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
//
// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
type FirstPayment struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// CreditorAccount Recebe os dados de conta do usuário recebedor.
	CreditorAccount CreditorAccountConsent `json:"creditorAccount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date Define a data alvo da liquidação do pagamento.
	// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
	Date timeutil.BrazilDate `json:"date"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// Month Configurar limite transacional mensal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Month struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um mês.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado mensalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Informações gerais sobre o cancelamento.
	Cancellation struct {
		// CancelledBy Informações gerais sobre o usuário que solicitou o cancelamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica
				Identification string `json:"identification"`

				// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
				Rel PatchPixPaymentDataCancellationCancelledByDocumentRel `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Estado para qual o pagamento deverá transitar
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PatchPixPaymentDataCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PatchPixPaymentDataCancellationCancelledByDocumentRel string

// PatchRecurringConsent defines model for PatchRecurringConsent.
type PatchRecurringConsent struct {
	// Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
	Data PatchRecurringConsent_Data `json:"data"`
}

// PatchRecurringConsent_Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
type PatchRecurringConsent_Data struct {
	union json.RawMessage
}

// PaymentPix Objeto contendo as informações do pagamento.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'. Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
// - O preenchimento deve seguir a seguinte lógica:
//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
//   - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
//   - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
//   - Exemplos:
//   - 1: Data de início do ciclo definido no consentimento: 23/07/25
//   - Periodicidade definida no consentimento: Semanal
//   - Preenchimento do paymentReference:
//   - Primeiro ciclo: 23-07-2025/P1W
//   - Segundo ciclo: 30-07-2025/P1W
//   - Terceiro ciclo: 06-07-2025/P1W
//   - 2: Data de início do ciclo definido no consentimento: 23/07/25
//   - Periodicidade definida no consentimento: Mensal
//   - Preenchimento do paymentReference:
//   - Primeiro ciclo: 23-07-2025/P1M
//   - Segundo ciclo: 23-08-2025/P1M
//   - Terceiro ciclo: 23-09-2025/P1M
type PaymentReference = string

// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
type PeriodicLimits struct {
	// Day Configurar limite transacional diário determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
	Day *Day `json:"day,omitempty"`

	// Month Configurar limite transacional mensal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Month *Month `json:"month,omitempty"`

	// Week Configurar limite transacional semanal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Week *Week `json:"week,omitempty"`

	// Year Configurar limite transacional anual determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Year *Year `json:"year,omitempty"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Identification string `json:"identification"`

			// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Rel PixPaymentCancellationCancelledByDocumentRel `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PixPaymentCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PixPaymentCancellationCancelledByDocumentRel string

// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
type RecurringConfiguration = autopayment.Configuration

// Rejection Objeto contendo as informações de rejeição dos consentimentos.
//
// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
type Rejection struct {
	// Reason Informações sobre o motivo da rejeição
	Reason *ConsentRejectionReason `json:"reason,omitempty"`

	// RejectedAt Data e hora em que o consentimento foi rejeitado
	RejectedAt timeutil.DateTime `json:"rejectedAt"`

	// RejectedBy Quem iniciou a solicitação de rejeição
	// - INICIADORA
	// - USUARIO
	// - DETENTORA
	RejectedBy RejectionRejectedBy `json:"rejectedBy"`

	// RejectedFrom Canal onde iniciou-se o processo de rejeição
	// - INICIADORA
	// - DETENTORA
	RejectedFrom RejectionRejectedFrom `json:"rejectedFrom"`
}

// RejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type RejectionRejectedBy string

// RejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type RejectionRejectedFrom string

// RejectionReason Objeto contendo o motivo de rejeição assíncrono
type RejectionReason struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração
	// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio.
	Detail string `json:"detail"`
}

// RejectionReasonGet Objeto contendo o motivo de rejeição assíncrono
type RejectionReasonGet struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
	// - CONSENTIMENTO_REVOGADO
	// - LIMITE_TENTATIVAS_EXCEDIDO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCodeGet `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - LIMITE_PERIODO_VALOR_EXCEDIDO – A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO – A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio
	Detail string `json:"detail"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsent defines model for ResponseErrorCreateConsent.
type ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// - DATA_PAGAMENTO_INVALIDA
		// - DETALHE_PAGAMENTO_INVALIDO
		// - PARAMETRO_NAO_INFORMADO
		// - PARAMETRO_INVALIDO
		// - ERRO_IDEMPOTENCIA
		// - NAO_INFORMADO
		// - FUNCIONALIDADE_NAO_HABILITADA
		Code ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - NAO_INFORMADO: Não informado.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// - DATA_PAGAMENTO_INVALIDA
// - DETALHE_PAGAMENTO_INVALIDO
// - PARAMETRO_NAO_INFORMADO
// - PARAMETRO_INVALIDO
// - ERRO_IDEMPOTENCIA
// - NAO_INFORMADO
// - FUNCIONALIDADE_NAO_HABILITADA
type ResponseErrorCreateConsentErrorsCode string

// ResponsePostRecurringConsent defines model for ResponsePostRecurringConsent.
type ResponsePostRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponsePostRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponsePostRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePostRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponsePostRecurringConsentDataRevocationReasonCode string

// ResponsePostRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedBy string

// ResponsePostRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsent defines model for ResponseRecurringConsent.
type ResponseRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// IbgeTownCode Campo utilizado pela iniciadora para cálculo do dia útil de liquidação do pagamento (vide especificação do endToEndId) baseado no município de cadastro do usuário pagador no detentor.
			//
			// [Restrições]
			// Campo de preenchimento obrigatório quando o oneOf utilizado do recurringConfiguration for “automatic”, e o consentimento passar pelo estado AUTHORISED.
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentDataRevocationReasonCode string

// ResponseRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedBy string

// ResponseRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsentPatch defines model for ResponseRecurringConsentPatch.
type ResponseRecurringConsentPatch struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser *LoggedUser `json:"loggedUser,omitempty"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *struct {
			// Reason Informações sobre o motivo da rejeição
			Reason *ConsentRejectionReason `json:"reason,omitempty"`

			// RejectedAt Data e hora em que o consentimento foi rejeitado
			RejectedAt timeutil.DateTime `json:"rejectedAt"`

			// RejectedBy Quem iniciou a solicitação de rejeição
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RejectedBy ResponseRecurringConsentPatchDataRejectionRejectedBy `json:"rejectedBy"`

			// RejectedFrom Canal onde iniciou-se o processo de rejeição
			// - INICIADORA
			// - DETENTORA
			RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom `json:"rejectedFrom"`
		} `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentPatchDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentPatchDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentPatchDataRejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedBy string

// ResponseRecurringConsentPatchDataRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedFrom string

// ResponseRecurringConsentPatchDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentPatchDataRevocationReasonCode string

// ResponseRecurringConsentPatchDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedBy string

// ResponseRecurringConsentPatchDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedFrom string

// ResponseRecurringPaymentsDataPatch defines model for ResponseRecurringPaymentsDataPatch.
type ResponseRecurringPaymentsDataPatch struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataPatchAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataPatchDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
	//
	// [Restrição]
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataPatchLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	// - O preenchimento deve seguir a seguinte lógica:
	//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
	//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
	//     - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
	//     - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
	//     - Exemplos:
	//       - 1: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Semanal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1W
	//         - Segundo ciclo: 30-07-2025/P1W
	//         - Terceiro ciclo: 06-07-2025/P1W
	//       - 2: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Mensal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1M
	//         - Segundo ciclo: 23-08-2025/P1M
	//         - Terceiro ciclo: 23-09-2025/P1M
	PaymentReference *PaymentReference `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
	// - AUTO – O campo transactionIdentification não deve ser preenchido.
	TransactionIdentification *TransactionIdentification `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataPatchAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataPatchAuthorisationFlow string

// ResponseRecurringPaymentsDataPatchDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataPatchDocumentRel string

// ResponseRecurringPaymentsDataPatchLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
//
// [Restrição]
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataPatchLocalInstrument string

// ResponseRecurringPaymentsDataRead defines model for ResponseRecurringPaymentsDataRead.
type ResponseRecurringPaymentsDataRead struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataReadAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
	//
	// [Restrição]
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataReadLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	// - O preenchimento deve seguir a seguinte lógica:
	//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
	//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
	//     - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
	//     - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
	//     - Exemplos:
	//       - 1: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Semanal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1W
	//         - Segundo ciclo: 30-07-2025/P1W
	//         - Terceiro ciclo: 06-07-2025/P1W
	//       - 2: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Mensal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1M
	//         - Segundo ciclo: 23-08-2025/P1M
	//         - Terceiro ciclo: 23-09-2025/P1M
	PaymentReference *PaymentReference `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
	// - AUTO – O campo transactionIdentification não deve ser preenchido.
	TransactionIdentification *TransactionIdentification `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataReadAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataReadAuthorisationFlow string

// ResponseRecurringPaymentsDataReadDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataReadDocumentRel string

// ResponseRecurringPaymentsDataReadLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
//
// [Restrição]
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataReadLocalInstrument string

// ResponseRecurringPaymentsIDPatch defines model for ResponseRecurringPaymentsIdPatch.
type ResponseRecurringPaymentsIDPatch struct {
	Data  ResponseRecurringPaymentsDataPatch `json:"data"`
	Links api.Links                          `json:"links"`
	Meta  api.Meta                           `json:"meta"`
}

// ResponseRecurringPaymentsIDPost defines model for ResponseRecurringPaymentsIdPost.
type ResponseRecurringPaymentsIDPost struct {
	Data  ResponseRecurringPaymentsPostData `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsIDRead defines model for ResponseRecurringPaymentsIdRead.
type ResponseRecurringPaymentsIDRead struct {
	Data  ResponseRecurringPaymentsDataRead `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsPostData defines model for ResponseRecurringPaymentsPostData.
type ResponseRecurringPaymentsPostData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsPostDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccountPostPixPaymentsResponse `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
	//
	// [Restrição]
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
	// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsPostDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	// - O preenchimento deve seguir a seguinte lógica:
	//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
	//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
	//     - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
	//     - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
	//     - Exemplos:
	//       - 1: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Semanal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1W
	//         - Segundo ciclo: 30-07-2025/P1W
	//         - Terceiro ciclo: 06-07-2025/P1W
	//       - 2: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Mensal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1M
	//         - Segundo ciclo: 23-08-2025/P1M
	//         - Terceiro ciclo: 23-09-2025/P1M
	PaymentReference *PaymentReference `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
	// - AUTO – O campo transactionIdentification não deve ser preenchido.
	TransactionIdentification *TransactionIdentification `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsPostDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsPostDataAuthorisationFlow string

// ResponseRecurringPaymentsPostDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsPostDataDocumentRel string

// ResponseRecurringPaymentsPostDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
// - AUTO - Indica o pagamento de uma recorrência de Pix automático, onde o consentimento foi previamente autorizado pelo pagador e o pagamento é realizado automaticamente pelo Iniciador de Pagamentos sob comando do recebedor.
//
// [Restrição]
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar uma recorrência (valor do campo "/data/paymentReferente" diferente de "zero"), apenas o método AUTO é permitido, ou;
// Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration") e a referência do pagamento indicar o pagamento inicial avulso (valor do campo "/data/paymentReferente" igual a "zero"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsPostDataLocalInstrument string

// ResponseRecurringPixData defines model for ResponseRecurringPixData.
type ResponseRecurringPixData = []struct {
	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento.
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa natural ou jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPixDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]Campo de preenchimento obrigatório caso seja um pagamento de Pix automático e deve ser enviado para critérios de coleta de métricas do ecossistema. Caso essa regra não seja respeitada, a instituição detentora da conta deve retornar um erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	// - O preenchimento deve seguir a seguinte lógica:
	//   - Primeiro Pagamento: Caso se trate do pagamento inicial avulso, especificado no campo “/data/firstPayment”, o valor deste campo deve ser preenchido com a string fixa "zero".
	//   - Pagamentos Recorrentes (Subsequentes): Para todos os pagamentos recorrentes realizados após o pagamento inicial, o campo paymentReference deve ser preenchido com uma string de Intervalo ISO 8601 no formato ```<start>/<duration>```, que representa o ciclo exato ao qual o pagamento se refere.
	//     - O componente ```<start>``` deve indicar a data de início do ciclo específico ao qual o pagamento enviado se refere.
	//     - O componente ```<duration>``` deve corresponder ao código da periodicidade do consentimento (P1W para semanal, P1M para mensal, P3M para trimestral, P6M para semestral e P1Y para anual)
	//     - Exemplos:
	//       - 1: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Semanal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1W
	//         - Segundo ciclo: 30-07-2025/P1W
	//         - Terceiro ciclo: 06-07-2025/P1W
	//       - 2: Data de início do ciclo definido no consentimento: 23/07/25
	//         - Periodicidade definida no consentimento: Mensal
	//         - Preenchimento do paymentReference:
	//         - Primeiro ciclo: 23-07-2025/P1M
	//         - Segundo ciclo: 23-08-2025/P1M
	//         - Terceiro ciclo: 23-09-2025/P1M
	PaymentReference *PaymentReference `json:"paymentReference,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReasonGet `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
	// - AUTO – O campo transactionIdentification não deve ser preenchido.
	TransactionIdentification *TransactionIdentification `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPixDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPixDataDocumentRel string

// ResponseRecurringPixPayment defines model for ResponseRecurringPixPayment.
type ResponseRecurringPixPayment struct {
	Data  ResponseRecurringPixData `json:"data"`
	Links api.Links                `json:"links"`
	Meta  api.Meta                 `json:"meta"`
}

// ResponseRecurringRetryPaymentsIDPost defines model for ResponseRecurringRetryPaymentsIdPost.
type ResponseRecurringRetryPaymentsIDPost struct {
	Data  ResponseRecurringRetryPaymentsPostData `json:"data"`
	Links api.Links                              `json:"links"`
	Meta  api.Meta                               `json:"meta"`
}

// ResponseRecurringRetryPaymentsPostData defines model for ResponseRecurringRetryPaymentsPostData.
type ResponseRecurringRetryPaymentsPostData struct {
	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date string `json:"date"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID OriginalRecurringPaymentID `json:"originalRecurringPaymentId"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`
}

// RiskSignalsConsentEdition Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
// Só estará presente após a primeira edição do consentimento de longa duração.
// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
type RiskSignalsConsentEdition = map[string]any

// RiskSignalsConsents Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
type RiskSignalsConsents = map[string]any

// RiskSignalsPayments Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
type RiskSignalsPayments = map[string]any

// Sweeping defines model for Sweeping.
type Sweeping struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime timeutil.DateTime `json:"startDateTime"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"sweeping"`
}

// SweepingRequest defines model for SweepingRequest.
type SweepingRequest struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime *timeutil.DateTime `json:"startDateTime,omitempty"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"sweeping"`
}

// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
//
// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
// - MANU - O campo transactionIdentification não deve ser preenchido;
// - DICT - O campo transactionIdentification não deve ser preenchido;
// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]);
// - AUTO – O campo transactionIdentification não deve ser preenchido.
type TransactionIdentification = string

// Vrp defines model for Vrp.
type Vrp struct {
	// Vrp Definição da configuração de recorrência para realização de transações de valores variáveis
	Vrp struct {
		// GlobalLimits Limite transacional máximo para pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
		GlobalLimits *struct {
			// QuantityLimit Quantidade máxima de ocorrência  de pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED"
			QuantityLimit *int `json:"quantityLimit,omitempty"`

			// TransactionLimit Valor transacional máximo para pagamentos sob este consentimento, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
			TransactionLimit *string `json:"transactionLimit,omitempty"`
		} `json:"globalLimits,omitempty"`

		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *struct {
			// Day Configurar limite transacional diário determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
			Day *Day `json:"day,omitempty"`

			// Month Configurar limite transacional mensal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Month *Month `json:"month,omitempty"`

			// Week Configurar limite transacional semanal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Week *Week `json:"week,omitempty"`

			// Year Configurar limite transacional anual determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Year *Year `json:"year,omitempty"`
		} `json:"periodicLimits,omitempty"`

		// TransactionLimit Limite máximo de valor permitido para cada transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"vrp"`
}

// Week Configurar limite transacional semanal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Week struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante uma semana.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado semanalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// Year Configurar limite transacional anual determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Year struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um ano.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado por um ano, a partir da data definida no campo `/data/startDateTime`.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
// O recurringPaymentId deve ser diferente do endToEndId.
// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
//
// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
type OriginalRecurringPaymentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// EndDate defines model for endDate.
type EndDate = string

// ParameterOriginalRecurringPaymentId defines model for originalRecurringPaymentId.
type ParameterOriginalRecurringPaymentId = string

// PathOriginalRecurringPaymentID defines model for pathOriginalRecurringPaymentId.
type PathOriginalRecurringPaymentID = string

// PathRecurringConsentID defines model for pathRecurringConsentId.
type PathRecurringConsentID = string

// PathRecurringPaymentID defines model for pathRecurringPaymentId.
type PathRecurringPaymentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// StartDate defines model for startDate.
type StartDate = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200RecurringPaymentsIDPatch defines model for 200RecurringPaymentsIdPatch.
type N200RecurringPaymentsIDPatch = ResponseRecurringPaymentsIDPatch

// N200RecurringPaymentsIDRead defines model for 200RecurringPaymentsIdRead.
type N200RecurringPaymentsIDRead = ResponseRecurringPaymentsIDRead

// N200RecurringPixPaymentRead defines model for 200RecurringPixPaymentRead.
type N200RecurringPixPaymentRead = ResponseRecurringPixPayment

// N201RecurringPaymentsIDPost defines model for 201RecurringPaymentsIdPost.
type N201RecurringPaymentsIDPost = ResponseRecurringPaymentsIDPost

// N201RecurringRetryPaymentsIDPost defines model for 201RecurringRetryPaymentsIdPost.
type N201RecurringRetryPaymentsIDPost = ResponseRecurringRetryPaymentsIDPost

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPaymentsConsents defines model for BadRequestPaymentsConsents.
type BadRequestPaymentsConsents = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// RecurringConsentsConsentID defines model for RecurringConsentsConsentId.
type RecurringConsentsConsentID = ResponseRecurringConsent

// RecurringConsentsConsentIDPatch defines model for RecurringConsentsConsentIdPatch.
type RecurringConsentsConsentIDPatch = ResponseRecurringConsentPatch

// RecurringConsentsPost defines model for RecurringConsentsPost.
type RecurringConsentsPost = ResponsePostRecurringConsent

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// AutomaticPaymentsGetPixRecurringPaymentsParams defines parameters for AutomaticPaymentsGetPixRecurringPayments.
type AutomaticPaymentsGetPixRecurringPaymentsParams struct {
	// RecurringConsentID O `recurringConsentId` é o identificador único do consentimento de longa duração e deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independe da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição detentora (bancoex).
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	RecurringConsentID RecurringConsentID `form:"recurringConsentId" json:"recurringConsentId"`

	// StartDate Data inicial de corte da ocorrência do pagamento ligada ao consentimento de longa duração.
	StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Data final de corte para recuperação da ocorrência do pagamento ligada ao consentimento de longa duração.
	EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`

	// ParameterOriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// Código ou identificador único criado pela instituição detentora da conta para representar a iniciação de pagamento.
	// Caso informado, devem ser retornados todos os pagamentos associados ao identificador informado, sendo eles o pagamento original (dono do identificador) e as novas tentativas que enviaram o identificador na sua requisição, indicando que representam nova tentativa.
	ParameterOriginalRecurringPaymentID *ParameterOriginalRecurringPaymentId `form:"originalRecurringPaymentId,omitempty" json:"originalRecurringPaymentId,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPostPixRecurringPaymentsParams defines parameters for AutomaticPaymentsPostPixRecurringPayments.
type AutomaticPaymentsPostPixRecurringPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostPixRecurringPaymentsRetryParams defines parameters for AutomaticPaymentsPostPixRecurringPaymentsRetry.
type AutomaticPaymentsPostPixRecurringPaymentsRetryParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsGetPixRecurringPaymentsPaymentID.
type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsParams defines parameters for AutomaticPaymentsPostRecurringConsents.
type AutomaticPaymentsPostRecurringConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsGetRecurringConsentsConsentID.
type AutomaticPaymentsGetRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsPatchRecurringConsentsConsentID.
type AutomaticPaymentsPatchRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody defines body for AutomaticPaymentsPostPixRecurringPayments for application/json ContentType.
type AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody = CreateRecurringPixPayment

// AutomaticPaymentsPostPixRecurringPaymentsRetryJSONRequestBody defines body for AutomaticPaymentsPostPixRecurringPaymentsRetry for application/json ContentType.
type AutomaticPaymentsPostPixRecurringPaymentsRetryJSONRequestBody = CreateRecurringRetryPixPayment

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody defines body for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID for application/json ContentType.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// AutomaticPaymentsPostRecurringConsentsJSONRequestBody defines body for AutomaticPaymentsPostRecurringConsents for application/json ContentType.
type AutomaticPaymentsPostRecurringConsentsJSONRequestBody = CreateRecurringConsent

// AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody defines body for AutomaticPaymentsPatchRecurringConsentsConsentID for application/json ContentType.
type AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody = PatchRecurringConsent

// AsConsentEdition returns the union data inside the PatchRecurringConsent_Data as a ConsentEdition
func (t PatchRecurringConsent_Data) AsConsentEdition() (ConsentEdition, error) {
	var body ConsentEdition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentEdition overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentEdition
func (t *PatchRecurringConsent_Data) FromConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentEdition performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentEdition
func (t *PatchRecurringConsent_Data) MergeConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRevocation returns the union data inside the PatchRecurringConsent_Data as a ConsentRevocation
func (t PatchRecurringConsent_Data) AsConsentRevocation() (ConsentRevocation, error) {
	var body ConsentRevocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRevocation overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) FromConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRevocation performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) MergeConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRejection returns the union data inside the PatchRecurringConsent_Data as a ConsentRejection
func (t PatchRecurringConsent_Data) AsConsentRejection() (ConsentRejection, error) {
	var body ConsentRejection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRejection overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRejection
func (t *PatchRecurringConsent_Data) FromConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRejection performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRejection
func (t *PatchRecurringConsent_Data) MergeConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchRecurringConsent_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchRecurringConsent_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams)
	// Cria nova tentativa de pagamento para o Pix Automático.
	// (POST /pix/recurring-payments/{originalRecurringPaymentId}/retry)
	AutomaticPaymentsPostPixRecurringPaymentsRetry(w http.ResponseWriter, r *http.Request, originalRecurringPaymentID PathOriginalRecurringPaymentID, params AutomaticPaymentsPostPixRecurringPaymentsRetryParams)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsParams

	// ------------- Required query parameter "recurringConsentId" -------------

	if paramValue := r.URL.Query().Get("recurringConsentId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "recurringConsentId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "recurringConsentId", r.URL.Query(), &params.RecurringConsentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
		return
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
		return
	}

	// ------------- Optional query parameter "originalRecurringPaymentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "originalRecurringPaymentId", r.URL.Query(), &params.ParameterOriginalRecurringPaymentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "recurring-consent:recurringConsentId", "recurring-payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "recurring-payments", "enrollment:enrollmentId", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostPixRecurringPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostPixRecurringPaymentsRetry operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPaymentsRetry(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "originalRecurringPaymentId" -------------
	var originalRecurringPaymentID PathOriginalRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "originalRecurringPaymentId", r.PathValue("originalRecurringPaymentId"), &originalRecurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostPixRecurringPaymentsRetryParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostPixRecurringPaymentsRetry(w, r, originalRecurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostRecurringConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostRecurringConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsGetPixRecurringPayments)
	m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsPostPixRecurringPayments)
	m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments/{originalRecurringPaymentId}/retry", wrapper.AutomaticPaymentsPostPixRecurringPaymentsRetry)
	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)
	m.HandleFunc("POST "+options.BaseURL+"/recurring-consents", wrapper.AutomaticPaymentsPostRecurringConsents)
	m.HandleFunc("GET "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)

	return m
}

type N200RecurringPaymentsIDPatchJSONResponse ResponseRecurringPaymentsIDPatch

type N200RecurringPaymentsIDReadJSONResponse ResponseRecurringPaymentsIDRead

type N200RecurringPixPaymentReadJSONResponse ResponseRecurringPixPayment

type N201RecurringPaymentsIDPostJSONResponse ResponseRecurringPaymentsIDPost

type N201RecurringRetryPaymentsIDPostJSONResponse ResponseRecurringRetryPaymentsIDPost

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type RecurringConsentsConsentIDJSONResponse ResponseRecurringConsent

type RecurringConsentsConsentIDPatchJSONResponse ResponseRecurringConsentPatch

type RecurringConsentsPostJSONResponse ResponsePostRecurringConsent

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixRecurringPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixRetryRecurringPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type AutomaticPaymentsGetPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsGetPixRecurringPaymentsParams
}

type AutomaticPaymentsGetPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPayments200JSONResponse struct {
	N200RecurringPixPaymentReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPayments200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsPostPixRecurringPaymentsParams
	Body   *AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
}

type AutomaticPaymentsPostPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPayments201JSONResponse struct {
	N201RecurringPaymentsIDPostJSONResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments201JSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetryRequestObject struct {
	OriginalRecurringPaymentID PathOriginalRecurringPaymentID `json:"originalRecurringPaymentId"`
	Params                     AutomaticPaymentsPostPixRecurringPaymentsRetryParams
	Body                       *AutomaticPaymentsPostPixRecurringPaymentsRetryJSONRequestBody
}

type AutomaticPaymentsPostPixRecurringPaymentsRetryResponseObject interface {
	VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry201JSONResponse struct {
	N201RecurringRetryPaymentsIDPostJSONResponse
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry201JSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry422ApplicationJwtResponse struct {
	UnprocessableEntityPixRetryRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetry529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetry529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsRetrydefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsRetrydefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams
	Body               *AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostRecurringConsentsRequestObject struct {
	Params AutomaticPaymentsPostRecurringConsentsParams
	Body   *AutomaticPaymentsPostRecurringConsentsJSONRequestBody
}

type AutomaticPaymentsPostRecurringConsentsResponseObject interface {
	VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostRecurringConsents201JSONResponse struct {
	RecurringConsentsPostJSONResponse
}

func (response AutomaticPaymentsPostRecurringConsents201JSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse struct {
	UnprocessableConsentsApplicationJwtResponse
}

func (response AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsGetRecurringConsentsConsentIDParams
}

type AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDJSONResponse
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsPatchRecurringConsentsConsentIDParams
	Body               *AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error)
	// Cria nova tentativa de pagamento para o Pix Automático.
	// (POST /pix/recurring-payments/{originalRecurringPaymentId}/retry)
	AutomaticPaymentsPostPixRecurringPaymentsRetry(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRetryRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsRetryResponseObject, error)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(ctx context.Context, request AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPayments(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams) {
	var request AutomaticPaymentsPostPixRecurringPaymentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostPixRecurringPayments(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostPixRecurringPaymentsRetry operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPaymentsRetry(w http.ResponseWriter, r *http.Request, originalRecurringPaymentID PathOriginalRecurringPaymentID, params AutomaticPaymentsPostPixRecurringPaymentsRetryParams) {
	var request AutomaticPaymentsPostPixRecurringPaymentsRetryRequestObject

	request.OriginalRecurringPaymentID = originalRecurringPaymentID
	request.Params = params

	var body AutomaticPaymentsPostPixRecurringPaymentsRetryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostPixRecurringPaymentsRetry(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRetryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPaymentsRetry")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsRetryResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsRetryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	var body AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (sh *strictHandler) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams) {
	var request AutomaticPaymentsPostRecurringConsentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostRecurringConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostRecurringConsents(ctx, request.(AutomaticPaymentsPostRecurringConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostRecurringConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostRecurringConsentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostRecurringConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	var body AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y93W8bR9Y3+K/Uw5kHQ2ZIiqTkLxnBPDRJJ8xriRyScmZi+pVL3SWqnO4upqpbkRMb",
	"8O1eL7DYixlg8jwXA7+ALxZ538VibhZY/if+SxZ1qqq/m6QsyXaSNgYTkeyuz1OnzsfvnPNjxWLuknnE",
	"80Vl/8fKEnPsEp9w+NQN/DPG6Q/Yp8yTX9hEWJwu1cdKD5+Q1T+xc8bQl7PZGC2xzVf/xZpoTLhLfYK+",
	"CwjCAlmc2MSzKKYCCfIcu+iUcY9Y1MYC2WRJPJt4NkM2Qz5dMmQTxIkVcMGQYA61qI9tVqlXqOz0jGCb",
	"8Eq94mGXVPZTY6xXOPkuoJzYlX2fB6ReEdYZcbEcvIsvHhFv4Z9V9jutvbv1iks980W7Xlli3ydcdvFk",
	"Pv9+Pv96PhdPP6vUK/6LpexI+Jx6i8qrV/XKX4Y2cZfMJ5714r+RF1usDOGCedihP2CbNdHQJp5PT6mF",
	"bcbldM00V/9c/RdD5MJyAkHPGZLbgUSwZNzHHGFEVb+r/yFXs1m0JBcNGo2v8S15se2y7LXSi5KdO/Hs",
	"PvZJds597GN0Sj3syBlZjPtEjV/u5ZJwPTkbI2YxztUc5J4v8QK7xPMZcugC2xhhhizmCblG6nubIId5",
	"C4zsQDcTzv27gPAX0dTN6Aom2E5NsBXf9v9enc/tH/de1RrV9pNWo/P0ZetPT9qNe09rjeruk1b76csn",
	"7c7TJ63GveiX3+fSB+N0IRdiIqlYfjvGL+RMhnYeqbhLBifFYp6/euMihqzVzzZdMMQCxOSex4kFI594",
	"PvbpOUamH7lA0SrKtk4l7QVNhOZeL2os2dTqXx61GLI4xXIXiIMR9YRP/YDqrSKyK8ax7FWODpsNXXIi",
	"t0fRpEctajY3Ng7VORYMUe+UcRfbrI5sck5cJAhHnPiMe9hmAvlM/j8T0bsCYSGYReFnnF6DWHsCGAdx",
	"iEBxQgoXpmozDxhLooUaAr7ksXMsouUUsHLEO6eSCWZW3pMnUU7+u4AKtUJ1RD2bWliOQb4bLYwLjUdt",
	"N+deAcWuoZU4EZML7C4d+cLsL8vJwdG9oz/PJqODr8++edy5mB61Hx7hH76aHvSdSj1J8K1iPvffn+DG",
	"D93GN5Kioz/n88bTH1v1e/de5RB3vXLRWLCGHvvY3Baj4km8gh7PRlc8Elc6BR/1CJh9l6uw5bYXM+tP",
	"hAz0poaD7yl2nbeZI/SMZx57hlZvMpuqN8PezP0RAUbCVz8BKwlcdDQ5RA105FHJGdCECBZwi6BD7BLY",
	"hCN4pC5blk/I90+pR20mj/WTycPe3fZe+2n1zPeXYn9nx2fMEU1K/NMm44udM991dvipJR+qyaHLHtN9",
	"zT1zrRMuxzIZogZQ4eoNwj6nJ8HqrS0lmhPE4FfYVYLmlYB78woislVJHWKJLQIzImJJrNXbU2oxOXQX",
	"SM0nXkhpsnkGj849KVnJJmhauDCylBRCqJD0TBCRnEtJXpKyHWaBcKLuVmDczBPUJhx4G0Zq41HAvf0T",
	"7FmMXOz32v3+7m67sytHJoUW4i4dLbLkbrlPXCb2514DsWie1YB7NfVdcuDhBSD5f7QsdvEJreqR1Zp5",
	"7cXWEskfOFBa1HA1nE8NFmCoLpnVP1f/iwjkStnVJj52zrCUWgU74QQBSxA+D8INCdsTsatOPhQ4Prx4",
	"aXJrFnGQ7BJvLf3eur2GG8g9XscRdtuvYr9Xa3+sz+eN5v7n/3H/98f/9tkf/n0+3/nT757+cQuuseYK",
	"GKbZPYtJkHEOu2FttuOqN8specklSy5ZcskPxSVT8vUvkk0KH3N/jZqtBM6Yon2zWnU0nI+rV1/0AuEz",
	"l/AjQXh3QTw/5+YAjQwxFAjCG1g+pBlAIILVT5wyFPhUHuM19hNL99OIGqm8z4Wx0ZJ08RAvaTfwz9Zs",
	"NnHTE3DYggVKXVn9y/Gpi9E5+QF4H9O0YTPeRJNQS7Gx3G5sMQ4Xh+SR8oDd6exuPmDyoVpzoDjXPpoG",
	"Xh21W2hKlqjTat9B7Xv7e7v7u210NOsVL+kpXtIGDvyzhr2GkDr3EospP8YJ6YB5L2cBefk1sV/OzoKX",
	"Dzl9OcX+y2ng1epIklnnFap+hb2XD8nJywPMX3aX/OUBfvHyq8B7+VXgvOwGi5dTsnw5svyXh+z8ZZ9Y",
	"NaToU7+/n/gPqn5xMHt5NOsVkaTcQEOWw2XXtjkRIu+Cl7cIJ6t/MjQcywMa7qYgiAifnhOOsB9gx4W7",
	"x2ELrPcqvqcbFjgkXLpsYD2WmyPcoecTji05xTyhRooTR8M+UNpeu9PZSGnyoRoKhJ44kxf1sK+5HCeO",
	"kWs8nxMwxBDhI/mXWErO1kTKcmATtCCREES8c8oQO+F0gf3Vz3LJtaavFxWjquVQ4vk1JI+ZIAE6xw6I",
	"BecE7qZ3r/8mb0Z5rbF3r/+u3o/dqYLwc8JryGPIiky/th6a8LEcmmDIkyMCEYQTi5xIyYoFkgBOGY++",
	"ClzdP/XOVz851GZ1FO8OhiVnCEKd3nka7UWD2rAqPuPe6qeGA+KbGYmmKDBLCx/7gUAWswnaa7WaqBtf",
	"FOgGW9jHHDE9onCMdmxAzU1UmRzblgYO+87dU2uP3Grs3rFwY8/Guw1sn3Ya905adzsnp/c6nbutSr0C",
	"8odf2a8EATQdo/Dddfe3vG9w47TbePj0x7uvGvGPe5f52O7kiv0g9yuyBG7QabXSeo8Y2mPsW2fyZ4tJ",
	"iRWuM7xcOtQCd8bOc6H8LtH6/J6T08p+5Xc7kd9mR/0qdia6w8KOYFjpG8ZmUgortGGhMb1A7MSn8jlJ",
	"OyKwiBCsWXlVL5jVhGD7Q0wK+rnZOdEL3d0Nzyns5ybm084jCCb8D0J4sp8bndOE+PzFh5pYXmfXPrsH",
	"2J6oy23DRO4j6wxzQfzPA/+0cffy8xpwznjeBLoJPwc6ZRS52FFuF1xHzKU+BZ0XVHaficT9KurqkvOk",
	"GvLCYdiW1xz2OT5fvYF1id7zMDqaPErN26yw1tnEb2Yd5DI8ZPyE2jbxPtqsR8hn3xIP+cRFRFhsKSVQ",
	"EMF8EFgCF6Mlc1Zvfalq2VJGWgQce6t/Yliic8ocbGM5mS+wT77HL2bUJSzwv6b+Wde2qewHO2POloT7",
	"lHwy++uZTcY+8WwKQo4xgvhEypYOBWQDET4+IQ6xqM3kNEES9rAzBUFQdffRdg92Su4SIpwzSX0LtQtS",
	"auuOh3ILPYZcanEmpOhKV/+EWRwQ/4zZh8zvOg77ntgfkQDBGuRSm3Hw9MljIxkkiKLGVCf5ZuAid/XG",
	"Z7YRrhVYQu2KnIllkaWPTxzyEWksCe+Qg6DeGZghY9qCGimy6SnhoAGCa5wu1UXirt7aFKMlIGvg1oBz",
	"KBt7HmhrjoWlkE04EfFWCDqaPWzc1evxkAXex9zXLLBH7Ru5oMInQJnmDFKpCLhgvYDdTHsbRcKefjP3",
	"ve4idy4nzyU7VP3KK0AYYIK2hoLaGje4gdG3UCLAgc/c1U8+tZQUUDzdG9YadD+FKsMHn/iNiHSy0U9h",
	"m6fUJ0MxOidcygcflecKfbOtflKWewtzTsAKRVDCAydPpzzIAoSgJaNCX5rUW4BNw1yT7uqnC+rCCszG",
	"U7Rw2Al26sgj8qy7TLvwXtUrRx7WOL6PuAK9hOkGB3IE1NJzxoHcYrIT2mQkr1JiUviVmsmSM7iqThyy",
	"jfz6vf+eU+hxgn2yhnSnZBFQLimWcSr5qKZYbRQmIHSqV0JsXnc8rCMqBb92c1eKPcfKpnNsZAcp7AUC",
	"ieCE+sQTmSkPPJ/6LzayqMvMeq/TSUw8wyCuZ/JAlMSzl4zK9cyfl1TUt5qaNmTB1o/D0w+X21LDYy3s",
	"WcRRv8BqBK6L+QsAVm1+oV45x04AYo0U87io7D+Rg7IBmdX9onswOJyNjg+7o+PxYHIwnA2Oe93D3uCR",
	"+qEiF8zH1IGjH/Endf61aKUNhN8FJDkQlhhKs1Kv+NQHq92Vm3r1tF5xiQ9EoU28fewTqUBU9iudVqfd",
	"aN1qdNqz1t393dZ+q/WN3P1X9fekJXWIMoaLGH7tOkiLbUFX6TFcjsSm2LGlliaCU2rJQZEkReX8vpaA",
	"pt1H/dHx8HB69HDYGw4OZ4M4wXQ1Fk6ACsQ8bGO9q0yIgCIBvUV9GdAcuM95HKoZp53sGD8SOeTtxhaC",
	"vbwDTwig25V5wMVCL8vqf9rKk2B2HlTLc3mNrP6BnNXPC61Je2Sx+tmiTMRc8QA+THTVXEdGPn9xNVpS",
	"l/csxMUOLixiy+stQVGP1BVvkziClphH1xLXoyGwo9ngcNadDR93p8eDv/QG/WE/xZWcvC6AlBz6XUBt",
	"HB6viOkYDUk+SRyGMOfYe642x4wuTnTrp/GRuJHPX/wSaDCcJ5DN9mdp/8fKMmH7MSTyY0WKHiL7gCKc",
	"DFBY4XpBBpdNAAs+p0Lb0yxOo6CDIoEcoDZZbrePBspZJtnce7I22fLj7qPR5LjbGx50jxXZ76PH2KFy",
	"NUnoVgscn+MlFgKjXBMTeuKlET1VNTQWyPsTO7UdL6T1p2pM+iRwFA4vnL3PsSfCa0seE+UAJbExDw8f",
	"dx8N+6N9NNKjBGi8UdhXb5ARhKE3hv48QT0GNm8Nz4fG9FkfDybDUX90rNo2x30fdaOxGPvbkmk61aO2",
	"sVIxzGLpGCUOwTTgck2oX4mDnjOCPx91D2fDfrc/eL9hYPRdgD3JYWySGAteOxYMY+mNDqeDw9lQyWbR",
	"EvcSr0U6RpWEkhOE1tRyWhkPDvuSZI+7R7PRZPhNt9fNtKhirHzQaiBaKiQFFxAkSwcLhJ3VPwF+VdVd",
	"vnv9t3F3Mht2Hz3663G31xuMZ4P+u9d/V6MYdyfdg8FsomTM4eHD0eSgKyczxnz1n3JV9EomCSJ6LZp+",
	"7I1w7vBwquXDeHM47YZXmriPdTdGAu4PHw8mX8AKJRZuH2k3Tfz6sOk54QslxcGP5pHExkIP/cGs++jL",
	"wXHUUzShPoDgSLLt5NSi1yaD3tG02x8d9wfyShxNunJFzFta0WZbzjZsbDoe5jbjMTSlwicuNDGOQm6G",
	"nvCx56/+0yNMoOp0PFT7PJjIveoPDsaj2eCwN+zuI8nfU8FosZOmzvhsNOs+Sq547MDpa9dnPnbC45pt",
	"Y9I9nEp6LmzH8CYbJ05wxFB5xFFtYjgI4/Gn42PPkUlkJzcmiciuH44m3ePxpPuN0dR0p2eMK4QQgL34",
	"6i1TwIusyyJSpvCCeHY4ACdCfiZINpxlgssvo1P4xGMuObZZVdSOLewu5R9P5Q1EOBifYeo4FeSUNHR5",
	"2tZt0x+Iq1EnORFaUZwO0pqhiGYEfXlr+1HIT+IFbmX/Sb7akr2Dwy/N9Cv1ytqLKvt7zjVSqVfy+Xvm",
	"hzyWXalXCjhq4pdYm9mHNrG8Sr1SzLUSLWR5Uv7P0/GwUq9kWES0XpuZQebZDYc+ej5fgcg7TrGJZ2m/",
	"8rQewx3lklAmDM5oKRnEZkztT0jPTDnjkijMKNSTE+23KuXRUh4t5dFSHi3l0Q8qjxbIkXBYSMQElQcr",
	"f/1LybWUXN9Dcg0Fj+s1qmeynWwL7g9No2nRZrZ66wcOS8aIabEmFF/qhRKOvq1L+aaUb0r5ppRvSvnm",
	"F2lvi7nL0mJS6vznyiNrvW1rRIrQGYlOYS8YWnL8A9soGhwmr19DETh19eZ5npNX6K1blwqPiwKcnijf",
	"lblVQ8vB0/A1dvKcWAAMcPHFUPm/VBik/hDl4ZIXzgt4UvskIRuP+XFJmwfy+3r0dYO68mJWqd3kRCoL",
	"6p8FJ02LuTtOQL99cb7jMuvbxgn2vt2hGsW8g5fUxDBF89BOuryBXxpVcV0ewPhJLEK6xE/lVpCUBCAF",
	"+H+stWNFoPpyS0i9UUSn8pNC+q54Y5p4MXqOPcVcNKo8lBkLOfZIxIRcEbF47dxlJ8QmFnERVp7fMJWc",
	"lNVUdD9ef4l0nUXgKkybzsYF0nMqoMGgczl2Y2NI2mC3wh5tsaRFZs8iK2nCirfVILa26pVk9gmRWbjH",
	"1wBbu34tqSSV3wCpfGBpYPfXIQ0UoJo+OTTQ9gL49aiXH0Kxu1bt52H30ZdSyn446Q6ms8nR7GjSjZpD",
	"DRSFoGEwkWEVC3vKMRE+D/yAqxxN3MMKKxt2E3DswfEzIDWtJqbtPKXR8xdr9FRWhtjSZe1zdtRjNlsc",
	"wssoEWfgxo0JBOKqu1GITUIwzfNSFzrsL+mL3+A5fx+H9fpTtt6jrcABUWsJ2XjtYD6wp7vktSWvLXnt",
	"r4jX/hbdWSUT+2UzsU/HKv0Rz2tpA79erTcbpfr+iq6RYJPsY6159WAcf0ALqfLv6bSbgTcaYh30h71u",
	"Qq592H006x4cT4eH3eH0ePRgMvyiOxtNhqPp8fhRd9YF1nMlS23+UD+gGIpQljMXW+5Ghh9nMjAnxI00",
	"BiBldovx9Tns6tHBoD+vSHFmXpkMvhr0ZvJzTdn6Mgu0j0ZVUUNG/Ihl05Cf4PATm6ac6yrNLrHhOaGY",
	"fC5BZJzZ6sLO81zjJWfnkC5QIJJegXAIIG2FtkhIcpngkSmyA3hAXKIJG8pfcy73HYybWCBOFhzKCoVh",
	"bDoU14eKH8aIaK6lzcQNlk5BPUzTlkct6S0d7GO4ZxNpPWN2SS0rCCT3IMDKCwuAhl+zdXU70+qnLNt9",
	"ypyhWbKGkjX8ullD6XW5jPwJkj32qZUVI3H8p7T4dEq9KP2LxbxTughipTY4ieWVVzjHWJWuSJsQlXpG",
	"ePV8ji2/T058lQ5vXSh8L/n0q3r4/hb1QVR+Jo59lkImJWjxL4NWq7V7t337dqfVvte607ndvnXr3ovb",
	"z2+n8gbf2q4EyI/t+u6t/CpZp5SHWSw3zfxh/Fl494LYXZcFeentH4MOeEovVMY3dqLSLtaRhYVUPwnx",
	"rDPIGB2VqNJ54tIpqmL7aPDlREDToh4mYhPBc8k/BcIIO35Ug0Wr3Rid00VUdCAJ2kNzb+49mUgNXlHY",
	"UzS4sJxAISP1lQsZu9+9/tuOjX28E6/WoAgRklSEBLzj4gvqBu5jzCk+cYhapnev/55iO+2W/Ndsd1J1",
	"sJLp5feS2eWhTkG73r79aj5vqvTvtVru9sIhPcdOwXmS67IknDKbWhq3agyeCStXLj4Y8NGDg+5h95H8",
	"82BwOFV/dQ+P1B/TwcFgOpuoD7PJMPwUD4RULVTqFdVApV6B9yv1Svh6pV6J3k4FwYWvZ+cuwJOr0hUS",
	"u7ACg4CaLqGxMgF7VnnEiTy7p/gHwuN2l4SltEoufI5timuxqjTRVR7DbMMVHhqSx/SiGSeIU+wIEk7m",
	"hDGHYE+z+yw9FR07k84sNinGb+IQnmNOVz+dEypu5BDFOEzR0bm5s+NSb/sVDwsQJeXEkHzk8kwTtTHk",
	"gkJlHMisS3mUTT/cPYDPJ6pN2vi7gDg4hdauhutaxHVqdUQcEsnRptYS9U7l8ecIM7Skgm2ex9w7TIDg",
	"IyJCHhbxgemcg+fhRVBXNQSeY1X96GrEIBf0UEnOcco1K/jW0+n8QqI30QiFYS03zIo5gUynFpkW18yJ",
	"6qAgjOSqGGRIOHrqrd6CPsCQRS0nNUW7sDbp6h8JAamJZhz7uCHAmBy4YUkouTHQccjEInFcEdvkYa+x",
	"u7t7rw7JlCGpNIvcXDZBDzgWq7cOxah6NOs1dmtNNEqA3VVJIHweOAJ0W8vBXAPQmUpiGZdKMtd1XSdi",
	"Vfkf1bUvNTUh1Jql97XT6uyq5EfxKgy6uMt1V/+pJ6RsOeLAp07zAcc/UEdXJrqqwG1aBeUhEGR0TrjN",
	"8akP7gFFVac4cHxTtaLo2svjRur8Sj3UlB8KL3/tQF3y1ZuGUZpR1TojUI4WyAQ7NVN/NlGENClFRCSq",
	"b6LovgU9HSsviR0o1SrcSjWb9N2Y0aBCaTwm/9TTUn5WPshby9xjm1VqUkOI1Ji1+k8sd36pBpVqUKkG",
	"lWpQqQaValCpBpVqUKkGlWpQqQZtrQZdnwpw/eL+g0BQjwihEh/nFJ80zKW6JEIwjJ4HfPVWXsk18DsR",
	"Tw1bEqmutZnJ+TCMF0OMMG/N7F001nxKIzjjtSYFSRRuvUxHUBYycFHvcPxVzjwUKSa1DZtZQX5UTVTo",
	"Wa1QesEOV/9yiSp1ZBqBAxe9p8bKTnXtYYbkDBzMUXpkzSTnS/xLsb+9TFHGbuMbqKoIZ+HHzqsCdpcj",
	"dM7o8gaGLxc/OejUmGHAe4XF3yOCTu2AmsXGYxDuaN4p0N74gSqpld30k494SlB5TMpj8mkcE4sTm/pp",
	"rOX6Qj/xZCSRnlY1TdXgFkCffTZROhhIUDOpwJ4SLQYJgCw7VKU32f/sM3ij3URj+azWAYVZ19PVW0Et",
	"vONhP+DY2UdzDzVQXxXhJdTHHOElkVJw4KoKLVrRe3Efkfvq6RHqjR9GaIyogDFDLhEubPszJRA7bLEg",
	"9pEgfMcs3U5y5Z+pGXYKxhvSgR4piMtnq59Ce6Z8KZa6RxKZTzyRN+yqqKnTmxq6ghdxhGH4GHFMf5Bz",
	"gGfD9EhG89MzS/K8DbNL7l8KIW22rIG6yZVPaPR52xCdrZzNAJk4RlOZg5XDsFRB5TTNDlyla4NpBRrR",
	"1BN1FvUvR+qCrrx0iILIm6NtG7uynVAq0dzL9hAOM9uH1Cs4/gEMZgzYBwScQ7en2POxoLigr5RUfYC5",
	"xVDX85lnxH6axgq2O62khC1ZDG78sHrdWP0fq/+zsfq/V/9PY/X/1pv/sT8PWq3O7c/+eCz/2LXg/0m1",
	"9m9/2pnP5/Pf//t8bv8BNZ7+saDIexYktA4XRC6WVKmXUamI/ML+UrGJ1fdP2kVgdW1CLzBHWhs28Rno",
	"KEel0q0ValZPjGoVlWGX70nJ/VvCo2LsNrPCguzy8ZpUxdwlV1aWrPtCjvcH5hF0NOtJlQy+0NCzWp4Q",
	"AJXQiRBEH9uoKLo+0XWUvvhTtc/lQlEbCqBjRC4kVzEhZhz/wKLoBxMZRj3ZAneph212H7HgPoxLjcR0",
	"GhuSoew61MlU6n4d9eVKyKuhjxiyFSknAs5IUlfVp2P1D4E6u/u37u3fugdKay1Hh8zWEUlpkw25rGmw",
	"7FU1zFn1T/vyp/ncftl50mp3dp/W9tV3nd29W/L7zOdvtlZLQ/K/Zt9cdHVtIdBqhngTSp+WGGwCNJSS",
	"ZzUCNIZPTcI2s3YHcmERP8zuZ7hu2AC5sJxAAOw1Y+oM5ZsdeU+8e/33jy7zbpTlabjMhWJwit0nHVBg",
	"GWvfoNh72RmYEJ3xw5gIWnyJXEZ8zTde5mTA0MxL+MDoUNaRyWKlYYVxBiedDUKb8uCRZoaKPo4T9ZP3",
	"T2S5g7lerumiYynzfSKe2gzEkXe0uu6Uof1+eM2FcmA9iiRMjy0u0IWG+/OkByKUtueVbX2VeZ6OeaX5",
	"QR0uuQcwe9Co+HZKFx52xMZSnNGjKSNMxmwaKp+Zs528OOWSLZVZuplq8xrg5FHjMELdwYTIgeTajnj8",
	"p8sXxZWvx+6+xKECf17mkHOCdSnfDQiJxMAn6i1YdPkVsR/kGLq6PuMQDcI8oU4KxCsni6dFQ044kYeH",
	"w96w21dJN46mR93JUBeU0Kk4Ej7jxNM5V5Ma40PO3DwG7kmlyYPgZ2pRFjRELLaZpdZ17jVQ1J0Om1Fj",
	"Kp5AwbDjiUXW22diy5yaT91sYd4lpmI+cnRYAVXAIfQnG8VjS0HNW6hA7+zWmICo5FzCb7ebCi0YcQGl",
	"5Xj646QPpZMRQy7z6blOShHbsRx80JpkVpKVR+ge02ScCLJpe4sC7gEmMTgYj44HfxkPJ93+KJ7BWP4q",
	"1204kz9oKtfhb7Pu9Hg0GX4xODjuD6az4eHoePjFUXc4DX9PhMWFqQMArnEk6WrYg6yyUWrgxC6mM+zk",
	"jb5SrxQPvlKvZMaukvsUDt38nD/ySr1SMPAkpRU9dKkAZpW6OE03iZNuyCBj7AopeEcdvR1JTs/eO5Xz",
	"/SLi2UdP+oliyeg7eV5VrgYQjVO5Gs4pPqEOQB5TuRme3l9PiekYQ7CnsABhkFmVqSTCOQRaipHCB3dX",
	"PzUcdj+XlhP5EGFpISwwnaE7xYDubzoC+ygv0cnqDaILuUCrfxhrF0jlLB0KGeY7gVmEEt39DSersFcw",
	"6i0ZeiKwgzllO9Q7lz1DqzvxjDw7LJCK6NPLjKiA3NE+CvXusGy6IlZDYibRd0KzSj0bKlT3M0GEl9+4",
	"q8QV5wcPrgkaDG+Kcxbp0GnhJv7b+4hT52yBi+SpnHuyeVX56px9S+y4dAVf5AlXfw6IawQWlBaqUmPP",
	"yiyxu2YL8eXK8hfM4iri17q5fBj5y2xEcjofQ/p6PPpvWeFLfbnNNPSB2HCkIjJ8D9Er3K3rE73CJpvq",
	"onk8+kLeM5NBb/Bg0B9NEt/GqDslpaUWMtkGSDTJJjIV/zLLnmniWoSQiN7XSCFmLxNiSPNqckh6ARI3",
	"uAE4wviA7SSsS7n3eHaNUkKB8cht2agyYXzQayYVSrDNaTBgY5uck1SYQBONmR25WbU7UPtrjZ0wcWWb",
	"ZdeJExjkTVC4OhGahCID/byCSPh10jE7rzQ/rol63bq8LzKjquAY7far2u9fqk9poEbt5kzWm2YUM1HX",
	"FWDj6TWBMeo37aDetEdjKXNgvmTozwHmRLj4YzmL46sHi1LfAOFK1srQ9172BMgj9H6iY449uzgDNjD5",
	"c2oH2Mkx/tvKHokdzWryD2Pf7G0Mvq19yGn1TbMTlT6TI+wsAhfHpvBfDGGbgoLjZOo9JSED1DtL8uv0",
	"SW1dJrNQFjm3TmhOoVHTkKO18nb4INzPkrN3LSvfv6F3Wy6i3PHVG1fuZIohRAALApkCiWucBTpSoKFc",
	"8BgNZ2PkE7lsFnOIEgTz6cfHebcA+Myx0Jh/cG6YqmUqDiWX8qLb3iPCJ/r2qGuvfANNiUmQqscEwQLD",
	"2bieRzlLTiwqMF/9pH0UPBaVtV5FVGtxAMAoQUI8EYgkhd3J+1KFgF2ioxzZE6s9ngHdraeQgRe43ejx",
	"MJ8gRCEtT7Y7fypEZjgdP0DVTNhgfoGqBxwL6hDKmagpEuI+tegSa6FgOh6iauzVmJOMxmtb1ZBgbhin",
	"46mbOpMpCBAGt+/cTZ7auwnnz918GOTdfDcwFSLIwwgYAd/GqGui9ohLhdC1MIxhxUX26u2CKkKpho+u",
	"3gARL4lnG7lQe1wxwlKVIp6tKR5LRV3j5uoQBbP614lDLYaIixZE3oMEHorFUsCBk5QSBYJZfPVG8og6",
	"mnseQ+SCcEsHahAkHwOJTajCBjF3Yj0KyfFsdTrd1c/nBHBZEGxHAa2Aa5eDtJvQIRWi4RMBNqeIV+yj",
	"XrfXQ1VlwOoPxqPpcDY67h4/Hk5n3RoiaPr4i6n5fTw6GncPe90MLKZ9585eBlJaHJGqY1H38onBC9yT",
	"PGIoPiueESkNRajwRH0X5bJDAGMpmkHnhIdHrCqgviRB5IIKn/Ka3ElB0BkLzgnXLlbsnGIvcFdvOLUA",
	"jqQlORidxbxzyTxM+cdW0fG518qChDauWae1DS5X8ppwIesJDpYn2PyGcXAoC4QrwMGlZwvwgDwsKqrO",
	"I+zFvBKz+6rQJo+MTjf55OeVWiqaSu1RQQY9fbWWILabB7Gtu/4fRU9+dCwQkFll/8n6EWdSMbyqr39h",
	"+j0hS+ottn3+MV9WXl0OTRFbq+sGU6T4ZGxn42pA4dZtDm2Qmt8WquOYXhTWVDLa4wZNJL85yaWvYVT9",
	"rTRYO1sklhTGYOTB084YpwKW9qHDvi86GVB+Qd/lmpWbuzVSqDhi6NQJVJaJpIwf3lbLWBgSjaVbzeH4",
	"U4J6wwddKX09HPZH9VDmyMpYzfB6iOBZUiJ4DkG7AqRpT3b+wmHYriMRnBBYQNIQRssuGHk029UbxNCX",
	"f30wGfaPHz4afZ2s4xj7oVKvyIGbv+Xg1d8JE3TyhYwEZnnL50OP+hTnGi8hpsOO4W+TMV42kVKuUiPO",
	"wLXshxum1iTmcJoSfk5X/4S/hzFDh5dNiVC51bp999bu7U6r1Wrv3rqeuCtDoNenyBv3sc3QCfHIKbUo",
	"XOI78RCKNL2BLq0kAs2tJiYOF32O5pUfCGfzSj1H6Y/1bJSPSLGvJkHHepI1kNRUJmG6CDCVWk1IrKoE",
	"W6bNyBGQrNCWEkWqz7aO4o9Cu9MDfFa7VjXcFLUt1fBSDS/V8E9BDQ9Z4WUU8V+/Hm7nJgNRmndWiBGQ",
	"vUWDgHJ07PWKb2M3R/XNURPl/3LyZcSv3tavIItg3J+5zlWb8PHR9LUQSb42jmd1y0q/N+AlzYSpGgce",
	"C2IRq2jujfTxyQl4VVA4iK2QrNWET4S57z2MiI+XWjQoEgJQVY5SjR6CLXPin969/jvEHP45wJLVxmsA",
	"yHsBsrhA0qx6NDpOfMa90NFg3BNQHsLFHqEcI7F661mcebiuikh8OZuN0V6ng+KFsiJA3HGiZkSaQ2xw",
	"J8e5RPsT8i6n8gDk0kGhlzmTKOCa3M7Es2ds4NkqO+J68c08OWZgYqjQkwWZse+9Xi4MaKRVr/hTqdxq",
	"yCduGFoPXXJfs1FtydSqpn0QeHHIhIoibzdvN28DuAh7Gn4ltZMwZCflB9U5dHwpqiA38Ki1eruk2bAi",
	"XEcMjafj5OnFQgQulbw9rLoAdyBx0SnhugaF8LENkjtRHdCl/OCxKJJW3RjCX/0XS6M0b+22Wu1WSnC8",
	"k6DnO5kQvjv5YoLDLOwMPeHzAv45CK26ps4FMqi9nIKT4OfrHh6hBhp68oaDJ8yyE2NzyJMwANU37M2K",
	"XrXO8DmUVjNgQHgQ4uMVDeTZLUIQQ4CKFF4RM1y7OfURw6lqJ23MWmIu9YSiCDkLODmn2OgA3hmxqM00",
	"rncUjZsly8YFbhoGpUrJxQL26go0mWbYp4wm+jR2CMNqjVM1KYGs3kTiBwpVO7MI4AsuWDHBTuQxBNaf",
	"yi6QFqtNeF5ywKH8jwprdyYN9DhuoNfpxd69/ls46nev/55vqbe3C6ObV6SYjtXZj1BoSbSGhXl2k6ph",
	"tcBkP0lDgE/mlTjSi4RWgVrdpBthyF298eXhBzKJ574Ap/2vbCVZYTa5y6ypEXnWLSdwpPhyJu1v8udK",
	"vSKZT6UOGGIVlZICfurfMyy0uEjkpptyzZuvJAPfKp2vfmdML2IvheanLd+Onn8Fou5FDvi8BwzYwjYW",
	"PgdLElMMW8rF8l19Y8bymozimrJ8XURVsPaRTxxyyjxSR6ThYurUkbU83bG85XMp6yh+jx2itHAQfQ+j",
	"cH3zMrKIEyLXUjg3sNvaAJgZNNu390xGINWdesOHpD1KP2LoQv/7D/3f5sXFRbV5cSFJGjJUqJjgO3eQ",
	"hTm2fMKJSA2sN34ILcdyc+rhSK2u3Q4NQuDmREsGHFUZKFb/ZEKPMdYg2GuLW9zb3GJigOmFzUcIHh0N",
	"+2CyMXeI3OpYUlyzYrFqVxC6/2TysLfX7nQip6/PmCMid69x9cqHavm2+5RQAmnHzDkHimMBSAD1UPID",
	"ko0mEtk28juIxWgnQNGR5fQcgs+prfgUtG7Ivfqd0nk2jVLSTNSG5rQpU2kTdbX4v9R2Fp1Pfl3jcurF",
	"Xu5kwopUO4q5R4HxKoz93eu/SR747vXf69kWYPLyvUzkulrCjNLV6bTbu+3OXqdyGRggT+EyN2dhX/3L",
	"0+UGN8VSgK5rb0Zkhj4l3IR8YObABS46mhyiBjryqJw1mhDBAm4RdIhdIo/XETwROx5RGL86Enfbe+2N",
	"R0I+VJMXleww3dXcM9MnXA5lMkQNkD9Xb3Ty4dVbm4FoxuBXYPFSzgi4B/DwwEUedolYYovAhGJVG+va",
	"5kQ9n3ix0EMCjR0CiuY5GBZSVhNINhFwAaqLkHqOvAYIpEZYEk+ljbaxImhjzZJL1jMpFwBNayxfAff2",
	"T7BnMXKx32v3+7u77c6uolJyQdylo3fxWZZenkktkQkoFM6imVYD7tXUd8mhxySn2OMZo7JSUoy5vKoH",
	"l9tiogpmaEKJmq6GM6pBzq+kbcqVKqAN8SHg/VFhBcCS5PENNyVsT8QcQfKhwPEVHvSyJAeDyWT9Fr7J",
	"WbF6A+ek2ECuOWKscrZ6MeMkTvCx0LuZDe+4dTuhwEqqiBVCiP6czxtPf2zVd9uvYr9Xa3+sz+eN5v7n",
	"/3H/98f/9tkf/n0+3/nT757+scBk41Lfx55FPgrUmriJ8uHyQoqBe5PyVIrVxny2UhjzMfrLeDZq7d5q",
	"tFqd5pVA2e+XnyPuqdOqvVy9YcZYuq69WeGLmRqNkUmqHiWCVkJz1jWc9otnbR+Xix+AzMvXjARJtXkl",
	"OEheW9tiQiQ5nRfpkznRRKXj42M5Pt7fLLvxMBXQ2IfHW8jbKd+oFCcrFV8hwJ+pxD1NRpKuzwmHzIWd",
	"ZqvZgvoFARRM4XUwHPqMQwi9ECZKAiA7CR8wcQpzSP0K4A5o7pWIhxLxUCIeSsTDJRAPqesgFlKZLogi",
	"ly+W6Tsv1i1RZKcM4yq5aclNyzCu31AYV4qZSik9Ut/ERKVUJB9O5C5l2pILl1y4lGl/ozLttZewuXQF",
	"m0sUsLlU/ZobKV+zVfWa9y9e8zFr12xTuuZSlWtupHCNtTztecvn67ymoSig2yPeOXMkG0ZeEu8sr07N",
	"SeEQS8YiKYYFsKqA2MUW4yHXUayACIs5Z4nk5fJ4QXOK5JTtNwqMS0EiECkAOhTgGlS7cp9zG95734bT",
	"gMu7d27vSR7VarV373wQIHFZhuhjlSGqV5aEC+ZtK+Ya/FX0UvoGirVXD4+p3uKnly161Md50CwDwOOG",
	"ryZvfWryEIS1eVKFgU3SoqIiQpqLsjCHEJY3hceECTWA0y5Q9Zni5f6LR3IczyRBPIu5AtW38QjGSIAR",
	"eVwt0VxeQtTw5tATT1U3jyqha/bNIMw+Sikkx0+TpVE6YdHo+A7IC3qhUgOkJ7SpPoZy6ca2xIayRlzD",
	"dZsfrn5xXi2G/s2nwkJzr5sOfYWdZfG8zdk3kwmvfI5/oFslvNKVR3CsdEw6/5ZKqEXT0UFafGmivk6A",
	"B+ejru8X/TbclxFsjJiRJQFGtsqO4qrAGCZ8DJPlebj5MnFVqWuXunZp8fxtWTwHCfBCKmguUdg+BbRT",
	"0M+6wSevqRiWithREijNeyebG7kOwgMBAIHPQNp9DgGMqYAGE0uWPB3ddI0pfUCYufZNPCSPxa9FUW5q",
	"x8Ph2vFbBXqLIbpTKmk9eQVpxQdKLMpb3MfegiC4zaTMFpYOQhEEpG40KalVQ7IvfbNBLQoVkqcL96tk",
	"qAvi2XCrRkmvTukFQ+1b+60WOpr16tC1DekjM+kpMXqOPZWfGpFTIrlaiP1ptWQLROXEkqOMZ9WS98/q",
	"rUNxXa9a2BKMq25q/EWhptiXzFmgTvssfT4G91p7rdbdu3c7rc5eu9O51b4lJbF2Z/fund32ndSp2e0k",
	"To38mNBNBk9r1dj1U9Oa4N6rWrUF6KGXCmYUfnzSbhh80e6TVqP9tFbtPGk1dp++fNJqqx+gkVvh3xEg",
	"UimYeUwthfrZirl5UTxEGD5hAiNevHjx4uDAtr/80nW/jf6h6m4nFhJxH80rFhayZXmD0HMyr9SRvD/R",
	"6k3dxEHJi9EhPseAfV39S1iBgyEkknrmU02XAt1XRpZ5ZTCvoIYirmo76rIGecfNKFEjK6EqKvUVXHNB",
	"OKiqgxjJxy7BfSMIZWQaKg+tUnNzH6CefqR6N7YeKOTaAqndg+HGFxO9e/2/w1Gr6yR9chUC2VA7vrKw",
	"HvJOBW0sPAtwwmyMRHAixRQtkjNuSxGFxOGlWjCOFyjRAWKcMk592R6uyxlCQKEwZ5/p2pths5ghEUl2",
	"8fZ0J9BqFGAYuJpN6JSwKsqF28QTib5FWCcl/mVd2zZNnYiY5FFXuuyG3ZW8NXAx8plD+Oo/gfiUfgbj",
	"b3dg2UXIMk4DP+CSoenPSyyEql7rIk4cg+ON7YHiXMp0Ei/DEy0ZjHM6HsLmx0+P3HtBvgu0tAj4NbzF",
	"tFC13Y6TWUJAEEhyiJ1u45sdIDkV06CSDOrQCY1RV1Fd6N3rv8Up8t3rv0NVw64tFeso21Wse9jieJBQ",
	"zmGp5/wSnhJJZvJXGg80XSZKwQ6cmJBjLv6M1MrJkoDsA4BT7HwXEI5Y4Mu9k5KyziUWoaqn4+Fv5ALI",
	"Vw1zsxREArpAgcCh0STaETT3DpgNUU1Sn/C5QbJTETIMocCSEyKYo8MW9pp3bu3WTbppzyfu0gG5Snd2",
	"Tj3J7m15AOde5KlmLrWoo5NXMChBrVCb+j3iIpcROU4peknBhnLgIKoJsPWIJdNhKPAoIvLOWf1PD9Jp",
	"oLk3JYuA6KQBodgBByKMZhgcHh001Q0EeksD9QJI1ij/gp56OnkjVOIA3aWBpvicegsRPiMlNRYsoTYq",
	"PDebdA9RA4WId2+hdyrxSihnLvnqTUNuRTJ8VY6oUq/ITiv1imwzlQdC/b6JMkIf/ftRBjqnWEvCN0wg",
	"H5I+tqaO8JIUFlPZPoxW8KsjmXhMzxSqHRkTVZJs1G9FFY+ifKcpZxJcy98F1FPqAJRNEuBg+7o7nA0P",
	"vzjuHs2+HE2G0+5sOJKL0V0EmNsqjiyegFG+NO5OZsPuo0d/Pe72eoPxbNBHDSl6WBQ7OleClCtMcgZo",
	"F57phikUTJG7nnp5AoXRwu+hBhN8fQ7lq3U9uenRAXwt+W3gUjtZzyl/KpV6JTtcFYqux6XLL+qSm1EB",
	"KNNhqmZiUS+5+6rPfw97FnEcFbHFmZu/tyq1ZzqdpzKmKi8y1RKBql7IaEwSlIqr7CR2yT/WmYqWTIjV",
	"23NCBQj8UT0v2DVD1fr1Ii8GlMqxMLCchN4smwzLf12hxSTw/zLFx9bXTCvYBlWTK38jRqmwvHipaZ3H",
	"BIIbdBom4/0oqAYlEFaCGvA1VcosL4SHCKnTcQiJZ6GQmypHl9xmVCUXTaR5QsIo8zka9w+/qOtB2wXW",
	"NrnKqNc97A0edfuj4/HgsD847A27tTXkk/N4wa4TT7sjJL85B/u+oH6gpyLHl2yv+8XgsK+yUb1Xi9Pe",
	"l/0UR84MVZ7rvA7TrDrvxW1Jax3/1hXrDELDSaWrUd50bSPGPDOb7DA3jGuccLumRRBwXNfzc2JRW6Un",
	"+i4Ap6JO4OQm8OYFsJzYoMeD6XTUPT7szo4m3UeSGasvvjqaDPvDXuokZ55eN7Utljm8JmOy9khff4ic",
	"MyegQEPaoK40Soh1nvQe91F1QixCz4ldS6ZFkgzgu4AKmhPurrgyGBjBUYVEoKovJrlDHbmSMVDPxoDc",
	"UTkNtMsMXJuQ2ooC+wBbv64eIIITVypl2oIQNxE0lVx02ENVTY45I48hUsDiGIaTy4Gbk5YZebzsaVjI",
	"9pTFatfKl6rdXm9ck/TD9X2OUXXyVW9WS80eRiofrqKuZZGlT2zUC4TPXMLRmLNT6pDUyH0mBU4ptGoD",
	"v14rj8hBaiPH89VP6JRx7IYXoxGL447F7EIos+uSg6wH6xoPF84sNKp6yg0nIFpSrSOIqqAbJ03gLEA6",
	"ylCJRvqd2PNKbPYM1Crxek0v1biPqtFSOQRDZOdYmURytjmar1wTRTQkSE07M7E4VYLW4BPX5N4Pw6yF",
	"ohX9no0T+62KSn7Vm8nDo4qr14oJUB0WQyqpjTJmDGVUkIsw7cUWYUp83yGQx6On0DjERn1yIpkQCrM6",
	"N9Z3rg3jmzuXtxWqjolnU2+xZrU58VUCHHfJeAhGyDt3YK/3Vj85VJCmgvAJgvDSkc1uRDMq/ab3ZR9V",
	"p9YZsYNtzrqcsfYqJE943POeQCxRTz+yH9tXLSyr7hJZFCI2GCeIeKnQ3uO+voKlDN7rjeE/Y5C8v4JU",
	"UHKb5T3RP/xCalO9L1MCuP5h3c1QeCeQUB46pZ6UvqDadGLgcuUULsGIuAgvVz+LLctkhffe8C+pYQ//",
	"UjTqVIn+3vq6rmkQQUFZ/YO8Av7JmzCZKUNB2uRPmOdUozWSqyK87qP+6Hh4OD16OOwNVUX8BnrcfTSa",
	"HHd7w4Pu8aPhwTD+7fDwcffRsD/Krfe/TRLS+FOTQe9oKqWzWMHi3N+n46FRHcOmEkPJKxZv3sr9bdgb",
	"F/42no6TZXRzn0qMeTacHT3qTob9bn9wPDyUAx1OZ2ZB1SIejweT4ag/OlYrOfhLb9DXw0898Oej7uFM",
	"tZXzlHp9Npp1HyUXd83Dk+7hFMql57+wj0ze3GRuXxQ4Psdg3ZeKa4QiUw8vGU8gY2P9yrl3Z8PH3Wmi",
	"EwP6ghxlOn+CSLtIErA0MPPrZKfA93zqLVTuqjRBmMK6sGUjuZGT7jembL1elv5g1n30ZWx8CTIyv0Yk",
	"GP2aTQEjSHRoI/isgQOGaV8S0Gp1+J4lUr2k2HGSAWWPaKVeyZ7Q8Esz4Eyd5npl8/FMPJQ9nfk/T8fD",
	"Sr1SdAKLfhrClbH5/BU9FB9UPl+o1CvFx7JSr6w9ldnfcw5l9NDmM5l5dsORjJ7POUqZORvSl6uVQ/nK",
	"5lJA+LEfs3SfvPxyiXHbu/AL4pfX4W/jOrymC2+rW/WTvQ7XX1DFh7u8vj7C9VV4hXzMe+1abqht7sAb",
	"ub4Kb6i199rHv74exqo35WHCTqlHTfyEhr9w6hLKE7fQ6n8DtRKSOJpUogkbMUbYJkLjZIQpFbZt5IkK",
	"J8SChS4IZX0KLbk49OPqRnCYithVASoQyqitBaaaVqLy9w4VyxP0ObqGqlfQVK0eQxsqX8YCc+z5lGtD",
	"x7rSXGb0cvBhqFZRIGO2JseOji169/rvufEEbn6Ax+O8a8BiLurI1QfdxaIuplk8/k1GquTWdtumvHsq",
	"F41sCBzv1ou1OH/l+/cMeFuQReCBjGZDIvzpqLHXad8BYJwgz3Ed/eHB5NEfmnNvxmwmUKzaiss8Aqg1",
	"JqJoPAAgqOISulIbfKkd3tD3ubKXyR1XcRXp9X4weZSCIGXj4Z7+uFsABCpI0qfMSxrlix0leCZU1VSc",
	"ygidBqIAhht571Ku4SjqhSCu1zg0T2mBNXLWhNav/NK3v5HUfr+mxKSTaZiY9Ep5Sf3LBWXmhmP6KhBT",
	"U03IHOqGQWY5T17swqNEWeHklhyZFa8m3ZU12BHiqaIkDUGQA5iRbDDCMBHAMF6TejNW+OrGS1QZSmoW",
	"lVlK7W07U4Wm3X51c3WT8oenyiMVck3DNH9/XaWS0ula16WUPWCeHNElw3ld4gkI+f6ko3k/UjCvu/of",
	"IkEAu60PEc6r9uRTCOcdY986u2pe4lQjl0tEnPdyZhRWDIWyqWrfgnBMI8NWCj2WzYRhEAUPXlyy5fAE",
	"gWtNwZkAcp/oci0TXhc8LVu0cSJbTIy3vXf3N8DpjagA/vIwTdCagnRb3gh7N15mj9zcHIuL7n3giyP1",
	"ZJze886jsmhdQmwqQIil+9Xt1pNnuZAjTFIVG4o50/pkS9mw/bgBvY44IHGNtkHs0IIukl5wOXKobFXZ",
	"f7JBtVSvDWyq8tDXt3p8Qs6ZyVy/7Rvao1B59fQS3Das//QeS8fW5XX/xVkMblDRR78MPT9FNZFKY5Zm",
	"DQklioYl1y8hRfY0MGVdRZAoAjCuROZUNESx6C4jmBqTgb96A6sL8GSHKLuZu3rjc2phIF5iMaGjEJta",
	"uA0rz8bqdUaVaVVsdEHcd6L8UxidHbipUrQqTNvSJFVsmQV4UgNlIdow3YXKWRYCOp3VzwtIk4bmHkIN",
	"NDYW11D721czFCAUKwIqqqBXT9XlyhgN45ZMXfdJu4NIHHuUj8UOyzWc0ouo8l4zHHmU5WMSRnkIVJ0G",
	"J4J8F8Cn2r6y7/rmVMVSg/DYS2HUgNDYppw5x8qApQi5cAZBVHLCJmjo+YTL6cvjj+7ebrXjMdDPnj1T",
	"aaSEj7mvckntqG9sU/MQvnz27JkKc4/OvhwZtRyGyAWGbB9ZJHWIV9brJ1dwhMJLguT2/+zZMzU3U0xR",
	"G/CgNKtO/BF2HatKlDcAc+q2H0hm2mossWgqLnuyIqYLxRZsaukkf5mC0+P21wbM6mJPbum4rWOqlGZV",
	"R+Nd/YUvD4bwOXx5+yB8T32HCBq3/2owiwF2atFsBqqClNhXX8iv2vuoX7RwUQ2v1Hj3UWd3p3Vnp3PL",
	"NARkn5yjehnnvDxVc0y8m+QQWUreTz6tWQOMU46m0brT6LQ6t3bG7a/jT0717aYf3G0VPTgj3Io32bqd",
	"92QDdT7Ceh0ABdzQch2sWS754N3cB9PLJZ+8F3syabVObM/a9IFJ0Ufy1d+//O9K5mnE/rP3aj7fGVfb",
	"X79sH7zcPXh5++Bl+6/5MpFZZbBs5AR3wvcqUNOYM6gAP39YinqzoSmnItCLTfpGX+Wzc40JbN2zyk72",
	"ql75npBvNz38tXzmVb3ygmC+6dm/ymfyzSih/aK31lKRkx4t1O/DQuJCssOMHX6dlq/uNCmgxjwpjCPi",
	"EBSBe3ILt43CWpOxgWugcEJG01lii4q36fCvOA6i1z3s5VZnCFXQrl9UCEqltVDBGMXRgLESipEEowS1",
	"J5OHvcbu7u69qKidvPN8jq1vCY9K29nMCsvbycdr9fAqP5r18mpF3Wp02rPW3f3d1n6r9U3atdSQjCib",
	"Mulq/qVZ9U/78qf53H7ZedJqd3af1vbVd53dvVvy+8znb7Z2SvWxT2Zq1NfqktrSsgbqj6Nto/jStL9B",
	"Ky2tbbhZmts+qJ8mpPuHnLnvaUgLg6mhYyw2V0LcHA5caAns+pXkaQ37TE8mb7qTXBxMURS4yW3ITPjV",
	"Iqy7C8eOhpfgkjM78JlIpYKM6XvNrW1yXQPK2Whcm35PyFJR8voHH/Nl5VVmPZIsFgc+08JmM7k6V2e1",
	"sbZhZyNz4BVtojm2z1zf4LZmHR3EndbiolL8Bik5r+T5Z7aj/rRNVJG9Oj0qWm+TrBEGrieHGY/kY6U0",
	"cBWAitqHPGHgzwFxlX2GBSiTGiBOnHOvgaK0CPLT0fSoOxkauK+BXBdlWtBPv2/OBTMJw9nTHE6K4MwD",
	"dRcmYxKQMRWOmDxn2blsMYGCYcdRsusvvNg+pOaTOCv5nD55ujZXusiNWkBYiNVbz+LMY3nagQ4T3HTZ",
	"5UUXvqpXbOJj6uQhn3zsnJHIL3zJQIv8eIh91A3z+zrEyLA64ZgQAUUCOzZDIpCyDRjGdKINrDJmxoTX",
	"+/nBFfvoMcTQI6AlpXZFuPsIdk+Ej09gEDZDTzIgoaoaJguUpljb8cI4sqc6O5PCS3AUDi+qqZvEVThh",
	"6uv72dCPKFggRKHKVlZv0PnqJ4faTBW1SKDZ91WcMCeSzWCb7cR3ZW011TAbyf3tIkz2Ud/I9zFHAz0n",
	"XMUfKynEPJK4C+5vik7ZR08SqZ+StGQFAj+9XxzBso+ehDZQopwIoXYLO2uSWK3eehQEIUn2aNztTZut",
	"Vkc1nQ/b30e95N3r6a1AVeKGqjuVZHF/XbjMvgnDDlyMTrFzBga4/Gzfw3jKblSdjodr2h72xnltYzT0",
	"TjmWckcgRX7ZRe8MnxOBxirzNRaoOuyN1zSdCDLI74SmOmFozFUuDcgwODVY9ESyrOp4Oq5pA76qV5k6",
	"yeujGfa1MX79SNa5n9JCnFKVAi6YuL8+WGhfJ/+CLCIqjt/TfBmyhoMS3hs/3AEseUZyswlymLfAAKQK",
	"b+W1sRmSTcbdv2FGRp2OUee0QEtGRcjkJFNyia/yamXT+EOagwuL2Cb4dXP0x6WGkag0FB8LXjsW3LxU",
	"LFZhaBU0RyL2vnDYSU5qtKa2Mv/GQ5xlR4mMU/gcR1nwETiWk1sW2RZVKrZmUZiZbDrEr0P6DGPpTqXL",
	"8aJ5yH2L5a9VUzKHt7k+cE1Nha/+U9KbvMmZS45tVhW1YzC1VkXtqUZl20yY/NhrSvCHeRJt+gNxtUM6",
	"+pVxupCsX60Ids5YYJLqivjOMCE51LpS/+tD7uJyTMJJEM01Vo7ohNjEIlJV5aqclk2QRxarny2qYXwJ",
	"nWrv7vbA8LQZRAqOody4hdybG7f7sUVfOahS+i2l31L6LaXfUvrdII5CCvVPQiK97EiuJJR+QI3gAwvB",
	"H1P6vVGB9EOJ1qXw+0sRfj+47KsqyQ84ZzwLwpcXdar4cb5IW4Cw1ld9HHWoagstGQUocnymt25dJvqz",
	"WBSOhBSHLFZvz4kDB/sscLEXhhSnx3WVVa9XfOo7eZlqV2/9wLnKOC6zJvmbr4a2lghcfGFqjO5uqDjq",
	"kryojAPi49SFHcKd0OofqDseGnYCuRVzvIDfBUT4oXNqrStPQbNF4Pj4l4MQ+ojOuYyHKLnWm5zcS9qU",
	"+3sdPu0lzQ5Hs5iNzKnHCfZJYbjQ1TiVMKwqrEuhboRYgU6SX2ZUwc6zmUTFvrba9buzbvbG6G7KXwTV",
	"CroHg9lkdJyTacv8FH9hMJFf9AcH49EMcn/nZul6eHTYG44OYRD9AbT9ZffB8NFw1u0nHZMFI1+fgAbK",
	"FuSNO/FL7PHMqHNSIa0dc8pTWjjo97pBIs4MqhNw63S9c6PYhgr+/tqdj0DT8eAFpbOGtfWApSSfidlg",
	"dDDJOnlknJayQL56qmQfI4Gs/pFrf1OtF+xjcdMJcIinSi9qmSfT5CUHmhCVFLvF0QZxbGOhu8iQk9J9",
	"yOpfSqqFCIIFcVHVcjB1IVKiZmwkWvPQT8fFeSnhI0tq5xrZ5i6Zryt0VS8a+gviWS8a35IXNT2Y6zYD",
	"6WbXHof9VLFJk6ZbIfCI1OdRLAGTBzFSblilJx1/9jBLiE+imj56m0Sg5gQ3+82JUWkxUh7GcDnrhedS",
	"W+qucCq3OG/GApuKw9KmqEscqfc5OOl+cg6BvEOTdLuGRtPd3yjBoc0UF23ExxWPt5WOPzH5acyEf5MB",
	"15cSjMA0eE7tADs5Qca2CqvGzkdJc5S2sSXo8oB6Z1jjU9UJulL2IqxLZxG7u6XeswbCiMMCVeuwnKpo",
	"Z+Ka1vEeyRbDOi5qL6OSU/kpuN5LH4rFOf1WIZMngaCSGw4gD84mx+CD5NMqJx6cjytTD5QYZU10FAXC",
	"Qmny2Ns3oWbrE6uCiHVkU+SUoy75gXlEKuHVo1kPvtCiX62M27lK3I5JEbltEkWhlKWTZPrFjZFvOFt2",
	"OZbxknEqpfAoFqQJkkZPVSQezsbIJ5Lfqlj/4ovHx/m19aWUIcDPwlXkf5itTmRdKZki5B7Y5kxGLBYo",
	"r+6UGHOzHhOYvoezcT3vyllyYlEBRc5VPGuUmmpjTQ7o7gBSlgoSpUKQOkJhd0zKv45POL5ER8nb4n8R",
	"8RSyFKjdTN0UJJE4WadESKROTiyqqQvHAqQdLrBc2iEbXSr389KTRqVItwFM5NW0fVWvULE82U54UAoD",
	"FPGuDtOYiXwXsErXQShnopYtDa7qLFVjr8ZiXGjce1xDgimXnByEpwLGsslSJAO5fedukoXdTdyjd5O5",
	"7KJyw7lxXFSIIC9fYSw7SnehNVziUiESWTGEPLurtwuqiLUaPrp6AwdpSTxbf2NCgsDJiKUUqQkEM2GQ",
	"FgLSzi2V2xvqNi+Iit+XD4WKuD70UMQ5dIaZ3Ll1NPeg7Cvhlg5GJ0g+pqvPpv3NOYWj3dXP5wQCz7QI",
	"JEkf1/LyEReHxahkdCJM5iGgWk/Er/ZVDdhqb3Q46x73B+PRdDgbHXePHw+ns24NEVX/Vf8+Hh2Nu4e9",
	"bi1DEXfu7CWpIRk93s5Qw9Mf2/W9fGLwAvckjxiKz4pnIhsNRSSyEuayZJApFM2E1dCgBp8AfA9B5IIK",
	"n3IQDdAZCyT3UI7ZRC3zuno6TOdhMe9csg6TLKZVdHjutdbKofkr1mltkw5ScppwGesJ/pWnmZGLJeVX",
	"F95gCWxCLzA3dfZCQ8CnKsyhrDRXkJoyPVvI3gM7PKYXUJPXpA2qzithXu55JWYpBRQHxBCieWVtXu95",
	"pYaSiYzVHuXfm+ZyV3Xo/yFQZ3f/1r39W/dgdrVr1JN+ixKqk0inu+7yjyXehRNZFKq6ro2CANdUe3Lv",
	"h3ZOoHtCWlj9y9PGyU0IGq10bbSWmGA5GzdRPyZ+BS46mhyiBjryqKQjKKAecIugQ+wSefzl7zH/aJSQ",
	"BcM5v9vea1/imMvHa/J2lx2nuzSLQLgc0GSIGsCupCzgc3oSrN7akNkbMfgVVp6geSXg3ryCIFWrh10i",
	"ltgiMK2YpbeueYokFS9cIMUN5aMmr1gK6koMXgwtCYesYFLEghxJJKwdamPkMCtCgzbnXs8UMQBjl+Gg",
	"Aff2T7BnMXKx32v3+7u77c6uKnJAVB4htZHPsiTzDPnEBXeglKxZNNFqwL2a+TY5+pjnIfZCFjEHd66R",
	"zap6gAVtJoznxPNVVoKo8Wo4r1q6ppALpa7BwA36k0IZKy98vIxi2JiIZQE2rnpQvN6f9LKg8Fu3E9xR",
	"btET3Pih2/hGssDoz/m88fTHVn23/Sr2e7X2x/p83mjuf/4f939//G+f/eHf5/OdP/3u6R9/XxwXuhUv",
	"CZM2yrfCnI/vGbMd5a788EHbUE5+U8z2unS66dJTOD6hNej4goJZAChNodizTRrfddqDbHB7x1GEcPhV",
	"VKMm4UnO+f1STuQkIj8Olo621cwqSsr3zEgphnZ21GrvyOV51tzkscFF1dwBNZtehX00yhoSYHwQqB23",
	"decDxrNrlGgyqrO9ZaNpwSnR1nMCOVk22TQ+KH5OzuvbK2YfUHjQUmC8SvIB2IX3yz0QnUb00dMPwDSu",
	"kn0gNpnUbEIXthoXQjeahMDsR3JS8fNyteTUXe09y6SlNo0cLeUZuZJ2DRWxw8sSsPPKxfYLcpSUiuhV",
	"+EoARHQtDtqQegqyJqK5N0pn2k2/FNYSS/i6051xRGxIZyPb1P6UMPG5zoBsgk6wMluDUGXqhvNs2TIt",
	"T4I075r0snrSYPAwU1cXfi6jNUOQo+rGBrT6WeqJYRBDVGMO0kOlM0SXHugbxAVnrB0FzDRhoanHUv+H",
	"DsMc53SheSbvInCo963IQ9I8gh+uC0rzcRA7ALQxc9RDWAffKaE7nxp0Z7nk7Bw7/QDORHaSkyjnt2aW",
	"KpTLwHvh9XB9c0PF4oXBqtqFyoKaughU/CYadyezYffRo78ed3u9wXg26DdRN9W6FGF0YSTsr95IIgBb",
	"9RnkpKQ4wvrVlW0AuoUdqOd5G5TrVydMy9og5l7eBq8Ft8Z2P7MSxodsVgDbrCa3unABstfDXqPdaXRu",
	"5dQI/MUXBSwhZCWErISQlRCyEkJWQshKCNnNQMhOFmTGvlfpJwtyHseS8is5JyzXqmoXrX5yrMBhRuBa",
	"/cunTiaKPxE3Uj2ndpZPqsjpGRt49tCuoRMsiHYduIFHrdXbpQIuWJJCtX8vs8deIlY/u3Pb+JDC3VLI",
	"imj+NkP5Sh6YJd69/luI0oAyQ9mrJL7LWsYrFh1u7bZa7VYKEncnIRfcyRSdvVOEhiuhgiVUsIQKllDB",
	"EipYQgVLqGAJFSyhgiVUsIQKllDBEipYQgVLqGAJFSyhgiVUsIQKfjJQQU7Ft1O68LCz0QkxiR6Nm3ZL",
	"sGEJNizBhiXYsAQblmDDEmxYBDYcY986KxGHJeKwRByWiMMScVgiDkvEYYk4LBGHJeKwRByWSetKJFqJ",
	"RCuRaAaJNvdKLFqJRSuxaCUWrcSilVi0EotWYtE+JSza+4DKwrrmHx5T9tWgN9sMKltrCVBtp4qpR+ty",
	"RSiONkiXF+ZVsDhqH94PjGOI86MjcdQkrgLFCc9Zdi5bTOAaMDjhPqTmkzgrRaC2ErhaAldL4GoJXC2B",
	"qyVwtQSulsDVErhaAldL4GoJXP3NA1dLrOoHwqqO8Qt5roVkMwWAVRy/Ch867PuibD4W80KIZyyzjzxv",
	"kWWSI4ZOneBCuWsTonrI3iJjuGRtoUE8D+w2Jag3fNBFLEAPh/1RfY1y2wydTDBaT9VA98HHpBCgRCpa",
	"S/zCYdiuIxGcENC/iRSl1MgKRh7NdvUGMfTlXx9Mhv3jh49GXzcTclTsh0q9Igdu/paDV38nhKrkCxmR",
	"0MKeRRxnK6/HmF7oze7F35KteMvnQ4/6FPssDyFwOP5K8u+h4d8JZIRk4NTGCtJwhk+oQ/2Ym0OubIxJ",
	"T00ta5vo9tRPHjDiJM7rVuv23Vu7tzutVqu9eysNAs4HP7Q7r5Qbt5Pv+H5PDF2SIA1+bu59YDlt7l2r",
	"pNZqtO6UktrlUHQxRNw2WDrz+Ku6AjIXkFuWzgT4/YwglVUJ1u9+YxdtBlHuNtqtRruVA7aOH7TWrwB7",
	"nQEzrtu6fuJh+TazApfkoSCTFk3I4qYeTbvi7LixyzbgGSWuZiyd0av5xuFDA8WJ9yf1/hT8kp1K/uok",
	"O18SIRhGHvYDjgH69Dzgq7c2tbBSERT8Jgw0iJQFY/0NXDA3w3NEGLAiuPqIj5fKpshpEY6iGrkiofg/",
	"evf6b8qoGYp6717/vSYH82cFNISLmks2Cl5xgHoiThYc1+NhDgaemNBk5BPIxR6hHCOxeutZnHm4jgjn",
	"DH05m43RXqeDGmjc/aJ7MDicjY77w8eDyReDw9nguDc6nA4OZ0P4IY0wSvzLXk5xlFESZlTVOKP2q9rv",
	"X6pP6aurVuCTzDEkz+jyUpTgUz9w8Ho6iAksvfFDKagcjr9KyiXwzUaMVJKQ1QxywVFhbsbNppnwSYCN",
	"WNgZgks6/4AOwrsXYcUHkTGQ5SSPBBBu9/AINdDQkwwYnnCxJwnfJshWkMQ8BBwYz4a9WdGr1hk+J1LE",
	"MVY3eFCutub80QmtmnNQU+E92GcBKpK+REy8UCIYyF363uDRVLXTKLpgwjvnhHhE0ocyF0hVmZNzig1G",
	"1TsjFrVhbbpHs1E07vhtBYFRaeM9SevWdWWfzDNfxPuMglvUWTaeh+QFuXoT3Y4oxIKZRQCgdsGKCXYi",
	"r1DgLXHemKNdGANHcsAxsAaSbAawqSkQTwK5huPINYUyT6f0zIew2UZZWY9lm1dqiIDz5JTEfCfJWECp",
	"emU2qarYfaafpdIUJrJBuaLzCrKp/lvOdF75gXA2r9TqCC+JhwViyF298ZlKOzqKm1wUov5XtpLJ7xR7",
	"xeeBI9hl1jTyqBYvJ3Ck+HImVUr5c6VekcynUgdDfaVekVuQss6r3zOXCuN0QT3spA0Cm1nxmjdfyQvv",
	"hWHJa5VS9diYXsRe0itkkS3fjp5/BbLURY6jpwcMWOf3lVKExxTDloKXfBc4T5wboFEcyS1fV/ElAHLa",
	"Rz5xyCnzSB2RhoupU0fW8nRHqtLyMlX8HjtE2R5AtjrU7nUpq+uXkUUcuI4jKSsUvMAUYUM0y6DZvr3X",
	"bqKxPAaqO/WGT8CcAuI7Qxf633/o/zYvLi6qzYsLSdIe02GtDN25gyzMseUTTkRqYL3xw0TURzQcqXS0",
	"22HAAjgN0JIBR1UA+tU/mdBjjDUIxoPiFvc2t5gYYHph81aOoaOjYR9CCswdIrc6Bo00KxZdnhFMcq/d",
	"6USquc+YIyKl3Cjk8iGQUackHpSbcK1H0U/nRIrL1FZ8QxJoSH46mCYlyYCV3TAHeC7egmIrKY1UDmYg",
	"fKyfUwLI6g1iS22Rs5Txa11Pknvk29g2ja8eDktNz84GEqwBfcOLoR6Q6kux9Oc4DIsCEOa713+TnA+S",
	"YWdagDHI97wwrjpBIRlZvtNpt3fbnb1O5TKh5deHFr5ZaPDcuyQ2uIDo1yGC595HhATPvV8KJjgPEXz9",
	"eOCrooHn3oeEA6+jthymMRBSL4EDv3qzbbr9lEiWcWkkGFpoi0/bTHMJ4GOClPNktnyAHAtS9KBZUXRr",
	"rs37EF5mWr00KTP4GnbVRKPYUQjH+CxiyDGVgqFnkRXgmb7MiHKnJAeeDkyNfC8eDolNHhsDY1zDUMkp",
	"8QPJTlMbPfvLcnJwdO/oz7PJ6ODrs28edy6mR+2HR/iHr6YHfSdtIl0bVbZm8+/de7UefT7ZCq6di9N2",
	"qe9jzyIfJcELcSUzDtdZCkaxiOyknJ1a+phjSQrpPkaT6WzU2r3VaLU6zSulgtke/aOJ9dpwPxHFFWN+",
	"Sm/Sb8ebpE2HkmSGGWv/OuKcFb5YiLaILoeEobVunD05qIqNoIyEwzhS9mO+kqxx9tJwhAnBdolGKNEI",
	"JRqhRCOU90eJRijRCCUaoUQjlGiEEo1QohFKNEKJRijRCCUaoUQjlGiEEo1QohFKNEKJRijRCCUaoUQj",
	"lGiEEo1QohFKNEKJRii9SSUa4XrQCEN7Qy2v9fxwY8qFMjvF5g1gwr/m9ZdNyj0ol3/z8udjca5M/tBs",
	"ufwblj8k1BIMVYKhSjBUCYYqxdfrA0NJ5hqdP2GYcImRKjFSJUaqxEiVGKkSI1VipEqMVImRKjFSJUaq",
	"xEiVGKlfNEbqveBEcm7ymL4frOiqmKzqlqCsWgKVpTltBpbV1fLlJXFYJVqqREuVaKkSLVWipUq0VImW",
	"KtFSJVqqREuVaKlfF1oq7UfLWmtjnpXtAAz0wuAWqE9ckQUwlE7f8hS+n4Ow9M1+NN/se3hXP4jPdFtP",
	"WekS/JRcgr86e3ZpWipNS6VpqTQtlaal0rT0CZmWviB+aV0qrUulXltal27OupQTe5enK5jIG87xiyLL",
	"0TiS368j6kibospgowJb3YT4/MWNxNslWi6D7i61EcWhX5+wAeyGDV6foK2hFLl/pSL3lQTD9713w9t0",
	"DdHlshIqvp3ShYcdoS0MA5vmi/dT6inlHXEqLBMJWrA5Ig7iFVnVO9QVDMor1K/TsHGuOgKImx34EFmI",
	"unGE8Mgg19ajfndC/PC8ggIRBw6rRGirnxERPpakGUaQ4uXqZwGBj9SF8BJi04KYF5sgh3kLjOyAa/MP",
	"mnsjNTSbwExTRgVtpYu1KeR3q/90ic+ZyPRRR+TCks0tk/jLsAFyYTmBAHh1BiUXRt7seNgl717/XZ2b",
	"VHSwcuTNiBfworvCDiG2ahUcqoJtDTXYjIMtOe3U+MV7MbDnE8/Da5VgHTcB9yl2ELwit8qmYskE9ek5",
	"hCmvfpI7SyyIg05wrx5xHCWN+y8e+WT/R+T26Oedz+Df7RZyxxb9vHNnD7kzbH1+67PPPmsjd4D5qeV9",
	"fu9Wu4XcB9izxedPOnefqr+/p7Z/9nmnvXdn7+7u7b07yD2wrM/vdPaQe+BZn8tXus7yDD9i3uLzx8PH",
	"I/15esa4b76wFVvAzthxPfH5j6+Q2xMLuRSfe4HjvKqj/IG3Ydytthr37u22GveunEw07r3kuLcZdms3",
	"PuzZ8ODBpDsdPkqMPf7tpgnksXKbnFOL5Brj+zELfHxvIzwyRksH+xhoRRkfu57NGbWfomHc0MFOfGpj",
	"JLXs89UbOPRPpAgY08HJOXHkKW1i1QIQLTcOhB397c6Ss3NqE74zJb5PvYVoTiUnJL/rHvYno2H/eNjX",
	"ZlA6ml5lFMulQ2AMRmNTDDag31J/J6Bq2Xbatzut1q17DRqa808ZPyeezfhORudv6X+NW3snuw1yx7rT",
	"gI/y//Zun5ye2vfu5Ip1Dl4KYkulcko9izxgzC88lUuQQLAynUjmWCUucqlDhSCLwLOZqOUeVYcuwnwF",
	"N72JTOxMXwifuD2HWd/+Ts9vQrAjedG/d+7+e+feje7it4R7xIH/7NRyc166Ol4i50YLr3FwkbgYya5w",
	"NosEcdTdrlcTJNzRVBFFeG9Qz7+9F226ZMoLwuWuLwhzWJEb+FHcBSOXwNgd62Z9pPoiSJC8XK9pe0Vz",
	"wdhCr6zZ1Gib5bfqgfDHhSt2zGx2HgaC2I/0p7E+0D24Yn+3DE4cajXwifA5tvyGj8W35sXGgvgOFr75",
	"DHGFMc+TUKFFQoAbxiMWEUIuChY3SUsW4yScWh4xddFwNtY6hXZJcin+h6ZiHI77v7TYI4VpzH3qnEVx",
	"iSJIe96MDqKDL5gdqhxMBViZMIYvxlOTN4R6cPS91dtz4tQRFRCBqEJWhBSq65JOiRvnEAJ+ZegMc/t7",
	"zElsadl9CBJS3YQT8sgiyIZH6pk5xAfRzcYmAiwpnjlYKnh2jmTWY4zbxMM2Rvoh7fg34hnxNOdz2ELr",
	"W5G4lpDWWHDikOjYeYF7ok6dFG+36F4/JRfsmgegvsiHQhDkEgt7VLgsqVXKG1mzAvmBJegkEWXXG3Un",
	"0wGkbzkcQJzdw8FkMujHNKcY4iGjSwF/4tR/UYhy0X7nBac2tkladJDaxrKJVCiU5kNxR7s5WWoyYwe/",
	"QN3xEA1Nt6iBQva14drRHGjp4Bc74bB32Dnh55R8/6cz5/Ol3zjhNTMaOpoWj6S7XKKu7xPhI2Ajl+AP",
	"SlKwzoj17Y7UvU4cKs6otzh+wQJ+jJfLY3Ecjq+Wp68slxNisYUHwt1jwm1q+ZdYf7xcJh1Gj7p/PZ4M",
	"eqMvDoffDPrFQuGVeo3teqL3J/P5vHIwGMymx/3B42FvcDw8nA2+mAxnf5W/PK1sR4eihx1Hqv6cLTgR",
	"olAess6wCy40iMj1GHJZ6C0z7NgAGT6A6OMSm+KdbmBTdoA9vCD8dwviHzCbVGs3KvJY2HGk6ForTvEt",
	"FDszxg99Y8TuC1Q1jE7H8AZg7DplQhDN2W1WqyOGXCJ5VNwKpo0giuPr/TxhzCHY0xt6hvlCbnjRTgqC",
	"MDrBPuEqljkrwwopeCMLc04Wymj2YYTZB6D1v9Abmr+NUiS5KQVk71bjRA3BZR71mTw3xMMnDrGNFpK3",
	"4n1yLglvoJ5ct+55iy3VCgZ5VZBNBPHOmXMO/umC3gZu4GD/Mv2s3iAiX7LBOswJdoraPmDWt1+Mp5ed",
	"QiBAcAxckJBOsSNYM2u2i/n3yQUVPg6jM2MiOsjbvryl1Q2r0rsdDj4MDYbyp5Gqm2e+6/xOLUy1VkMs",
	"qCv565xwJR5jTx4kyHyz+gdqd+rX3vdDzlzZv5HwL8XgBAIX0T5SgLmYPap+RRHdcsI/d+/ebt9t7TZU",
	"HzTqo9ZEVEypptgHL6bs1JeS7/X1nelSD+ZOgwphOj55IXTHa07xAfO+JS8mgecRXngApHAOemL86aLT",
	"NGHMJ3YfGMz2RwqgGSpriTH+uXHFxibo3eu/ccZ8ZZe9MZ07VEOKlO9QGJEnnuSvwZE46THPI5Z/ec4Y",
	"Wj0RRiwAE3LsmXOK0dH0Qf7iO9hbBHhB1mwktSlzMxegF2VPGE5H6PbuvUb7ZnnPc3yOd+TSw8F3iJRj",
	"HunhJ4964/qlmVMWeLb6E3QdsmNWzmI2SV16sSQh4jHhIteiIn/QtpQcGvtwokRAHbv5eDCZDkeHv5sM",
	"Hg2608ENL2auSLHbEGCiO1cLVrikwuKEeA84XZz53jpBnCEtRNoEnXDqnIEI7hMnTcuptTaZ3FZvQMWg",
	"nNXlRRumSCKezwlqIYw6t27VwQyicMinmF6AJ8dkeDvHnEKKEoQtxnXiDoZO8QmnFtZeXp3IpIkmscw5",
	"3nXaq2FZfzftTQaDw+MHk+EXX84OB9NpfJNjc4Y8IujUCfwAR9N99/pvrWbr3eu/I/i7DX9fYsyfvF20",
	"2ECiCK5PXeJJwswhOPUbSDkK8IGXDqC+zhliVrDEyNuG8G7okJ9T8v3O19Sz2fcHxOfUEpJzPpAMTVRr",
	"UnvaJKu131tWA3bdp2Lp4Be68xvmLS7xsbPj+g7HQk7iB/iaY0kgy53d1t27d+/sNtSeCvpDyLqTJpAz",
	"ItlLdqe7jh8o8IfczrrUSZb0gjiiuZ2NHfxvOdZ1zBdXaDcFcNCDN73lQRQCQfiMuuQbcNWfClLs31HQ",
	"VvD4h5CEUyncnTGuxJ6UZJBwDmiOpyWFo1kPMehuH/1//9fZ2ZN9133aRKP8tEJK55dKOAtlOsDbQHo9",
	"zgGxZev8UwK51At8JurKOkyk3rT6l+NTFzKknWHN4n4gnDVRVwq9dYTdEyZQLCnnHxqt3f1W6w+IwJ9/",
	"QNDt+eonh0odgcSQPm5odkgsxwcQgnzqkh25dbbBfsoTrfZxG+XrbrNVf3/py9BNrE+HeYubtSbF5C+D",
	"iCuQENL4P+NujgtjuQcgJgznMP16CsaROVVJ5ISLl0/UiJ5i70U+Kkj81vBAN4AGKuE2nwzc5gaRHr84",
	"VMM1eNz7KmcuybjXLuP/Kz2dpaez9HTesKfz5r2ZH8hBKQXdt54VOOzj+uw+pMuudFVt76r6VTkEfkt2",
	"+es1TX8gq6y8PAYpXFhowovslYEbmWmNaZYo0yz1FHKf3M9ri46mqXbyTZ+tpmyw3WzdjMUwf/alReoj",
	"WqQuZ1ZIsaucs1Cge3xCFgkT5/jpWiSm3xOy/P/Ze5fmNo4sX/yrZGAmokEbAEGQ1IMdE/9/GYRkTEsE",
	"BgTV0yM6qCQqCaZcD3RmgaLsUYTv8q7v1h1h9V10aCK8csxmtvgm/iQ38pzMrMyqAghJtEV3Y2WLqMep",
	"k5nnfX6HJ1OiYfHk+jEJqW8thySqTEITwCizYmRDfySvK2VgEbkckiwmZl7e4m/U3X1ljgzchEZYyRxv",
	"6BHCcacQ/hTKP1nyngrfT2ZP0ilfAfHXLVTVGkQJjJ7SCZMSAG9ofM4NNE/ug/kboWG8KOGhJIR5TBbi",
	"E2WP1pSR5ymUba2DWuQ0AYz8CZWpxIkoywnQY/UUQ2GcnsQBTBkTE9QVyu5sSkwsAVS7lR550676+iid",
	"pnPFaaTIEmyeVNQKDo7CPyJwwoxf/4G9HrEpl5l4D0xJLyJH87E//hAuz+tfki70k4QurknaMJXjBcCh",
	"F5Wo+S8QM9/gDr047HfHL5S5/aJ/1O++2Cy8s/AF9ViWNlU6H6c8fbCgxYb5X0rQfoCM3USeN5HnO9FP",
	"9wvXuYVzAf6RDwD8yzSebcLgmzD4Jgy+CYNvwuCbMPgmDP7brIt/H3thE5PfxOTfLyZ/R+3dTXpgkx74",
	"5asOy0bQTVF/E0gvQxlK55ciCvEFT7i1/8v89UYjQ+QeQim2OcBNDFCJK6Jc2fI8ihkTPA355AmPeXYj",
	"4tvQvxqR4kS2IuSY/+uAVCIBF0sOrxiZUSkB2E8ZZ7oW+BPAAX8UGHClHcvAGIUQKOQVvBmhIAOtc6mc",
	"QNjhEp+gLFeDhqi5hAjVyn7NH4vHCU1cFOvOuAFq4q8WTM0LGFdAGO822/trQRj/Q2IWpxmNgihKX7Ew",
	"iGF2VNmMgDUwA41xR9OMJ1NuVlymsRMmzdJQHV6Zh0ZNl4vegHHpyBSn0Gs/qGVcJ9wGsNXkfAZht8I8",
	"XubO403YFM6eG5vNJ20YkE43dOoMloFwXWunU8CnfOjBU+752wX2y05j596b09OW+v/Om61q+FMHJBoE",
	"0E3sRkAaRbX7MR7+ppksARCG6Cq6cErIQ5u9KAx7jynXcKBwa6RoYtW8xREQRLCXDOGBlpJUxdFfjqVz",
	"yQZXTISCXmQOTy/oPMpqB5mYs8YKc7+UutR7MZ1XSExkD5mJxbsmnYn0Su3Y+uSSIQOV2KbRlpJ7cl4A",
	"e6Xeg9ysp84vWd8/lepmm8b2mIlfU/QzCpZEmSFFHVdpE7iPsHq9yrAy5sBIfXYV1vTGKthYBRurYGMV",
	"bKyCjVXwaayCNx+l4MarJnkUcmCCZrQpmfrSqmllLjMM6DqcFcH0pC8AQeRJRieZ3ufD46FZEzBIMNOs",
	"WJuKkMUFfPjTpCdlYWiPzh+IxVtvLI9DniC6ITbCSJZdOKtpGybwBbfzkJqRbdRUWhg1LgHxHqaGQeOo",
	"JR2AtyWZUEEnGRNMGsLCVJIEjnvGrjF/MuTXOZy2EuXZNQ9Jvff0GbnXabb3t6Ct9uCJYhs07i7+R07m",
	"EZUNxY/f0d8RSn73ze+IuYBy/4LAXHC4+HHKM4j2TXhMuf69Db8//F2Fhht648gmaWJHIhVhGuCDFv8T",
	"pnmdkC0QguzbASGnSZM8DY5OSJMMzKcu22+oTMPyQKff43MO+93xbTynf9TvrvWcikeYYGkquEG7wMuA",
	"GUopLN6Rzr67C2h0QZN5vHgn+CSVpP6cNr/5z6D5H/+pdOeWpik4GQ/Iz9/9n4/4uqLe77Xb7d0HO/fu",
	"ddo7D9v3O/d29vcfvr738p4vgnb3lw0f+HansbtfPW7gmZiVDeEr/ONH28BF98HToQX0kMXbK8ZlyRye",
	"Ruk5jXJjuBCcRcdGsxg3t6dsXIdFt9+CsheQx0QCGtVGL7eFuXqYxGmtOzg6PnnaOzytle12KFbg2esl",
	"ivDf4GdI9iKBoIpSh2NF/+o2yXW30067Kvq9ripfh9UwXBMILowfuO0V+JUMnarse9lNq9qZ0uUXl1Dx",
	"NGNi8SPmijOlVpJyFsboodImC+nrmzzCQ5xvFacJZjNWXfsULnrTqL1i7OubLv6juuZNo/aaUXHTtX9S",
	"11Ty7eZ9ps+02VtGTOQ6eA0z8pNujoLJpoRplbX2R83zYmGUFqvCRG28EydZTFGD37R3lnm82rlNdUdB",
	"Q9k9MUtSqexAZeBMMKlYf+FJNKwGLq7eiy1nvmquwGRF5c368lF/d1FfmPWnUksFXbVqUpbzmGr2tIri",
	"LuYJj+cxjOf5cNHnO43OsiCQpVoXMCQ+sWT6kz6f77WvoDx5s6uqdhWhSVrYUb/KllK6At+uPFjArBfK",
	"8AqxthrGZkM1l1fY74X/Xnzirbh6+FmxJUd9hfI1lQG+eAd+ST7ArDgJDNLxUBZ4pfxLfI8fSoAiNBpd",
	"pnPl0AXO9d5l9ubFOxebJb+63k8yQUNOwawfmgvG5oIGueJhscpxy46+o7a/K58mi9IqP27UM54VuZ90",
	"dttpMiDl2WFLZrfl88Q+weS2G2dyV43NUgzr581UOl5wAedNnagr6u+ViP95zsMqSvItZnGnUAXcpZly",
	"bxo1qRaTZ6+PYdY9SM6jNBmxkAs2yQIcQo74cd0U67UvovSVaRMs/+r98UREtYOaiearnyQTV0y0NAO2",
	"s/RrlkDRRzrDt7NEpBGoy4P8f5VYqA01FJo+PsLOJbbsn8dEYNOVbYxxSv7yeGutUUvErDmxEFS1bnlo",
	"huu1MPVgYIkSwdaQTGcs4WGef1OLTm2UV09Oc0pN84OvNzmWYc1EmqWTNEqN8NY7ER+vXmSPXHNmm1Rr",
	"PcW01J0Loue+YZPi4gco6g5MLycx/a0t0EOK8WsujyvB1UUd9YCB2hudyg3ii+9H0fw6JXB5mVbkmNO/",
	"OEsx9qf+IJw1aBFIzglkF34hRBb8VSFMsV+t5KQ8pgfKsn7RzfsJNoTexAdu3680R0ZvEQhc4aMrVUYJ",
	"ZGwiMM+FYwSXits82XCX9ygOOeoKBp9OI3k7e9SoJoHDeJIJi7wdSxiwEX+213p8lmB+zFgCNqZ7o3eV",
	"fbfEbRAzGa9q+k1DbSGb16o7cyLVv3IcQoi1xGnIItPFa07IpIpv+V6/c+v9BjpnLlKgPYX8AyiUmHL1",
	"yGnWhOTghaLl/1dH6ZwmX/Nkei5aqZgqnUBj9bzH6RUTCTW9joMZS8gjnijmkS8ElTwCc6/npq//m8la",
	"ozb3aHde0TyH+1o6c8nTbSoY9foBtrFbxKtbHfbV0vb94zesBhpoEMQClYu3VywCH+GK03Pdf04lFvnm",
	"Edb14AtIfciv3b8QRsaF+oV+krGIT5VmlVvGpK3gmtO7rgSeMnOpxDy89OXKTLArLjMqlanm7qX0PAPH",
	"b/FO2W6FwGBeceKNNGBJOEt5kql3hCD3IKPj35xAn3ww7IPl+E9kILg22P+bydOkSV50B0fj4IXisrFw",
	"Fz9I17pGvmrzWuapWvDPJnymzEC5ZEP9Hl4xDB6PBze9Ij/2Raat8R6dv4IjJHNLW5oxYYmcxylJClwr",
	"iiN0waGshyuFDDKBlOUBYaT4JGeboV/DkFr/iRIfKbXCI1UP1y4FLBrmSwQaCJRwJSectrKQGTuQp4n+",
	"Vjn3C0XU48Ymo59XcyiOMzxZ0qSGUbZSKcE/U9bhdM6Liht60FjEJhwdGcnQCg3gtmwOy5eS6ZxjWzeb",
	"zgWIHNyAhR0I+VIO4XMBTC2tyHL8kSY5tLkY9Sl+eUzhIByQoFA/QyWZgAqYcEUBtAhT6cQd0GP1bRy0",
	"xf0jlq83uoshhJwgmVZVXuRcTjOevFRC5YLH0PvB5mTCJxGGgHUi13QUsoxGl9p7VIv8PF68/fOcJ8Bm",
	"tSphKvMCI7XBLvCIaBFNs0gtLU1aCcu2X/Gv+bacKZWxPXi0PaNTJrd3Hj7Y22nf27sP452bpJvz54AE",
	"Pr/qnkl5NklDtmWZmJT4VpXtiD232ISjlG3hDnfOnZX5uVQnAQ6WZ1bmba1gOV8IJi91tZ4jZFvkKUWU",
	"ZO7NUXKhiyOefE2ePx+Ov6pUj/hPTqPmVNCQwRE91o4mGYr0gkfQuEL65qQyIcmhoBcZ2SVNsvhfgoHu",
	"PXQ1JGlWvWvp1XVvJbc+cs0fdNr7OzsP2tvD8eeKjM81GZ8jGZ8XPvnzYNj/3Hzy5/qTP99ptT93P/lz",
	"+OTPd//pfqvT6rSax0xc8TAVzZA1vY2xpYXCiE214KBC0OQlVBmcJkFJ5DHTZIfy0TcbgqKCz6OqUyV/",
	"QQJWvEj98wuaTFLSZUkmaNSAk5vbmyxRKk/vbb1L6Dnl1ymUCTz3boanAfPypXn16lXrfHLemqZXrXOB",
	"jbw8gjCtXjEu6PaMX/9/cRrSKDhnIkv/RbDpPIKPoxOans34teFXLm1RRL6OUhpKaETOSzVuYlGDwAHD",
	"e7E9PJF0qssiM0Ev2JTGJIOW9BmiNhlgIDf25hvsS+ucdG/7igctqQeLEVfaaCb0LoYWQcr6zNRlilRS",
	"wnxcg9AKk8bfGaxg9vrai+AoWbMDhqnIcKX93le9PF21W9KIYdmJok+J00GF9QExQF/LPe6NidoK22Xb",
	"YPvbcozyDWGrbjHfOZ8pkoVFenLUHJ2ov52B8USYyTimgsSMG5U3FTTJzpRjAvBIfGaMUq0UwI+CuqOU",
	"pDMnQoFwSvDoK55MsJ23ZKbWL1+fCx4S5aNttRSzYH3ZFVSqXdFv8jCyWz5VLHS7gswpD6lwcJ5sMZB2",
	"GZXNlDElaWlK0Ifuh0ZVC57OCdPK45JC2/cVE1PtEygbNktFAjxhQqTky/F4SPbabbP0ARSb51soBkis",
	"WUQJjRZ/oyEAG1mDjPpXG51owycS7QhMgWxDmbHO6ugFNeWQORcYYbEGF7lcvD3nkVeYgnEmiOc73DHE",
	"PwPmGXJWobU7VsxqdHn1ZL2aptaNeA+2ibIq28pDwIBwpVonycgFVYfSc6HKMTNNmQtpVhYxjZIvpiPo",
	"sNfQsRIsRyay9nnMQh5ScsUlVR8/S4Wuz1v8UCXJaNHucEdKI6mhsqq5yK1h+nIOciypAMtHUAWUUHBi",
	"gmjxDjpuZaonRFiGp1hBmKlPy1gScju01JXW/kZqACNQXFkPUzkhSnzUh8G4+yXZLoXrXBFlA3ZvtrQL",
	"ZEvLFj9K2xaQV6UxRIbQ6QzZMKauX4RuUzFS52IMia7pyEoBqUOd3lyxqxtkpWrDVI5eREGyNMTxInr/",
	"IgKEoDGJqUB3HMWhk4lRTldG43NI9nl36so4KOqlUcYEFXXIMaOJawrp5xoxRt241bDPsnOq4M5mpJgn",
	"USPG+qkCNgnkrn2OYiExdnCkItEign4DXGTXMy6WGfFsG9KUV15i16tRNmVukTpKeapdNggq6Fzkpaba",
	"NCyuN8s5DT39jsAwN9vUoMw/cslHvA/NLyGe/ZLGS6i31YxFKhokpjoyrXw6Z/GAvkPw5RiGcSYsAbkD",
	"4dF8PzjGZ8gx0llhj6bga80Wb6faEXzeWyqym+T58bOvlhmDH+lG3N95sNfef3j//pb6wOOVxwzyjnmG",
	"4Io7Qp7UAboFN7092+8rbQp9KurYGrvAbyUzgX7bzsVx8r2yHSMo5tCyuCgoQApKPk3AYjT5kChHvXRy",
	"4akgLNInfKYUlMQhKdhipH7W+9o0qgkmKzVyMX3nRJpQzd4A8jllSUjD1Mu8myIQSUL1j87DBtltk3RO",
	"dncMnB2JF/8FMS91iYlh6vYhPcM2SSGWxCbQc6+uV+ojX1UwzTQYZ1VxPBLhZZ2xTjtPtTupfNwdihgM",
	"UUFAEatETITVpHjcRyrNfcy8TBHW/NjNgsuITV1Q3wNf5tDgTKZCyNEQNi9wQa1DA1ba77NwZIsjgXVN",
	"SyHTXurvgHYZjr0FawllpcO8SeRuIwNQBAUS0KKVwmo9GoyCs+Eo+I/B2bA3etof9w8HygROUh10Yg1d",
	"uyEnwqmGpnNJW1XGHULZUfKSJmhR+B9p9puzkZWgNbtT6hfDijSqY4KlCUanNXc2kYT4JNYUGTjgm3CE",
	"T2tbDXM643KlfMY8FNmbNGOe3lQf29k92H94sP/wktRPxt2tqrOt/pRbKC+VHgZrdWk6w7ODrlwpAeFY",
	"37hcWS9jDFSmVZmpB7OhR33MxIEicqdFPvvMk0qJH7O7cawTqZ8NB8fjKnF+tvXZZ4ScJoTstHbIZ5/5",
	"sWLMF3FpriHkdN5ud+6xRM5+v9NStxz5GhmdNROSNNFunRu02qUQDjTtWJBNMaJ026Rg6uy6pXg5v+AT",
	"ruvYQ0YkjQCBFjjpCITt8yj985zRkCJSXAXVnTLV1vvzFtZzfmGltW4qERnanbR8ZVqG0R3y2WddQF1W",
	"u1r5tLbXSJ3GxQ/SVptUhEXKSVDg0IQJI2MbXoChQV6+yhpOrGZryXJ2Wjv5CcHN380feqB/KzXFOi+2",
	"To9hhxssOuyOSBO9924aMrLX3iH1/tGz4En/8Kz7pN87GmN/SwVhnSJhAX7gWH3gAXnGBFoF0v/FqQAz",
	"cFVIX4mOk6PgZPzlYNT/j97hUip2i1S48S9qg3mWU7JwhTSXJNJoO+kRhtV/LmltUv8iODw77j8+CsYn",
	"o95S2vZKSxdRHku1NyawIjSj+c329tjcbtdeUY1aoU7nIdhdDcJpRhh5mfGtwgRHzUhdUDdBonfhM5au",
	"bcXLzfoSwea4W15mvLBKu6Un2gO1WzpQkieZiUur4xMv/proEKwxp8BZ1AIrdd/U6ZAmOUn03qXnESM9",
	"KAAmdZ0T0m2kttdNeQI+/mS2eDdJ1I7EmPDWgTpzVSu3C2L3OCc3P5wFPu2CvO2ZSIn2XDxf1915RWfZ",
	"d4rRbc79J1IfBqPgaW88GpwdBYOz/tGjwehpcDhYumy7IEgfQV+4qy3F4q8xU8a1S4zzZ/el6TkL2QQA",
	"/i/cBzlzS6lLmV7/wRLJvguS9Thf7BW8VMLOIEhbFe+dXGswOkWh2kRdvNMnwFq9GBvyS5qsTURJ/TAY",
	"B2fD4HHwtHc0th8SrOCuEnqO21pNpFdMb3nsFO5qDoNOMZkYaPde/DThKakf9sbBky97ZdIGK0nbJYcs",
	"prygLrV/MkNbGM04QwqVqKbkXM6UTQwBNUHnIds6IPV1t5ySc/2QxbM0Q0vAZcbl4q0XO9bgdoh9H4Ib",
	"kt9IiqrdCuR6b6S22mHv6XAw7h11+6tXaZ88micoB7AJALhwCdkmZfofkKDK9sPBE8qenCiDwsxVIIkS",
	"OQRyUvi4+qOTo25/cAT75bAHp/PL4Iv+k/44OAzwJJwmHWUkVq0Ju2aTeQYf5uDuadFm2+EXPyYTkSYV",
	"1mQh1g2+Ooaw/KKwAkSAl+O1dh9kTdaMKdwopzvtNvbA/gGnXKAKGvX+tdcd9w4J+oPQHjFiVKaJY15j",
	"ItFIhw6IYD8S/wGsqrSqOiC0Hymloa1JQZnMxFyZBAdkAHp/Tmg0NekNhJ2AQLyzbXx7itpo8go/oP4o",
	"ePJloI7VKOgdj0cn45NRUGk/dECUjyGDEbJikSl4Xcr+G+RhjgTjBckFFzFE9wphSgtHAnenc1Ifq+N0",
	"1vv3YX8UHA7OgpOxMraCbjBYStIuGWn/udAp5JFSkDfocgNC0Q0FEXW1VdQhGpydHJ8Eo/5ySvbIUyiU",
	"xKObCj5l8bbyaXgCdS7GCQlRYxXbmiAZNGHn+sWQXsLKS1dHlDo46lAodnw2GPUf956eHfaOx/2jwVn/",
	"8UnQP15K6z4x2OOGKq2qKghNckAEVqzqK9IBggfDFY66WErGPRIUqqdBMqs18pbP1lhj5KA6cwR0QsMH",
	"7qp17nZkEcOWH8g0lnyyenAy7h2N+121F8nZYf9Zb/S4dzTWpvZpsvvriNbGB8lWN8F969K1WZKtzwZ/",
	"0KL1So8YqJatH2Ept4wcRcu4ivFrcPugUhqjCX1EHQvpwA/4fqAJs9SCKby8Q0bsCkcNgJCw8CPemchB",
	"SXRcMZ0XaaJurJfCekyXCjp2faDYrAxFKxgEzdItJQOfDR4rETjqdXtf9A4Ho6W07xZo16Fuj3IT/l5O",
	"9w2kWnqMSNb2zd6NQbBcXjXJsT10JvJVXaqRR7/2YLPduaDMHmzYOxiU2YPN/KmDMnuwLe9mUGYP7IYP",
	"DsrA7Z8qKIMv/6igTIkX+8abdfoeHdsk/06sIa8KFwC80Dcs1h15N/XmWudW6fdg3H8WlAIIexWx2DsZ",
	"OqpgqXJbnLjRkoXs3GbUSGKFxocGjZCaOxU02oM4ixMyWko4sJtGodcH6AeM0Lr2bHrMcEOugmAGI6/g",
	"cgvE8k17HDw5VEQfnzzqd/u5IbqEqA4xKDB+bZF3onQ9xDzKBIUkOElNVZvXXfA8KWat6trlgZYvGm1t",
	"J7aO96tCydMNUEwuTCGpPwueDEZnQbf/NDh70lc+xcqvBCGfirLZpj4PP87AQ9jYnK1GKyAn6mxTasDY",
	"NN+RohuiX0jNHjlG0dr1Gx5cjhccYl0+AhMyY4NXoXsIyAVO4vv5u+8N9NDP3/2lof6tLe6fv/uLWgL4",
	"A4Y3Tmvglh0rz6Uct1tO+v4nCNzhm++Rw3JszgmtFrtHiorPz9SjR+mUpcn8soJJmYc2c9/uzOPd1gqy",
	"75MRm+CcW99f8yVVPseCQ4dRxQ0uJaNe9+RYmbmHPaWcBqNgy0AIekl/WzKA0GdzSVex+MEtBozpLcWL",
	"kbKHeRFUzp4kJcd6bIhfMt9PZEaTbPHXhCklczzsb1UyT/2w6q077bsTLNYU7WhxbYTW9YSFpvjbgHYd",
	"kEcpzwFjjfQ2ANs5RJUfZkIoFx9ex6KA6frkpKLV0ZGBKInPhr1Rf3A4OEOR2Pv3bu/wpgXeMXoImw4w",
	"dK2/jha+LnCvAXf0HN0oA9s2z9XTcrSg1UUQxU/5t5PgaIwBdPd7VnzQLikgObAk1C1nfmTxoHAhi5Wg",
	"HgajcT948uRPZ0G32xuOUYjT6ZyKEMejmkJ01JW2al2asnVZlPDD3tEhCK/K4GnVN+yZRUGEQ7vdlM++",
	"XEE52MK57WAb9A00mlk016qg5ILya+rAwesXq1uUpFk1Dmit9cQtOR6Mgye+DF9zm+4bjhT6Zn59zuSY",
	"cxbxMK/WWsar5H2YNAqOjtUe+SBG3XMYJZh1taSVSwWvQQNY59eVitByEKyXi7c6Ae0U3hjic2dtPULv",
	"K3cCmvawWs/KRyVoPIgdrHdz9bQpGL3QT7DVZuk8F565wDUVpakeeEwnYBCtLPaqVxX7majWfmVUyzYp",
	"ebL57H27lM4II6tuyoNf+79y8Ks61rV/V2Nd+36sSzPgFw12QcHivdtLPDhlv7ecdLj9bflhqYl/7Y5J",
	"fQQZXxZu3Zz9vY2AzL3bz1Dcg0PQ/OSRhgJJHdL8+4szFL5xlzRvL8oQrhVbKFCwR5q/jnteeO++eu+d",
	"dc6XUX2PNO+qb16g9D5p/vL+b+GdD0iT9JQiL1WdFMEQj4f9vBBlHlMAG6yoVnENdf/2ykqTldQ9XJu6",
	"fnf4MdT1u8PqQpizfne4lLyd9g30xfPEFjZga4ceTOEmdN+T6JufueRLhsfDG9K38E07y7+pquZovQ/Q",
	"Q3Kqq5WK2s8XipXfkp+5pd+hdNEdj79WE75rlehvOvpT/Ky9/LN+U7Gf6q9RunDMs3lE9dj8vto6UjeX",
	"QKxHSZZ8KDgoZ2eiUEq6w0fb3aPhv67TmtMy3WmerwyNaAmMks/H3oysGFDSAZy0L3rtnQaZ0HNWPdsp",
	"nodg9Bm827TY/wdmMzxOGWsCLeX6uD8+eRKMkGX9I7XP+8fjlQbijtLG3QJgAVaLHJCBa0rIjF5RNwtT",
	"xiDAvm5un1A8aqZIZDk19/M9uXboS/4dhb6K/HiQ82MT+FrOpod3MehVdMXav8WA19Kv2blTZSFLyex8",
	"0tRaZW+6UqPo6SmXfBWUJraqB4B5x8iUKqEDjjQWIWeuulNnPTbo7U6QLyyOJwxzAJpV7wYgKM+b1fEX",
	"L/DkHAnrmBV7ZQsBKTuDDaaI4ZQ1RThgHfDpnEaE4hCwdA5DvFpeI8ZwcNgjc5w4Ggz7oLsQV/cZgCap",
	"BVE3B8r5KoCX5ZhHiXICrW53hZmdTYEQufx8DniK+O0xS0xs9UDtt6YbPQm9O6w7b+7FGpzpXFmslLRh",
	"QlucgiLV4E1mvgHgLZp6NlMbE+dRoblMAWbjSh31G7YQ4fGMTjIGCAGTVErtuOJpaZLBq4QJZZVzmfGJ",
	"bB3PeOuRovspFV8zIVvBbBbpmWTwd9kKH7bXvvvpPGIBju5/vxuPJzSOmfigewfZJRMfQOxJ8nWSvvI+",
	"EzHKFm8j2FlWF0rCdM++zK10WJuVa8HKkE+KMHMPK99yQOxK9aBROiaZWPyXBFwx6RJUwJYq0sE9sYJP",
	"7IrFu5AD2O7K2c8HBi1j2ThnE41+q6Pmi7fNyDGSCgLIbxtfh+CWodiGMkuYpRaiIASdqBsknIgii90T",
	"v9wmaViEIBhmwWz62DwVwbeM0m3hEg7IxG6S1PH5+OKnEODVuZylyeLHKxYBpJsmCgEESOjAc8Q0YVwg",
	"nqnkIROI4eGg3zQIu2bxLEoRacRFWvhCULn4MeIuHColCfQ4ao9fR8v7xwPy4F57x8BpOeP7IIeAX4dS",
	"Luc8OeT4rvrQGB3DncMG6V23Dsjon8lOu91ot7cOcNSGZsMEIf6o3QjOKjv6Q3FZGPYaVHpOyYRf8ajI",
	"DsdJppK02wft9iVkuwBA4rJFhuCmA5sA32ke5zapIYILRfO+Ihnu3YHHIDAJ5QlMkVGb2l6UryKXSwZ5",
	"AwadIQNijdD4EvI8yGiZeazndbnM/KPDzFbbsHNgsez0LVRZ7FNG/GhBPuVKmVSziGU44JQt/gZsUx+p",
	"eRVa8JHmBUysAeAOZQWZC/NPCNOYJ9PU21OhP/ARt5jZVO/D/g58o/ITFLP/lpMDXDe/SXad6Z/c9TFi",
	"x3vkLt4FS5FCjChyvqJFTmIfzC23rhN7FVm8Q1V8zt05PZa9GluPJRMmILb45znA2VQt81OWyMIqPyXu",
	"mcnX2T02Md6mCKGRRoMMHUhCmhIoPcHd5SMQAe5ZxJJQw/l6y4FxNEQe8jGeCiuj6QLcLDPYSH8/LM+u",
	"c4FBssHfq8+QufzmY6R7bCTCTYWIk1TmbACDyVzG/slh7H674gDhLDONmOpwU7PwJUjfKuaG7BsWn4vU",
	"Mpomq5i8cs/bJcdNGlOx+FvaIJBAUj/vez+/nCeXyqUzP3f8uyXLgDDkuVz8VHUqNGyWuwrF80GTtOVY",
	"G1IyaY0L+nIeUuWjTbWVIqqEuTJ55wmAumlfRckSC9kHEQsKaH6x4j+aRE56UTrDG61+JV31T716i3dg",
	"+FqdDH8RLD8gVkIhGKLG2XIBltBWk4wIhj5Ji4xN7byDs+SkqJ2BVgwDb+mcdIOjrgNEY7WT/YrUtQhy",
	"TpawZZSNqRhesAw/2PBb9pw7Z/AVCG0Rl1ITzildpjwsGGBCFj/kx1jTeWDuYzLjM9wRuXzR5DRyyCme",
	"hPyKhzYknG+/4pMd3ZeHAAAGjlkDrAzK7X/NTWZrXVuYW77h6rqqdKXhKrXZGs+EOgDQTy0Vn8w8WhO9",
	"d8YDFgbo+/hhRRQ9ZyrzBb9OdYJbYgxQSi3Rnb1p5kDj/ObqsZEYB0/QEQapU0YxQwdbvZNQnJUD3Ob5",
	"uXI8c0InPKaOLOtSfQ6ptF6bVucFM0aP3QCkKjfm7uxMM7n75+++R5Q0Xf8y0rcySEFp/D1WHqQxc/PJ",
	"GpOw4SD2qVMHgw0o4IBHwBMyw3xTAadE09si/QqwK8nmdj6mDeFrYEWJ/uhy4ozLhd+sDdUDEjjmpTIq",
	"TUWLcIdQ5jZmqkH/TCDNzqO0zFsCMWch6rbNirBjM7vy5+/+AoEcbjQYvCNmIae2WVWP29M7KrfBgQLg",
	"rvG3WqSHKttkOzBPk0xYCVAhwUd0HoKhoJUyrQJTVJJl8eOE4yFV72uY4I6GgCyc3MU70tnFx0aXaUuR",
	"YgwTJBdVlc6Cdna32/ddHnQebrfv/56k2gorXL7bLlze3t9uP2gQA3o7S4X6MGAGcZcdDdcDjSannuY6",
	"EL/G4nqe1HusM0AyzsTiJ8CsBRbe1YV21xe6+PDdu8RzMPIfOi0N+A7AfMbcTIsbRjJh64HMful0YN3z",
	"bZL//ED//HCNbTFWb5KZUFtDZ1WrDr9BB3W7+zZ75KP3SFM3e97ONtEBKH+f5HKls73TLqz+Mdssfnnx",
	"G3+fq9/eKaw+eNyrV35z5n/zq35frzpkP47BmqSl+h/PRvdx2HF2qDxNAK71cvEWzXRjn+YtCjBF7P0f",
	"rGmfxyYT2h8PG3YMDgkX7845VL+6GdIWecQnYLFSMU1XzuYxBRKiYbwpRcbLeTSlomKwpTsnIvdvGn51",
	"CMSDkvSqyv+3XE7NgE6bqEjSq1KlQqEWqGKQyJHGXcorAmgF1nn5bdUjrh0kZQer3YPBsUldp+CkVLVW",
	"f185wOWIZeJ1MJmwWcZCJQRgTsTP330/FnMlFLaqfUqSzg1BaT7N20LKG3x1syL+lPIAEp5w5qhlMvXK",
	"HPTIdzOnqXgBizE24M5ha5HF//bXIy8PLS4ETE4qrHv1M5HWGEp93OqEwvMqaiuciEaOU1+qlC7OFfBa",
	"P8zkVrcEGgLjKCz9D2jkbEvnlV/TcA66izyvSwvQbdUTWQs7yXzUqNS2ovZMgrXbQgKufa1Ri/iEJRLG",
	"PeuBr8GMTi4Z6bTapRmur169alH4uZWK6ba+V24/6Xd7R8e9prrnTaOW8QymuVcPtyXNqil5tUbtigmJ",
	"o147rU6r3RST1o56XDpjCZ3x2kFtt9UGqmY0u4Spu0v6b9RPU5aVJxs/XbwDHQHb9HwuJ1RUomNjOd/L",
	"uZYF7jRJU/QnsTxCadMyNhnMz9RTVpTsSTEiFOWnLYdmNeqxLo2G3yJMx6LrLAnhL3q2lCZaD19xa8+g",
	"pyrWkPumiKcU7MWZxoCSpzgCU7HtCpkFesyyIb8u7h8JfIfqNiZk7eD5t7V/FuyidlD7p+1JGs/SBNql",
	"8ku2vWnotTeNG2+47s5llsZMnEgmgilLsrXuekRnXL1LMWrtG8yr+rMgDAWTcu07+8qiohPNvzXuqphF",
	"vsZddjesc7HeJutculw+1N581ajpsck41LrTbqv/VD3RXrfdabfzZ/HroYkBUvWZtb11HvEFDWGevczw",
	"lp2bbzlJzChRpt+ze/NNj1JxzsOQJXjH3s13HKXZo3Se6Ffs33zDU5ZdpuFRmgVRlL4ytN1b602o3Ol5",
	"pBaytr8O5/pYyRAdw1TwnhCpwHvX+LbHNGOv6Osxj1k6z/7Is8sgDHkGRRFDoYRExpmEx3Ue3vy4Y56x",
	"vhxcMRGlNMQvD9kFnUeZmUGuTvTBtzWa11Ftv5RKMH9bk5NLFtNlb8Ff5fZIv01/6JvSkPAews8qr0vQ",
	"MG3BZHSpJ4+C0Fo6Bf951Qz3r9SZkPM4puJ17aD2BUhfX2MUm/eq9QWY98Uq8VatUcvoFF5uz5BVlLWv",
	"3jRqs1TepMcKljVdOkyzRUY42kIRUm5rbd2sGoap3OiG29QN/67BXVgyef0H9lqLYBCFX6Th61s7OF3B",
	"aMYq5HTVIRriANTS7qL+XBk3KzTk12r7wAw2wcLaQSbm7E1Jneyso052SturH6qNt1EnH6NO9jqdddjg",
	"wP4h6l/Fcd9op19YO3nSsZuGTCkInP4Ph6wAj3xQYWE2qrVZ49vaUZqMcOZptu57ZrmYZ4lII6gROMj/",
	"F96XiJnFay7qza7gdLVqukkTvmnUliI0LDdp32wLlgkQo2so0oIqXRlv8jQ7fFm5ZQN6wGh0mc5bpHc9",
	"ieaSXy0LVEGYcWCccx3dgyc4+fCKiJSe0uYMKq6cWqBngC4dH11/XwgMhH858qFeCtQnEH2NkcWN4sdA",
	"u57/Pf5k5gs+gZGH+hDjdM1Zagd0iaphqNiehDMV8/Cot46t0yTw2leK67xkhDslV0xAQAfKzwSbWJR3",
	"H2wDMTbcygdKFm/1WH5v9Pc67vgymwvigRvD6wMNrxnNLgcrXOE7a7rBsr+H/VaOYS8fHkkdeXT71hxS",
	"vjHp7oZJl4nXG7vutxF1AOtpRS5qmUnxMTZVhcq/jai6Z/B9WBzaEHS40X0foft+mfCvFe6b8O8m/PsP",
	"E/79KMcWspmTy7JU7UnpjBu2np6G/sLyfMhsi1KXAXYwZOwljW1SkEpb6CuJ5NlcXwxdEQGO0cYZ33KO",
	"cJP14+6Xh1sN5W7lUyKTxduIS0bqw8Ojx1sW+gVMRckd6Jdzhk8KeQh+ncugK8ptE5mm5P+m0EfSAkxR",
	"3XJRBfkCz/baUBSV24oakuohdBR6fCi6eB5AAY9nUKvtVxk0ih+AGX7tZpLTBHAbNV7TXqejoa1gKEmO",
	"dODOFlOf0nuCPzifBGUOEH3f63TUW51CG1jgC/oNw+ywR49yzpMS8M2VxusUPhuNqx+xBiwClImEBvkh",
	"z18jXc9HTGa6yuErrJlCQ4K6k9J//u776gqVn7/7iwUq+Pm77229CtSjYM2IW92hq0Ty4hSLoODAO/pL",
	"c5pgL8eSepHy3Hq/4MPWyHUO2m1S/7KqQ3iLMDNIAR7pltUtvUVXmtn6usUPNqPPLpiy0coOlvoaPTbH",
	"zLOfGMTatapcGiRNQmYbPxw+AL6JEQgNkuniA+/zL9dK/w+VONoYXr+m4XV3gg1m8VdEFwIlX9yRlDks",
	"5Mi28awTPvhg4xKI3FiXnyh0YLm/sVDvYKigUMVaUo5Lg303RgrKUznXTKt4SZWbwQSdGoUX5cTWC2UI",
	"acMw+GPQH/ePHp9p1PHjYNwfHK1ZxjAqPHpTw/Abq2HQ6/Y+BQyl6bVULK9puKUIeGmffWDc2+xdu103",
	"yuzDlZnLxI0au6MR7xKmagm/oNCnXanFunlJQrUWq5wtfUsV5KtV3Voh8JL8MERu3LBbccOcouwPin8v",
	"XZ9N/HsT//5HiX+vU9bsCOKlMW9Pugr2kmHnIYJoQysbCwEfdA3xCoHtHdKsRATxZrgfnCZNDGQ7QWto",
	"F/XfYcPW1gPx4PV/Dwi1GJortG46EEo/f/e9cVcQlD+vNjJY4RKe5HSSOa5asQOpgHdtQv8QCMagvkVh",
	"gtiMqOgatl3AIaeknrcyW8Cv06TgR3rs24LYtcXBjaGFNZUt7wuW0DJb/CQNrIsF77NIUujMhgDBYsfK",
	"pILrUitsoLUzWvy5/BVFXKlUzuMloyETtkgrW/w04xNooHOhiQG6hmcsJrvQl9pZupFYyPV+U0QOvJK0",
	"CjwgczkBYC5bh1ZNrlvL9zziyddf1U0vXjpjyQW20J1DB12LZhGVktOklbBs+xX/mm/LGZ0wuT14tD2j",
	"Uya373Ue7Dzcv3dvfws3a06N16Wm48sszsPTFZZYEY6qXkgAECYnaXTJsf81TdjgggCE9EuWAb+XphS2",
	"zEZGVrDYx2+XpP4ipBlt6SP1L/9C8iP1Aj9tAK124NHBKp7WsD1yIpQESYXcTmjMTmuYLuHfQKWhIjRm",
	"/rwSFucDxVnEDBATwlu9blnR4TMI01QeWtN7t/xe8GsWBnE6TzKQExrAKEy3sNTRaWqmzj6s6Am98VUx",
	"vebxPH5GBVf61740/zyXJRlLLmkOHTaPyYxLW4Vi0AVxMzvoYyzKcyzvzYyYJ5UUumxpWPzpePEWBZqF",
	"kCwC9Vvqq5um67fFwa0C/HzMkhThrQ2tRRZZPrvMh/0Eug8hXwE1H0aUzLhYFt5gANjPrrnMaOyVLvvS",
	"GNJMs1RiJgskKVQb6XwWQqQ1IKMsfQy0Skl9muyu0LovGc/Vs/6+SwqzQpR3noMflPrxi0PQAVITR5dY",
	"0dAgDnqBReabXNIYUos2nQ7fHadXTJDKoJCZkbN+xmzjp/1qftodS5fdqYjkR3msm8Tap0usbbJqd9fv",
	"HaEnahxR64e+v+eLdKlFQ03gf4ZaTq4UV8jIUKThHGRACYaDznjrnCaTtDVJ49a5AF+geU6Tr3kyzW2S",
	"vJr3qgNCc/nLvkzjNDKuU9X7Lt//hV9ZVizx8mVRGjIy1a5r0eGoNQw6SQVXy5+21gtyQ6bq6Tb5+ear",
	"N/8vAAD///nI2qLbogMA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
