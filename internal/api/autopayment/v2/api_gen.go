//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/autopayment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreatePixRecurringPaymentErrorsCode.
const (
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOPENDENTEAUTORIZACAO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHEPAGAMENTOINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeERROIDEMPOTENCIA                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO                        N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOVALOREXCEDIDO                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeNAOINFORMADO                              N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTODIVERGENTECONSENTIMENTO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADOSPI                      N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_SPI"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETROINVALIDO                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeSALDOINSUFICIENTE                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "SALDO_INSUFICIENTE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORACIMALIMITE                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_ACIMA_LIMITE"
	N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORINVALIDO                             N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_INVALIDO"
)

// Defines values for N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode.
const (
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodeCANCELAMENTOFORAPERIODOPERMITIDO N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "CANCELAMENTO_FORA_PERIODO_PERMITIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePAGAMENTONAOPERMITECANCELAMENTO  N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETROINVALIDO                N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETRONAOINFORMADO            N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorRecurringConsentsErrorsCode.
const (
	N422ResponseErrorRecurringConsentsErrorsCodeCAMPONAOPERMITIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "CAMPO_NAO_PERMITIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeCONSENTIMENTONAOPERMITECANCELAMENTO N422ResponseErrorRecurringConsentsErrorsCode = "CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO"
	N422ResponseErrorRecurringConsentsErrorsCodeDETALHEEDICAOINVALIDO               N422ResponseErrorRecurringConsentsErrorsCode = "DETALHE_EDICAO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodeFALTAMSINAISOBRIGATORIOSPLATAFORMA  N422ResponseErrorRecurringConsentsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETROINVALIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorRecurringConsentsErrorsCodePARAMETRONAOINFORMADO               N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorRecurringConsentsErrorsCodePERMISSAOINSUFICIENTE               N422ResponseErrorRecurringConsentsErrorsCode = "PERMISSAO_INSUFICIENTE"
)

// Defines values for AutomaticAutomaticInterval.
const (
	AutomaticAutomaticIntervalANUAL      AutomaticAutomaticInterval = "ANUAL"
	AutomaticAutomaticIntervalMENSAL     AutomaticAutomaticInterval = "MENSAL"
	AutomaticAutomaticIntervalSEMANAL    AutomaticAutomaticInterval = "SEMANAL"
	AutomaticAutomaticIntervalSEMESTRAL  AutomaticAutomaticInterval = "SEMESTRAL"
	AutomaticAutomaticIntervalTRIMESTRAL AutomaticAutomaticInterval = "TRIMESTRAL"
)

// Defines values for AutomaticRequestAutomaticInterval.
const (
	AutomaticRequestAutomaticIntervalANUAL      AutomaticRequestAutomaticInterval = "ANUAL"
	AutomaticRequestAutomaticIntervalMENSAL     AutomaticRequestAutomaticInterval = "MENSAL"
	AutomaticRequestAutomaticIntervalSEMANAL    AutomaticRequestAutomaticInterval = "SEMANAL"
	AutomaticRequestAutomaticIntervalSEMESTRAL  AutomaticRequestAutomaticInterval = "SEMESTRAL"
	AutomaticRequestAutomaticIntervalTRIMESTRAL AutomaticRequestAutomaticInterval = "TRIMESTRAL"
)

// Defines values for ConsentRejectionRejectionRejectedBy.
const (
	ConsentRejectionRejectionRejectedByDETENTORA  ConsentRejectionRejectionRejectedBy = "DETENTORA"
	ConsentRejectionRejectionRejectedByINICIADORA ConsentRejectionRejectionRejectedBy = "INICIADORA"
	ConsentRejectionRejectionRejectedByUSUARIO    ConsentRejectionRejectionRejectedBy = "USUARIO"
)

// Defines values for ConsentRejectionRejectionRejectedFrom.
const (
	ConsentRejectionRejectionRejectedFromDETENTORA  ConsentRejectionRejectionRejectedFrom = "DETENTORA"
	ConsentRejectionRejectionRejectedFromINICIADORA ConsentRejectionRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ConsentRejectionStatus.
const (
	ConsentRejectionStatusREJECTED ConsentRejectionStatus = "REJECTED"
)

// Defines values for ConsentRejectionReasonCode.
const (
	ConsentRejectionReasonCodeAUTENTICACAODIVERGENTE    ConsentRejectionReasonCode = "AUTENTICACAO_DIVERGENTE"
	ConsentRejectionReasonCodeCONTANAOPERMITEPAGAMENTO  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
	ConsentRejectionReasonCodeCONTASORIGEMDESTINOIGUAIS ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	ConsentRejectionReasonCodeFALHAINFRAESTRUTURA       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
	ConsentRejectionReasonCodeNAOINFORMADO              ConsentRejectionReasonCode = "NAO_INFORMADO"
	ConsentRejectionReasonCodeREJEITADOUSUARIO          ConsentRejectionReasonCode = "REJEITADO_USUARIO"
	ConsentRejectionReasonCodeSALDOINSUFICIENTE         ConsentRejectionReasonCode = "SALDO_INSUFICIENTE"
	ConsentRejectionReasonCodeTEMPOEXPIRADOAUTORIZACAO  ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
	ConsentRejectionReasonCodeVALORACIMALIMITE          ConsentRejectionReasonCode = "VALOR_ACIMA_LIMITE"
)

// Defines values for ConsentRevocationRevocationRevokedBy.
const (
	ConsentRevocationRevocationRevokedByDETENTORA  ConsentRevocationRevocationRevokedBy = "DETENTORA"
	ConsentRevocationRevocationRevokedByINICIADORA ConsentRevocationRevocationRevokedBy = "INICIADORA"
	ConsentRevocationRevocationRevokedByUSUARIO    ConsentRevocationRevocationRevokedBy = "USUARIO"
)

// Defines values for ConsentRevocationRevocationRevokedFrom.
const (
	ConsentRevocationRevocationRevokedFromDETENTORA  ConsentRevocationRevocationRevokedFrom = "DETENTORA"
	ConsentRevocationRevocationRevokedFromINICIADORA ConsentRevocationRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ConsentRevocationStatus.
const (
	REVOKED ConsentRevocationStatus = "REVOKED"
)

// Defines values for ConsentRevokedReasonCode.
const (
	ConsentRevokedReasonCodeNAOINFORMADO      ConsentRevokedReasonCode = "NAO_INFORMADO"
	ConsentRevokedReasonCodeREVOGADORECEBEDOR ConsentRevokedReasonCode = "REVOGADO_RECEBEDOR"
	ConsentRevokedReasonCodeREVOGADOUSUARIO   ConsentRevokedReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ContractDebtorDocumentRel.
const (
	ContractDebtorDocumentRelCNPJ ContractDebtorDocumentRel = "CNPJ"
	ContractDebtorDocumentRelCPF  ContractDebtorDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataAuthorisationFlow.
const (
	CreateRecurringPixPaymentDataAuthorisationFlowCIBAFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowFIDOFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreateRecurringPixPaymentDataAuthorisationFlowHYBRIDFLOW CreateRecurringPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for CreateRecurringPixPaymentDataDocumentRel.
const (
	CreateRecurringPixPaymentDataDocumentRelCNPJ CreateRecurringPixPaymentDataDocumentRel = "CNPJ"
	CreateRecurringPixPaymentDataDocumentRelCPF  CreateRecurringPixPaymentDataDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataLocalInstrument.
const (
	CreateRecurringPixPaymentDataLocalInstrumentDICT CreateRecurringPixPaymentDataLocalInstrument = "DICT"
	CreateRecurringPixPaymentDataLocalInstrumentINIC CreateRecurringPixPaymentDataLocalInstrument = "INIC"
	CreateRecurringPixPaymentDataLocalInstrumentMANU CreateRecurringPixPaymentDataLocalInstrument = "MANU"
)

// Defines values for EnumAccountTypeConsents.
const (
	EnumAccountTypeConsentsCACC EnumAccountTypeConsents = "CACC"
	EnumAccountTypeConsentsSVGS EnumAccountTypeConsents = "SVGS"
	EnumAccountTypeConsentsTRAN EnumAccountTypeConsents = "TRAN"
)

// Defines values for EnumAccountTypePayments.
const (
	EnumAccountTypePaymentsCACC EnumAccountTypePayments = "CACC"
	EnumAccountTypePaymentsSVGS EnumAccountTypePayments = "SVGS"
	EnumAccountTypePaymentsTRAN EnumAccountTypePayments = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	EnumAuthorisationStatusTypeAUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	EnumAuthorisationStatusTypeAWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	EnumAuthorisationStatusTypeCONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	EnumAuthorisationStatusTypePARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	EnumAuthorisationStatusTypeREJECTED              EnumAuthorisationStatusType = "REJECTED"
	EnumAuthorisationStatusTypeREVOKED               EnumAuthorisationStatusType = "REVOKED"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	EnumPaymentCancellationFromTypeDETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	EnumPaymentCancellationFromTypeINICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOPENDENCIA   EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonCode.
const (
	EnumRejectionReasonCodeCONSENTIMENTOINVALIDO                     EnumRejectionReasonCode = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeCONSENTIMENTOREVOGADO                     EnumRejectionReasonCode = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeFORAPRAZOPERMITIDO                        EnumRejectionReasonCode = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeNAOINFORMADO                              EnumRejectionReasonCode = "NAO_INFORMADO"
	EnumRejectionReasonCodePAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodePAGAMENTORECUSADODETENTORA                EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodePAGAMENTORECUSADOSPI                      EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeSALDOINSUFICIENTE                         EnumRejectionReasonCode = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeVALORACIMALIMITE                          EnumRejectionReasonCode = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeVALORINVALIDO                             EnumRejectionReasonCode = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonCodeGet.
const (
	EnumRejectionReasonCodeGetCONSENTIMENTOINVALIDO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_INVALIDO"
	EnumRejectionReasonCodeGetCONSENTIMENTOREVOGADO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_REVOGADO"
	EnumRejectionReasonCodeGetDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonCodeGetDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_TENTATIVA_INVALIDO"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonCodeGetFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonCodeGetFORAPRAZOPERMITIDO                        EnumRejectionReasonCodeGet = "FORA_PRAZO_PERMITIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCodeGet = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCodeGet = "LIMITE_PERIODO_VALOR_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCodeGet = "LIMITE_TENTATIVAS_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCodeGet = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCodeGet = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
	EnumRejectionReasonCodeGetNAOINFORMADO                              EnumRejectionReasonCodeGet = "NAO_INFORMADO"
	EnumRejectionReasonCodeGetPAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCodeGet = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADODETENTORA                EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonCodeGetPAGAMENTORECUSADOSPI                      EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonCodeGetSALDOINSUFICIENTE                         EnumRejectionReasonCodeGet = "SALDO_INSUFICIENTE"
	EnumRejectionReasonCodeGetTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCodeGet = "TITULARIDADE_INCONSISTENTE"
	EnumRejectionReasonCodeGetVALORACIMALIMITE                          EnumRejectionReasonCodeGet = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonCodeGetVALORINVALIDO                             EnumRejectionReasonCodeGet = "VALOR_INVALIDO"
)

// Defines values for PatchPixPaymentDataCancellationCancelledByDocumentRel.
const (
	PatchPixPaymentDataCancellationCancelledByDocumentRelCNPJ PatchPixPaymentDataCancellationCancelledByDocumentRel = "CNPJ"
	PatchPixPaymentDataCancellationCancelledByDocumentRelCPF  PatchPixPaymentDataCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for PixPaymentCancellationCancelledByDocumentRel.
const (
	PixPaymentCancellationCancelledByDocumentRelCNPJ PixPaymentCancellationCancelledByDocumentRel = "CNPJ"
	PixPaymentCancellationCancelledByDocumentRelCPF  PixPaymentCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for RejectionRejectedBy.
const (
	RejectionRejectedByDETENTORA  RejectionRejectedBy = "DETENTORA"
	RejectionRejectedByINICIADORA RejectionRejectedBy = "INICIADORA"
	RejectionRejectedByUSUARIO    RejectionRejectedBy = "USUARIO"
)

// Defines values for RejectionRejectedFrom.
const (
	RejectionRejectedFromDETENTORA  RejectionRejectedFrom = "DETENTORA"
	RejectionRejectedFromINICIADORA RejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseErrorCreateConsentErrorsCode.
const (
	ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA       ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO    ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA            ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	ResponseErrorCreateConsentErrorsCodeFUNCIONALIDADENAOHABILITADA ResponseErrorCreateConsentErrorsCode = "FUNCIONALIDADE_NAO_HABILITADA"
	ResponseErrorCreateConsentErrorsCodeNAOINFORMADO                ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO           ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO       ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationReasonCode.
const (
	ResponsePostRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponsePostRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedBy.
const (
	ResponsePostRecurringConsentDataRevocationRevokedByDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedByINICIADORA ResponsePostRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponsePostRecurringConsentDataRevocationRevokedByUSUARIO    ResponsePostRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedFrom.
const (
	ResponsePostRecurringConsentDataRevocationRevokedFromDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponsePostRecurringConsentDataRevocationRevokedFromINICIADORA ResponsePostRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentDataRevocationReasonCode.
const (
	ResponseRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	ResponseRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedBy.
const (
	ResponseRecurringConsentDataRevocationRevokedByDETENTORA  ResponseRecurringConsentDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedByINICIADORA ResponseRecurringConsentDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentDataRevocationRevokedByUSUARIO    ResponseRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedFrom.
const (
	ResponseRecurringConsentDataRevocationRevokedFromDETENTORA  ResponseRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
	ResponseRecurringConsentDataRevocationRevokedFromINICIADORA ResponseRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedBy.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedByDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRejectionRejectedByUSUARIO    ResponseRecurringConsentPatchDataRejectionRejectedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedFrom.
const (
	ResponseRecurringConsentPatchDataRejectionRejectedFromDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedFrom = "DETENTORA"
	ResponseRecurringConsentPatchDataRejectionRejectedFromINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationReasonCode.
const (
	NAOINFORMADO      ResponseRecurringConsentPatchDataRevocationReasonCode = "NAO_INFORMADO"
	REVOGADORECEBEDOR ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
	REVOGADOUSUARIO   ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedBy.
const (
	ResponseRecurringConsentPatchDataRevocationRevokedByDETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedBy = "DETENTORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByINICIADORA ResponseRecurringConsentPatchDataRevocationRevokedBy = "INICIADORA"
	ResponseRecurringConsentPatchDataRevocationRevokedByUSUARIO    ResponseRecurringConsentPatchDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedFrom.
const (
	DETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedFrom = "DETENTORA"
	INICIADORA ResponseRecurringConsentPatchDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringPaymentsDataPatchAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataPatchAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataPatchAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataPatchAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataPatchDocumentRel.
const (
	ResponseRecurringPaymentsDataPatchDocumentRelCNPJ ResponseRecurringPaymentsDataPatchDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataPatchDocumentRelCPF  ResponseRecurringPaymentsDataPatchDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataPatchLocalInstrument.
const (
	ResponseRecurringPaymentsDataPatchLocalInstrumentDICT ResponseRecurringPaymentsDataPatchLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataPatchLocalInstrumentINIC ResponseRecurringPaymentsDataPatchLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataPatchLocalInstrumentMANU ResponseRecurringPaymentsDataPatchLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsDataReadAuthorisationFlow.
const (
	ResponseRecurringPaymentsDataReadAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsDataReadAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataReadAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataReadDocumentRel.
const (
	ResponseRecurringPaymentsDataReadDocumentRelCNPJ ResponseRecurringPaymentsDataReadDocumentRel = "CNPJ"
	ResponseRecurringPaymentsDataReadDocumentRelCPF  ResponseRecurringPaymentsDataReadDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataReadLocalInstrument.
const (
	ResponseRecurringPaymentsDataReadLocalInstrumentDICT ResponseRecurringPaymentsDataReadLocalInstrument = "DICT"
	ResponseRecurringPaymentsDataReadLocalInstrumentINIC ResponseRecurringPaymentsDataReadLocalInstrument = "INIC"
	ResponseRecurringPaymentsDataReadLocalInstrumentMANU ResponseRecurringPaymentsDataReadLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsPostDataAuthorisationFlow.
const (
	ResponseRecurringPaymentsPostDataAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "CIBA_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "FIDO_FLOW"
	ResponseRecurringPaymentsPostDataAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsPostDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsPostDataDocumentRel.
const (
	ResponseRecurringPaymentsPostDataDocumentRelCNPJ ResponseRecurringPaymentsPostDataDocumentRel = "CNPJ"
	ResponseRecurringPaymentsPostDataDocumentRelCPF  ResponseRecurringPaymentsPostDataDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsPostDataLocalInstrument.
const (
	ResponseRecurringPaymentsPostDataLocalInstrumentDICT ResponseRecurringPaymentsPostDataLocalInstrument = "DICT"
	ResponseRecurringPaymentsPostDataLocalInstrumentINIC ResponseRecurringPaymentsPostDataLocalInstrument = "INIC"
	ResponseRecurringPaymentsPostDataLocalInstrumentMANU ResponseRecurringPaymentsPostDataLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPixDataDocumentRel.
const (
	ResponseRecurringPixDataDocumentRelCNPJ ResponseRecurringPixDataDocumentRel = "CNPJ"
	ResponseRecurringPixDataDocumentRelCPF  ResponseRecurringPixDataDocumentRel = "CPF"
)

// N422ResponseErrorCreatePixRecurringPayment defines model for 422ResponseErrorCreatePixRecurringPayment.
type N422ResponseErrorCreatePixRecurringPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Code N422ResponseErrorCreatePixRecurringPaymentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
		// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
		// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
		// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
		// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
		// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
		// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: Limite de transação excedido.
		// - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
		// - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
		// - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
type N422ResponseErrorCreatePixRecurringPaymentErrorsCode string

// N422ResponseErrorCreateRecurringPaymentsPaymentID defines model for 422ResponseErrorCreateRecurringPaymentsPaymentId.
type N422ResponseErrorCreateRecurringPaymentsPaymentID struct {
	Errors []struct {
		// Code - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Code N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode `json:"code"`

		// Detail - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
		// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
type N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode string

// N422ResponseErrorRecurringConsents defines model for 422ResponseErrorRecurringConsents.
type N422ResponseErrorRecurringConsents struct {
	Errors []struct {
		Code N422ResponseErrorRecurringConsentsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED")
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED").
		// - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
		// - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
		// - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
		// - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
		// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorRecurringConsentsErrorsCode defines model for 422ResponseErrorRecurringConsents.Errors.Code.
type N422ResponseErrorRecurringConsentsErrorsCode string

// Automatic defines model for Automatic.
type Automatic struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"automatic"`
}

// AutomaticAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticAutomaticInterval string

// AutomaticRequest defines model for AutomaticRequest.
type AutomaticRequest struct {
	// Automatic Definição da configuração de recorrência para pagamentos automáticos
	Automatic struct {
		// ContractDebtor Informações sobre o cliente devedor do contrato.
		ContractDebtor ContractDebtor `json:"contractDebtor"`

		// ContractID Identificador do contrato de transação
		ContractID string `json:"contractId"`

		// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
		//
		// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
		FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

		// FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
		FixedAmount *string `json:"fixedAmount,omitempty"`

		// Interval Define a periodicidade permitida para realização de transações
		// - SEMANAL
		// - MENSAL
		// - ANUAL
		// - SEMESTRAL
		// - TRIMESTRAL
		Interval AutomaticRequestAutomaticInterval `json:"interval"`

		// IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
		IsRetryAccepted bool `json:"isRetryAccepted"`

		// MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
		//
		// [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
		MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

		// MinimumVariableAmount Valor definido pelo usuário recebedor.
		// Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
		// Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
		// Não representa um valor mínimo de cobrança para o pagamento.
		MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

		// ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`
	} `json:"automatic"`
}

// AutomaticRequestAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticRequestAutomaticInterval string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
//
// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentEdition defines model for ConsentEdition.
type ConsentEdition = autopayment.ConsentEdition

// ConsentRejection defines model for ConsentRejection.
type ConsentRejection struct {
	// Rejection Objeto contendo as informações de rejeição dos consentimentos.
	Rejection struct {
		// Reason Informações sobre o motivo da rejeição
		Reason ConsentRejectionReason `json:"reason"`

		// RejectedBy Ator responsável pela solicitação rejeição
		RejectedBy ConsentRejectionRejectionRejectedBy `json:"rejectedBy"`

		// RejectedFrom Canal onde iniciou-se o processo de rejeição
		// - INICIADORA
		// - DETENTORA
		RejectedFrom ConsentRejectionRejectionRejectedFrom `json:"rejectedFrom"`
	} `json:"rejection"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRejectionStatus `json:"status,omitempty"`
}

// ConsentRejectionRejectionRejectedBy Ator responsável pela solicitação rejeição
type ConsentRejectionRejectionRejectedBy string

// ConsentRejectionRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ConsentRejectionRejectionRejectedFrom string

// ConsentRejectionStatus Estado atual do consentimento de longa duração
type ConsentRejectionStatus string

// ConsentRejectionReason Informações sobre o motivo da rejeição
type ConsentRejectionReason struct {
	// Code Código indicador do motivo de rejeição.
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - AUTENTICACAO_DIVERGENTE
	Code ConsentRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de rejeição indicado no campo `/data/rejection/reason/code`
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento];
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento;
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento;
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento;
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido para permitir a realização de transações pelo cliente;
	// - AUTENTICACAO_DIVERGENTE : Usuário autenticado no detentor diverge do usuário autenticado no iniciador;
	Detail string `json:"detail"`
}

// ConsentRejectionReasonCode Código indicador do motivo de rejeição.
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - AUTENTICACAO_DIVERGENTE
type ConsentRejectionReasonCode string

// ConsentRevocation defines model for ConsentRevocation.
type ConsentRevocation struct {
	// Revocation Objeto contendo as informações de revogação dos consentimentos de longa duração.
	Revocation struct {
		// Reason Informações sobre o motivo da revogação
		Reason ConsentRevokedReason `json:"reason"`

		// RevokedBy Quem iniciou a solicitação de revogação
		// - INICIADORA
		// - USUARIO
		// - DETENTORA
		RevokedBy ConsentRevocationRevocationRevokedBy `json:"revokedBy"`

		// RevokedFrom Canal onde iniciou-se o processo de revogação
		// - INICIADORA
		// - DETENTORA
		RevokedFrom ConsentRevocationRevocationRevokedFrom `json:"revokedFrom"`
	} `json:"revocation"`

	// Status Estado atual do consentimento de longa duração
	Status *ConsentRevocationStatus `json:"status,omitempty"`
}

// ConsentRevocationRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ConsentRevocationRevocationRevokedBy string

// ConsentRevocationRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ConsentRevocationRevocationRevokedFrom string

// ConsentRevocationStatus Estado atual do consentimento de longa duração
type ConsentRevocationStatus string

// ConsentRevokedReason Informações sobre o motivo da revogação
type ConsentRevokedReason struct {
	// Code Código indicador do motivo de revogação.
	// - REVOGADO_RECEBEDOR
	// - REVOGADO_USUARIO
	// - NAO_INFORMADO
	Code ConsentRevokedReasonCode `json:"code"`

	// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
	// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
	Detail string `json:"detail"`
}

// ConsentRevokedReasonCode Código indicador do motivo de revogação.
// - REVOGADO_RECEBEDOR
// - REVOGADO_USUARIO
// - NAO_INFORMADO
type ConsentRevokedReasonCode string

// ContractDebtor Informações sobre o cliente devedor do contrato.
type ContractDebtor struct {
	Document struct {
		// Identification Número do documento de identificação oficial do cliente devedor do contrato.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do cliente devedor do contrato.
		Rel ContractDebtorDocumentRel `json:"rel"`
	} `json:"document"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular devedor do contrato.
	Name string `json:"name"`
}

// ContractDebtorDocumentRel Tipo do documento de identificação oficial do cliente devedor do contrato.
type ContractDebtorDocumentRel string

// CreateRecurringConsent defines model for CreateRecurringConsent.
type CreateRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Creditors      Creditors       `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration autopayment.Configuration `json:"recurringConfiguration"`
	} `json:"data"`
}

// CreateRecurringPixPayment defines model for CreateRecurringPixPayment.
type CreateRecurringPixPayment struct {
	// Data Objeto contendo dados do pagamento e do recebedor (creditor).
	Data CreateRecurringPixPaymentData `json:"data"`
}

// CreateRecurringPixPaymentData Objeto contendo dados do pagamento e do recebedor (creditor).
type CreateRecurringPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *CreateRecurringPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	//
	// [Restrição] - Se /data/paymentReference = "zero", as informações da conta de crédito enviadas (/data/creditorAccount) devem ser iguais as presentes na conta de crédito informada na criação do consentimento(`/data/recurringConfiguration/automatic/firstPayment/creditorAccount`)
	CreditorAccount struct {
		// AccountType Tipos de contas usadas para pagamento via Pix.
		// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
		// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
		// Segue descrição de cada valor do ENUM para o escopo do Pix.
		//
		// - CACC - Current - Conta Corrente.
		// - SVGS - Savings - Conta de Poupança.
		// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
		AccountType EnumAccountTypePayments `json:"accountType"`

		// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
		Ispb string `json:"ispb"`

		// Issuer Código da Agência emissora da conta sem dígito.
		// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
		// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
		//
		// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
		Issuer *string `json:"issuer,omitempty"`

		// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
		// se houver valor alfanumérico, este deve ser convertido para 0.
		Number string `json:"number"`
	} `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel CreateRecurringPixPaymentDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
	//
	// - "E" - fixo (1 caractere);
	// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
	// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
	// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
	//
	// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
	//
	// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
	EndToEndID EndToEndIDPost `json:"endToEndId"`

	// IbgeTownCode O campo ibgeTownCode no arranjo Pix tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do Pix.
	//
	// Caso a informação referente ao município não seja enviada, o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument CreateRecurringPixPaymentDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
	//
	// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
	RiskSignals *RiskSignalsPayments `json:"riskSignals,omitempty"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
	// - MANU - O campo transactionIdentification não deve ser preenchido;
	// - DICT - O campo transactionIdentification não deve ser preenchido;
	// - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// CreateRecurringPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreateRecurringPixPaymentDataAuthorisationFlow string

// CreateRecurringPixPaymentDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type CreateRecurringPixPaymentDataDocumentRel string

// CreateRecurringPixPaymentDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type CreateRecurringPixPaymentDataLocalInstrument string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
// [Restrição]
// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountConsent Recebe os dados de conta do usuário recebedor.
type CreditorAccountConsent struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreditorAccountPostPixPaymentsResponse Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccountPostPixPaymentsResponse struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypePayments `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
	// do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Creditors defines model for Creditors.
type Creditors = []struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// Day Configurar limite transacional diário determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
type Day struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um dia.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado diariamente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountTypeConsents `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
//
// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
type EndToEndID = string

// EndToEndIDPost Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// - "E" - fixo (1 caractere);
// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
//
// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
type EndToEndIDPost = string

// EnumAccountTypeConsents Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypeConsents string

// EnumAccountTypePayments Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypePayments string

// EnumAuthorisationStatusType Status atual do consentimento recorrente de acordo com a máquina de estados
// - AWAITING_AUTHORISATION - Aguardando autorização
// - PARTIALLY_ACCEPTED - Parcialmente aceito
// - AUTHORISED - Autorizado
// - REJECTED - Rejeitado
// - REVOKED - Revogado
// - CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Estado para qual o pagamento deverá transitar
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual do pagamento. O estado evolui na seguinte ordem:
// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
// Em caso insucesso:
// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonCode Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
// - CONSENTIMENTO_REVOGADO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCode string

// EnumRejectionReasonCodeGet Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
// - CONSENTIMENTO_REVOGADO
// - LIMITE_TENTATIVAS_EXCEDIDO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCodeGet string

// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
//
// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
type FirstPayment struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// CreditorAccount Recebe os dados de conta do usuário recebedor.
	CreditorAccount CreditorAccountConsent `json:"creditorAccount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date Define a data alvo da liquidação do pagamento.
	// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
	Date timeutil.BrazilDate `json:"date"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// Month Configurar limite transacional mensal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Month struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um mês.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado mensalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Informações gerais sobre o cancelamento.
	Cancellation struct {
		// CancelledBy Informações gerais sobre o usuário que solicitou o cancelamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica
				Identification string `json:"identification"`

				// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
				Rel PatchPixPaymentDataCancellationCancelledByDocumentRel `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Estado para qual o pagamento deverá transitar
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PatchPixPaymentDataCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PatchPixPaymentDataCancellationCancelledByDocumentRel string

// PatchRecurringConsent defines model for PatchRecurringConsent.
type PatchRecurringConsent struct {
	// Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
	Data PatchRecurringConsent_Data `json:"data"`
}

// PatchRecurringConsent_Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
type PatchRecurringConsent_Data struct {
	union json.RawMessage
}

// PaymentPix Objeto contendo as informações do pagamento.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'. Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
type PeriodicLimits struct {
	// Day Configurar limite transacional diário determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
	Day *Day `json:"day,omitempty"`

	// Month Configurar limite transacional mensal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Month *Month `json:"month,omitempty"`

	// Week Configurar limite transacional semanal determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Week *Week `json:"week,omitempty"`

	// Year Configurar limite transacional anual determinado pelo usuário pagador.
	//
	// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
	Year *Year `json:"year,omitempty"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Identification string `json:"identification"`

			// Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
			Rel PixPaymentCancellationCancelledByDocumentRel `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PixPaymentCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PixPaymentCancellationCancelledByDocumentRel string

// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
type RecurringConfiguration = autopayment.Configuration

// Rejection Objeto contendo as informações de rejeição dos consentimentos.
//
// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
type Rejection struct {
	// Reason Informações sobre o motivo da rejeição
	Reason *ConsentRejectionReason `json:"reason,omitempty"`

	// RejectedAt Data e hora em que o consentimento foi rejeitado
	RejectedAt timeutil.DateTime `json:"rejectedAt"`

	// RejectedBy Quem iniciou a solicitação de rejeição
	// - INICIADORA
	// - USUARIO
	// - DETENTORA
	RejectedBy RejectionRejectedBy `json:"rejectedBy"`

	// RejectedFrom Canal onde iniciou-se o processo de rejeição
	// - INICIADORA
	// - DETENTORA
	RejectedFrom RejectionRejectedFrom `json:"rejectedFrom"`
}

// RejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type RejectionRejectedBy string

// RejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type RejectionRejectedFrom string

// RejectionReason Objeto contendo o motivo de rejeição assíncrono
type RejectionReason struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCode `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração
	// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio.
	Detail string `json:"detail"`
}

// RejectionReasonGet Objeto contendo o motivo de rejeição assíncrono
type RejectionReasonGet struct {
	// Code Código identificador do motivo de rejeição.
	// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
	// - PAGAMENTO_RECUSADO_DETENTORA
	// - PAGAMENTO_RECUSADO_SPI
	// - CONSENTIMENTO_INVALIDO
	// - FALHA_INFRAESTRUTURA_SPI
	// - FALHA_INFRAESTRUTURA_ICP
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
	// - FALHA_INFRAESTRUTURA_DETENTORA
	// - LIMITE_PERIODO_VALOR_EXCEDIDO
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
	// - TITULARIDADE_INCONSISTENTE
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
	// - CONSENTIMENTO_REVOGADO
	// - LIMITE_TENTATIVAS_EXCEDIDO
	// - FORA_PRAZO_PERMITIDO
	// - DETALHE_TENTATIVA_INVALIDO
	// - DETALHE_PAGAMENTO_INVALIDO
	//
	// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
	Code EnumRejectionReasonCodeGet `json:"code"`

	// Detail Detalhe sobre o código identificador do motivo de rejeição.
	//
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
	// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
	// - VALOR_INVALIDO: O valor enviado não é válido;
	// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
	// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
	// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
	// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
	// - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
	// - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
	// - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
	// - LIMITE_PERIODO_VALOR_EXCEDIDO – A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
	// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO – A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
	// - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração.
	// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
	// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
	// - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
	// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido
	// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
	// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
	// - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio
	Detail string `json:"detail"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsent defines model for ResponseErrorCreateConsent.
type ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// - DATA_PAGAMENTO_INVALIDA
		// - DETALHE_PAGAMENTO_INVALIDO
		// - PARAMETRO_NAO_INFORMADO
		// - PARAMETRO_INVALIDO
		// - ERRO_IDEMPOTENCIA
		// - NAO_INFORMADO
		// - FUNCIONALIDADE_NAO_HABILITADA
		Code ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - NAO_INFORMADO: Não informado.
		// - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// - DATA_PAGAMENTO_INVALIDA
// - DETALHE_PAGAMENTO_INVALIDO
// - PARAMETRO_NAO_INFORMADO
// - PARAMETRO_INVALIDO
// - ERRO_IDEMPOTENCIA
// - NAO_INFORMADO
// - FUNCIONALIDADE_NAO_HABILITADA
type ResponseErrorCreateConsentErrorsCode string

// ResponsePostRecurringConsent defines model for ResponsePostRecurringConsent.
type ResponsePostRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponsePostRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponsePostRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePostRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponsePostRecurringConsentDataRevocationReasonCode string

// ResponsePostRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedBy string

// ResponsePostRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsent defines model for ResponseRecurringConsent.
type ResponseRecurringConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// IbgeTownCode Campo utilizado pela iniciadora para cálculo do dia útil de liquidação do pagamento (vide especificação do endToEndId) baseado no município de cadastro do usuário pagador no detentor.
			//
			// [Restrições]
			// Campo de preenchimento obrigatório quando o oneOf utilizado do recurringConfiguration for “automatic”, e o consentimento passar pelo estado AUTHORISED.
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *Rejection `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentDataRevocationReasonCode string

// ResponseRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedBy string

// ResponseRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsentPatch defines model for ResponseRecurringConsentPatch.
type ResponseRecurringConsentPatch struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
	Data struct {
		// AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
		AdditionalInformation *string `json:"additionalInformation,omitempty"`

		// ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
		//
		// [Restrição]
		// Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
		ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

		// AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
		//
		// [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
		AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
		//
		// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`
		Creditors        Creditors         `json:"creditors"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
		// - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
		// - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
		//
		// [Restrições]
		// - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM.
			//
			// - CACC - Current - Conta Corrente.
			// - SVGS - Savings - Conta de Poupança.
			// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountTypeConsents `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			//
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser *LoggedUser `json:"loggedUser,omitempty"`

		// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
		RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
		RecurringConsentID string `json:"recurringConsentId"`

		// Rejection Objeto contendo as informações de rejeição dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
		Rejection *struct {
			// Reason Informações sobre o motivo da rejeição
			Reason *ConsentRejectionReason `json:"reason,omitempty"`

			// RejectedAt Data e hora em que o consentimento foi rejeitado
			RejectedAt timeutil.DateTime `json:"rejectedAt"`

			// RejectedBy Quem iniciou a solicitação de rejeição
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RejectedBy ResponseRecurringConsentPatchDataRejectionRejectedBy `json:"rejectedBy"`

			// RejectedFrom Canal onde iniciou-se o processo de rejeição
			// - INICIADORA
			// - DETENTORA
			RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom `json:"rejectedFrom"`
		} `json:"rejection,omitempty"`

		// Revocation Objeto contendo as informações de revogação dos consentimentos.
		//
		// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
		Revocation *struct {
			// Reason Informações sobre o motivo da revogação
			Reason *struct {
				// Code Código indicador do motivo da revogação
				Code ResponseRecurringConsentPatchDataRevocationReasonCode `json:"code"`

				// Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
				// - NAO_INFORMADO: Não informada pela detentora de conta;
				// - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
				// - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
				Detail string `json:"detail"`
			} `json:"reason,omitempty"`

			// RevokedAt Data e hora em que o consentimento foi revogado
			RevokedAt timeutil.DateTime `json:"revokedAt"`

			// RevokedBy Quem iniciou a solicitação de revogação
			// - INICIADORA
			// - USUARIO
			// - DETENTORA
			RevokedBy ResponseRecurringConsentPatchDataRevocationRevokedBy `json:"revokedBy"`

			// RevokedFrom Canal onde iniciou-se o processo de revogação
			// - INICIADORA
			// - DETENTORA
			RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom `json:"revokedFrom"`
		} `json:"revocation,omitempty"`

		// RiskSignals Sinais de risco para iniciação de pagamentos automáticos
		//
		// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
		RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

		// Status Status atual do consentimento recorrente de acordo com a máquina de estados
		// - AWAITING_AUTHORISATION - Aguardando autorização
		// - PARTIALLY_ACCEPTED - Parcialmente aceito
		// - AUTHORISED - Autorizado
		// - REJECTED - Rejeitado
		// - REVOKED - Revogado
		// - CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
		// O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
		// Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
		// A edição só é permitida para o produto Pix automático.
		UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentPatchDataRejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedBy string

// ResponseRecurringConsentPatchDataRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedFrom string

// ResponseRecurringConsentPatchDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentPatchDataRevocationReasonCode string

// ResponseRecurringConsentPatchDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedBy string

// ResponseRecurringConsentPatchDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedFrom string

// ResponseRecurringPaymentsDataPatch defines model for ResponseRecurringPaymentsDataPatch.
type ResponseRecurringPaymentsDataPatch struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataPatchAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataPatchDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataPatchLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataPatchAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataPatchAuthorisationFlow string

// ResponseRecurringPaymentsDataPatchDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataPatchDocumentRel string

// ResponseRecurringPaymentsDataPatchLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataPatchLocalInstrument string

// ResponseRecurringPaymentsDataRead defines model for ResponseRecurringPaymentsDataRead.
type ResponseRecurringPaymentsDataRead struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsDataReadAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	// [Restrição]
	// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
	CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsDataReadLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	//
	// [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataReadAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataReadAuthorisationFlow string

// ResponseRecurringPaymentsDataReadDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataReadDocumentRel string

// ResponseRecurringPaymentsDataReadLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataReadLocalInstrument string

// ResponseRecurringPaymentsIDPatch defines model for ResponseRecurringPaymentsIdPatch.
type ResponseRecurringPaymentsIDPatch struct {
	Data  ResponseRecurringPaymentsDataPatch `json:"data"`
	Links api.Links                          `json:"links"`
	Meta  api.Meta                           `json:"meta"`
}

// ResponseRecurringPaymentsIDPost defines model for ResponseRecurringPaymentsIdPost.
type ResponseRecurringPaymentsIDPost struct {
	Data  ResponseRecurringPaymentsPostData `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsIDRead defines model for ResponseRecurringPaymentsIdRead.
type ResponseRecurringPaymentsIDRead struct {
	Data  ResponseRecurringPaymentsDataRead `json:"data"`
	Links api.Links                         `json:"links"`
	Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsPostData defines model for ResponseRecurringPaymentsPostData.
type ResponseRecurringPaymentsPostData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponseRecurringPaymentsPostDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccountPostPixPaymentsResponse `json:"creditorAccount"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

	// Document Informações do documento identificador do recebedor da transação.
	Document struct {
		// Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
		// O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
		// Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// LocalInstrument Especifica a forma de iniciação do pagamento
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
	//
	// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
	LocalInstrument ResponseRecurringPaymentsPostDataLocalInstrument `json:"localInstrument"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
	//
	// [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
	//
	// [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
	//
	// [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
	Proxy *string `json:"proxy,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsPostDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsPostDataAuthorisationFlow string

// ResponseRecurringPaymentsPostDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsPostDataDocumentRel string

// ResponseRecurringPaymentsPostDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsPostDataLocalInstrument string

// ResponseRecurringPixData defines model for ResponseRecurringPixData.
type ResponseRecurringPixData = []struct {
	// CreationDateTime Data e hora em que o pagamento foi criado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
	Date timeutil.BrazilDate `json:"date"`

	// Document Informações do documento.
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa natural ou jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
		Rel ResponseRecurringPixDataDocumentRel `json:"rel"`
	} `json:"document"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
	//
	// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
	EndToEndID EndToEndID `json:"endToEndId"`

	// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
	// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
	// O recurringPaymentId deve ser diferente do endToEndId.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	//
	// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
	OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

	// Payment Objeto contendo as informações do pagamento.
	Payment PaymentPix `json:"payment"`

	// PaymentReference [Restrição]
	// Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
	//
	// - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
	// - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
	// - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
	// - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
	//   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
	//   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
	//   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
	//   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
	// - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
	//   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
	//   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
	// - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
	//   - Exemplo de Formatos:
	//     - Primeiro pagamento: "zero"
	//     - Semanal: "W50-2024"
	//     - Mensal: "M09-2024"
	//     - Trimestral: "Q3-2024"
	//     - Semestral: "S2-2024"
	//     - Anual: "Y2024"
	PaymentReference *string `json:"paymentReference,omitempty"`

	// RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	//
	// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
	RecurringConsentID *string `json:"recurringConsentId,omitempty"`

	// RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	RecurringPaymentID string `json:"recurringPaymentId"`

	// RejectionReason Objeto contendo o motivo de rejeição assíncrono
	RejectionReason *RejectionReasonGet `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual do pagamento. O estado evolui na seguinte ordem:
	// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
	// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	// Em caso insucesso:
	// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
	// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	// Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
	// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
	//
	// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
	//
	// MANU - O campo transactionIdentification não deve ser preenchido;
	// DICT - O campo transactionIdentification não deve ser preenchido;
	// INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPixDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPixDataDocumentRel string

// ResponseRecurringPixPayment defines model for ResponseRecurringPixPayment.
type ResponseRecurringPixPayment struct {
	Data  ResponseRecurringPixData `json:"data"`
	Links api.Links                `json:"links"`
	Meta  api.Meta                 `json:"meta"`
}

// RiskSignalsConsentEdition Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
// Só estará presente após a primeira edição do consentimento de longa duração.
// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
type RiskSignalsConsentEdition = map[string]any

// RiskSignalsConsents Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
type RiskSignalsConsents = map[string]any

// RiskSignalsPayments Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
type RiskSignalsPayments = map[string]any

// Sweeping defines model for Sweeping.
type Sweeping struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime timeutil.DateTime `json:"startDateTime"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`

		// UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
		UseOverdraftLimit bool `json:"useOverdraftLimit"`
	} `json:"sweeping"`
}

// SweepingRequest defines model for SweepingRequest.
type SweepingRequest struct {
	// Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
	Sweeping struct {
		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

		// StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
		// Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
		//
		// [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
		StartDateTime *timeutil.DateTime `json:"startDateTime,omitempty"`

		// TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
		TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

		// TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"sweeping"`
}

// Vrp defines model for Vrp.
type Vrp struct {
	// Vrp Definição da configuração de recorrência para realização de transações de valores variáveis
	Vrp struct {
		// GlobalLimits Limite transacional máximo para pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
		GlobalLimits *struct {
			// QuantityLimit Quantidade máxima de ocorrência  de pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED"
			QuantityLimit *int `json:"quantityLimit,omitempty"`

			// TransactionLimit Valor transacional máximo para pagamentos sob este consentimento, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
			TransactionLimit *string `json:"transactionLimit,omitempty"`
		} `json:"globalLimits,omitempty"`

		// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
		PeriodicLimits *struct {
			// Day Configurar limite transacional diário determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
			Day *Day `json:"day,omitempty"`

			// Month Configurar limite transacional mensal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Month *Month `json:"month,omitempty"`

			// Week Configurar limite transacional semanal determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Week *Week `json:"week,omitempty"`

			// Year Configurar limite transacional anual determinado pelo usuário pagador.
			//
			// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
			Year *Year `json:"year,omitempty"`
		} `json:"periodicLimits,omitempty"`

		// TransactionLimit Limite máximo de valor permitido para cada transação de pagamento.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"vrp"`
}

// Week Configurar limite transacional semanal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Week struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante uma semana.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado semanalmente.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// Year Configurar limite transacional anual determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Year struct {
	// QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um ano.
	QuantityLimit *int `json:"quantityLimit,omitempty"`

	// TransactionLimit Valor máximo a ser transacionado por um ano, a partir da data definida no campo `/data/startDateTime`.
	TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
// O recurringPaymentId deve ser diferente do endToEndId.
// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
//
// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
type OriginalRecurringPaymentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// EndDate defines model for endDate.
type EndDate = string

// ParameterOriginalRecurringPaymentId defines model for originalRecurringPaymentId.
type ParameterOriginalRecurringPaymentId = string

// PathRecurringConsentID defines model for pathRecurringConsentId.
type PathRecurringConsentID = string

// PathRecurringPaymentID defines model for pathRecurringPaymentId.
type PathRecurringPaymentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// StartDate defines model for startDate.
type StartDate = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200RecurringPaymentsIDPatch defines model for 200RecurringPaymentsIdPatch.
type N200RecurringPaymentsIDPatch = ResponseRecurringPaymentsIDPatch

// N200RecurringPaymentsIDRead defines model for 200RecurringPaymentsIdRead.
type N200RecurringPaymentsIDRead = ResponseRecurringPaymentsIDRead

// N200RecurringPixPaymentRead defines model for 200RecurringPixPaymentRead.
type N200RecurringPixPaymentRead = ResponseRecurringPixPayment

// N201RecurringPaymentsIDPost defines model for 201RecurringPaymentsIdPost.
type N201RecurringPaymentsIDPost = ResponseRecurringPaymentsIDPost

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPaymentsConsents defines model for BadRequestPaymentsConsents.
type BadRequestPaymentsConsents = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// RecurringConsentsConsentID defines model for RecurringConsentsConsentId.
type RecurringConsentsConsentID = ResponseRecurringConsent

// RecurringConsentsConsentIDPatch defines model for RecurringConsentsConsentIdPatch.
type RecurringConsentsConsentIDPatch = ResponseRecurringConsentPatch

// RecurringConsentsPost defines model for RecurringConsentsPost.
type RecurringConsentsPost = ResponsePostRecurringConsent

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// AutomaticPaymentsGetPixRecurringPaymentsParams defines parameters for AutomaticPaymentsGetPixRecurringPayments.
type AutomaticPaymentsGetPixRecurringPaymentsParams struct {
	// RecurringConsentID O `recurringConsentId` é o identificador único do consentimento de longa duração e deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independe da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição detentora (bancoex).
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	RecurringConsentID RecurringConsentID `form:"recurringConsentId" json:"recurringConsentId"`

	// StartDate Data inicial de corte da ocorrência do pagamento ligada ao consentimento de longa duração.
	StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

	// EndDate Data final de corte para recuperação da ocorrência do pagamento ligada ao consentimento de longa duração.
	EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`

	// ParameterOriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
	// Código ou identificador único criado pela instituição detentora da conta para representar a iniciação de pagamento.
	// Caso informado, devem ser retornados todos os pagamentos associados ao identificador informado, sendo eles o pagamento original (dono do identificador) e as novas tentativas que enviaram o identificador na sua requisição, indicando que representam nova tentativa.
	ParameterOriginalRecurringPaymentID *ParameterOriginalRecurringPaymentId `form:"originalRecurringPaymentId,omitempty" json:"originalRecurringPaymentId,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPostPixRecurringPaymentsParams defines parameters for AutomaticPaymentsPostPixRecurringPayments.
type AutomaticPaymentsPostPixRecurringPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsGetPixRecurringPaymentsPaymentID.
type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsParams defines parameters for AutomaticPaymentsPostRecurringConsents.
type AutomaticPaymentsPostRecurringConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsGetRecurringConsentsConsentID.
type AutomaticPaymentsGetRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsPatchRecurringConsentsConsentID.
type AutomaticPaymentsPatchRecurringConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody defines body for AutomaticPaymentsPostPixRecurringPayments for application/json ContentType.
type AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody = CreateRecurringPixPayment

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody defines body for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID for application/json ContentType.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// AutomaticPaymentsPostRecurringConsentsJSONRequestBody defines body for AutomaticPaymentsPostRecurringConsents for application/json ContentType.
type AutomaticPaymentsPostRecurringConsentsJSONRequestBody = CreateRecurringConsent

// AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody defines body for AutomaticPaymentsPatchRecurringConsentsConsentID for application/json ContentType.
type AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody = PatchRecurringConsent

// AsConsentEdition returns the union data inside the PatchRecurringConsent_Data as a ConsentEdition
func (t PatchRecurringConsent_Data) AsConsentEdition() (ConsentEdition, error) {
	var body ConsentEdition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentEdition overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentEdition
func (t *PatchRecurringConsent_Data) FromConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentEdition performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentEdition
func (t *PatchRecurringConsent_Data) MergeConsentEdition(v ConsentEdition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRevocation returns the union data inside the PatchRecurringConsent_Data as a ConsentRevocation
func (t PatchRecurringConsent_Data) AsConsentRevocation() (ConsentRevocation, error) {
	var body ConsentRevocation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRevocation overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) FromConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRevocation performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) MergeConsentRevocation(v ConsentRevocation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConsentRejection returns the union data inside the PatchRecurringConsent_Data as a ConsentRejection
func (t PatchRecurringConsent_Data) AsConsentRejection() (ConsentRejection, error) {
	var body ConsentRejection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConsentRejection overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRejection
func (t *PatchRecurringConsent_Data) FromConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConsentRejection performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRejection
func (t *PatchRecurringConsent_Data) MergeConsentRejection(v ConsentRejection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PatchRecurringConsent_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PatchRecurringConsent_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsParams

	// ------------- Required query parameter "recurringConsentId" -------------

	if paramValue := r.URL.Query().Get("recurringConsentId"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "recurringConsentId"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "recurringConsentId", r.URL.Query(), &params.RecurringConsentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	// ------------- Optional query parameter "startDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
		return
	}

	// ------------- Optional query parameter "endDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
		return
	}

	// ------------- Optional query parameter "originalRecurringPaymentId" -------------

	err = runtime.BindQueryParameter("form", true, false, "originalRecurringPaymentId", r.URL.Query(), &params.ParameterOriginalRecurringPaymentID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "recurring-consent:recurringConsentId", "recurring-payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "recurring-payments", "enrollment:enrollmentId", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostPixRecurringPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostPixRecurringPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringPaymentId" -------------
	var recurringPaymentID PathRecurringPaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPostRecurringConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPostRecurringConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsGetRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsGetRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID PathRecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AutomaticPaymentsPatchRecurringConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AutomaticPaymentsPatchRecurringConsentsConsentID(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsGetPixRecurringPayments)
	m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsPostPixRecurringPayments)
	m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)
	m.HandleFunc("POST "+options.BaseURL+"/recurring-consents", wrapper.AutomaticPaymentsPostRecurringConsents)
	m.HandleFunc("GET "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)

	return m
}

type N200RecurringPaymentsIDPatchJSONResponse ResponseRecurringPaymentsIDPatch

type N200RecurringPaymentsIDReadJSONResponse ResponseRecurringPaymentsIDRead

type N200RecurringPixPaymentReadJSONResponse ResponseRecurringPixPayment

type N201RecurringPaymentsIDPostJSONResponse ResponseRecurringPaymentsIDPost

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type RecurringConsentsConsentIDJSONResponse ResponseRecurringConsent

type RecurringConsentsConsentIDPatchJSONResponse ResponseRecurringConsentPatch

type RecurringConsentsPostJSONResponse ResponsePostRecurringConsent

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPatchApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixRecurringPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type AutomaticPaymentsGetPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsGetPixRecurringPaymentsParams
}

type AutomaticPaymentsGetPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPayments200JSONResponse struct {
	N200RecurringPixPaymentReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPayments200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostPixRecurringPaymentsRequestObject struct {
	Params AutomaticPaymentsPostPixRecurringPaymentsParams
	Body   *AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
}

type AutomaticPaymentsPostPixRecurringPaymentsResponseObject interface {
	VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPayments201JSONResponse struct {
	N201RecurringPaymentsIDPostJSONResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments201JSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject struct {
	RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
	Params             AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams
	Body               *AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject interface {
	VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse struct {
	N200RecurringPaymentsIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPostRecurringConsentsRequestObject struct {
	Params AutomaticPaymentsPostRecurringConsentsParams
	Body   *AutomaticPaymentsPostRecurringConsentsJSONRequestBody
}

type AutomaticPaymentsPostRecurringConsentsResponseObject interface {
	VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostRecurringConsents201JSONResponse struct {
	RecurringConsentsPostJSONResponse
}

func (response AutomaticPaymentsPostRecurringConsents201JSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse struct {
	UnprocessableConsentsApplicationJwtResponse
}

func (response AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsGetRecurringConsentsConsentIDParams
}

type AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDJSONResponse
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject struct {
	RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
	Params             AutomaticPaymentsPatchRecurringConsentsConsentIDParams
	Body               *AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject interface {
	VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse struct {
	RecurringConsentsConsentIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Busca informações de transações de pagamentos associadas a um consentimento.
	// (GET /pix/recurring-payments)
	AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error)
	// Cria uma transação de pagamento.
	// (POST /pix/recurring-payments)
	AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error)
	// Busca informações de uma transação de pagamento.
	// (GET /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cancelamento de solicitação de pagamento automático.
	// (PATCH /pix/recurring-payments/{recurringPaymentId})
	AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error)
	// Cria um consentimento para transações de pagamentos.
	// (POST /recurring-consents)
	AutomaticPaymentsPostRecurringConsents(ctx context.Context, request AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error)
	// Busca informações de um consentimento.
	// (GET /recurring-consents/{recurringConsentId})
	AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error)
	// Rejeita, revoga ou edita um consentimento.
	// (PATCH /recurring-consents/{recurringConsentId})
	AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPayments(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams) {
	var request AutomaticPaymentsPostPixRecurringPaymentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostPixRecurringPayments(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams) {
	var request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject

	request.RecurringPaymentID = recurringPaymentID
	request.Params = params

	var body AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchPixRecurringPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (sh *strictHandler) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams) {
	var request AutomaticPaymentsPostRecurringConsentsRequestObject

	request.Params = params

	var body AutomaticPaymentsPostRecurringConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPostRecurringConsents(ctx, request.(AutomaticPaymentsPostRecurringConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPostRecurringConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPostRecurringConsentsResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPostRecurringConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsGetRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsGetRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams) {
	var request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	var body AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AutomaticPaymentsPatchRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AutomaticPaymentsPatchRecurringConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
