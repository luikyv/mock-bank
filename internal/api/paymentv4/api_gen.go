//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/payment"
	"github.com/luiky/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
	N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
	CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
	EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
	EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
	EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
	EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
	EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
	EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
	EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
	EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
	EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
	EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
	EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
	EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
	EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
	EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
	EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
	EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
	EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
	PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
	DICT EnumLocalInstrument = "DICT"
	INIC EnumLocalInstrument = "INIC"
	MANU EnumLocalInstrument = "MANU"
	QRDN EnumLocalInstrument = "QRDN"
	QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
	CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
	EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
	EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
	EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
	COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
	CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
	FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
	FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
	FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
	FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
	FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
	FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
	NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
	PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
	PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
	SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
	VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
	VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
	ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
	ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
	ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
	DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
	QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
	QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
	SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
	SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
	SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
	TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Code EnumErrorsCreatePixPayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
		Code EnumErrorsCreatePayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: endToEndId
		// - PARAMETRO_INVALIDO: endToEndId
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
		// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Saldo insuficiente.
		// - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
		// - VALOR_INVALIDO: Valor inválido.
		// - COBRANCA_INVALIDA: Cobrança inválida.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
		// - NAO_INFORMADO: Não informado.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
	// Code Define o código da razão pela qual o consentimento foi rejeitado
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - TEMPO_EXPIRADO_CONSUMO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - QRCODE_INVALIDO
	Code EnumConsentRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao consentimento rejeitado.
	// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
	// - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	// - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
	//
	// [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
	Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`
	} `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
		//
		// • “E” – fixo (1 caractere);
		//
		// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
		//
		// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
		//
		// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
		//
		// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
		//
		// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
		//
		// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
		EndToEndID EndToEndIDWithoutRestriction `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment PaymentPix `json:"payment"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
		// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
		// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
		// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
		// Este campo deverá ser no formato UTF-8.
		// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
		QrCode *string `json:"qrCode,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
		// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
		// - Letras minúsculas, de ‘a’ a ‘z’
		// - Letras maiúsculas, de ‘A’ a ‘z’
		// - Dígitos decimais, de ‘0’ a ‘9’
		//
		// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
		//
		// – MANU - O campo transactionIdentification não deve ser preenchido.
		// – DICT - O campo transactionIdentification não deve ser preenchido.
		// – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRES - Caso o QR Code estático possua o dado <i><<i/>TxId<i>><i/> preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o <i><<i/>TxId<i>><i/> o campo transactionIdentification não deverá ser preenchido. O <i><<i/>TxId<i>><i/> deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRDN - Será obrigatório seu preenchimento com o <i><<i/>TxId<i>><i/> do payload JSON do QR Code dinâmico. O <i><<i/>TxId<i>><i/> deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		//
		// A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição]
	// Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
	// Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
	// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
	// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
	// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
	// Este campo deverá ser no formato UTF-8.
	// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
	QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
	// Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
	Cancellation struct {
		// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Identification string `json:"identification"`

				// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Rel string `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Utilizado para informar para qual estado deve ir o pagamento.
	// Atualmente o único valor possível é CANC.
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date [Restrição] Mutuamente excludente com o objeto schedule.
	//
	// Este campo é obrigatório no caso de pagamento único.
	//
	// Neste caso, o objeto schedule não deve ser informado.
	Date *timeutil.BrazilDate `json:"date,omitempty"`

	// Details Objeto contendo os detalhes do pagamento.
	Details Details `json:"details"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// Schedule [Restrição] Mutuamente excludente com o campo date.
	// Este campo é obrigatório no caso de agendamento.
	// Neste caso, o campo date não deverá ser informado.
	// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
	// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
	Schedule *Schedule `json:"schedule,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
	//
	// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
	// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonTypeGetPix `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreationDateTime Data e hora em que o recurso foi criado.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount DebtorAccount `json:"debtorAccount"`

		// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
		EndToEndID EndToEndID `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`
		} `json:"payment"`

		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
		RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
		//
		// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
		//
		// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
		//
		// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
		//
		// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
		//
		// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
		//
		// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
		//
		// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
		//
		// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
		//
		// Em caso insucesso:
		//
		// RJCT (REJECTED) - Instrução de pagamento rejeitada.
		Status EnumPaymentStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
	Data []struct {
		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePatchPixPaymentData `json:"data"`
	Links api.Links                   `json:"links"`
	Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	Cancellation PatchPixPaymentCancellation `json:"cancellation"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment PaymentConsent `json:"payment"`

		// RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
		//
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
		RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePixPaymentData `json:"data"`
	Links api.Links              `json:"links"`
	Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
	// Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
	// Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
	Custom struct {
		// AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
		// O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
		AdditionalInformation string `json:"additionalInformation"`

		// Dates Define os dias em que estão planejadas as ocorrências das liquidações.
		Dates []timeutil.BrazilDate `json:"dates"`
	} `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
	Daily struct {
		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
	Monthly struct {
		// DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
		DayOfMonth int `json:"dayOfMonth"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
	// Single Define a política de agendamento único.
	Single struct {
		// Date Define a data alvo da liquidação do pagamento.
		// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
		//
		// [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
		// relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
		// partir da data do consentimento, também considerando o fuso horário de Brasília.
		Date timeutil.BrazilDate `json:"date"`
	} `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
	Weekly struct {
		// DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
		DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PatchPixConsents defines model for 200PatchPixConsents.
type N200PatchPixConsents = ResponsePatchPixConsent

// N200PatchPixPayments defines model for 200PatchPixPayments.
type N200PatchPixPayments = ResponsePatchPixPayment

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N200PaymentsInitiationPixPaymentIDRead defines model for 200PaymentsInitiationPixPaymentIdRead.
type N200PaymentsInitiationPixPaymentIDRead = ResponsePixPayment

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// N201PaymentsInitiationPixPaymentCreated defines model for 201PaymentsInitiationPixPaymentCreated.
type N201PaymentsInitiationPixPaymentCreated = ResponseCreatePixPayment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// PaymentsPostPixPaymentsJSONRequestBody defines body for PaymentsPostPixPayments for application/json ContentType.
type PaymentsPostPixPaymentsJSONRequestBody = CreatePixPayment

// PaymentsPatchPixPaymentsConsentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsConsentID for application/json ContentType.
type PaymentsPatchPixPaymentsConsentIDJSONRequestBody = PatchPixPayment

// PaymentsPatchPixPaymentsPaymentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsPaymentID for application/json ContentType.
type PaymentsPatchPixPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostPixPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostPixPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
	m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
	m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
	m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

	return m
}

type N200PatchPixConsentsJSONResponse ResponsePatchPixConsent

type N200PatchPixPaymentsJSONResponse ResponsePatchPixPayment

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadJSONResponse ResponsePixPayment

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedJSONResponse ResponseCreatePixPayment

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
	Params PaymentsPostConsentsParams
	Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
	VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
	N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetConsentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
	VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
	N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPostPixPaymentsRequestObject struct {
	Params PaymentsPostPixPaymentsParams
	Body   *PaymentsPostPixPaymentsJSONRequestBody
}

type PaymentsPostPixPaymentsResponseObject interface {
	VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201JSONResponse struct {
	N201PaymentsInitiationPixPaymentCreatedJSONResponse
}

func (response PaymentsPostPixPayments201JSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsPatchPixPaymentsConsentIDParams
	Body      *PaymentsPatchPixPaymentsConsentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200JSONResponse struct {
	N200PatchPixConsentsJSONResponse
}

func (response PaymentsPatchPixPaymentsConsentID200JSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200JSONResponse struct {
	N200PaymentsInitiationPixPaymentIDReadJSONResponse
}

func (response PaymentsGetPixPaymentsPaymentID200JSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsPatchPixPaymentsPaymentIDParams
	Body      *PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200JSONResponse struct {
	N200PatchPixPaymentsJSONResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200JSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) {
	var request PaymentsPostConsentsRequestObject

	request.Params = params

	var body PaymentsPostConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) {
	var request PaymentsGetConsentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) {
	var request PaymentsPostPixPaymentsRequestObject

	request.Params = params

	var body PaymentsPostPixPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostPixPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) {
	var request PaymentsPatchPixPaymentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	var body PaymentsPatchPixPaymentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) {
	var request PaymentsGetPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) {
	var request PaymentsPatchPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	var body PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
