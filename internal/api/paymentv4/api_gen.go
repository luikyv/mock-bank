//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/payment"
	"github.com/luiky/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
	N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
	CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
	EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
	EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
	EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
	EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
	EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
	EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
	EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
	EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
	EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
	EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
	EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
	EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
	EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
	EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
	EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
	EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
	EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
	PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
	DICT EnumLocalInstrument = "DICT"
	INIC EnumLocalInstrument = "INIC"
	MANU EnumLocalInstrument = "MANU"
	QRDN EnumLocalInstrument = "QRDN"
	QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
	CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
	EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
	EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
	EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
	COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
	CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
	FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
	FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
	FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
	FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
	FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
	FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
	NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
	PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
	PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
	SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
	VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
	VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
	ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
	ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
	ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
	DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
	QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
	QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
	SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
	SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
	SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
	TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Code EnumErrorsCreatePixPayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
		Code EnumErrorsCreatePayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: endToEndId
		// - PARAMETRO_INVALIDO: endToEndId
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
		// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Saldo insuficiente.
		// - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
		// - VALOR_INVALIDO: Valor inválido.
		// - COBRANCA_INVALIDA: Cobrança inválida.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
		// - NAO_INFORMADO: Não informado.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
	// Code Define o código da razão pela qual o consentimento foi rejeitado
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - TEMPO_EXPIRADO_CONSUMO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - QRCODE_INVALIDO
	Code EnumConsentRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao consentimento rejeitado.
	// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
	// - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	// - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
	//
	// [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
	Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.Date `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`
	} `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
		//
		// • “E” – fixo (1 caractere);
		//
		// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
		//
		// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
		//
		// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
		//
		// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
		//
		// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
		//
		// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
		EndToEndID EndToEndIDWithoutRestriction `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment PaymentPix `json:"payment"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
		// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
		// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
		// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
		// Este campo deverá ser no formato UTF-8.
		// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
		QrCode *string `json:"qrCode,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
		// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
		// - Letras minúsculas, de ‘a’ a ‘z’
		// - Letras maiúsculas, de ‘A’ a ‘z’
		// - Dígitos decimais, de ‘0’ a ‘9’
		//
		// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
		//
		// – MANU - O campo transactionIdentification não deve ser preenchido.
		// – DICT - O campo transactionIdentification não deve ser preenchido.
		// – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRES - Caso o QR Code estático possua o dado <i><<i/>TxId<i>><i/> preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o <i><<i/>TxId<i>><i/> o campo transactionIdentification não deverá ser preenchido. O <i><<i/>TxId<i>><i/> deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRDN - Será obrigatório seu preenchimento com o <i><<i/>TxId<i>><i/> do payload JSON do QR Code dinâmico. O <i><<i/>TxId<i>><i/> deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		//
		// A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição]
	// Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
	// Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
	// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
	// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
	// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
	// Este campo deverá ser no formato UTF-8.
	// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
	QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
	// Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
	Cancellation struct {
		// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Identification string `json:"identification"`

				// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Rel string `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Utilizado para informar para qual estado deve ir o pagamento.
	// Atualmente o único valor possível é CANC.
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date [Restrição] Mutuamente excludente com o objeto schedule.
	//
	// Este campo é obrigatório no caso de pagamento único.
	//
	// Neste caso, o objeto schedule não deve ser informado.
	Date *timeutil.Date `json:"date,omitempty"`

	// Details Objeto contendo os detalhes do pagamento.
	Details Details `json:"details"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// Schedule [Restrição] Mutuamente excludente com o campo date.
	// Este campo é obrigatório no caso de agendamento.
	// Neste caso, o campo date não deverá ser informado.
	// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
	// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
	Schedule *Schedule `json:"schedule,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
	//
	// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
	// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonTypeGetPix `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.Date `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreationDateTime Data e hora em que o recurso foi criado.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount DebtorAccount `json:"debtorAccount"`

		// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
		EndToEndID EndToEndID `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`
		} `json:"payment"`

		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
		RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
		//
		// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
		//
		// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
		//
		// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
		//
		// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
		//
		// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
		//
		// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
		//
		// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
		//
		// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
		//
		// Em caso insucesso:
		//
		// RJCT (REJECTED) - Instrução de pagamento rejeitada.
		Status EnumPaymentStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
	Data []struct {
		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePatchPixPaymentData `json:"data"`
	Links api.Links                   `json:"links"`
	Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	Cancellation PatchPixPaymentCancellation `json:"cancellation"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment PaymentConsent `json:"payment"`

		// RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
		//
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
		RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePixPaymentData `json:"data"`
	Links api.Links              `json:"links"`
	Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
	// Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
	// Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
	Custom struct {
		// AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
		// O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
		AdditionalInformation string `json:"additionalInformation"`

		// Dates Define os dias em que estão planejadas as ocorrências das liquidações.
		Dates []timeutil.Date `json:"dates"`
	} `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
	Daily struct {
		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.Date `json:"startDate"`
	} `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
	Monthly struct {
		// DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
		DayOfMonth int `json:"dayOfMonth"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.Date `json:"startDate"`
	} `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
	// Single Define a política de agendamento único.
	Single struct {
		// Date Define a data alvo da liquidação do pagamento.
		// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
		//
		// [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
		// relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
		// partir da data do consentimento, também considerando o fuso horário de Brasília.
		Date timeutil.Date `json:"date"`
	} `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
	Weekly struct {
		// DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
		DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.Date `json:"startDate"`
	} `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostPixPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostPixPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
	m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
	m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
	m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

	return m
}

type N200PatchPixConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200PatchPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
	Params PaymentsPostConsentsParams
	Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
	VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
	N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetConsentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
	VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
	N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPostPixPaymentsRequestObject struct {
	Params PaymentsPostPixPaymentsParams
	Body   io.Reader
}

type PaymentsPostPixPaymentsResponseObject interface {
	VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201ApplicationJwtResponse struct {
	N201PaymentsInitiationPixPaymentCreatedApplicationJwtResponse
}

func (response PaymentsPostPixPayments201ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(201)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsPatchPixPaymentsConsentIDParams
	Body      io.Reader
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200ApplicationJwtResponse struct {
	N200PatchPixConsentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID200ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200ApplicationJwtResponse struct {
	N200PaymentsInitiationPixPaymentIDReadApplicationJwtResponse
}

func (response PaymentsGetPixPaymentsPaymentID200ApplicationJwtResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsPatchPixPaymentsPaymentIDParams
	Body      io.Reader
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200ApplicationJwtResponse struct {
	N200PatchPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) {
	var request PaymentsPostConsentsRequestObject

	request.Params = params

	var body PaymentsPostConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) {
	var request PaymentsGetConsentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) {
	var request PaymentsPostPixPaymentsRequestObject

	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostPixPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) {
	var request PaymentsPatchPixPaymentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) {
	var request PaymentsGetPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) {
	var request PaymentsPatchPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9W28bR7owCv+VWpwZDGWTFA86WcFghiZph1mWyJBUJiumP6XUXZLK6e5iuroVObEB",
	"337XC9h4X2AGmMxcDLwAX81aGxtzs4GX/8S/ZKOeququ6m4eJNuxk6GQwBLZXfVU1VPP+fBDyWH+jAUk",
	"iHjp8IfSDIfYJxEJ4a92HF2ykH6PI8oC8YFLuBPSmfyz1MFnZP537F0y9OlkMkQz7Ibzv7EaGpLQpxFB",
	"38YEYY6ckLgkcCimHHHyFPvonIUBcaiLOXLJjAQuCVyGXIYiOmPIJSgkThxyhjjzqEMj7LJSpUTFpJcE",
	"uyQsVUoB9knpMANjpRSSb2MaErd0GIUxqZS4c0l8LID38fUjElxEl6XDZn3noFLyaaA/aFRKMxxFJBRT",
	"PJ5Ov5tO/zid8id3SpVS9GwmJuJRSIOL0osXldKXfZf4MxaRwHn27+TZGjtDQs4C7NHvsctqqO+SIKLn",
	"1MEuC8Vy9TLnf5//jSFy7Xgxp1cMieNAPJ6xMMIhwojKeef/JXaztmhLrqs0ha/6DXm27rbs1LObkl+7",
	"wwJOgqjv5lc9QMmXaP4KMQGusc75PwPqwCmrx6hPgoghglxyRcL5j4iTEMU+Ohkdoyo6Ceg5C300IpzF",
	"oUPQMfZJDaFpcAKPVMQw4gnx/jkNqMtQgNHj0YPOQWOn8aR8GUUzfri9HTHm8Rol0XmNhRfbl5HvbYfn",
	"jnhoS8ApZszONQ30GZFQwDLqoyqg8/wVwlFIz+L5a1eg5xli8C3sJ0HTUhwG0xIiYlRxHHyGHQIrInxG",
	"nPnrc+owAbovjjOISCDP3JW3hcGj00BcEzEEzWKKvhgCoyiPSBARRBAN9DWKCHIx8pgDyAZjw551WMCp",
	"S0IsLhpG8kBRHAaHZzhwGLk+7DS63Var0WwJ4AQSEn/mKRRMzzUiPuOH06CKWLq+chwGW/IzG2DMOXMo",
	"FlMajwsIacAjGsVUrj4KccADn3LOQozKCqQtVDSmsY9IfBECSqWDl5OFbMHK+4AkYiv+h3DkCyLkkgh7",
	"l1iQH87OQoLkCqMwTg4jGY8DdvqAm+Kh2IvgxRujWm0a6As7w9Flel3TG7Uu9drdW0y8/n/iTB/j6vft",
	"6lf16r0n6a/TafXJD/VKq/HC+L68dbcynVZrh7/7wye/Pv23O7/9zXS6/ftfPbn760LKN8PP/AW3P0PU",
	"MGIzEuJkQ2f4AsN9rxXvQjrymrvQqNetdS9b8717L4rXc92JecR8Ep5wErYvSBAVLCxwqYMRQzEnYRWL",
	"h9RdjXk8/zGkDMURFddtCUV21DzVdJDSsoXdmjddP8AzKphiF0ckv5gujjAifnYBHrtgMZoRD6P5P72I",
	"+hhdke+BTDFBc8gsYmENjcgsJAJZsYvFoWKHhUDPBTUT12G/2Vp9HcRDW7WeJDCHaBwHFdSoozGZoWa9",
	"sY8a9w53WoetBjqZdBbv6Dme0SqOo8uqK1a66K7cs/ZS/GngTPmIBc8nMXn+R+I+n1zGzx+E9PkYR8/H",
	"cbBVQdOp+0PzBSp/hoPnD8jZ8yMcPm/PwudH+Nnzz+Lg+Wex97wdXzwfk9nzgRM9P2ZXz7vE2YIXd16o",
	"9w+tf1D54dHk+cmks/XrxeensbI/a7tuSDgvYraC3odk/neG+kNBApPD5AQRHtErEiIcxdjzgS147AKr",
	"szKOdMX+JmhLZ1WsQHl/aNsPIhJiR6ywiMIIvn/S7wKi7TSazZWIJh7aQjFX62aCo/a7AnEdFobE0/JW",
	"EIWCs34bEx4h8RufCZpcQx3sS3n0IiFlBJHgijLEzkJ6gaP5P8SOw8WhAQVeJziY41ESRFtIXDJOYnSF",
	"PeDfVwQYyZuXfxJsTPAg9ubln+X7LhHsHF7nJLwi4RYKGHJSUdJVoPEIC9A4Q4GACGQFAZRYZgaSCjLH",
	"hfnFUkDMUkdM002vUheWH7EwmP9Y9UCg0lMqzAF5lkc4ijlymEvQTr2uoBFIdSbEsNhXC6bB1fxHj7rs",
	"p4EDsRjtNJuoLB9x5v9w6QVDw/aofdSbjAan/eMv2o/63cFWDbXN8wKAsIOFlM0U7AI+uaEsAR2gUos0",
	"QFp1i+ylLWVw5Br7M0+86+4fnDs7ZLfa2ndwdcfFrSp2z5vVe2f1g+bZ+b1m86BeqpRAuIlKh6U4hqGN",
	"G9laJiY8rlfv4ep5u/rgyQ8HL6rmnzs3+bPRLGStL8Qi5TUC4tWs14c4ci6H9Loj5R342GFCBAami2cz",
	"jzqgxm0//Q4+Srfl1yE5Lx2WfrWdqqvb8lu+PVLzZMaXQGRZuTjyvEyChvQaOThwiCc4m0AfHjuEc1Yr",
	"vaiYwA+lmPLegFfjv2vgJdB65zta4hwR7C5bCZdq/02XArMtOYYudhnPK4LWothZRMVTS5bTD2hEAdJ0",
	"41av6Vans/Rg1HKIoigLTmjxghoLzqcTEhyRd39ActzVx9RZfDpOSLUwsWAtRYezxoJuczpqPW9xecRq",
	"8jfnPnZHUihYcQSfIOcSh5xEv4uj8+rBzVfQC0MWFoHdBrGEcqUnnzOKfOwBzXdxBTGfRhQ0erBJRIxb",
	"cgmvSOEgEGr8M49hV3BIHIX4av4KMDZ9L8DoZPQos+51qN17Xf+YXMQ0RJgjFgqJSqvxSg0hALd8RZ0t",
	"Ru1hv4J4fEYj4qNGrVlrZRa1HhX/uNfVrDVqLTitByw8o65Lgg+2mAGK2DckQAIuwh02Y4gGIGELOh6j",
	"2Mdoxrz560jo0a4QgS/iEAfzv2PA6CvKBOcSiwENIMDeGARgOeMHWxYsQYCPSBgycYsucES+w8/UaYi1",
	"BQz51AkZFyI7nf+diVUckeiSuccsanse+24lBX+fJwMmK5+6LEQgwsYICwIHcq62JQq6F/vIn7+KmKuV",
	"Cml0dmE9YiWOUBjxmUc+IC20zeQCCBpcgp3U0JIkpMil5ySU9lDGwa8ABM+fv3YpRjPwUAA/BgQVgz2N",
	"FZtzsBDWSUi4OQpBJ5MH1QO1Hw9YHHzIc807SOS5kWvKIwKYqRkGFQqFD0YbOM0xjUifD65IKDjCB8VO",
	"TiOwVcx/lIZYB4chATMFQZYBUaxDLJkD25sxyuEjHNHgQihjDHkUXE7+/Mdr6sMxToZjdOGxM+xVUEDE",
	"rvhMWSBfVEonAVaeow+4Ax1LucexgIA6as04BlawnSjR4lQlpU0+kiuZhQwu9ZlHekFEo2frq1hK34Qn",
	"HwixwpaO9ESwVB77Pg6flQ6XP1kpXWEvBjoh6GbIS4ePBRiuUBAfDEZH7dNh+2H7qHc8STTydklsTYSp",
	"Vzz64yPmYjG6S57YBAqU74hGoDMvg6tWevGkUvJJBGtR1p4ujsiEgq7erDcb1fputdmY1A8OW/XDev0r",
	"cWYvKmue9k6zaR24FEuXyNe3FgKUZNNCgpXGXAkFAa8tQAdDNL4RQoyx54od5PE5dQSExEaDgu+XHv64",
	"/agrjnx88qDf6feOJz3z2NtA0THixCMOZYEQyeGoZ4zzmCIOs6VzSddUSMDTJfiZ5WLQKJGH8QMhgil2",
	"vmNkCDhq1pqIoOZtcIJ/WKRIacFxe3A67I2O+pPeaad93Ok9kl+YSDJMLrZEDRVpoMwf8I1x+Os8/YGR",
	"4d3gArA3ErgzRoNIHTmPZ4JEEveIuBRPwED3wTi9NFOCq1aronAk0v+uv02kzlop3WHAuuXE9fCH0iwU",
	"4kJEJZJqNPuhJGglzz8gkS8XtyEtxiApiiFgy68oVwqyExomBNt2BbQIL7QA8UOEpsGbl39FixjgIVrK",
	"vPTr3fak+G1w7K16uTdpP/q0l39/cIi64BMn8oCyQ7BkiNSWLm5r/xiWI94f4nD+V59EobprVLrdC19N",
	"ZzXeys/VG4lnu72j4WDSO+7024dInH0mCkY/nYHnOAsEAv87CWK/dPh4mRyyYIvFNwv3r1QpLdgZ6xvj",
	"8dziSpWS/eKTiuENWAJvxvSeEsuc79egGGkUBRZHDgqu7dBN/SchUbfydki8THZ7G7TWd+48P6UhQqyF",
	"/AYaPg6YT04d7M+YgpadEZc4BM3/wlFILkIIWkMBuZj/w6E3uxnW4JYH8XZ3ZjGw2IRVklecnnyIXcyX",
	"3bOO4BLzf7ogZvgk4PiC+KjseJj6yMUR3kIuvSLhBVFmfPW0EfAj9DosOMoVKM/WpUXlXIza1tKLnKDg",
	"thkMpL2dZiiR6WWUAmVNX/30Mt1YwcjFDq7r2k5kkexlnMxfR7HH7HAmdRGT1VYW3knl792wlQ/OVtZA",
	"LkMHtVFpd/dGQRKp2/ixFGA0diU0/0nyGjt7SpxIIKCPr/tSCGqBP1j9kUZ34jDEz+BJJQZfVy9YVX85",
	"o7Uj8Xkl/bhKfYGgMmBYLKR0QaPL+KzmMH/bi+k3z7Z95nxTPcPBN9tUmXS38Yxqx3C6DCWoFcG9UnK+",
	"vdS3TJjtBbEP8/G8qP4+ees00Pi8Sh8S+L1Sr8lg5RpvfNR07qPbnZ/46t77RV1d/lPd3Z/m4lZR3rJ1",
	"iN6hPUtM8UX70WB02u70j9qnj/oC7Q/RQMUqlVmMvo1xEIEAI2CGiGplN9hCsReFeIY5B3kZ02tgUMpk",
	"rnI+Qvo9QGgGagFEylcSogS4RL81Z5GRUjLwjRgQp1xZQ6tj1bQBQJu3YTaGPh+hDoNoCs1lxWCdwf1R",
	"+7jTNmSTL0BgS4Ah1zOq/AUVMZP53RUJHKWpsxiNZdjYF0owkMMfj3vHk74tv6A3L/8T2WEQqTW+THwd",
	"gHZOA+xtwUALJRkSuBPWC9y+az+W7o/9xDsXg+W0mnx2+1/0Rg8Fpp5aaxcin4rOSQUYJeuD6Qm+LAzg",
	"gRnel5plQz/qdU7G7e7gtNubiA9G7UP02LKIMeSziF4l2UQcP1k0xnjYP0SP9cVWpp80uyTCZzI8E7nM",
	"n78OKBMAYs4CNGx3xrV6vSmH/kj0qDw6D3vHXTjp9slkMOp/1e60B4cZvE7SR3AcQT5Vcnd8iAifeZgj",
	"7M3/DtkPZYX4b17+adgeTfrtR4/+47Td6fSGk173zcs/q2yHlMO+W+P+RyymFPOCAi/EIpredqgP7EeR",
	"Z3H8Z7BrLiskq1/YobaLqGWHnamYi1Qd+Wkon3Htl9k8FpFF43Wx6VcFy12upK1N+OAmqpslg8JTEkhu",
	"SOtWKL6ryVkqkyrHN8uGiS+g7DZdKxgmYGhMeUSkmpo8wFE/4BEOovlfA8I4Ko+H/a1FhK1AY/4o6U6R",
	"+28jyK8tyN+POQ0I59JnWJCSoXNOyjPCOcPoaRzOX7vUwVuQYkQCgaEhrvIkASXIiip9Mw4/Rccaejwi",
	"YuPhqSdoGBISOJdaijMJCSdWJtNNZkHnDJIQOsfDzwoWIZDFVkNc5sTF1odUJCtOlz6e/9MnMltRD8IU",
	"R1fvSUiZwFTsyXToKPZwiLJw1Swcb1g/Nno3dqyo/+nU/aGxUxSxL1CiQD2aQEL2u4ZY7LYNpw3m43b1",
	"qyc/7CxI2jNxN7PpchV5TM68lRxiEc4r+jQi4gPKghHIevmtOVLypRBTnpJU7rT5BLLzT4XSqqKxQqLT",
	"T1NZlSm+WkPTYBrYF6DHOUmF2jRjWqtTQgGEUCiQqtG2EC+3NZsWLPMixh7CaNT7rNeZ9LqSVN5OyS7e",
	"I/AxL9G1hTQ8f+Vr1qy2BLsUJELKEc6mBMDORniB5HNbhfKTVTIDXsRq4c0H7UefCsnqwajdG09GJ5MT",
	"UD+6lkNeHIeHzrF3iSUxOg+xOM04ikMQwSg+ox79nsVCuFXRGbBoqUxMBLc97X057I8EL1/CQUHvZTHC",
	"oJ5lEjtnsUsE3ghthoY+ZFMVjS8Y98kR7GnyrowgpFC3AMA89+LrTPi8mMwpAgd2SqBafyLGPxmftEd9",
	"e3x5uALyLPPPjqlEi0l7fDoY9R/2jk67vfGkfzw47T88affHxcaW+SuF8/O/qG9dwiMaCKgtO1+iZsBW",
	"2WYXmNYyNiaS1sJZdSGLxxx7OKRsmwZXYmYYdduj38baNrHN4ihk/MlNIPrAtibDllSoo6DHWd67HTAk",
	"5JvgqVrvk7c0LH0+6gy6PYsQfD6CK64Ssd2VARlZWlFEcCGpcQE9kkalkAOAARb3ThAwGPUSX1Gc0OHQ",
	"ppEqrRE2nZOLmMrgYkEwD9GRYbJIWAoNZFAvlHrw01nFfQ8pCwnPCr23uWNvo1UXi8VLxGEdn9olZxEL",
	"247D4qLM+8HZUxIxIGmOYh04J3xA4o683IiF9IL4WudyWVibBm2e4TdgKGUmUci/h2bMJaHMrg0FNn4P",
	"xWoCVhz2kzCKCnIE0ljJwBEJLgWMHgHEEXQ+C5Jr4vcxk4MkWfrqK3WhpRhMUGKGC5Yn/AoxQVULkTFl",
	"malxAemQiAl2KPGtSzWrPsP0WpCI7FURt7J9Mvl0MOqPe11EkOQnvS6o7xjImFgm5UrAqaBkKTq/TF8Y",
	"U7Yxxfya5ihCeEnGjYg2RWQHnL+SsMOivArsFuzo5fxH5JAALgjX22xuW4T9M4FssOERAOOw4JJoE3Ky",
	"ZxJvVEA6Rj7hPk4D780dBRqmb2UNHTMOh5xMf8niKxLCK8qCnaK1ShrXq3Ox3hYWUqBmpEiUw/JW6bi/",
	"VRKduoTaQaNFOcpnZ0VOkyxM2iDWHw/vo3KmFsgie8P9EHPqERoyviUvXxhRh86wTNtA42EflY1X03A6",
	"YDCJqWILcSaLHAggAqln5ahio9na2d3bP7ApnV0H6iCXI/3kh4NidYlyHpNwYQwhxOcmxiRd2sa4bT5y",
	"568vaASsp5w8On8FqDgjgas+kUKLQCLMEI5I4Co0xAKJJG3gFfHlbP7PM486QDouSIg9ROChxJrMpSAL",
	"iRURvZImdiecv3JpxCpoGgRQ+Cd05q8dKn1fEb0CpxLPVe2paAlDVu8S6ODP/3FFPMhTEAycwsXFWwUE",
	"Y4k2L6V2nnBHI3sH9u4QddqdDipLyazbGw7G/cngtH36RX88aW8hgsZfPBzr74eDk2H7uNPOWYYa+/s7",
	"OR10abr8kx8alQW6cxD7Z0XIsPiiBNoaoDFCijySWFnlPBRLkkWjFM4IKSC5X2VZ8IPI5B8ablUQlJDS",
	"REXKbdg7x0Hsz1+FUIEKXkhoi8OCK0E6tOBUX3R57tWzgsIam9asr6PJC0qT7GTFol+FMkRRFnPOKCOU",
	"4IWChYyFlmwuwxVvGN+btxOd5Sxnyyhwxs72olJyQiIuZbjqzb5tAAHtOyNULXvdlsBeVEoeu7gg7gkn",
	"K2d+lD6ZVoZavdeupkOpLG7WGKML9hP7xTKi9H64OFUZ/iavWFMwWKBwDvUx5bVEg0mwngHHZqn9IGe8",
	"EYQLBA1tQ4BktUjQ2NQXMQvnr6pCegh9QadhHP08i+Xq9N8uDeZ/9fX7FEpLZSrAyUET2gqQYi+CciRC",
	"1ZFSktyPAulAExhlGjE1sxQusTJQbyA/PPOu2qXE5yuokXqvkk6o9BhZ7gX8ZFCSRfnWd5rNHAmpi59a",
	"o5mxUNoVmmxDYLkMFstKY+/FdFqTFZS2tgpJsBOHIQmcZ0s5ss8IxDgoMitYTACuYlfIZ/3xoLrTbOxX",
	"xLGJnamg394fPfptbRpMGOSKcrk5hCOfBSRSImRiWOKAH9JRrwtlqZIPeu4rmuypFH+y23R/9ChTxsXe",
	"EWkbbb0o3gW3sOqXzXuP4iiWcqMsNekmopPgxHBbxR13Y4/IG9DjEAwl0G7+KuPDU8qKdZ9lpUf57jGR",
	"L3NWyQ8vsTxBKdNlZ+2JzMIR/5kVb1TdL6sGlb1Xsg7XVrXceFyvNp88r//+caN678lWtdx6XG88ef64",
	"0XwCTCr5Jr+pFcsVIyhDHFGv1pWTv6U/Rg9XepGYTflqki0fEzLo2QWZsO+CTmE2iyYV4qmIfRdAmaTU",
	"FoOG/S8rkLSv6SBMFkbqFJXyCUM4zD2KA5VzFMGxqyTEvdoeBFvgIJZyC4yaBE+IG0Ygeq+hqkRhg9XC",
	"TdEZ1pghPw6oM389o/nSVvgTxNBwDJXOoAYTUQUmY58KBU1Aa2RA++ichFRfSeyCdYbICegMTDVgbZu/",
	"Zq5WteHqfpJBvd1Wvd6oZ5SGfYtk7edcLPvFUqJG+1UnPNbPvdCDrNbflCAk9baMaAVjGBSyorlpinMr",
	"XSaGXGAIJynfX+1zEZLYEkFuSVyvFuKSyMC1JAxmmakttCnrBRQ4+FRaOAd56oHHvisq7yvvRGJcyNod",
	"UxtVaJrNbQtcYt+ZGc5IamT0F6hNY4I6/fttwZ8e9LuDSsbkYZlL5HXTN1jeDR4pfs+lRSnJxoPKIgQ2",
	"kFS5FkUWQJ6uFsr8fvof90f97umDR4M/1qwkK+OLUqUkANe/C+Dl71aWk/1CnsUHs6eqrhAr0ryPh5+J",
	"c05cvban1yVCk5V87xKcL5FhKBZ7EqWi2FiV8xC/m7WDAqgYZHszd+t7B7utvWa9Xm+0dm/tf11SWbm/",
	"ViFlVZRpleU7QTBcQ931Ky//FHWXP2jZ5XdcdflnWnP5bUsuf0QFl1GhE90UZcW9WGyIShzqSiHSpDTH",
	"ISz3ekLaskJs4cFng5H2fqJazikPX9NQ0Mk8/kKQeR2vvFpA0U/+kUaXLI7kmTjaZLGRY39WciwQuj7c",
	"Xy2wrRJPH2VesS1Gy95WUuGQXsNLIbsuUvEhPNoRhCIKwfnNULffmYitiUjg6INJdryGBqZdWbzOwdwC",
	"hOcQRcQj5ywgFUSqPqZeBTmz820hgAjZS0ZjY49IUoENr51LkneRQzwIhsoruFLygnYZqFdr7O00asrQ",
	"JKeTr0Rgo9LFEa7Vzx/Uv7Xr6+ty7fp6C8Ft0JWP9veNAlY2YJ3hA8u7loIjGGOjkbhOKuCfmDFwtUhr",
	"/vzv4FEZypCaZEQQuRYPubPGkAaA2X0t2jkmi0Cb5XnFSRt3VW8YsC2dIxFgpMpGt2rTYGxEA2Vcppbf",
	"TaaRhDJE5/pZglaKNWQugsUHJFCfj7rHYrmfj3pjZI6n6JFNVWtga8FW9ooQsWdKzXCkRL9s2v5xv1Mr",
	"UBuWvXPUPj6pJDCplVqWmdRCWFs+mJi+UrD27PDJyJz4s5BkTZA64UHI2gs9EZlQx/39m+QBfBsWM5sx",
	"+TZOHG9mKTgZhRDKqsYuUJPUqCs+o2eWDmjGIMz//0L+WzYyF1QeybIGAqU9ItBCPJhYXpW7RmirQrKX",
	"FfwiFgbMzsnRIQx4Nv8HT0QocQHEsQCKcYzO40AilUwZm7+CUKH56yvioQgnVvm83VuFTxRbteV11ozZ",
	"leVVIYEF/JrSQW5sBNxijMg2i5PF52ATY3TYjGJEUId5uGZZJE3qE6TUEor11W7qdjQ8zDMWpnvPzjgJ",
	"ryT5ibCPg0tmlprbbTTR2bMoH4lTr9eb9UZ9p7FjoG2ztdPc29ur1xs790e1h4Mvavc792vD/pf1xs7O",
	"3t7+7l5nr7HX23vQarbqrUbr3k59b3f/YK+x192v73X2dpu9vdbeg71uc78ldM7mNLg/qnUGR7XByWQ0",
	"qDca9Xoy3W6zvlOv1+u7rXrr3sHe7k59r9Fs1XZ2dw/qzfuj3XuN3ePBUa87GPU6vfvi3716/eD+qD3u",
	"P+q39xr1g/16fX/nXr2+15wGu636bmN3NNTDV5v1xr3dOoCxbyzmPkRo1Rv13UatXqsf1Hd2i5bbbA3b",
	"3VF7UDsZPRKfbIuP2venQad70GjdE8vIrAy2r9a+3+nWBAS1P375H1/tteo7vfv7e7D3BkHYbTRvQhFC",
	"4tMowoFDlAZTHMZd5NJVRCwbe6kuIg3E7Q4R9i5iPyM24sSERKAIZ4KAFaAYOrYV28LLwvRlkHwijL4c",
	"Tgb11m61Xm/WsgaJ+o3SpaRXWrZkWB7fPglxBIH+LilUok0Hndgp05MkvpIFOYV2jp1IcXYlKCckjam2",
	"ARixUMhqlg8WAWGztleHGM5/tDbQMtAl3SDgIMTYAM45CSWRqmhur0r/Y21HwNrHowPRZFgKKLUQLWWy",
	"gAE3Sb5RfzRQlsvrKCGYMy1kCfoWXVMXlXtHX6C9ZrW+u4X4/G8y0eyR2DeOfBrM/8md2MMcEtTevPxf",
	"+M3L/42w+O37Ny//t/ksptln27lnuzLGIHWd6kfryaP34NHl1NW0j+by5tK8SL3ORKYAkUIl/P8nyCao",
	"mrg9F+LjEoEFyZFAcHsnIwkhZ62Riryz2dgtzddhS0KEo/kr1Nw1kcWK3OCoLDT+5+3qV8/r1XtPthKo",
	"QMSsaqtvnnFDKLDAKwiEm8b1esuh8A+Rf6iPtuVnk+u+m3+I2A8ZC0slvOX7oXl1RuIDNyEYWipazNVL",
	"SAOZBfTvCHC2PhrkIa6hwbuC412dffcYVdEYYM3kRsUZG5e8ge8K/LSe32fjwbERKmAIhe9nt2SGZnMP",
	"EdS6yZ4JytIuyO2wNT6ujJSahElRlBj6eEK5zlmIfRWZJ5hAthuQzaSy9YJ69Xq9ddDY2xOiVH2/udfY",
	"3b33bO/pXiYKYHdRt7MfGpXW7hoBVoa5Lm/CSc0xectg1vFSmOC4OKfxBn7ArEHyLcPBdbqHy9AZCcg5",
	"dShIZtuGGQhtQmc3obOb0NmfdeisGS2bXO1NvKxNXt9/ro3YxZ9Ztg3qSl0kBOSpiPkh2QPezhRDIhoy",
	"28MOs4L7NulQJxablgq2k+s2zGbDbDbMZpOn8S/Ed5Ko1uVhe0zHiRC+kmi+ffDCO/Jhb9zRG3f0xh19",
	"M3c0rPed+aNXjLZxSG8c0huH9MYh/bNzSOfyL7IG26wMVCR89awQzRv4a2WMeUXztVw5tQXm7UyD9FU1",
	"aSvgCCXAvCImNCf0FJIKsZ2+Ialu9u60sy3lc641o9aKvJsdlkaJSnE7Adc1FfrstendE0h7cHDQrDcb",
	"9UbzoF6vHwBSH+y3GvsZYbvVtITtVjOTwdd7slXWOqv+befFVrkOOWjPZbJa8ufjRlVnqbUe16uNJ1vl",
	"5uN6tfXk+eN6Q34Bg+wmv5u+gcaCRMGlIblr6UcGbUtkRy0UPnv27NnRket++qnvf5P+oHKraTCaT9Cb",
	"l39yMBdDCy2UXpE3L/9cQUIJR/NXFd1+UxBmL+fARsR0fW8JiS4wKsW/efmn3puXf4ZCpuf0mqFyI516",
	"6xMZHC4e1DDDkzmLF0NYJmwKpnhBQiiE9X/+O92+//PfFVO3PtTGlZydhOp+uAseoIF6pHxgMmPDkyXP",
	"1wDd3GYA38XiUl1Kc5VPg1gM1zD3HPZJVXdh4kmpvJ5MOhVxBXh85lPOlbEvH2SRmNzMKlY6i5iykEJO",
	"LIYMWtU7C2vxgwRX1BgWM8RTm5E5npoERlWVoWSasTgKVzvSpOwfuiTg1tw8KaZlflhB2CFUErxMpZiK",
	"lHDWOGfZKRejiHkknP8VEFNyXVhDowlbzyt6xedxFIeCKCYCGOcg4hMfhcTTMUDGOZBzoktAWUXh0m0D",
	"WMfDvoEG5g0TWCDkGbg1XpITtNYCUbnRWOJIFXRlu139alv5nhOioBOSVGqI1HzFBTTx883LP6uMjLbr",
	"08jIMssAAcdu6lMF16hS8E1yfwTqiW+pmQdmmhMEGD3PMKtobpczlIVkRsDaApH12Ps2FjpwHIVWd1oj",
	"Rms87AOnMrRIIS0aiFtBGecwSIsVQU7FdkQ4uJCuZ3/GeFpVMvXeVnT+XSg0RRwl9mioOJhIuCCBBop+",
	"ubKnboJmQBAbu4f1urz5EI+FoVRUxsYuWDIOVAF0iZ1pUlm9LkYgqNk63L0noEwmcAlYjeevPVrQgOmX",
	"yE6LTfOFBVVTGylH0NKYZ4T92jRI+1FxFIVGjUxNVVWcwYhw5qk0qp3a/m5LYTGY1fyZB7KVmuuKBoJX",
	"uoJCTYPUTc586lBPGp7BsiwLy1X0e8SXxQsgByUUCEpDILNyCEMJDaDLMhEalGDY8/8OqINBRb+AiD+r",
	"QiZQiSS3qnd8cgRXpyrtxlXUgXzlSPwG83QY/C1rAILtuIrG+IoGFzx5Rtw3Fs+g0LmsczlqH6Mqmugw",
	"n+BCHZP1SlqKJJy/qopzsDNZBUSlSklMWqqUxJh24qr6vhgtzHQxWR6jGDVGUlpFTKb65DM8K4jJSx4w",
	"3csa2unHZmtK6cJq/7Hdn/SPH57qqmztSX9wXEPHGHEaxcurbOdLa1dUqRLtHzSdciFxKNeWqnOaxF6K",
	"waGoq8oddqFUoczAUwuUsOriJsglUEjNxWW+Zaccl2UfE5eJb6z5xQdBscUstTyUpfNzS14zo1Adi9Ny",
	"uGiQWRn0gQmS09Al7ZQdgwHah9lMW1NtsXLCsuXjp0HPTy2N+RKqsvlDvpafWT9S1loxCvqqah1wk7X5",
	"hHKQiYsxAlVR+yLGoSuTVM09h9o3OUwAAcN4pQB/YLZ0j6uonWCA+EqDi6popMtpis+T/YWLyWOfusy6",
	"hMUrKFVK6WSlSkkPX6qU9IiyB2dmIfYFXjh24ZVeUv64QHU6pwExekW4GIX4exmd7CVcO4N60O8+2Zxs",
	"6eNc/eJFZYmXVxJeXAe4sHjvqiq8K8rlFteuLS43W1Dl1UIFeztyrVMrpaLNEJR74V7kv1RboVDK2gmJ",
	"Wws3Qn9dvA+CjxQ1Qs/vQqlSymyCjbSFwxQibFFTrLfofry4usDCDijgSJCEedME60M3wap8mBZYy5t5",
	"Vtdv5Xnr+u0fQROsTWOYD9IYxmIf69PfHKPJXUElZ+Rvzs17gucfWoWoq5uSL8ak4q/Hw/6C7uSrj/Cd",
	"cCerDtR7YVDvoZOowqvVY9pbtMbzC7bsUT58xd6rXhJtYLZIX6SqANtWqVb9QKhl8IiuhkE0sSsKggKC",
	"J3OrCl9NHOdSqINElc9HyLH8tPI7SGDS3yUeXvGdSrnqp1pocT0vGc2JI2lmLywExY1IDL9A5kj2SBWC",
	"NZxbumKXlU0ArmqBh1jHNkKp8EX1u2RfFpVtsZ1UQtTygFmAU2uPQsenwYVHkBuHYOvEdoBpxkqAZyTA",
	"UK3Sn7+KoHKlDKmAY9LhH9xIkHSTMEyFyeJ5QVz6nQlIod1j+KcnZFtxFjYeq8cKMVVX6IU748maOSHz",
	"i5UlWVktW01NcnVZr5Uqo7BsrwJqknYQMLthr9j9L1S1zowuLFbQb3cHozaqGpdcva7tzrlE3gCqtoMV",
	"zvIWiiETsvoWIyYc3DqKFFhJ7RX1tg7AembdY1imtQ6y1fllFxkZMCOvC0R6qIKw2hiyQBDhCEtbfZi2",
	"OCqqf0d4JIQsy76Fk4JlKbobx4zK5LqmxVnrtv4ODbvHDytGVEZh3mEQ+0hR3K5ma51+e2sJ+hQ8vuDU",
	"SaCiUwiP8BUoFob5TcBnj9d+2DvuSsp/qxHHnU+79ohHJ48m/eGj9vi0/ajT7rbHt4O0PelkDKK5LRAi",
	"QtFCrM9z4GTtqEXDrovQy4yrJwtoCvwFxEQbXQWiUFv1hMyGKMaepPC6wq2u/5zEKc1fASrVcluVX+WK",
	"ZQ1JuPBuTmSPtYpushbgKA4xhHM/jUPqSp7/bQzBo8oI6af9QlxSXAnTlmR64/GgfXrcnpyM2o+EqCg/",
	"+Oxk1O/2O20j2qQQ/mVHIQ2UCEcgICwpqo4G+lDIFfNiCkipe+aAN1RX5EKjzhddVB4Rh9Ar4m7ZooKg",
	"Vt/GlNOCaoiShcjEfiAIPHbEtmZIWQX5gorRwMXQPyRRrSHRXxAWKNVFgdZJFVGFE8ZnPomSrBHTzQ0c",
	"qllDgDOorDC5AHqzcgLUB9CqkQBeX+Ec9Aa7SVuDnTOjG5h4qdzudIZbAne0vRGj8uizzmQrswMAbauG",
	"kHihjNqOQ2YRcVEn5hHzSYiGITunHslAHzGhnmGeRMKrPQuIAFQ57J/Of1RZtJqba/eWmX6T3wzp5pyF",
	"IJPC/polM3IbjsqBTFbhEJVr1FoAj64drcRipMo0y0uv3jGeV9YsHUVovS5zKXZgu4ZdVE63yyMY6kAO",
	"pXu/4LjTNYt9kQhE4szSc4szMVQ1rvFR1ifDJc6o91xsnTuAvCsu02edibhMT4kTCfgWIqNpps7ZXLQb",
	"XrvE92Azxh1jM8YkimQ3RNSBxojiwy45g1BT5adbehsEAMopvRqA/RoClovKQxK4NLhYsvMhiWTIuz9j",
	"IU4CygruIvjLg/mPHuUEpjmoIeDDqKzrOK++0WIdyk9v3+MgewO104gG6hEggerElOtDTmeV1zSdUulx",
	"GwRfEFDFqUuVkrjj8M8QXCqfgXgvDk9wgu7xw1KlJJaY0WblF8vYwkKGkAbPKm8JNNCzAFdRyfMfE8lb",
	"eeJWtTbLcLb+lxmw+18ugvpdOniyLMfwfBVZzFH13Tb1K7aeQxWTj6SvX95abkB3C3N5ocEcVW9nMRfE",
	"JGczz5mhUVXaoZOO8dtmVK0uDLE8JlaNu9r2h6pvZaVebqcGLSGxvD8OmE9O4YY+kUfAzohLHBKi+V84",
	"CslFKHMUA3Ix/4dDWW4RefMjqmZapqZdcIkyST9ZPIzg4lX0OEnilAbBNOkG8FZHt8xfB5QJMKEB47Dd",
	"Gdfq9aYevchVmAPuLfu5LppHrUPxhtjHeoabWeIXDp/Y5fLjd2lIVKaBS5CVCSyl147U3CepqY9yVBYj",
	"Lp2y3xkWzohR394zMYVMdBvKfFjMUbnfGS4dfTgeniaJAQvmyZyNy9AwlHpEmC3tnmrC5eF4KHuWS+Wo",
	"gHwW77CBz3QNYJYQgFyiOghnUHmcJ/RssdfZ3g0xKuQO20xUZgpZ7QsRQQU1U8A6SC9iTOXcg1wj08J7",
	"E6QhSNBbZv7aTQ2SLqHXEGSodKPEzlfRPEM24+LUr0BVOOYwf4YjSGRS9XeETH4Rqr+gAhDjVhxoxpD5",
	"jl09H4+LZkGEwyIqs+grZbpddJUXfWXdw4VjG+tYGi9xS79RgXj2kECl6I2QthHSNkLaRkjbCGkbIe1f",
	"SEjTyze8LynZEHM/gBVjnRQSGvnFGylvI+W9XylPv1+MnbcRAleVpC4qMaNZ7Xrd4JzZeSeYPV3WkisJ",
	"OVLuOBJcMe+KyjBSw9ALXkSV7w+lfHzEoAYKi6FwSSVXJVm3cHWYpzNuVdHaZzMCww1gAHkT06iJTPkU",
	"VaghXxOluASKGvd4+FnxwDu3HTjbkeZgf29n/+AetE3bz7dNM8sVNfJd1Bovfv18aT+1APtFtuY06SLj",
	"Pi0s7iJkKsjF84gs+RpJ56uVZmKXE83P8DQO56+B6OfmwCjRQ6D2lycThGHacyx4O8UL5sps5xEOHYba",
	"QcQCnX9HI5bZ1mY930wWV7+fv6zO/6/5/6rO/+/5/1Od/7+V2h8Op3G93ty7c/fUKNZLylv/9vvt6XQ6",
	"/fVvplP3t6j65G5xOtzMcl+v2bvS8Hlnqx8Y41WSO6mOuKjuwSOri3UmEkB7Rcs2AkjBggQygqzKCfLY",
	"RWHxg75V/GC4uAm4y5y4uKUlXUG5jnXZMfGfHAQONZufzoReaRcis5sTNtKfDC4U36nizghecSLj24PX",
	"GT5Y1u1YNzteoyyZvaES6NVNSfUBFSHREEfO5Tp9SZe3r7IG6YpX1i6JnHnZjHVZq4Jnwu+STDToSpAL",
	"QwPXmoyyAvJjBljJQkmZJqeCLXmyHLbUBwuLtOmAhnZBfKrYCJmRjFVgwuJQPqOYVhq6KRFs9KBTbbVa",
	"9ypGnZ1OraB59G612ZjUDw5b9cN6/atsG+mqULnzFfPerpf0pPz7Q/HVdOo+bz6uN5qtJ1uH8rNma2dX",
	"fJ77+6sbNaCeSKjfURPqJiBmcmr3Cwrb9e2Wd6pnhkx9vxFW2RX+lhLOZVguhnexJdcZ9MiAaRks+elv",
	"R50LtkDmRfP5j1fEU6a0ZZvwYcj2u4T7Y6bnCWY/CJl/A7mkMHQZJhYa8i0HMiIKsosw6aZ9H5M5s4tZ",
	"g3l0FbMqpNGrWQq+COMZRvliyiQNxb4xDcjrRwNZ1ww+OJTFT5NurWnIGHCgb2MChVSEsM0X5QVle1dX",
	"7MJy2QBkqD2SduAGRhf7+WURM7KbyZIgy3nghppuqOkviJouIln3nxXSIhnyf0tSacQSZ+dV41ZsOlZM",
	"DeW40sGy2lSUxEqnxMFsy00X4Dr2i8vrfyFTeuzIP4f5qCnoF057beWqi9bFT63RzCDuPctAYneZL4Ow",
	"2qg09l5MpzXxe/PFVrGi7kCNFefZ0vrosqJLoItec3IRQ+kH5gpc7o8H1Z1mYx9qfgkCWkG/vT969Nva",
	"NJhA7hHj0pJFOPJZQKAgF+OpmQXKyiiPnOqoJj6UZVfl3FdU1q5ymSpGn92m+6NHy25KWV+V4l0QKkB+",
	"B+zUraM4inXHrmvHi92kkD1DTCKPTuaqIVWHw2BeVmnPIK0OlaKXzCmQ7x4rzsdB/coMn6mFa7pTCxQf",
	"8V9W3cng0ltrOjdSWt6dwgLkwE3riy+jLboM+abb+M+t27hG+1UnrKOtoW3lzSyPhbwlUtZGTSErmrin",
	"OLeE0RRGoSxgMpr/y+ZsTFfQklTzffCYJGIjISIamZMQjmwsApClYXEF5jRnFcpnuSQioU8DNY5+nsUL",
	"ajTD+9ItazjySeIASaryAaS6WtRh0n9R7sfCDL/Uj2LEyaRwiZV1knKTmXd1Jq4O1zD621WsBqZQtRZq",
	"VEKIw6eTyVCHouw0m78gpi6UtJ8HW89c5+TyJrtTeHt/FsZWWUfTlk8GWkwwRWHlwbOED+WmVz0DWFqB",
	"T94mXc/FqMcPOY1oY+HdWHg3NomNTWJj4f1YLLyZ+Oc8KhypWE0sQ5kLGtKhvmXNlZEO4iss+DpnZ2HK",
	"dtLaDVne0+OcpIGhaUSIliYTXiNZjCyBUsBoMmmMBeE4SmVbdRxFiXuJrlggFikWbpu2jaK7mBVkULIs",
	"O9k5uHV7B1hYAuAah70o0H1z5LlkgJ/9wQOlJlb1RsOOWRyTsFzxLHLjFPbaXFibIXdOZzGnAeG8F0Q0",
	"erbqxO7bTwvaLacv6lTSL2hNkouWT0rdLwc89e5gWcFeI27so5PRMaqik4CKnYHK2nHoEHSMfVKbBifw",
	"gCGpQq6y6nTyePSgc9DYaTwpX0bRjB9ub0eMebxGSXReY+HF9mXke9vhuSMe2kLzVzBfZqZp0oKehAKQ",
	"UR9VQa6Zv0I4CukZBNqKK4oYfAu7SdC0FIfBtISgj0uAfcJn2CGwHJCm56/Poby9VL2EVBhkFO2T0fE0",
	"AAU41wlGBfqHUFQihI4NYAMVGjtJKlG4WPbg0n622jQQKEpdEsrKwkjiP4rD4PAMBw4j14edRrfbajWa",
	"LWn2INfEn3m2nb3vooj4jEOBMpYurhyHwZb8zAY36aEprm66F7mQbrCRBLrfZ1mBVDiksYdJjwNz7HKy",
	"jq3aNLCpK1TAlm0NwR8pyatcnpmfn4zGgZr6utsjtMqCZrg3xbGsKl248RlCtrtnyXLiFaP6ffrrdFp9",
	"8kO90mq8ML4vb92tTKfV2uHv/vDJr0//7c5vfzOdbv/+V0/uFtsoBDWjLEiUnKX6Y1IrKl8mWV77Gjrx",
	"ExyDBpzG22volqrrm7whSvdOE6KoT75nARGaZ/lk0oEPlDq6tVFF30YVVZHXq9hFJtAbOPrZDfp/Sqzh",
	"dg/sF+LgZjR8ezxcUsRIpa7VkLKeWi9CETQlFBVXIK/kGhO+efmn7N1Bd9Gu6vbDoc3KNGhDZQwo2gY1",
	"TCraNQDEeBYy6B1XBpKP1QeqwaNgr7J4Skh9QsP0+XCrkl+6KpcFRDutpb9qtUUtBmAo5ZtI7VIYzZg3",
	"fx3J8GkLVN1DwqLsa+x0Ui6+oohtblLYZvn4yUzcWWOr9+rGXquuU3KnmdzrpBFfUlxRZ0ACQfcLKpRo",
	"G3Tqv3F0CXwDA3x2ZQyWr/6/oUS3p0SeFTG+jJgYseUvxF498z/ugIKNs2fj7NlEcGwiODYRHJsIjk0E",
	"xxoRHOsHKy5q7ZUMYguPa+oW2twCRQGjWHlMP6CGu5Esby9Z5sy92sq5AEUKLCOFamoljX01RFdDo05F",
	"0yIc92jwDaC4uRV4RmuP4Iu33gI8o3AdfSLN0dlpjsTn72iWomw6vUIFwRp29TXy/ATp5zeO6pJtsQtz",
	"eJemnmOTuDzw2HeLyuU7LFAOCy9XOj+xmwip/9yLr1kuJaKoELsgPWkaRHEjg07/flsIjA/63UElUy7e",
	"lJUU/9MsNVCFe5UAzoEHCqaEn3kMuxXE4zMCO2m0iF0AebpaIZ+hT//j/qjfPX3waPBHuzyE8UWpUhKA",
	"698F8PJ3q/yA/UJe5g5mT/sBjShWtqvMsRwPPxPnXNx/Qsh91FWC6CUUpIkMx8UMyqAklNkshNI3bEyB",
	"7Ipu8+z63sFua68JGfW7+Yz6bFTBgsT5jSdm44nZeGLeoSemKFzP1i2h3fciArowVC/HISzPekLafpme",
	"IFNKVj4gQRneQkQW9+4dysj1an1/LRn5X9nxs64DJ/P4TR1AecdP0k59tZ6XPLmxPPzcLA9evk3aKp0+",
	"21ntFjb+TT7HxsS/yef4KPI51NUt0mX03rE4I2UqtSYtA7a8JKxW7FVhX7034TRYovuI63FF3Rh74vJ+",
	"nYD5dYqFRv8/hr5OGdbXNeWZAJ3XBl1cMzMaM1WQA5wIsYLuK+fx0sCFcxLFaZ+Q5AwnX85GRyf3Tj6f",
	"jAZHf7z86ovm9fik8eAEf//Z+KjrZT0TdbuSmx0svkSkvHevmKTPQnZddBOgy6QjJPQohCLMTLY7FISW",
	"BI5meEattgGHLiM8aVLJgSqBxH+IIuKRcxaQCiJVH1OvgpzZ+bbQ/AXGyKaW2CNSRhebdJy6hPS7yCGe",
	"rBaXry0HJg83FNveqzX2dho1RY/ldPKVCEi5Tny5Vj9/UP/Wrq+vy7Xr6y0EUoYOO9jfRw4OsROREOpk",
	"GoB1hg8WlOzL1AysLKzhN1ShDHpEsHUsHnJnjSENALP7WlyV7+Sk30UXwDZk7oI4aUMG0huWivryBowe",
	"dHYazWarNg3GRh3qitX6J7XUiallselQ1gu+fpagldLJMgKGpYBJoKDjqe65aY6n5DxbspV3G1s1rsU9",
	"nymy7khT2rJp+8f9Tq3AXrfsHdkeVMOkVmr5KFNGWls+mJi+UrD27PDZuKYMp8Zp39gctxV6zN7+wb16",
	"JnNmf3/9MGzBTHLZE8tkw2yyBYzg0yjCgUOUqaE4l6hbIMioRUuxKJecQwNOQipko4vYz4jvOLH1El/I",
	"JwnBriC7/RleUizSMEYKShlhNBpPBvXWbrVeb9aylsP6Tbb1xqU+3tZv5mIEhX98nHjLVnaB3pgKfj6m",
	"AtVrWpz8qnq/kxBHULnTJYXmU1OR0qKSlvjFVypajwYRdiLFWpQGrK8mZsB4QoRlB8osWmUJb9vqHnBF",
	"tGWPJT3llLZhsASWGgikwqIaVDK77XBFcgPiCTkhuMSIU9fQ+LJdL/HC7t9ZjOzV6/XWQWNvr1lv3Kvv",
	"N/cau7v3nu093cvI7ruLhLkfGpXW7hopgKl0bllkCn2gC7ylhhfU1ttTtT1vbcp6cLLWpCJNQjsvwxA/",
	"23hQLQ8q9O/Pu00JtPW3HKfFqV0LdFrVLsIy+gv8dmeMwiFaBuvdmzCpRflgZjsJj1zIInEzFqLL2McB",
	"qApC88rC9Tb5YJVSRCOvqM3v/HUUe28Dx032pDgtTYK2ND3Nx9d9ebyNFqh6+q/8ldGonMlYJBHOZKOl",
	"Jsr5X1B72NeUDHyFOfuZ+JLwaG1pQevBH6zowMcTjpLdutwBV35KuqMIxjJSo4tarsx/TA7q8Q+mEWgN",
	"60WxBFospr2o3GT065uO/qRy+5iT/D3Z2MJ+abawjbK0UZaWUHdTvC5ElY2ceyM59500BFgwmGwMsNnu",
	"xdvdXauywSb48hcffJkpzHaD7htWTbdNHOcmjnMTx7mJ4/wXr6ixiaPcxFFu4ig3cZQ/bRzlcqEtqaC9",
	"ieDaRHBtIrg2EVybCK5NBNcmgmsTwbVxSmwiuDYRXD+LCC6j0MUHjuZaoztc6nLYVFfe2II3tuCNLXhT",
	"XXlTXXlTXXlTXXlTXXlTXXlTXfkjqK68hsdAi+03Nw2pNwssRJtikJtikJtikP86MYfvKrpzE9i5ziZv",
	"Yjo3MZ03junchHNuTHgbE97GhLcx4W3COTfhnJtwzk045yaccxPOuQnn3IRzbsI5N+Gc/6rhnGmz901Q",
	"5yaoc6OqbII6N0Gdv+CgziL/wtjoM3jbRqDyrMUKamjdDqD4ggQuTmIN7Naf6YApA8+JZuK1AZqF+Hsj",
	"viGNarADQvTbrlBEKEc4ELIciEjSkjjDYUQhuAPIp5DiQgPB7BF1sXsMGon5nET1slzAthhqO3voWxAN",
	"ky6/qB+qvF+KFodyxzm9UgeQ9EadljgNLjwyLUm8ZwEZnEP5rnVaRo7hXajHtc7jXUy9Z2s//UdCvrnB",
	"40csiC5v8Hwn5hHzodqXScHV3aglWP3WBFzfthfGXVGT52szJp8vu0ltDijGtXQDZliPcol18qsylBJC",
	"b17+SVwC/ubln7fSFhC+ovMzElEX8yRUR76afA4GGD+ZRdwrTb8legnZkUZA/xfjekVfONlNCaonDtuj",
	"9lFvMhqc9o+/aD/qdwcS/TKuQ9elEYh3S0XKCbmOGPLolRCfxfVNXU1KyJTXFoYAK5f4lKvyjoKtJTJn",
	"EhW2rVicJBERzJA0zzC8k+LtZE9gcnJNz2iyEyGRwVF2OxE3DjEo4mbg11IwssYHJo7n21gwZ44ERfJp",
	"cME4VKvcEzSE8Lcr1SmQpkh6P6cBQYwjl2Ku7d+qQ8XMwwF5CviIOWIOC8P5fwWOeFB85tFvY6nM/Q/h",
	"lq/usRD7WtX6QRVM//KPe9XmXsksxWcJienTv9gGzWmJz726WeKzma0Wlo8LgMMvvj15Dp4Nj5EkaBmn",
	"l3S8IFKj8ONvY5ykTxRiE0byERe7xGJlHLCLE7AOKVGOy1uWItPfmIVLLQMjaBC1VHMY6sd+spHyj3Qf",
	"xf5fyNA3HuEQCnMuxn1Eg/lrh8KlvqIXEsXFHyFJUT4XQf2LR9gMGqUbWUkxYCXySRRahnuazefQzF/0",
	"hYufDc7htSVn6lIIafHn/8UTOpY47Q1StoKSiQNMsK3VMLCtUYRtP+3VaO4suxvi283d+EnuhoGRlVte",
	"FI3ty66Kks5zF4Inny/AOTs43dAzpGqRj/FylyGF0oewdwVoYaJnVvEeoPOYM3TJQikHuQQ6Ws1fe6YJ",
	"PBMclkqeBIWqEVdif5KBDUJekdFsJFEta0XdQbnWO1ONDyxbYlpwLbwOhJLYvdtAAp8hlD1p7aUWSn3i",
	"UhwpTWvGeERCykIhLE2DkHjadKnUxFy8kBmfwpZtiO3jMjwf3bv7rboGkCOMpkFWOc3J6BH2z+av/PWn",
	"L7Dc/evd44isvqrqui27qUrVzd3U7xZ8DgREvLSKo2GBwDjAt+FpKuhw3Ht4ctxtnz7o9UftUqU06Y06",
	"6V+fn7RHE/PP/rHx57j3pflX+367OyhVSt3BUf/44cCOVcy8mtNIflpeKbB0I0d+LLwSUP22rFJdosLn",
	"OHHikEbPxhCxCHfrmAUj4tKQOJHKLfkeNKfiIJsHENE7EE+igDiEc+28CjGgnWmjFsyA6w9CE0EJOIVD",
	"Oa/gYElC+rnHvjPjqG1grA9PQq90WNJBeOIrTsIrEtYUAm1H7BsiiDZ32Ew1CwlC5nlissP0V6ipP4Q8",
	"L4JCgqUFMeNOAp9CSC4oj0LtqoTcMM61EcijggOKRQThrKr4DS8dljr5rHxjLxbtBJuRgArQ+tDkVO1u",
	"JgacR8AOAzC9yLSdxCMlOdosZBFzGNhtVKAsBLbI4WupeVxA2hNbxfIni8XfDM3/gqBRhnLeIWU4pyyo",
	"QVFvsd9rnsqLtAg4Ew81xQCAV82fDA1raES+jYny8sslQpytfRgI4tfFATp529X7x1mFSIdGZLY+pyR3",
	"gRXHMr19cPZHi4fvHw07cJ87IYGdxR5/N2iow7FCiCeC3IIsbRSnJL9OnrUTYWV2MAkwz7xop8vqubnc",
	"aZ9w3wLIFhpSQ3kS8CwjdhSQIFpHIb6av9KKhWz7KyXj5BI4RfuWovNHcsriIxqcM3XDIuwADyc+dGwq",
	"XURVYNbnApY/CBwVDJwGF2dhjYVCOhDEoXRYesiuBEsP5n8HLWMwIwF6QAOxZao7MXrz8j9Rzwwm+B+w",
	"V8YW7MYU1TPZ1VgJEpRt45Bgl3ASXDHvirgs3JZBuCYuiq3KpImYiSe8gkKZGDX/Ubd5uqKQgALcjouL",
	"GBqlZBYRB65dhgVL1XFikNEd+1LSBrmN2wRmFpIryiPM0fyVdf7sLCKyIfgVzXklEx5r4CHjECQJzbr4",
	"18glLpBAjnD29YDwCAuMAk34V2gQirHUiiEaTZB95XcFaMMIomeDSOxIjDn6esQ8wr9OW1R7Uv8Wy5z/",
	"Jc2Lag/7kCnxdWdwPGl/XbFaTXEzplRutooR0CV8IpydvHC3P4Ephu2Hk8GqKdJLnz2INeYBnxBHcJV4",
	"ao3gaYZI7DMUCAqkDyJXi0jnUwgaGEOWPlCEJARWbCrKnaWJdZn3Ofpa0pSvK+hryUPEEOl4yrEOJy49",
	"gaFk9hhRQRp8dfgSvb9WshxlAf9aLozHdmxPDUkvFHgMdWyF2Fwibxagc5o1gjmnEjM4uYhplgnafeWF",
	"3ioFyWlcr7ccjC5Dcv676W3Jw6/k7FEcYj4toQiHFyT63bR0eubh4JtpCWYhbeMhmHYbyy8EIlzEYIMC",
	"6EOgb/Le/AqNyAXgkRFaT6+nQTu3rzK8DRQ+RZ1SciTeSXbrQhwp7GvByNDnHQcOQx0SRCH2KsBaU3ZF",
	"AnFnQukYZsijwTcIn2F6zQ4RQtPgsd7E7777rnbmnNUu2FXtLNyGI6AeKNDnEuNpiLdn9Pr3PnOx1z4j",
	"YcR+F5KL2AOosYPZ6Yxep5k/72rELbW16YlI7IfcSi6+PFbS3nWU7GeeMVbgXujX4Ab5JOD4QjkuoxCf",
	"kwvsowjD5Zc+3KggL8uWEixfrkk+QCtdOlBC3KZBQtzksYvNSq6JkGlUiLEpimNzP7ggUcbqcAEltfGJ",
	"ZLiujc9oFp951NF4M2RhJHM6rLsE2RxV1CGhFq85Itf0giYU0AJSb3jAD6fB48e94ydoqOK9XWKPUiQr",
	"NGtGXpm49AqN1J3HkSdmw0EtINH2d/Qbui3T1bYHD7Zn+ILw7YNm/WCnsb+33Tu+K2a+y+665K458V0x",
	"8V018V058d1mrfGbZv03veZvDuq/Obi/pVbNfKbWB1qS3Hv02R/Hh+gxfNlOvhzKL98S/MZBvb7XaOzv",
	"bovh76rh77K7avi71btXrVq9Vr9bvZtSE31/OoIQMA/sYVKKFF8MCjgTZEQQLdumYU8+4jFkBYWIM2nS",
	"VuJoGvEkPhKfnQJLREQXiGEh8gnVxoKLEAfRqRA7BU5FdKbFl1MnlY2Bpg6lOrYkfEpAVuVGfFN+JESy",
	"7oE8/7SGsPTSU4e5RBP4tg7TUFfGhxDbmYcR9uZ/xy6WyJFJCTCyXKRHgFVQpDkmNodMBT6LYyaKIwdh",
	"wsEBZG2aQfo4mr8C+abZOty9h8qFlvotMyZNq7IF/hc0DT6b/5hEwOWWIT1B7sJlFEIOEDJErnEkbdJC",
	"sgJ/yPwvANQ2RBlrAVhZg2SVJts+KwV2QnW8XfqyR8FUpRDVxVK9S3apoBKREJtk/I8RgrOgEJRcEAQ6",
	"ZSN+NIJ8odMUxDZk7VnSnCtuDpd4IlgXCZR8L7hAQdC7jGHVO26ZhLXCoWJwmvcqqFUXemmrkVSPAj+2",
	"9gKovVVRsIbdP02Ygzwh2F4nolfSD15B08BgfHIzwHxeHO+bt6ir4M40mNXIC5PynwBPioOy6yxgqY0L",
	"GSM9kjkrhnUnE4QlzQwygl0F/wcWDHAaQvMTdEsQJgEEDWTiYBCRCgQR2/FtZlEJsSgIYttpNsUeib8d",
	"lUSXj2sDL12EvUsov9VVt9DaJRpczX8UCPTm5Z8lhnwe6/3Rq5LJC6FO3IaA7oj4VuCfafpIvBxib9Iz",
	"JIjNxHpmMKTchBBNA2BpTqgsfKQi1FCXaA05keGkMJCApC3DUh5SAo5dyWvc+bQLEhMD4wkXUAcGfAFG",
	"06BwBb4kHWllMlQGaUl6NFN/ptY1gLjFSlLCNp3bWkoCFizEhDqr7Ytl5cIhw/mPyGdXJCx8bxosOpQA",
	"fxun9igrTl1WoPusM0HEiGVkyGdwTV2Fovq2JYgNZzgNHrQffdo+bT/sHXfbR73jyeB02H4ofxvX0CBD",
	"7SCRFmbsDI7HJ0dQfy1H36bBnTvm33fuoPIdDKX5bFm12xkJfDszyzpIAUEya5Qy6ztvXv6nrqgCJjCX",
	"cI6Ry5w4VZ+2hO7S1ZGT6KmKn15imqmkyaM8TSUTNBpUS4vtLk1uNWR1otgc+E+lbVCmxyhCFh4ile58",
	"vFSCKd8ZDsYTtK3dIne2PkHToJl/LSU8VTSev4Zbmr6u1Xv5eqtmsyIz29UaqnznYU+8Ta+TEbZ/SBIQ",
	"XtzZ+mQa7NRQlwC9sbaOXBMnlsUfdBhrcu5aUBA3SwFqTWvz5QrorKG8kbaVVZ1GonMZ9q1EdF29iITz",
	"cSDaMuaeoU8nkyHqMJegZr2Oqmjw7/C1rj0obltZprkRdwvJK2akvH0yDXbf1dZk6lNb2/Nudkfj1/YP",
	"ib9k3Z0RlzKzN6ouY35TBM7fuWOmEls741JtEJKGCJ2UEZHQpwH2E4FCKeaLVNnEojL/sephfueOums2",
	"ScrlVGSu3ql99U637twRtAWhRq2B7tyxDKHKgEy5fgaBSaq5RwI++6RRE68c6wwTLf2q3A4uJa6EP/GI",
	"JOdjlyrX5WEw2Gm1NLitzbtlcl1DYkfic+pQHSlAEMeey1QSiinCbJ957NuYYBdv1RZA3cxCbSCvdXQ6",
	"07fctazBVvEjqRYJZRNzNJEpapRJdQVsVlsVg2cn0VgO8+Ez71LKAlBw9I7eoTs1NBEj2OBIM5emvlol",
	"DRYRzU8QmkaFG9DKH1uitNi4SzJ15VVMWf6YkrD+JdhXk3jWRHfuCIEEhgdpMjWeMw4qnfamF9hp8k4h",
	"wBAnNWpULJW8gp5+F1UMw8zWAmxu1hopB8mZaA7Vd7kUT2NiKYVEaY5DViSoGlRmp95AZSUpn3Ye9XvH",
	"k61PFgDWzALWlguciAUeoi9ICBAgbn9jRAtKp6yGLwfHybEqovtVr7sQilYWCtPYhRPrYrJTPPMET+1h",
	"afaOCRgGsmuCVkfl++3u6bj/8Lg9ORn1FsK2kzs6D1OfC9xw4ERwhNOXk9d9/Xpy9gJqeUPLOHYriHJe",
	"QRRHiKCnEd2S0pPUWRjXG6lYhCOBbsEyFp5tweT6fFFIYoktTyOaOaVWbsSaJtyt3IXiVLCJiDo6vmb+",
	"1wD+qqzkfjvNJlRc07z7zCNIdnVAZVU1S7HzJP88yIqrKJq/cqDstDRPbx2KO1d0ci3gOuMU3PRyZvap",
	"BeymF1xRVSjaF8zWTJDkJuYlakjRg/IUk1xIjsqp8nrcFgrsg8HoqN0dLDy1FrCRBxCGZkrf4fyvPolC",
	"GxbjY3NSdkZc4ghlT2WEJwEUSckKbEKm1eoFfK0FhHWcnvWSrRS0DoC3dAbr5qqUMTu98tVCQxMqw5al",
	"SpYGt70lxIozXkPHLDEHuDIXTnDGKxxS6YZ+8/JP4BkBdfvNyz+nJiiHQfWiglldDSdIpI6HQ1O7rSLB",
	"GtJB7dVIfThZT/k0ky18iqpQtmILSpXQmaR5yhm1YBghYUXPZuQUaICYfUiv0TYSgqP4JLFHydqegePF",
	"gIvnMbCmT5aeWRNpG8qCI3OzXydmoPkrRbQSy1LB8XLwQYIPG5W77UnhaX6yBMAW6soDtmunmkAmcq8M",
	"PVL3wiztIm8FiAHaB0hQQC7m/3AoQ+Vub9J+9GkvD9pgKWg7hVqLsgLOpL1EylMaFMylZMFjaXmFNMoQ",
	"xy7ZOkTldclEs7Yr5EV/xiIpu5qbcTn/Ebn0ioQ6ApYEUagr4Lhg6ktfRFlZLOGh5d5IkIdu72g4mPSO",
	"O/22JBGgU69QDxao2Ke2ip2qCU0g2B+d+NYE7vARim9NYBQfWnxrgtD/cYpvAra3EN/g9Q8lvsnJ30p8",
	"axboQx+l+FZwcM01pbfmRyW9NT8+6a1Za64pvcGTtQYaY8+1go9tSUCaRUyGLqOlpNkESWOKTNKSNQuV",
	"G8AylI7bj7oC8PHJg35H4Gxv4Y7KBTwCZyTPpPybkMkyNmUWZxJWksf/h/AtFHtRiGeYc4zOMb1WbiNw",
	"dApwxWHIqOLAkkC/aD8ajE7bnf5R+/RR/6i/Al4giMwsK1f+fAS3aCsPsq6mkwhSibdHvWMOIwFZIZdI",
	"IHZQh50p5pg4w5LpZecF5aG9IoFDdRS6olnlzuD+qH3caa8S0ORsu0gW2UJWGoK52qzBUAdUVTlRdcaS",
	"wqKMo3MKhq43L/+k3SZCbmex+EQbTKclAeXxuHc86a8lsElQ91A3LxmZ5fidRUsoKN4v8zJSh0hqh8tb",
	"SFPBstv/ojd6KPD+1FrA1hKw99GIODFPaoYm6GmTFLNKf1j8ggnJqNc5Gbe7g9NubyI+GLW3dO1wGfmb",
	"ltAxvGNiWCVe6UJ6KY5V0OcjhbcKobUxNTWgLjufg49R1peg3fsAsr6iy/UPIewvhaiBMilHSX34TCuG",
	"Q9Tz0df5Rl5fI3wR49DFaauxhGUm0UBchwMJPV86ZAPOfHGYvsAwuQu5u2bThWHvuAu3rX0yEcJsu9Me",
	"pGJS3soFBDjj25QaDE5s94WSyzFY23UgSgXl1Pn5K5UeU0EzFs5f+YvDY7AXqSqklvNf00M0UiKakAvg",
	"OdNRJbQsXa6YH64lxh0WrOfNy7+iHuwIdFhzQVLRUu6hQADpp4WwiTt31AUu3BprqPx1WDTYPTkYuGEL",
	"NM5iR+zpUh9mqnO2fmKds1jFbH2sKmbrJ1cxlXVhR5z1x+0nX4Fi78dLbgRGSI/vO9C8duAOFG12BpXy",
	"+1uIzTuAze9fiwCzr46nNKvUGiGVdq1jPv+H8nGK/RF4gCN6lQ8dc9fWVTLL/qj1lAysP72OkgHgPeon",
	"mZl2P2KBfxHMe79IaT+zyP2PRNLPgHXw00j5mVnvWYx2POwfot61rORAv8e58JGxEDYKTnY87C+colFH",
	"DwS3gDjQtAIRP4QWnCyWvi4aONRNagzm/FrnLMR+4gqjSiYKNdUVW7EsQlIDt1NgncyL3SmzWS14R8SI",
	"ALd9iyojHVitimYta57b+aK7hfLmCfGW7qybPKxl7y0tvVdQNrBFGjWQiu9JWY5OzpHeMWNdCMwfmpEF",
	"5EIyJQ6RrzMSqrrMWaFksfALgokW/QuNgks1B+v1wwKJpWhEZfxxWZp8d5gVZxSl4UlsOkdspnYtI+e8",
	"A1UE6MudO5+8C00EiMKdOxC4u/vuRNP3GKd4ujBM8fSdRylmhdJEstwFyfKLIpGS3VCo3AWhsqrIl5Q3",
	"Qkx4FIJ7+xAN4JLFsp+BpCayDg6zRaRimdZdHtoo6Vn/+MGo3RtPRieTk1F7awGUQrueEH9W1EsTZBqh",
	"zw3S3JRA2TTOaeizOG8lTeq0w9ssRuVJ72g4OO19OeyPBME3TRqfLACqhapoZGfbpHK5AUyGvclMDRbn",
	"KnHkt0igR38i4DkZn7RH/cWw7KAqOoKgfCkmsJBeEH/bJTyiATtE7STy0k0CM6xcHtAHBFVMCLWO8rf0",
	"CZXnmdJFSJMfnw5G/Ye9o9NubzzpHw9O+w9P2v3xQmh3xXGqCA0NVyKr5kCVtaBVkZ9MqYMsJOBRGvZG",
	"QkpP+eNCQPZQ9SdRqnpC5zC1JqvSuw4RDVaoXmurTbsgBlbXUJx0pwJDNWJaJ7Ly3B8HmZyD7bQ/2zaL",
	"o5A9Uelksut+iJK9SFMqDG1MImASNbymjrULgmQ1Jx2L+6Y+y5RcXFIqR5sOtfJV/nzUGXR7y0XZXRAq",
	"q4meZwBga3XZ0d9KtduVcmZVGmuTdw/fpUydL0KTpBJCjtMVCaW5zm5gR3HaFSHLw4Ki6gEZyX3RahsJ",
	"ydcUXteryFP6cwryPFD6pHGxqYvmGMACsi9F0cSKvQvi9OMjpkC3/dpm5gCQ75zExWXCMQtdnWB4HgfQ",
	"KSxbFehtU6936wd7rXs79S2kqrhwltQ8j/3M6s+ZlSbKrFw9qaNWklR8I30ypCxUphWMgDbg2p07YqPE",
	"/19//bX453l15c/z23z9HAZHvUiQKUGui7cSPc8ewjYEiuif52hQsJ7nPwHkK3+eo8VCCLJGaBgvycH7",
	"aYHGTMEzc/wikcv4Ovlp5sZfA3jrWue/Tn5a2cF/xtu+xuA5GW7BtuT3vMOSeNOFx7r+mbbe55nufHRn",
	"ukQafPszXSb0vvU9ssWBG9wj1M6pE0q8Mt/PCDnrH+n6sJtiXPHgu7cZPC/8Fg++d5vB171G++/zGh18",
	"dNdo3W1pFCHjJQsphxolMlhTV1u56bbc6hoVS3YfmB0pGamnOj9Ddy6zbposA2MXtjEy8ysQ0EU8wmUr",
	"4dNhe9L5dJnDFPpnCe1syQuFBi1I/quiwRpzLKp2z3IrsbTaxGwbBzSC1PZamue43nhJ3KlpdzermCTZ",
	"qlCJISsIL19jsZ2vALigELCi1kJW2Qit1fOk+CCXIXuZ0ifWW1DJLlewwVxlVtVJFU0xjulfsIAuYxpo",
	"W4vy27qya5wvJlP2ymH3+CEiUFNiS5kvtDE1qTRa0wrBr34F1UGUN1ZW/E/sA0lmy4KTEwO0TW+ufj9f",
	"Ll3m2cp6GBEOkWtWrFCYk1S/4MoMsFe37hUNXJKGWjFVHlV56syzUPVvg1xXArPiD8t06jMb8eWXXYPd",
	"Ui3nwXj/t/zMOjMoW5BDVkeEqQmYXC4geob6uKgHWtKxUleFQdNSPuZ5WlLaqs7/mpaMg0wPMFMG5doh",
	"LnXxtCQWVKqUPOqQgEMhZVVxtT3DziVBzVo9V0T1u+++q2H4usbCi231Lt9+1O/0jse9qnjnRaUU0QjK",
	"yxcX0ROXOV+ZrVQpXZGQy1qrO7W6HEno2XhGS4clqEkmm7ReQp3b7bQA+A+lGeNRvnzw0fyVID4rWieu",
	"sECpUuEhlj1Sob+vJD5DxqOOBkJABtEJJOQL+x2mj2xbRbgXNhk0Xrh+gGdUvAUF69d9QTYGJGF/1nbd",
	"kHC+9pv9ICKh7gy71lt6rhNOwvYFtChc/daXKraTBM6zfyfPoH8iFBLl0X3mPtPlg8Vohz+U8GzmqQa1",
	"209Vd2nZiHFVT+ROSHBE1NGpU5NVim2cUWXwcrXeCrFmYc/XktkyIApjAj0EoPiRrNLcrDcWQZw8t92s",
	"NzSuaTxT/8rViGMp7dTrq0e6j92R3FQ9oHx1DSBOAl3ITs/XWv3SAxaeUdclgXxjZ/Ubxyx6wOJATbG7",
	"+oUjEl0y95hFbc9j32nY9taaqe04ZBbhM+g1Wtpp7K6zDTyezVgYEfeIuBTrlto7zeY6LxsxpzLkNCEc",
	"Lyql3XWOsK96W4yhAHcvDBk0Btlt3lv97phGpM8HVyQUuC33yiXnOPaid3bBRmo2BVn+ZvWkZ1J73mtW",
	"wwwgmQvrwj9Oq5o/EQSCx76Pw2elw1IHSrnfmKBH+AKGTS3epScCnEJ5Uqz8gizhL2mdZq+oA9OtGcxD",
	"EmXufb97Y0aTtjVYgxr/a3ClJzliXF+HGNcXEOO+OyL4NrR4Q4MTGrwhgbcngcVNLAoklHWJoKlhr5au",
	"E0kpBLX4dnL0kF4nkslGlP7JRenvohtL0smB3USKXiwyoyG9fvdic6p1pvC+hexsIOmGdH9Q8dlEvw33",
	"sLlHQX+vx7rLVKWg3VXFZC2VVR3rjKEWdXszBsz0aiuU3t+aRy2U2mc4cgq6NENf1iRgNDUW87QHrOob",
	"BWUGiUtdy1OnimpDBLQVLqWa15On2NdWYteK+uU0itXDh6itwsbt4GxptmUxColhgA3mP3qUE1Qedo8f",
	"bkFr28UeCMNqrYYzm3moosFQDVmVef90QZn34grrELR+TiJ6VVj1vcj2fUUDJ1YtrpBMFM3EeqahudIY",
	"rKLtjCqPdnFv1X7TsmgPrDmfzn80jOSqpJQsgrzIwF6bBlU0JonBVghVAQkuLZdI2XAXbCW2bd02NwGo",
	"gjK1l6X7Qpl3ZdCxih3faTaVLRc8cGlqg+kZ77SPO71H8guAE2zREA4KThOoHp5pP3ZF0Dn+noTKX2EA",
	"87A3QQHLFlu/UimNYt81qv6NyVaN4NKqoDPiC1gTs7Pp10jBylc8kPF2WcO4mDe6lHZ0AzqrkLwVw6xC",
	"UaE5svGpDNFMTOe6fPpOfUc2T1sgeAryYDD12yvZGxH0FsaGn0hezZzyanHVoqs3tOqua0iQIJlGwI3t",
	"4NYC6FvLkBsr7FuaIHSbzaJGBUnjPPB7y4wOq3zG+nKeEdFwM6PsbU0TD4mp9Kl/b8EfErg3Rth3ZYQt",
	"Uu03ltiNJfajsMTeWKWt/JJ11UQtyCgh0DfnjMgBXciot3Kg0BWm2ntmqCNCEzJHTeoD2dUKxOBJtQJx",
	"CgLabQiOYipbEkPYnQ7IMZPnqT8j879nw9nes0730Wp1S80NZuZbYmwwbQ3vzdRwA9Vuw7rfNev+V9LT",
	"bKv/RrLY6Gk/cz3t5iZ3mF3spSSaNrBil6ns6YiGIXNjGDkXPopntHaGA4fVHObXzkJIo6yqttuplne1",
	"A4Rp8RSfMp957AIvnOVy3WmeJMtNwl+NZb948uL/CwAA///M6ScoWw0CAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
