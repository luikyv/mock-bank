//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/payment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
	N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
	CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
	EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
	EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
	EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
	EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
	EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
	EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
	EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
	EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
	EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
	EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
	EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
	EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
	EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
	EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
	EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
	EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
	EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
	PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
	DICT EnumLocalInstrument = "DICT"
	INIC EnumLocalInstrument = "INIC"
	MANU EnumLocalInstrument = "MANU"
	QRDN EnumLocalInstrument = "QRDN"
	QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
	CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
	EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
	EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
	EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
	COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
	CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
	FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
	FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
	FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
	FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
	FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
	FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
	NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
	PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
	PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
	SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
	VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
	VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
	ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
	ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
	ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
	DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
	QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
	QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
	SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
	SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
	SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
	TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Code EnumErrorsCreatePixPayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
		Code EnumErrorsCreatePayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: endToEndId
		// - PARAMETRO_INVALIDO: endToEndId
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
		// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Saldo insuficiente.
		// - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
		// - VALOR_INVALIDO: Valor inválido.
		// - COBRANCA_INVALIDA: Cobrança inválida.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
		// - NAO_INFORMADO: Não informado.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
	// Code Define o código da razão pela qual o consentimento foi rejeitado
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - TEMPO_EXPIRADO_CONSUMO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - QRCODE_INVALIDO
	Code EnumConsentRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao consentimento rejeitado.
	// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
	// - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	// - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
	//
	// [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
	Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`
	} `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator *string `json:"cnpjInitiator,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

		// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
		//
		// • “E” – fixo (1 caractere);
		//
		// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
		//
		// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
		//
		// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
		//
		// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
		//
		// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
		//
		// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
		EndToEndID *EndToEndIDWithoutRestriction `json:"endToEndId,omitempty"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument *EnumLocalInstrument `json:"localInstrument,omitempty"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment *PaymentPix `json:"payment,omitempty"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
		// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
		// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
		// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
		// Este campo deverá ser no formato UTF-8.
		// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
		QrCode *string `json:"qrCode,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
		// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
		// - Letras minúsculas, de ‘a’ a ‘z’
		// - Letras maiúsculas, de ‘A’ a ‘z’
		// - Dígitos decimais, de ‘0’ a ‘9’
		//
		// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
		//
		// – MANU - O campo transactionIdentification não deve ser preenchido.
		// – DICT - O campo transactionIdentification não deve ser preenchido.
		// – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRES - Caso o QR Code estático possua o dado <i><<i/>TxId<i>><i/> preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o <i><<i/>TxId<i>><i/> o campo transactionIdentification não deverá ser preenchido. O <i><<i/>TxId<i>><i/> deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRDN - Será obrigatório seu preenchimento com o <i><<i/>TxId<i>><i/> do payload JSON do QR Code dinâmico. O <i><<i/>TxId<i>><i/> deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		//
		// A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição]
	// Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
	// Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
	// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
	// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
	// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
	// Este campo deverá ser no formato UTF-8.
	// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
	QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
	// Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
	Cancellation struct {
		// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Identification string `json:"identification"`

				// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Rel string `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Utilizado para informar para qual estado deve ir o pagamento.
	// Atualmente o único valor possível é CANC.
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date [Restrição] Mutuamente excludente com o objeto schedule.
	//
	// Este campo é obrigatório no caso de pagamento único.
	//
	// Neste caso, o objeto schedule não deve ser informado.
	Date *timeutil.BrazilDate `json:"date,omitempty"`

	// Details Objeto contendo os detalhes do pagamento.
	Details Details `json:"details"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// Schedule [Restrição] Mutuamente excludente com o campo date.
	// Este campo é obrigatório no caso de agendamento.
	// Neste caso, o campo date não deverá ser informado.
	// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
	// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
	Schedule *Schedule `json:"schedule,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
	//
	// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
	// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonTypeGetPix `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreationDateTime Data e hora em que o recurso foi criado.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount DebtorAccount `json:"debtorAccount"`

		// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
		EndToEndID EndToEndID `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`
		} `json:"payment"`

		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
		RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
		//
		// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
		//
		// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
		//
		// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
		//
		// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
		//
		// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
		//
		// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
		//
		// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
		//
		// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
		//
		// Em caso insucesso:
		//
		// RJCT (REJECTED) - Instrução de pagamento rejeitada.
		Status EnumPaymentStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
	Data []struct {
		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePatchPixPaymentData `json:"data"`
	Links api.Links                   `json:"links"`
	Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	Cancellation PatchPixPaymentCancellation `json:"cancellation"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment PaymentConsent `json:"payment"`

		// RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
		//
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
		RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePixPaymentData `json:"data"`
	Links api.Links              `json:"links"`
	Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
	// Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
	// Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
	Custom struct {
		// AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
		// O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
		AdditionalInformation string `json:"additionalInformation"`

		// Dates Define os dias em que estão planejadas as ocorrências das liquidações.
		Dates []timeutil.BrazilDate `json:"dates"`
	} `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
	Daily struct {
		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
	Monthly struct {
		// DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
		DayOfMonth int `json:"dayOfMonth"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
	// Single Define a política de agendamento único.
	Single struct {
		// Date Define a data alvo da liquidação do pagamento.
		// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
		//
		// [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
		// relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
		// partir da data do consentimento, também considerando o fuso horário de Brasília.
		Date timeutil.BrazilDate `json:"date"`
	} `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
	Weekly struct {
		// DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
		DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PatchPixConsents defines model for 200PatchPixConsents.
type N200PatchPixConsents = ResponsePatchPixConsent

// N200PatchPixPayments defines model for 200PatchPixPayments.
type N200PatchPixPayments = ResponsePatchPixPayment

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N200PaymentsInitiationPixPaymentIDRead defines model for 200PaymentsInitiationPixPaymentIdRead.
type N200PaymentsInitiationPixPaymentIDRead = ResponsePixPayment

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// N201PaymentsInitiationPixPaymentCreated defines model for 201PaymentsInitiationPixPaymentCreated.
type N201PaymentsInitiationPixPaymentCreated = ResponseCreatePixPayment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// PaymentsPostPixPaymentsJSONRequestBody defines body for PaymentsPostPixPayments for application/json ContentType.
type PaymentsPostPixPaymentsJSONRequestBody = CreatePixPayment

// PaymentsPatchPixPaymentsConsentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsConsentID for application/json ContentType.
type PaymentsPatchPixPaymentsConsentIDJSONRequestBody = PatchPixPayment

// PaymentsPatchPixPaymentsPaymentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsPaymentID for application/json ContentType.
type PaymentsPatchPixPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostPixPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostPixPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
	m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
	m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
	m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

	return m
}

type N200PatchPixConsentsJSONResponse ResponsePatchPixConsent

type N200PatchPixPaymentsJSONResponse ResponsePatchPixPayment

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadJSONResponse ResponsePixPayment

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedJSONResponse ResponseCreatePixPayment

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
	Params PaymentsPostConsentsParams
	Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
	VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
	N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetConsentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
	VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
	N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPostPixPaymentsRequestObject struct {
	Params PaymentsPostPixPaymentsParams
	Body   *PaymentsPostPixPaymentsJSONRequestBody
}

type PaymentsPostPixPaymentsResponseObject interface {
	VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201JSONResponse struct {
	N201PaymentsInitiationPixPaymentCreatedJSONResponse
}

func (response PaymentsPostPixPayments201JSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsPatchPixPaymentsConsentIDParams
	Body      *PaymentsPatchPixPaymentsConsentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200JSONResponse struct {
	N200PatchPixConsentsJSONResponse
}

func (response PaymentsPatchPixPaymentsConsentID200JSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200JSONResponse struct {
	N200PaymentsInitiationPixPaymentIDReadJSONResponse
}

func (response PaymentsGetPixPaymentsPaymentID200JSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsPatchPixPaymentsPaymentIDParams
	Body      *PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200JSONResponse struct {
	N200PatchPixPaymentsJSONResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200JSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) {
	var request PaymentsPostConsentsRequestObject

	request.Params = params

	var body PaymentsPostConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) {
	var request PaymentsGetConsentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) {
	var request PaymentsPostPixPaymentsRequestObject

	request.Params = params

	var body PaymentsPostPixPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostPixPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) {
	var request PaymentsPatchPixPaymentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	var body PaymentsPatchPixPaymentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) {
	var request PaymentsGetPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) {
	var request PaymentsPatchPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	var body PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"6jRPk+UmEbDGsl8+ffn/BQAA//8Qw93OYw0CAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
