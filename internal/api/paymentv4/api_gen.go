//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/payment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
	N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
	CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
	EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
	EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
	EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
	EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
	EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
	EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
	EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
	EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
	EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
	EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
	EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
	EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
	EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
	EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
	EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
	EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
	EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
	PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
	DICT EnumLocalInstrument = "DICT"
	INIC EnumLocalInstrument = "INIC"
	MANU EnumLocalInstrument = "MANU"
	QRDN EnumLocalInstrument = "QRDN"
	QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
	CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
	EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
	EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
	EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
	COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
	CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
	FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
	FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
	FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
	FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
	FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
	FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
	NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
	PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
	PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
	SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
	VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
	VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
	ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
	ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
	ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
	DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
	QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
	QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
	SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
	SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
	SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
	TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Code EnumErrorsCreatePixPayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
		Code EnumErrorsCreatePayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: endToEndId
		// - PARAMETRO_INVALIDO: endToEndId
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
		// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Saldo insuficiente.
		// - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
		// - VALOR_INVALIDO: Valor inválido.
		// - COBRANCA_INVALIDA: Cobrança inválida.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
		// - NAO_INFORMADO: Não informado.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
	// Code Define o código da razão pela qual o consentimento foi rejeitado
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - TEMPO_EXPIRADO_CONSUMO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - QRCODE_INVALIDO
	Code EnumConsentRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao consentimento rejeitado.
	// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
	// - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	// - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
	//
	// [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
	Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`
	} `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
		//
		// • “E” – fixo (1 caractere);
		//
		// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
		//
		// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
		//
		// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
		//
		// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
		//
		// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
		//
		// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
		EndToEndID EndToEndIDWithoutRestriction `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment PaymentPix `json:"payment"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
		// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
		// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
		// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
		// Este campo deverá ser no formato UTF-8.
		// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
		QrCode *string `json:"qrCode,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
		// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
		// - Letras minúsculas, de ‘a’ a ‘z’
		// - Letras maiúsculas, de ‘A’ a ‘z’
		// - Dígitos decimais, de ‘0’ a ‘9’
		//
		// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
		//
		// – MANU - O campo transactionIdentification não deve ser preenchido.
		// – DICT - O campo transactionIdentification não deve ser preenchido.
		// – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRES - Caso o QR Code estático possua o dado <i><<i/>TxId<i>><i/> preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o <i><<i/>TxId<i>><i/> o campo transactionIdentification não deverá ser preenchido. O <i><<i/>TxId<i>><i/> deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRDN - Será obrigatório seu preenchimento com o <i><<i/>TxId<i>><i/> do payload JSON do QR Code dinâmico. O <i><<i/>TxId<i>><i/> deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		//
		// A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição]
	// Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
	// Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
	// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
	// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
	// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
	// Este campo deverá ser no formato UTF-8.
	// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
	QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
	// Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
	Cancellation struct {
		// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Identification string `json:"identification"`

				// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Rel string `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Utilizado para informar para qual estado deve ir o pagamento.
	// Atualmente o único valor possível é CANC.
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date [Restrição] Mutuamente excludente com o objeto schedule.
	//
	// Este campo é obrigatório no caso de pagamento único.
	//
	// Neste caso, o objeto schedule não deve ser informado.
	Date *timeutil.BrazilDate `json:"date,omitempty"`

	// Details Objeto contendo os detalhes do pagamento.
	Details Details `json:"details"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// Schedule [Restrição] Mutuamente excludente com o campo date.
	// Este campo é obrigatório no caso de agendamento.
	// Neste caso, o campo date não deverá ser informado.
	// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
	// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
	Schedule *Schedule `json:"schedule,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
	//
	// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
	// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonTypeGetPix `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreationDateTime Data e hora em que o recurso foi criado.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount DebtorAccount `json:"debtorAccount"`

		// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
		EndToEndID EndToEndID `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`
		} `json:"payment"`

		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
		RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
		//
		// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
		//
		// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
		//
		// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
		//
		// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
		//
		// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
		//
		// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
		//
		// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
		//
		// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
		//
		// Em caso insucesso:
		//
		// RJCT (REJECTED) - Instrução de pagamento rejeitada.
		Status EnumPaymentStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
	Data []struct {
		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePatchPixPaymentData `json:"data"`
	Links api.Links                   `json:"links"`
	Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	Cancellation PatchPixPaymentCancellation `json:"cancellation"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment PaymentConsent `json:"payment"`

		// RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
		//
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
		RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePixPaymentData `json:"data"`
	Links api.Links              `json:"links"`
	Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
	// Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
	// Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
	Custom struct {
		// AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
		// O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
		AdditionalInformation string `json:"additionalInformation"`

		// Dates Define os dias em que estão planejadas as ocorrências das liquidações.
		Dates []timeutil.BrazilDate `json:"dates"`
	} `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
	Daily struct {
		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
	Monthly struct {
		// DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
		DayOfMonth int `json:"dayOfMonth"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
	// Single Define a política de agendamento único.
	Single struct {
		// Date Define a data alvo da liquidação do pagamento.
		// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
		//
		// [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
		// relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
		// partir da data do consentimento, também considerando o fuso horário de Brasília.
		Date timeutil.BrazilDate `json:"date"`
	} `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
	Weekly struct {
		// DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
		DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PatchPixConsents defines model for 200PatchPixConsents.
type N200PatchPixConsents = ResponsePatchPixConsent

// N200PatchPixPayments defines model for 200PatchPixPayments.
type N200PatchPixPayments = ResponsePatchPixPayment

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N200PaymentsInitiationPixPaymentIDRead defines model for 200PaymentsInitiationPixPaymentIdRead.
type N200PaymentsInitiationPixPaymentIDRead = ResponsePixPayment

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// N201PaymentsInitiationPixPaymentCreated defines model for 201PaymentsInitiationPixPaymentCreated.
type N201PaymentsInitiationPixPaymentCreated = ResponseCreatePixPayment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// PaymentsPostPixPaymentsJSONRequestBody defines body for PaymentsPostPixPayments for application/json ContentType.
type PaymentsPostPixPaymentsJSONRequestBody = CreatePixPayment

// PaymentsPatchPixPaymentsConsentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsConsentID for application/json ContentType.
type PaymentsPatchPixPaymentsConsentIDJSONRequestBody = PatchPixPayment

// PaymentsPatchPixPaymentsPaymentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsPaymentID for application/json ContentType.
type PaymentsPatchPixPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostPixPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostPixPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
	m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
	m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
	m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

	return m
}

type N200PatchPixConsentsJSONResponse ResponsePatchPixConsent

type N200PatchPixPaymentsJSONResponse ResponsePatchPixPayment

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadJSONResponse ResponsePixPayment

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedJSONResponse ResponseCreatePixPayment

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
	Params PaymentsPostConsentsParams
	Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
	VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
	N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetConsentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
	VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
	N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPostPixPaymentsRequestObject struct {
	Params PaymentsPostPixPaymentsParams
	Body   *PaymentsPostPixPaymentsJSONRequestBody
}

type PaymentsPostPixPaymentsResponseObject interface {
	VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201JSONResponse struct {
	N201PaymentsInitiationPixPaymentCreatedJSONResponse
}

func (response PaymentsPostPixPayments201JSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsPatchPixPaymentsConsentIDParams
	Body      *PaymentsPatchPixPaymentsConsentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200JSONResponse struct {
	N200PatchPixConsentsJSONResponse
}

func (response PaymentsPatchPixPaymentsConsentID200JSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200JSONResponse struct {
	N200PaymentsInitiationPixPaymentIDReadJSONResponse
}

func (response PaymentsGetPixPaymentsPaymentID200JSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsPatchPixPaymentsPaymentIDParams
	Body      *PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200JSONResponse struct {
	N200PatchPixPaymentsJSONResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200JSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) {
	var request PaymentsPostConsentsRequestObject

	request.Params = params

	var body PaymentsPostConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) {
	var request PaymentsGetConsentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) {
	var request PaymentsPostPixPaymentsRequestObject

	request.Params = params

	var body PaymentsPostPixPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostPixPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) {
	var request PaymentsPatchPixPaymentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	var body PaymentsPatchPixPaymentsConsentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) {
	var request PaymentsGetPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) {
	var request PaymentsPatchPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	var body PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
