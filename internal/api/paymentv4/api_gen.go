//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/payment"
	"github.com/luiky/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
	OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
	N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
	N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
	CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
	AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
	AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
	CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
	PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
	REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
	EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
	EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
	EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
	EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
	EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
	EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
	EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
	EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
	EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
	EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
	EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
	EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
	EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
	EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
	EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
	EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
	EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
	EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
	EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
	PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
	DICT EnumLocalInstrument = "DICT"
	INIC EnumLocalInstrument = "INIC"
	MANU EnumLocalInstrument = "MANU"
	QRDN EnumLocalInstrument = "QRDN"
	QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
	DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
	INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
	CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
	CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
	CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
	EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
	PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
	EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
	EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
	EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
	EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
	EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
	EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
	EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
	EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
	PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
	EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
	EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
	EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
	EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
	EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
	EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
	EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
	EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
	COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
	CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
	DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
	FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
	FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
	FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
	FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
	FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
	FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
	FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
	NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
	PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
	PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
	PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
	SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
	VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
	VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
	ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
	ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
	ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
	ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
	ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
	DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
	QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
	QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
	SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
	SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
	SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
	TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
		// • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
		// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
		// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// • PARAMETRO_INVALIDO: Parâmetro inválido.
		// • ERRO_IDEMPOTENCIA: Erro idempotência.
		// • NAO_INFORMADO: Não informado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Code EnumErrorsCreatePixPayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação da iniciação de pagamento:
		// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - NAO_INFORMADO: Não informada pela detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
		Code EnumErrorsCreatePayment `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
		// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
		// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
		// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: endToEndId
		// - PARAMETRO_INVALIDO: endToEndId
		// - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
		// - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
		// - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - SALDO_INSUFICIENTE: Saldo insuficiente.
		// - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
		// - VALOR_INVALIDO: Valor inválido.
		// - COBRANCA_INVALIDA: Cobrança inválida.
		// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
		// - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
		// - NAO_INFORMADO: Não informado.
		// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
		// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
		// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
		// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
	// Code Define o código da razão pela qual o consentimento foi rejeitado
	// - VALOR_INVALIDO
	// - NAO_INFORMADO
	// - FALHA_INFRAESTRUTURA
	// - TEMPO_EXPIRADO_AUTORIZACAO
	// - TEMPO_EXPIRADO_CONSUMO
	// - REJEITADO_USUARIO
	// - CONTAS_ORIGEM_DESTINO_IGUAIS
	// - CONTA_NAO_PERMITE_PAGAMENTO
	// - SALDO_INSUFICIENTE
	// - VALOR_ACIMA_LIMITE
	// - QRCODE_INVALIDO
	Code EnumConsentRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao consentimento rejeitado.
	// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
	// - NAO_INFORMADO: Não informada pela detentora de conta;
	// - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	// - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
	// - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
	// - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
	// - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
	// - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
	// - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
	// - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	// - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
	//
	// [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
	Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`
	} `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
		//
		// • “E” – fixo (1 caractere);
		//
		// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
		//
		// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
		//
		// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
		//
		// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
		//
		// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
		//
		// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
		EndToEndID EndToEndIDWithoutRestriction `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment PaymentPix `json:"payment"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
		// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
		// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
		// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
		// Este campo deverá ser no formato UTF-8.
		// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
		QrCode *string `json:"qrCode,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
		// Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
		// - Letras minúsculas, de ‘a’ a ‘z’
		// - Letras maiúsculas, de ‘A’ a ‘z’
		// - Dígitos decimais, de ‘0’ a ‘9’
		//
		// [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
		//
		// – MANU - O campo transactionIdentification não deve ser preenchido.
		// – DICT - O campo transactionIdentification não deve ser preenchido.
		// – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRES - Caso o QR Code estático possua o dado <i><<i/>TxId<i>><i/> preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o <i><<i/>TxId<i>><i/> o campo transactionIdentification não deverá ser preenchido. O <i><<i/>TxId<i>><i/> deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		// – QRDN - Será obrigatório seu preenchimento com o <i><<i/>TxId<i>><i/> do payload JSON do QR Code dinâmico. O <i><<i/>TxId<i>><i/> deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
		//
		// A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM.
	//
	// - CACC - Current - Conta Corrente.
	// - SVGS - Savings - Conta de Poupança.
	// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	//
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição]
	// Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
	// Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
	// É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
	// Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
	// No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
	// Este campo deverá ser no formato UTF-8.
	// [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
	QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
	// CpfCnpj Identificação da pessoa envolvida na transação.
	// Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
	// O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
	// O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
	CpfCnpj string `json:"cpfCnpj"`

	// Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
	// Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
	Name string `json:"name"`

	// PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
	PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
	Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
	// Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
	// Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
	Cancellation struct {
		// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
		CancelledBy struct {
			// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
			Document struct {
				// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Identification string `json:"identification"`

				// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
				Rel string `json:"rel"`
			} `json:"document"`
		} `json:"cancelledBy"`
	} `json:"cancellation"`

	// Status Utilizado para informar para qual estado deve ir o pagamento.
	// Atualmente o único valor possível é CANC.
	Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
	// Amount Valor da transação com 2 casas decimais.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`

	// Date [Restrição] Mutuamente excludente com o objeto schedule.
	//
	// Este campo é obrigatório no caso de pagamento único.
	//
	// Neste caso, o objeto schedule não deve ser informado.
	Date *timeutil.BrazilDate `json:"date,omitempty"`

	// Details Objeto contendo os detalhes do pagamento.
	Details Details `json:"details"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// Schedule [Restrição] Mutuamente excludente com o campo date.
	// Este campo é obrigatório no caso de agendamento.
	// Neste caso, o campo date não deverá ser informado.
	// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
	// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
	Schedule *Schedule `json:"schedule,omitempty"`

	// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
	Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
	// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
	//
	// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
	// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
	Amount string `json:"amount"`

	// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
	// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
	Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
	// CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
	CancelledAt timeutil.DateTime `json:"cancelledAt"`

	// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
	CancelledBy struct {
		// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
		Document struct {
			// Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Identification string `json:"identification"`

			// Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
			Rel string `json:"rel"`
		} `json:"document"`
	} `json:"cancelledBy"`

	// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
	//
	// Valores possíveis:
	//
	// INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
	//
	// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
	CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

	// Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
	//
	// Valores possíveis:
	//
	// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
	//
	// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
	//
	// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
	Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonType `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
	// Code Define o código da razão pela qual o pagamento foi rejeitado
	//
	// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
	//
	// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
	//
	// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
	//
	// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
	//
	// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
	//
	// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
	//
	// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
	//
	// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
	//
	// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
	//
	// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
	//
	// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
	//
	// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
	//
	// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
	//
	// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
	//
	// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
	//
	// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
	//
	// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
	//
	// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
	Code EnumRejectionReasonTypeGetPix `json:"code"`

	// Detail Contém informações adicionais ao pagamento rejeitado
	Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`

			// Date [Restrição] Mutuamente excludente com o objeto schedule.
			//
			// Este campo é obrigatório no caso de pagamento único.
			//
			// Neste caso, o objeto schedule não deve ser informado.
			Date *timeutil.BrazilDate `json:"date,omitempty"`

			// Details Objeto contendo os detalhes do pagamento.
			Details Details `json:"details"`

			// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
			//
			// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
			IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

			// Schedule [Restrição] Mutuamente excludente com o campo date.
			// Este campo é obrigatório no caso de agendamento.
			// Neste caso, o campo date não deverá ser informado.
			// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
			// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
			Schedule *Schedule `json:"schedule,omitempty"`

			// Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
			Type EnumPaymentType `json:"type"`
		} `json:"payment"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
	Data []struct {
		// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
		//
		// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
		AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

		// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
		CnpjInitiator string `json:"cnpjInitiator"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		//
		// [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
		ConsentID *string `json:"consentId,omitempty"`

		// CreationDateTime Data e hora em que o recurso foi criado.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
		CreditorAccount CreditorAccount `json:"creditorAccount"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
		DebtorAccount DebtorAccount `json:"debtorAccount"`

		// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
		EndToEndID EndToEndID `json:"endToEndId"`

		// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
		//
		// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
		IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

		// LocalInstrument Especifica a forma de iniciação do pagamento:
		// - MANU - Inserção manual de dados da conta transacional
		// - DICT - Inserção manual de chave Pix
		// - QRDN - QR code dinâmico
		// - QRES - QR code estático
		// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
		//
		// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
		LocalInstrument EnumLocalInstrument `json:"localInstrument"`

		// Payment Objeto contendo dados do pagameto como moeda e valor.
		Payment struct {
			// Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
			//
			// Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
			// Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
			Amount string `json:"amount"`

			// Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
			// Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
			Currency string `json:"currency"`
		} `json:"payment"`

		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
		// No caso de telefone celular deve ser informado no padrão E.1641.
		// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
		// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
		// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
		// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
		// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
		// Esta validação é opcional caso o localInstrument for igual a INIC.
		// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
		Proxy *string `json:"proxy,omitempty"`

		// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
		RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

		// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
		RemittanceInformation *string `json:"remittanceInformation,omitempty"`

		// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
		//
		// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
		//
		// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
		//
		// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
		//
		// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
		//
		// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
		//
		// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
		//
		// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
		//
		// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
		//
		// Em caso insucesso:
		//
		// RJCT (REJECTED) - Instrução de pagamento rejeitada.
		Status EnumPaymentStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
		//
		// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
		TransactionIdentification *string `json:"transactionIdentification,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
	Data []struct {
		// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
		// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
		// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
		PaymentID string `json:"paymentId"`

		// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
		// Uma string com data e hora conforme especificação RFC-3339,
		// sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePatchPixPaymentData `json:"data"`
	Links api.Links                   `json:"links"`
	Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	Cancellation PatchPixPaymentCancellation `json:"cancellation"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
	// Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transnmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentID string `json:"consentId"`

		// CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// Creditor Objeto contendo os dados do recebedor (creditor).
		Creditor Identification `json:"creditor"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
		// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
		//
		// [Restrição]
		// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
		// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
		DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

		// ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
		// Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
		// Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
		// Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
		// Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
		// Caso não seja consumido, deve ser movido para o status REJECTED.
		ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
		LoggedUser LoggedUser `json:"loggedUser"`

		// Payment Objeto contendo dados de pagamento para consentimento.
		Payment PaymentConsent `json:"payment"`

		// RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
		//
		// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
		RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

		// Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
		//
		// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
		//
		//
		// Estados possíveis:
		//
		// AWAITING_AUTHORISATION - Aguardando autorização
		//
		// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
		//
		// AUTHORISED - Autorizado
		//
		// REJECTED - Rejeitado
		//
		// CONSUMED - Consumido
		Status EnumAuthorisationStatusType `json:"status"`

		// StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
	// Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
	Data  ResponsePixPaymentData `json:"data"`
	Links api.Links              `json:"links"`
	Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
	// AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
	//
	// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
	AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

	// Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
	//
	// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
	Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

	// CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
	CnpjInitiator string `json:"cnpjInitiator"`

	// ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
	// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
	// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
	// seja um identificador de recurso persistente e independente da localização.
	// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
	// - o namespace(urn)
	// - o identificador associado ao namespace da instituição transnmissora (bancoex)
	// - o identificador específico dentro do namespace (C1DD33123).
	// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
	ConsentID string `json:"consentId"`

	// CreationDateTime Data e hora em que o recurso foi criado.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	CreationDateTime timeutil.DateTime `json:"creationDateTime"`

	// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
	CreditorAccount CreditorAccount `json:"creditorAccount"`

	// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
	// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
	DebtorAccount DebtorAccount `json:"debtorAccount"`

	// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
	EndToEndID EndToEndID `json:"endToEndId"`

	// IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
	//
	// 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// LocalInstrument Especifica a forma de iniciação do pagamento:
	// - MANU - Inserção manual de dados da conta transacional
	// - DICT - Inserção manual de chave Pix
	// - QRDN - QR code dinâmico
	// - QRES - QR code estático
	// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
	//
	// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
	LocalInstrument EnumLocalInstrument `json:"localInstrument"`

	// Payment Objeto contendo dados do pagameto como moeda e valor.
	Payment PaymentPix `json:"payment"`

	// PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
	// a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
	// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
	PaymentID string `json:"paymentId"`

	// Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
	// No caso de telefone celular deve ser informado no padrão E.1641.
	// Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
	// No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
	// Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
	// No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
	// Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
	// Esta validação é opcional caso o localInstrument for igual a INIC.
	// [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
	Proxy *string `json:"proxy,omitempty"`

	// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
	// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
	RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

	// RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
	RemittanceInformation *string `json:"remittanceInformation,omitempty"`

	// Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
	//
	// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
	//
	// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
	//
	// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
	//
	// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
	//
	// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
	//
	// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
	//
	// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
	//
	// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
	//
	// Em caso insucesso:
	//
	// RJCT (REJECTED) - Instrução de pagamento rejeitada.
	Status EnumPaymentStatusType `json:"status"`

	// StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
	// Uma string com data e hora conforme especificação RFC-3339,
	// sempre com a utilização de timezone UTC(UTC time format).
	StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

	// TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
	//
	// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
	TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
	// Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
	// Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
	Custom struct {
		// AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
		// O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
		AdditionalInformation string `json:"additionalInformation"`

		// Dates Define os dias em que estão planejadas as ocorrências das liquidações.
		Dates []timeutil.BrazilDate `json:"dates"`
	} `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
	Daily struct {
		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
	Monthly struct {
		// DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
		DayOfMonth int `json:"dayOfMonth"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
	// Single Define a política de agendamento único.
	Single struct {
		// Date Define a data alvo da liquidação do pagamento.
		// O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
		//
		// [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
		// relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
		// partir da data do consentimento, também considerando o fuso horário de Brasília.
		Date timeutil.BrazilDate `json:"date"`
	} `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
	Weekly struct {
		// DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
		DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

		// Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
		Quantity int32 `json:"quantity"`

		// StartDate Define o início da vigência da recorrência.
		StartDate timeutil.BrazilDate `json:"startDate"`
	} `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N200PaymentsInitiationPixPaymentIDRead defines model for 200PaymentsInitiationPixPaymentIdRead.
type N200PaymentsInitiationPixPaymentIDRead = ResponsePixPayment

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// N201PaymentsInitiationPixPaymentCreated defines model for 201PaymentsInitiationPixPaymentCreated.
type N201PaymentsInitiationPixPaymentCreated = ResponseCreatePixPayment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// PaymentsPostPixPaymentsJSONRequestBody defines body for PaymentsPostPixPayments for application/json ContentType.
type PaymentsPostPixPaymentsJSONRequestBody = CreatePixPayment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostConsentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostConsents(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetConsentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

	ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPostPixPaymentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPostPixPayments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var consentID ConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsConsentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsGetPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "paymentId" -------------
	var paymentID PaymentID

	err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "paymentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PaymentsPatchPixPaymentsPaymentIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
	m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
	m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
	m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
	m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

	return m
}

type N200PatchPixConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200PatchPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadJSONResponse ResponsePixPayment

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedJSONResponse ResponseCreatePixPayment

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
	Params PaymentsPostConsentsParams
	Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
	VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
	N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostConsentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetConsentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
	VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
	N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPostPixPaymentsRequestObject struct {
	Params PaymentsPostPixPaymentsParams
	Body   *PaymentsPostPixPaymentsJSONRequestBody
}

type PaymentsPostPixPaymentsResponseObject interface {
	VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201JSONResponse struct {
	N201PaymentsInitiationPixPaymentCreatedJSONResponse
}

func (response PaymentsPostPixPayments201JSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
	ConsentID ConsentID `json:"consentId"`
	Params    PaymentsPatchPixPaymentsConsentIDParams
	Body      io.Reader
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200ApplicationJwtResponse struct {
	N200PatchPixConsentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID200ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200JSONResponse struct {
	N200PaymentsInitiationPixPaymentIDReadJSONResponse
}

func (response PaymentsGetPixPaymentsPaymentID200JSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
	PaymentID PaymentID `json:"paymentId"`
	Params    PaymentsPatchPixPaymentsPaymentIDParams
	Body      io.Reader
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
	VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200ApplicationJwtResponse struct {
	N200PatchPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
	UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Criar consentimento para a iniciação de pagamento.
	// (POST /consents)
	PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
	// Consultar consentimento para iniciação de pagamento.
	// (GET /consents/{consentId})
	PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
	// Criar iniciação de pagamento.
	// (POST /pix/payments)
	PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
	// Cancelar todos os pagamentos referentes ao mesmo Consentimento.
	// (PATCH /pix/payments/consents/{consentId})
	PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
	// Consultar iniciação de pagamento.
	// (GET /pix/payments/{paymentId})
	PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
	// Cancelar iniciação de pagamento.
	// (PATCH /pix/payments/{paymentId})
	PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) {
	var request PaymentsPostConsentsRequestObject

	request.Params = params

	var body PaymentsPostConsentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostConsents")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) {
	var request PaymentsGetConsentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetConsentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) {
	var request PaymentsPostPixPaymentsRequestObject

	request.Params = params

	var body PaymentsPostPixPaymentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPostPixPayments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok {
		if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) {
	var request PaymentsPatchPixPaymentsConsentIDRequestObject

	request.ConsentID = consentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) {
	var request PaymentsGetPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) {
	var request PaymentsPatchPixPaymentsPaymentIDRequestObject

	request.PaymentID = paymentID
	request.Params = params

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok {
		if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
