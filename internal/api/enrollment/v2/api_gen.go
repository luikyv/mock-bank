//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/enrollment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseConsentsAuthorizationErrorsCode.
const (
	N422ResponseConsentsAuthorizationErrorsCodeCONTADEBITODIVERGENTECONSENTIMENTOVINCULO N422ResponseConsentsAuthorizationErrorsCode = "CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO"
	N422ResponseConsentsAuthorizationErrorsCodeERROIDEMPOTENCIA                          N422ResponseConsentsAuthorizationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseConsentsAuthorizationErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA      N422ResponseConsentsAuthorizationErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	N422ResponseConsentsAuthorizationErrorsCodeORIGEMFIDOINVALIDA                        N422ResponseConsentsAuthorizationErrorsCode = "ORIGEM_FIDO_INVALIDA"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETROINVALIDO                         N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETRONAOINFORMADO                     N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseConsentsAuthorizationErrorsCodeRISCO                                     N422ResponseConsentsAuthorizationErrorsCode = "RISCO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSCONSENTIMENTOINVALIDO               N422ResponseConsentsAuthorizationErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSVINCULOINVALIDO                     N422ResponseConsentsAuthorizationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorCancelEnrollmentErrorsCode.
const (
	N422ResponseErrorCancelEnrollmentErrorsCodeERROIDEMPOTENCIA          N422ResponseErrorCancelEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREJEICAO            N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REJEICAO"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREVOGACAO           N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REVOGACAO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETROINVALIDO         N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETRONAOINFORMADO     N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCancelEnrollmentErrorsCodeREJEITADOOUTROSEMDETALHES N422ResponseErrorCancelEnrollmentErrorsCode = "REJEITADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeREVOGADOOUTROSEMDETALHES  N422ResponseErrorCancelEnrollmentErrorsCode = "REVOGADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeSTATUSINVALIDO            N422ResponseErrorCancelEnrollmentErrorsCode = "STATUS_INVALIDO"
)

// Defines values for N422ResponseErrorCreateEnrollmentErrorsCode.
const (
	N422ResponseErrorCreateEnrollmentErrorsCodeCONTAINVALIDA         N422ResponseErrorCreateEnrollmentErrorsCode = "CONTA_INVALIDA"
	N422ResponseErrorCreateEnrollmentErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorCreateEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETROINVALIDO     N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreateEnrollmentErrorsCodePERMISSOESINVALIDAS   N422ResponseErrorCreateEnrollmentErrorsCode = "PERMISSOES_INVALIDAS"
)

// Defines values for N422ResponseErrorFidoRegistrationErrorsCode.
const (
	N422ResponseErrorFidoRegistrationErrorsCodeCHALLENGEINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "CHALLENGE_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationErrorsCodeEXTENSIONINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "EXTENSION_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeORIGEMFIDOINVALIDA    N422ResponseErrorFidoRegistrationErrorsCode = "ORIGEM_FIDO_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationErrorsCodePUBLICKEYINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "PUBLIC_KEY_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeRPIDHASHINVALIDO      N422ResponseErrorFidoRegistrationErrorsCode = "RP_ID_HASH_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoRegistrationOptionsErrorsCode.
const (
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorFidoRegistrationOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeMAXIMOCHALLENGESATINGIDO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "MAXIMO_CHALLENGES_ATINGIDO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETROINVALIDO        N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeRPINVALIDA               N422ResponseErrorFidoRegistrationOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeSTATUSVINCULOINVALIDO    N422ResponseErrorFidoRegistrationOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoSignOptionsErrorsCode.
const (
	N422ResponseErrorFidoSignOptionsErrorsCodeERROIDEMPOTENCIA                      N422ResponseErrorFidoSignOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETROINVALIDO                     N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETRONAOINFORMADO                 N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoSignOptionsErrorsCodePERMISSAOINVALIDAVINCULOCONSENTIMENTO N422ResponseErrorFidoSignOptionsErrorsCode = "PERMISSAO_INVALIDA_VINCULO_CONSENTIMENTO"
	N422ResponseErrorFidoSignOptionsErrorsCodeRPINVALIDA                            N422ResponseErrorFidoSignOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSCONSENTIMENTOINVALIDO           N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSVINCULOINVALIDO                 N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorRiskSignalsErrorsCode.
const (
	N422ResponseErrorRiskSignalsErrorsCodeERROIDEMPOTENCIA                     N422ResponseErrorRiskSignalsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorRiskSignalsErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA N422ResponseErrorRiskSignalsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	N422ResponseErrorRiskSignalsErrorsCodePARAMETROINVALIDO                    N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorRiskSignalsErrorsCodePARAMETRONAOINFORMADO                N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorRiskSignalsErrorsCodeSTATUSVINCULOINVALIDO                N422ResponseErrorRiskSignalsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseRecurringConsentsAuthorizationErrorsCode.
const (
	N422ResponseRecurringConsentsAuthorizationErrorsCodeCONTADEBITODIVERGENTECONSENTIMENTOVINCULO N422ResponseRecurringConsentsAuthorizationErrorsCode = "CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO"
	N422ResponseRecurringConsentsAuthorizationErrorsCodeERROIDEMPOTENCIA                          N422ResponseRecurringConsentsAuthorizationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseRecurringConsentsAuthorizationErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA      N422ResponseRecurringConsentsAuthorizationErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	N422ResponseRecurringConsentsAuthorizationErrorsCodePARAMETROINVALIDO                         N422ResponseRecurringConsentsAuthorizationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseRecurringConsentsAuthorizationErrorsCodePARAMETRONAOINFORMADO                     N422ResponseRecurringConsentsAuthorizationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseRecurringConsentsAuthorizationErrorsCodeRISCO                                     N422ResponseRecurringConsentsAuthorizationErrorsCode = "RISCO"
	N422ResponseRecurringConsentsAuthorizationErrorsCodeSTATUSCONSENTIMENTOINVALIDO               N422ResponseRecurringConsentsAuthorizationErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseRecurringConsentsAuthorizationErrorsCodeSTATUSVINCULOINVALIDO                     N422ResponseRecurringConsentsAuthorizationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for ConsentAuthorizationDataRiskSignalsGeolocationType.
const (
	COARSE   ConsentAuthorizationDataRiskSignalsGeolocationType = "COARSE"
	FINE     ConsentAuthorizationDataRiskSignalsGeolocationType = "FINE"
	INFERRED ConsentAuthorizationDataRiskSignalsGeolocationType = "INFERRED"
)

// Defines values for EnrollmentFidoOptionsInputDataPlatform.
const (
	EnrollmentFidoOptionsInputDataPlatformANDROID       EnrollmentFidoOptionsInputDataPlatform = "ANDROID"
	EnrollmentFidoOptionsInputDataPlatformBROWSER       EnrollmentFidoOptionsInputDataPlatform = "BROWSER"
	EnrollmentFidoOptionsInputDataPlatformCROSSPLATFORM EnrollmentFidoOptionsInputDataPlatform = "CROSS_PLATFORM"
	EnrollmentFidoOptionsInputDataPlatformIOS           EnrollmentFidoOptionsInputDataPlatform = "IOS"
)

// Defines values for EnrollmentRejectionReason.
const (
	REJEITADODISPOSITIVOINCOMPATIVEL              EnrollmentRejectionReason = "REJEITADO_DISPOSITIVO_INCOMPATIVEL"
	REJEITADOFALHAFIDO                            EnrollmentRejectionReason = "REJEITADO_FALHA_FIDO"
	REJEITADOFALHAHYBRIDFLOW                      EnrollmentRejectionReason = "REJEITADO_FALHA_HYBRID_FLOW"
	REJEITADOFALHAINFRAESTRUTURA                  EnrollmentRejectionReason = "REJEITADO_FALHA_INFRAESTRUTURA"
	REJEITADOMANUALMENTE                          EnrollmentRejectionReason = "REJEITADO_MANUALMENTE"
	REJEITADOMAXIMOCHALLENGESATINGIDO             EnrollmentRejectionReason = "REJEITADO_MAXIMO_CHALLENGES_ATINGIDO"
	REJEITADOOUTRO                                EnrollmentRejectionReason = "REJEITADO_OUTRO"
	REJEITADOSEGURANCAINTERNA                     EnrollmentRejectionReason = "REJEITADO_SEGURANCA_INTERNA"
	REJEITADOTEMPOEXPIRADOACCOUNTHOLDERVALIDATION EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION"
	REJEITADOTEMPOEXPIRADOENROLLMENT              EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ENROLLMENT"
	REJEITADOTEMPOEXPIRADORISKSIGNALS             EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS"
	REJEITADOTITULARIDADEDIVERGENTE               EnrollmentRejectionReason = "REJEITADO_TITULARIDADE_DIVERGENTE"
)

// Defines values for EnrollmentRevocationReason.
const (
	REVOGADOFALHAINFRAESTRUTURA EnrollmentRevocationReason = "REVOGADO_FALHA_INFRAESTRUTURA"
	REVOGADOMANUALMENTE         EnrollmentRevocationReason = "REVOGADO_MANUALMENTE"
	REVOGADOOUTRO               EnrollmentRevocationReason = "REVOGADO_OUTRO"
	REVOGADOSEGURANCAINTERNA    EnrollmentRevocationReason = "REVOGADO_SEGURANCA_INTERNA"
	REVOGADOVALIDADEEXPIRADA    EnrollmentRevocationReason = "REVOGADO_VALIDADE_EXPIRADA"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumEnrollmentCancelledFrom.
const (
	DETENTORA  EnumEnrollmentCancelledFrom = "DETENTORA"
	INICIADORA EnumEnrollmentCancelledFrom = "INICIADORA"
)

// Defines values for EnumEnrollmentPermission.
const (
	PAYMENTSINITIATE          EnumEnrollmentPermission = "PAYMENTS_INITIATE"
	RECURRINGPAYMENTSINITIATE EnumEnrollmentPermission = "RECURRING_PAYMENTS_INITIATE"
)

// Defines values for EnumEnrollmentStatus.
const (
	AUTHORISED                      EnumEnrollmentStatus = "AUTHORISED"
	AWAITINGACCOUNTHOLDERVALIDATION EnumEnrollmentStatus = "AWAITING_ACCOUNT_HOLDER_VALIDATION"
	AWAITINGENROLLMENT              EnumEnrollmentStatus = "AWAITING_ENROLLMENT"
	AWAITINGRISKSIGNALS             EnumEnrollmentStatus = "AWAITING_RISK_SIGNALS"
	REJECTED                        EnumEnrollmentStatus = "REJECTED"
	REVOKED                         EnumEnrollmentStatus = "REVOKED"
)

// Defines values for EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform.
const (
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformANDROID       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "ANDROID"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformBROWSER       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "BROWSER"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformCROSSPLATFORM EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "CROSS_PLATFORM"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformIOS           EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "IOS"
)

// N422ResponseConsentsAuthorization defines model for 422ResponseConsentsAuthorization.
type N422ResponseConsentsAuthorization struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo ```fidoAssertion.response.clientDataJSON.origin``` não pode ser verificado.
		Code N422ResponseConsentsAuthorizationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo ```fidoAssertion.response.clientDataJSON.origin``` não pode ser verificado.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento inválido.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Falta de sinais obrigatórios para a plataforma do usuário.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - ORIGEM_FIDO_INVALIDA: "Origin" não pode ser verificada.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseConsentsAuthorizationErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - ORIGEM_FIDO_INVALIDA: O valor contido no campo ```fidoAssertion.response.clientDataJSON.origin``` não pode ser verificado.
type N422ResponseConsentsAuthorizationErrorsCode string

// N422ResponseErrorCancelEnrollment defines model for 422ResponseErrorCancelEnrollment.
type N422ResponseErrorCancelEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos no cancelamento do vínculo de conta:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCancelEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta deve estar associada a um motivo de rejeição.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta deve estar associada a um motivo de revogação.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_INVALIDO: Status inválido.
		// - MOTIVO_REJEICAO: Motivo de rejeição não especificado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - MOTIVO_REVOGACAO: Motivo de revogação não especificado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCancelEnrollmentErrorsCode Códigos de erros previstos no cancelamento do vínculo de conta:
// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCancelEnrollmentErrorsCode string

// N422ResponseErrorCreateEnrollment defines model for 422ResponseErrorCreateEnrollment.
type N422ResponseErrorCreateEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação do vínculo de conta:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCreateEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE" ou contêm valores não suportados para esta operação.
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - PERMISSOES_INVALIDAS: Permissões inválidas.
		// - CONTA_INVALIDA: Conta inválida.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCreateEnrollmentErrorsCode Códigos de erros previstos na criação do vínculo de conta:
// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCreateEnrollmentErrorsCode string

// N422ResponseErrorFidoRegistration defines model for 422ResponseErrorFidoRegistration.
type N422ResponseErrorFidoRegistration struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoRegistrationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_VINCULO_INVALIDO: Status inválido do vínculo de conta.
		// - ORIGEM_FIDO_INVALIDA: "Origin" não pode ser verificada.
		// - RP_INVALIDA: "RpIdHash" não pode ser verificado.
		// - CHALLENGE_INVALIDO: Challenge inválido.
		// - PUBLIC_KEY_INVALIDA: Chave pública inválida.
		// - EXTENSION_INVALIDA: Extensões inválidas.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationErrorsCode Códigos de erros previstos:
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationErrorsCode string

// N422ResponseErrorFidoRegistrationOptions defines model for 422ResponseErrorFidoRegistrationOptions.
type N422ResponseErrorFidoRegistrationOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - MAXIMO_CHALLENGES_ATINGIDO: Parâmetros de assinatura FIDO já foram gerados para o enrollmentId especificado.
		Code N422ResponseErrorFidoRegistrationOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - MAXIMO_CHALLENGES_ATINGIDO: Parâmetros de assinatura FIDO já foram gerados para o enrollmentId especificado.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - MAXIMO_CHALLENGES_ATINGIDO: Parâmetros de assinatura FIDO já foram gerados para o enrollmentId especificado.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - MAXIMO_CHALLENGES_ATINGIDO: Parâmetros de assinatura FIDO já foram gerados para o enrollmentId especificado.
type N422ResponseErrorFidoRegistrationOptionsErrorsCode string

// N422ResponseErrorFidoSignOptions defines model for 422ResponseErrorFidoSignOptions.
type N422ResponseErrorFidoSignOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - PERMISSAO_INVALIDA_VINCULO_CONSENTIMENTO: A permissão definida no vínculo não é válida para o tipo de consentimento informado
		Code N422ResponseErrorFidoSignOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		// - PERMISSAO_INVALIDA_VINCULO_CONSENTIMENTO: A permissão definida no vínculo não é válida para o tipo de consentimento informado.
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento de pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		// - PERMISSAO_INVALIDA_VINCULO_CONSENTIMENTO: A permissão definida no vínculo não é válida para o tipo de consentimento informado
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoSignOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - PERMISSAO_INVALIDA_VINCULO_CONSENTIMENTO: A permissão definida no vínculo não é válida para o tipo de consentimento informado
type N422ResponseErrorFidoSignOptionsErrorsCode string

// N422ResponseErrorRiskSignals defines model for 422ResponseErrorRiskSignals.
type N422ResponseErrorRiskSignals struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorRiskSignalsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorRiskSignalsErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorRiskSignalsErrorsCode string

// N422ResponseRecurringConsentsAuthorization defines model for 422ResponseRecurringConsentsAuthorization.
type N422ResponseRecurringConsentsAuthorization struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseRecurringConsentsAuthorizationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento inválido.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Falta de sinais obrigatórios para a plataforma do usuário.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseRecurringConsentsAuthorizationErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseRecurringConsentsAuthorizationErrorsCode string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentAuthorization defines model for ConsentAuthorization.
type ConsentAuthorization struct {
	// Data Objeto que contém sinais de risco e o id do vínculo de conta para avaliação da autorização de um consentimento de pagamento.
	Data struct {
		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// FidoAssertion Dados da asserção
		FidoAssertion struct {
			// ClientExtensionResults Estrutura para extensão de resultados
			ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

			// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública utilizada no processo de autenticação.
			ID string `json:"id"`

			// RawID Identificador da credencial. Para envio à detentora de conta, o valor deste atributo deve ser idêntico ao valor do atributo id.
			RawID string `json:"rawId"`

			// Response Traz as informações da resposta a asserção.
			Response struct {
				// AuthenticatorData Representa a estrutura de dados do autenticador. Deve ser enviado no formato base64url para a detentora de conta.
				AuthenticatorData string `json:"authenticatorData"`

				// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado no formato base64url para a detentora de conta.
				ClientDataJSON string `json:"clientDataJSON"`

				// Signature Sequência de bytes contendo a assinatura. Deve ser enviado no formato base64url para a detentora de conta.
				Signature string `json:"signature"`

				// UserHandle Nome de usuário que foi enviado durante a criação da credencial. Deve ser enviado no formato base64url para a detentora de conta.
				// Caso o autenticador FIDO2 não retorne este campo, a iniciadora deve enviar uma string vazia à detentora de conta.
				UserHandle string `json:"userHandle"`
			} `json:"response"`

			// Type Tipo da credencial.
			Type string `json:"type"`
		} `json:"fidoAssertion"`

		// RiskSignals Conjunto de sinais extraídos do dispositivo do usuário para ativação do consentimento de pagamento.
		// A obrigatoriedade das informações variam de acordo com a plataforma utilizada.
		RiskSignals struct {
			// AccountTenure Data de cadastro do cliente na iniciadora.
			AccountTenure timeutil.BrazilDate `json:"accountTenure"`

			// AntennaInformation Indica em qual antena o dispositivo está conectado.
			AntennaInformation *string `json:"antennaInformation,omitempty"`

			// DeviceID ID único do dispositivo gerado pela plataforma.
			// A geração deve utilizar-se da propriedade do sistema que identifica a combinação de usuário logado, chave de assinatura do aplicativo e dispositivo ou de algoritmos heurísticos capazes de criar um identificador único para o dispositivo.
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor/).
			DeviceID string `json:"deviceId"`

			// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/SystemClock#elapsedRealtime%28%29).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/kernel/kern/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

			// Geolocation Localização do usuário, obtida com seu consentimento.
			//
			// [Android] Informação obtida através do [link](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-abstract-tasklocation-getlastlocation) considerando as permissões necessárias.
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/corelocation/).
			//
			// [Restrição] A ITP deve solicitar ao usuário a permissão para compartilhamento de sua localização. Este campo poderá ser omitido caso o GPS esteja indisponível, isto é, sem sinal, ou em dispositivos sem o hardware necessário; ou caso o usuário negue o consentimento.
			Geolocation *struct {
				Latitude  *float32                                            `json:"latitude,omitempty"`
				Longitude *float32                                            `json:"longitude,omitempty"`
				Type      *ConsentAuthorizationDataRiskSignalsGeolocationType `json:"type,omitempty"`
			} `json:"geolocation,omitempty"`

			// Integrity Informa a integridade do dispositivo e app.
			//
			// [Android] Conforme documentação Play API Integrity, [link](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
			//
			// [iOS] Conforme documentação App Attest, [link](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity).
			Integrity *struct {
				// AppRecognitionVerdict Informa a integridade do app
				AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

				// DeviceRecognitionVerdict Informa a integridade do dispositivo
				DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
			} `json:"integrity,omitempty"`

			// IsCallInProgress Indica chamada ativa no momento do vínculo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/media/AudioManager#getMode()).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/callkit/).
			//
			// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
			IsCallInProgress *bool `json:"isCallInProgress,omitempty"`

			// IsCharging Indica se a bateria do dispositivo está sendo carregada.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/BatteryManager).
			//
			// [iOS] Informações obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620045-batterymonitoringenabled/).
			IsCharging *bool `json:"isCharging,omitempty"`

			// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
			IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

			// IsEmulated Indica se o dispositivo é emulado ou real.
			IsEmulated *bool `json:"isEmulated,omitempty"`

			// IsMockGPS Indica se o dispositivo está usando um GPS falso. Deve ser enviado sempre que exista o campo geolocation com tipo `COARSE` ou `FINE`.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/location/Location.html#isMock()) ou, para versões anteriores à 12, [link](https://developer.android.com/reference/android/location/Location.html#isFromMockProvider()).
			//
			// [iOS] Informação obtida através dos links:
			// sourceInformation, [link](https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation).
			// isSimulatedBySoftware, [link](https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware).
			IsMockGPS *bool `json:"isMockGPS,omitempty"`

			// IsMonkeyRunner Indica o uso do MonkeyRunner.
			IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

			// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

			// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
			IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

			// Language Indica o idioma do dispositivo no formato ISO 639-1.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/util/Locale#getLanguage()).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/foundation/locale/languagecode/).
			Language string `json:"language"`

			// OsVersion Versão do sistema operacional.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/Build.VERSION#RELEASE).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620043-systemversion/).
			OsVersion string `json:"osVersion"`

			// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
			//
			// [Android] O valor é inteiro, tipicamente entre 0 a 255, podendo a faixa de valores variar de acordo com o fabricante do celular. Referência no [link](https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS).
			//
			// [iOS] O valor é ponto flutuante entre “0.0” e “1.0”. Referência no [link](https://developer.apple.com/documentation/uikit/uiscreen/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

			// ScreenDimensions Dimensões que o aplicativo ocupa na tela do dispositivo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/view/WindowMetrics#getBounds()), ou, para versões anteriores à 11, [link](https://developer.android.com/reference/android/util/DisplayMetrics).
			//
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/metal/mtlrasterizationratemap/3088873-screensize/).
			ScreenDimensions struct {
				// Height Altura da tela, em pixels.
				Height int `json:"height"`

				// Width Largura da tela, em pixels.
				Width int `json:"width"`
			} `json:"screenDimensions"`

			// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]. O formato especificado permite a omissão da parte correspondente aos minutos, caso esta última tenha valor zero. Assim, ambos os valores '-03:00' e '-03' são válidos e representam o mesmo fuso horário.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/time/ZonedDateTime#getOffset()) ou, para versões anteriores à 8.0, [link](https://developer.android.com/reference/java/util/TimeZone#getOffset(long)).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/foundation/timezone/).
			UserTimeZoneOffset string `json:"userTimeZoneOffset"`
		} `json:"riskSignals"`
	} `json:"data"`
}

// ConsentAuthorizationDataRiskSignalsGeolocationType defines model for ConsentAuthorization.Data.RiskSignals.Geolocation.Type.
type ConsentAuthorizationDataRiskSignalsGeolocationType string

// CreateEnrollment defines model for CreateEnrollment.
type CreateEnrollment struct {
	// Data Objeto contendo as informações para criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// Journey Informações adicionais sobre o contexto de Jornada Otimizada.
		// [RESTRIÇÃO] Objeto de envio obrigatório quando o usuário manifestar consentimento para compartilhamento de saldo através da Jornada Otimizada, independente do status do consentimento de dados”
		Journey *EnrollmentJourney `json:"journey,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser              `json:"loggedUser"`
		Permissions []enrollment.Permission `json:"permissions"`
	} `json:"data"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	// CACC - Current - Conta Corrente.
	// SVGS - Savings - Conta de Poupança.
	// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EnrollmentFidoOptionsInput defines model for EnrollmentFidoOptionsInput.
type EnrollmentFidoOptionsInput struct {
	// Data Objeto que contém as informações sobre a Relying Party e a plataforma sobre a qual o usuário está utilizando o serviço da iniciadora para utilização de FIDO2.
	Data struct {
		// Platform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
		// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
		Platform EnrollmentFidoOptionsInputDataPlatform `json:"platform"`

		// Rp Identificador único da Relying Party, que corresponde ao valor do CN do certificado de transporte da iniciadora.
		Rp string `json:"rp"`
	} `json:"data"`
}

// EnrollmentFidoOptionsInputDataPlatform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
type EnrollmentFidoOptionsInputDataPlatform string

// EnrollmentFidoRegistration Objeto que contém a resposta da criação de uma nova credencial FIDO2.
type EnrollmentFidoRegistration struct {
	Data struct {
		// AuthenticatorAttachment Indica a forma de comunicação com o autenticador.
		AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

		// ClientExtensionResults Extensões da credencial, específicas por plataforma
		ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

		// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública criada no processo de registro do dispositivo.
		ID string `json:"id"`

		// RawID Identificador da credencial. Para envio ao detentor, o valor deste atributo deve ser idêntico ao valor do atributo id.
		RawID    string `json:"rawId"`
		Response struct {
			// AttestationObject Agrega as informações da chave pública da credencial. Deve ser enviado em formato base64url para o detentor.
			AttestationObject string `json:"attestationObject"`

			// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado em formato base64url para o detentor.
			ClientDataJSON string `json:"clientDataJSON"`
		} `json:"response"`

		// Type Tipo da credencial
		Type *string `json:"type,omitempty"`
	} `json:"data"`
}

// EnrollmentFidoRegistrationOptions defines model for EnrollmentFidoRegistrationOptions.
type EnrollmentFidoRegistrationOptions struct {
	// Data Objeto que contém as informações necessárias para registro de uma nova credencial FIDO2.
	Data struct {
		// Attestation Indica o tipo de attestation que o autenticador pode utilizar.
		Attestation *string `json:"attestation,omitempty"`

		// AttestationFormats Indica as preferências de formato sobre o campo attestation.
		AttestationFormats *[]string `json:"attestationFormats,omitempty"`

		// AuthenticatorSelection Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
		AuthenticatorSelection *FidoAuthenticatorSelectionCriteria `json:"authenticatorSelection,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// ExcludeCredentials Lista de IDs de credenciais já existentes para este usuário e autenticador. É utilizado para evitar a criação de múltiplas credenciais para o mesmo usuário em mesmo autenticador. Caso seja enviado, a iniciadora pode rejeitar o registro de uma das credenciais já existentes no dispositivo, ou seguir com a criação, substituindo ou não o vínculo já existente.
		ExcludeCredentials *[]FidoPublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions       *map[string]interface{}                  `json:"extensions,omitempty"`
		PubKeyCredParams []FidoPublicKeyCredentialCreationOptions `json:"pubKeyCredParams"`
		Rp               FidoRelyingParty                         `json:"rp"`

		// Timeout Representa, em milissegundos, o tempo de validade do challenge para registro da credencial FIDO2. O valor desse campo deverá ser 300000, representando 5 minutos. Esse valor foi definido com base na máquina de estados do vínculo e na documentação do protocolo da webAuthn.
		Timeout *int     `json:"timeout,omitempty"`
		User    FidoUser `json:"user"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentFidoSignOptions defines model for EnrollmentFidoSignOptions.
type EnrollmentFidoSignOptions struct {
	// Data Objeto que contém as informações necessárias para assinatura com uma credencial FIDO2 previamente registrada.
	Data struct {
		AllowCredentials *[]FidoPublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions *map[string]interface{} `json:"extensions,omitempty"`

		// RpID Identificador da Relying Party.
		RpID *string `json:"rpId,omitempty"`

		// Timeout Expiração, em milissegundos, do challenge.
		Timeout          *int32  `json:"timeout,omitempty"`
		UserVerification *string `json:"userVerification,omitempty"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentJourney Informações adicionais sobre o contexto de Jornada Otimizada.
// [RESTRIÇÃO] Objeto de envio obrigatório quando o usuário manifestar consentimento para compartilhamento de saldo através da Jornada Otimizada, independente do status do consentimento de dados”
type EnrollmentJourney struct {
	// IsLinked Campo para identificação de consentimento iniciado em Jornada Otimizada.
	IsLinked bool `json:"isLinked"`

	// LinkID Identificador do consentimento de dados ao qual este consentimento está vinculado.
	LinkID string `json:"linkId"`
}

// EnrollmentRejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REJEITADO_TITULARIDADE_DIVERGENTE: A titularidade do usuário logado na detentora é incompatível com a informada na criação do enrollment
//
// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
//
// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
//
// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
//
// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
//
// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
//
// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
//
// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
//
// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
//
// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
//
// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRejectionReason string

// EnrollmentRevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
//
// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
//
// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
//
// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRevocationReason string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
// CACC - Current - Conta Corrente.
// SVGS - Savings - Conta de Poupança.
// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumEnrollmentCancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
//
//	INICIADORA - Vínculo de conta nos canais da iniciadora.
//
//	DETENTORA - Vínculo de conta nos canais da detentora.
type EnumEnrollmentCancelledFrom string

// EnumEnrollmentPermission Permissões atribuídas ao vínculo de conta:
// • PAYMENTS_INITIATE: Permite a utilização do vinculo para iniciação de pagamentos sem redirecionamento nas famílias de API “payments-consents” e “payments-pix”.
// • RECURRING_PAYMENTS_INITIATE: Permite a utilização do vinculo para iniciação de Pix Automático sem redirecionamento nas famílias de API "payments-recurring-consents-automatic" e "payments-pix-recurring-payments-automatic".
type EnumEnrollmentPermission string

// EnumEnrollmentStatus Status do vínculo de conta:
//
// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
//
// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
//
// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
//
// • AUTHORISED: Vínculo de conta pronto para uso.
//
// • REVOKED: Vínculo de conta revogado.
//
// • REJECTED: Vínculo de conta rejeitado.
type EnumEnrollmentStatus string

// FidoAuthenticatorSelectionCriteria Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
type FidoAuthenticatorSelectionCriteria struct {
	// AuthenticatorAttachment Indica os tipos de autenticadores suportados (ex: Sistema Operacional ou Cross-Platform como uma chave USB)
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

	// RequireResidentKey Indica o requisito de verificação do usuário.
	RequireResidentKey *bool `json:"requireResidentKey,omitempty"`

	// ResidentKey Indica o requisito de verificação do usuário.
	ResidentKey *string `json:"residentKey,omitempty"`

	// UserVerification Indica o tipo de "discoverability" da credencial.
	UserVerification *string `json:"userVerification,omitempty"`
}

// FidoPublicKeyCredentialCreationOptions defines model for FidoPublicKeyCredentialCreationOptions.
type FidoPublicKeyCredentialCreationOptions struct {
	// Alg Identificador do algoritmo (COSE)
	Alg int `json:"alg"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoPublicKeyCredentialDescriptor defines model for FidoPublicKeyCredentialDescriptor.
type FidoPublicKeyCredentialDescriptor struct {
	// ID Identificador único da credencial.
	ID string `json:"id"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoRelyingParty defines model for FidoRelyingParty.
type FidoRelyingParty struct {
	// ID Identificador único da Relying Party. Esse campo deve ser preenchido com o valor que é enviado na requisição no campo /data/rp.
	ID string `json:"id"`

	// Name Nome amigável da Relying Party para exibição aos usuários. Deve ser obtido através do Software Statement Assertion, atributo software_client_name.
	Name string `json:"name"`
}

// FidoUser defines model for FidoUser.
type FidoUser struct {
	// DisplayName Identificador do usuário para fins de apresentação. Deve ser formado pelo nome social, se existente, ou nome e sobrenome do cadastro do cliente no detentor de contas.
	DisplayName string `json:"displayName"`

	// ID Identificador único do usuário sob registro em formato base64. A conversão deste valor para o formato original (BufferSource ou ArrayBuffer) não deve ultrapassar 64 bytes.
	// O identificador único deve ser opaco, ou seja, não deve carregar dados pessoais sobre o usuário, por exemplo (não exaustivo) um UUID RFC4122 cumpre com os requisitos desse campo
	ID string `json:"id"`

	// Name Identificador do usuário human-readable.
	Name string `json:"name"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ResponseCreateEnrollment defines model for ResponseCreateEnrollment.
type ResponseCreateEnrollment struct {
	// Data Objeto contendo as informações de resposta da criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// Journey Informações adicionais sobre o contexto de Jornada Otimizada.
		// [RESTRIÇÃO] Objeto de envio obrigatório quando o usuário manifestar consentimento para compartilhamento de saldo através da Jornada Otimizada, independente do status do consentimento de dados”
		Journey *EnrollmentJourney `json:"journey,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollment defines model for ResponseEnrollment.
type ResponseEnrollment struct {
	// Data Objeto que agrupa as informações de qual foi o usuário logado que solicitou o cancelamento do vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Cancellation   *struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`

			// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do vínculo de conta.
			// Pode estar ausente em cenários de processos automatizados realizarem o cancelamento do vínculo, por exemplo, por data de expiração.
			CancelledBy *struct {
				// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
				Document struct {
					// Identification Número do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Identification string `json:"identification"`

					// Rel Tipo do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Rel string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`

			// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
			//
			//   INICIADORA - Vínculo de conta nos canais da iniciadora.
			//
			//   DETENTORA - Vínculo de conta nos canais da detentora.
			CancelledFrom EnumEnrollmentCancelledFrom                 `json:"cancelledFrom"`
			Reason        ResponseEnrollment_Data_Cancellation_Reason `json:"reason"`

			// RejectedAt Instante de rejeição do vínculo de conta no ambiente da detentora.
			RejectedAt *timeutil.DateTime `json:"rejectedAt,omitempty"`
		} `json:"cancellation,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DailyLimit Limite diário cumulativo para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos para valores tais que, garantidamente, não serão autorizados.
		// Este campo só estará presente quando o usuário, durante a autorização do vínculo, definir um valor máximo diário diferente do seu limite Pix disponível para o dia.
		DailyLimit    *string `json:"dailyLimit,omitempty"`
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento via Pix.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM para o escopo do Pix.
			// CACC - Current - Conta Corrente.
			// SVGS - Savings - Conta de Poupança.
			// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountPaymentsType `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// Journey Informações adicionais sobre o contexto de Jornada Otimizada.
		// [RESTRIÇÃO] Objeto de envio obrigatório quando o usuário manifestar consentimento para compartilhamento de saldo através da Jornada Otimizada, independente do status do consentimento de dados”
		Journey *EnrollmentJourney `json:"journey,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionLimit Valor máximo, por transação, admitido para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos de valores tais que, garantidamente, não serão autorizados.
		//
		// [Restrição] Campo de preenchimento obrigatório pelos participantes quando o campo `status` for preenchido com os valores `AUTHORISED` ou `AWAITING_ENROLLMENT`.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollmentDataCancellationReason0 Motivo da rejeição do vínculo de conta.
type ResponseEnrollmentDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TITULARIDADE_DIVERGENTE: A titularidade do usuário logado na detentora é incompatível com a informada na criação do enrollment
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// ResponseEnrollmentDataCancellationReason1 Motivo da revogação do vínculo de conta.
type ResponseEnrollmentDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// ResponseEnrollment_Data_Cancellation_Reason defines model for ResponseEnrollment.Data.Cancellation.Reason.
type ResponseEnrollment_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// RiskSignals defines model for RiskSignals.
type RiskSignals struct {
	// Data Informa a integridade do dispositivo e app
	Data map[string]any `json:"data"`
}

// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type ConsentIDType = string

// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type EnrollmentID = string

// RecurringConsentIDSignOptions Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição transmissora (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type RecurringConsentIDSignOptions = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ParameterConsentID defines model for consentId.
type ParameterConsentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// XBcbNfc defines model for x-bcb-nfc.
type XBcbNfc = bool

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200EnrollmentsEnrollmentIDRead defines model for 200EnrollmentsEnrollmentIdRead.
type N200EnrollmentsEnrollmentIDRead = ResponseEnrollment

// N201EnrollmentFidoRegistrationOptions defines model for 201EnrollmentFidoRegistrationOptions.
type N201EnrollmentFidoRegistrationOptions = EnrollmentFidoRegistrationOptions

// N201EnrollmentFidoSignOptions defines model for 201EnrollmentFidoSignOptions.
type N201EnrollmentFidoSignOptions = EnrollmentFidoSignOptions

// N201EnrollmentsCreated defines model for 201EnrollmentsCreated.
type N201EnrollmentsCreated = ResponseCreateEnrollment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// ForbiddenEnrollments defines model for ForbiddenEnrollments.
type ForbiddenEnrollments = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// AuthorizeConsentParams defines parameters for AuthorizeConsent.
type AuthorizeConsentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`

	// XBcbNfc O campo representa uma transação iniciada via NFC. O envio desse campo é obrigatório nesse cenário. As detentoras devem armazenar a informação e correlacioná-la com o consentimento e o pagamento originado.
	XBcbNfc *XBcbNfc `json:"x-bcb-nfc,omitempty"`
}

// PostEnrollmentsParams defines parameters for PostEnrollments.
type PostEnrollmentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// GetEnrollmentParams defines parameters for GetEnrollment.
type GetEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// DeleteEnrollmentJSONBody defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody struct {
	Data struct {
		Cancellation struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`
			CancelledBy           *struct {
				Document struct {
					Identification string `json:"identification"`
					Rel            string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`
			Reason DeleteEnrollmentJSONBody_Data_Cancellation_Reason `json:"reason"`
		} `json:"cancellation"`
	} `json:"data"`
}

// DeleteEnrollmentParams defines parameters for DeleteEnrollment.
type DeleteEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason0 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TITULARIDADE_DIVERGENTE: A titularidade do usuário logado na detentora é incompatível com a informada na criação do enrollment
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason1 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// DeleteEnrollmentJSONBody_Data_Cancellation_Reason defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// EnrollmentRegisterFidoCredentialParams defines parameters for EnrollmentRegisterFidoCredential.
type EnrollmentRegisterFidoCredentialParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoRegistrationOptionsParams defines parameters for EnrollmentCreateFidoRegistrationOptions.
type EnrollmentCreateFidoRegistrationOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBody defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBody struct {
	Data struct {
		// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentIDType *ConsentIDType                                         `json:"consentId,omitempty"`
		Platform      EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform `json:"platform"`

		// RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição transmissora (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		RecurringConsentID *RecurringConsentIDSignOptions `json:"recurringConsentId,omitempty"`
		Rp                 string                         `json:"rp"`
	} `json:"data"`
}

// EnrollmentCreateFidoSigningOptionsParams defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform string

// RiskSignalsParams defines parameters for RiskSignals.
type RiskSignalsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AuthorizeRecurringConsentParams defines parameters for AuthorizeRecurringConsent.
type AuthorizeRecurringConsentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AuthorizeConsentJSONRequestBody defines body for AuthorizeConsent for application/json ContentType.
type AuthorizeConsentJSONRequestBody = ConsentAuthorization

// PostEnrollmentsJSONRequestBody defines body for PostEnrollments for application/json ContentType.
type PostEnrollmentsJSONRequestBody = CreateEnrollment

// DeleteEnrollmentJSONRequestBody defines body for DeleteEnrollment for application/json ContentType.
type DeleteEnrollmentJSONRequestBody DeleteEnrollmentJSONBody

// EnrollmentRegisterFidoCredentialJSONRequestBody defines body for EnrollmentRegisterFidoCredential for application/json ContentType.
type EnrollmentRegisterFidoCredentialJSONRequestBody = EnrollmentFidoRegistration

// EnrollmentCreateFidoRegistrationOptionsJSONRequestBody defines body for EnrollmentCreateFidoRegistrationOptions for application/json ContentType.
type EnrollmentCreateFidoRegistrationOptionsJSONRequestBody = EnrollmentFidoOptionsInput

// EnrollmentCreateFidoSigningOptionsJSONRequestBody defines body for EnrollmentCreateFidoSigningOptions for application/json ContentType.
type EnrollmentCreateFidoSigningOptionsJSONRequestBody EnrollmentCreateFidoSigningOptionsJSONBody

// RiskSignalsJSONRequestBody defines body for RiskSignals for application/json ContentType.
type RiskSignalsJSONRequestBody = RiskSignals

// AuthorizeRecurringConsentJSONRequestBody defines body for AuthorizeRecurringConsent for application/json ContentType.
type AuthorizeRecurringConsentJSONRequestBody = ConsentAuthorization

// AsResponseEnrollmentDataCancellationReason0 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason0
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason0() (ResponseEnrollmentDataCancellationReason0, error) {
	var body ResponseEnrollmentDataCancellationReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason0 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason0 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseEnrollmentDataCancellationReason1 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason1
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason1() (ResponseEnrollmentDataCancellationReason1, error) {
	var body ResponseEnrollmentDataCancellationReason1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason1 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason1 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponseEnrollment_Data_Cancellation_Reason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponseEnrollment_Data_Cancellation_Reason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams)
	// Autorização de um consentimento de Pix Automático na jornada sem redirecionamento
	// (POST /recurring-consents/{recurringConsentId}/authorise)
	AuthorizeRecurringConsent(w http.ResponseWriter, r *http.Request, recurringConsentID RecurringConsentID, params AuthorizeRecurringConsentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var parameterConsentID ParameterConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &parameterConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeConsentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	// ------------- Optional header parameter "x-bcb-nfc" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-bcb-nfc")]; found {
		var XBcbNfc XBcbNfc
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-bcb-nfc", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-bcb-nfc", valueList[0], &XBcbNfc, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-bcb-nfc", Err: err})
			return
		}

		params.XBcbNfc = &XBcbNfc

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthorizeConsent(w, r, parameterConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostEnrollments operation middleware
func (siw *ServerInterfaceWrapper) PostEnrollments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEnrollmentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostEnrollments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEnrollment operation middleware
func (siw *ServerInterfaceWrapper) GetEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteEnrollment operation middleware
func (siw *ServerInterfaceWrapper) DeleteEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentRegisterFidoCredential operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentRegisterFidoCredentialParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentRegisterFidoCredential(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoRegistrationOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoRegistrationOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoSigningOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoSigningOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RiskSignals operation middleware
func (siw *ServerInterfaceWrapper) RiskSignals(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RiskSignalsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RiskSignals(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthorizeRecurringConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeRecurringConsent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "recurringConsentId" -------------
	var recurringConsentID RecurringConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "recurring-payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeRecurringConsentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthorizeRecurringConsent(w, r, recurringConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents/{consentId}/authorise", wrapper.AuthorizeConsent)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments", wrapper.PostEnrollments)
	m.HandleFunc("GET "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.GetEnrollment)
	m.HandleFunc("PATCH "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.DeleteEnrollment)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration", wrapper.EnrollmentRegisterFidoCredential)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration-options", wrapper.EnrollmentCreateFidoRegistrationOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-sign-options", wrapper.EnrollmentCreateFidoSigningOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/risk-signals", wrapper.RiskSignals)
	m.HandleFunc("POST "+options.BaseURL+"/recurring-consents/{recurringConsentId}/authorise", wrapper.AuthorizeRecurringConsent)

	return m
}

type N200EnrollmentsEnrollmentIDReadJSONResponse ResponseEnrollment

type N201EnrollmentFidoRegistrationOptionsJSONResponse EnrollmentFidoRegistrationOptions

type N201EnrollmentFidoSignOptionsJSONResponse EnrollmentFidoSignOptions

type N201EnrollmentsCreatedJSONResponse ResponseCreateEnrollment

type N204EnrollmentsEnrollmentIDDeleteResponse struct {
}

type N204EnrollmentsFidoRegistrationResponse struct {
}

type N204EnrollmentsRiskSignalsResponse struct {
}

type N204PaymentsConsentsAuthorizedResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsAuthorizationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentCancelApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityRecurringConsentsAuthorizationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type AuthorizeConsentRequestObject struct {
	ParameterConsentID ParameterConsentID `json:"consentId"`
	Params             AuthorizeConsentParams
	Body               *AuthorizeConsentJSONRequestBody
}

type AuthorizeConsentResponseObject interface {
	VisitAuthorizeConsentResponse(w http.ResponseWriter) error
}

type AuthorizeConsent204Response = N204PaymentsConsentsAuthorizedResponse

func (response AuthorizeConsent204Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AuthorizeConsent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent400ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent401ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent403ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent404ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent405ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent406ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent415ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsAuthorizationApplicationJwtResponse
}

func (response AuthorizeConsent422ApplicationJwtResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AuthorizeConsent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent500ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent529ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AuthorizeConsentdefaultJSONResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostEnrollmentsRequestObject struct {
	Params PostEnrollmentsParams
	Body   *PostEnrollmentsJSONRequestBody
}

type PostEnrollmentsResponseObject interface {
	VisitPostEnrollmentsResponse(w http.ResponseWriter) error
}

type PostEnrollments201JSONResponse struct {
	N201EnrollmentsCreatedJSONResponse
}

func (response PostEnrollments201JSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments400ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments401ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments403ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments404ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments405ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments406ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments415ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentApplicationJwtResponse
}

func (response PostEnrollments422ApplicationJwtResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostEnrollments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments500ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments529ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollmentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PostEnrollmentsdefaultJSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       GetEnrollmentParams
}

type GetEnrollmentResponseObject interface {
	VisitGetEnrollmentResponse(w http.ResponseWriter) error
}

type GetEnrollment200JSONResponse struct {
	N200EnrollmentsEnrollmentIDReadJSONResponse
}

func (response GetEnrollment200JSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment400ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment401ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment403ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment404ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment405ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment406ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment500ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment529ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response GetEnrollmentdefaultJSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       DeleteEnrollmentParams
	Body         *DeleteEnrollmentJSONRequestBody
}

type DeleteEnrollmentResponseObject interface {
	VisitDeleteEnrollmentResponse(w http.ResponseWriter) error
}

type DeleteEnrollment204Response = N204EnrollmentsEnrollmentIDDeleteResponse

func (response DeleteEnrollment204Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment400ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment401ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment403ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment404ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment405ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment406ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentCancelApplicationJwtResponse
}

func (response DeleteEnrollment422ApplicationJwtResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment500ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment529ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response DeleteEnrollmentdefaultJSONResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentRegisterFidoCredentialRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentRegisterFidoCredentialParams
	Body         *EnrollmentRegisterFidoCredentialJSONRequestBody
}

type EnrollmentRegisterFidoCredentialResponseObject interface {
	VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error
}

type EnrollmentRegisterFidoCredential204Response = N204EnrollmentsFidoRegistrationResponse

func (response EnrollmentRegisterFidoCredential204Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse
}

func (response EnrollmentRegisterFidoCredential422ApplicationJwtResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredentialdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentRegisterFidoCredentialdefaultJSONResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoRegistrationOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoRegistrationOptionsParams
	Body         *EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
}

type EnrollmentCreateFidoRegistrationOptionsResponseObject interface {
	VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoRegistrationOptions201JSONResponse struct {
	N201EnrollmentFidoRegistrationOptionsJSONResponse
}

func (response EnrollmentCreateFidoRegistrationOptions201JSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoSigningOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoSigningOptionsParams
	Body         *EnrollmentCreateFidoSigningOptionsJSONRequestBody
}

type EnrollmentCreateFidoSigningOptionsResponseObject interface {
	VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoSigningOptions201JSONResponse struct {
	N201EnrollmentFidoSignOptionsJSONResponse
}

func (response EnrollmentCreateFidoSigningOptions201JSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoSigningOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RiskSignalsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       RiskSignalsParams
	Body         *RiskSignalsJSONRequestBody
}

type RiskSignalsResponseObject interface {
	VisitRiskSignalsResponse(w http.ResponseWriter) error
}

type RiskSignals204Response = N204EnrollmentsRiskSignalsResponse

func (response RiskSignals204Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RiskSignals400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response RiskSignals400ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals401ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response RiskSignals403ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response RiskSignals404ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals405ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response RiskSignals406ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response RiskSignals415ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse
}

func (response RiskSignals422ApplicationJwtResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RiskSignals500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response RiskSignals500ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals529ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignalsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response RiskSignalsdefaultJSONResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AuthorizeRecurringConsentRequestObject struct {
	RecurringConsentID RecurringConsentID `json:"recurringConsentId"`
	Params             AuthorizeRecurringConsentParams
	Body               *AuthorizeRecurringConsentJSONRequestBody
}

type AuthorizeRecurringConsentResponseObject interface {
	VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error
}

type AuthorizeRecurringConsent204Response = N204PaymentsConsentsAuthorizedResponse

func (response AuthorizeRecurringConsent204Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AuthorizeRecurringConsent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent400ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent401ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent403ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent404ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent405ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent406ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent422ApplicationJwtResponse struct {
	UnprocessableEntityRecurringConsentsAuthorizationApplicationJwtResponse
}

func (response AuthorizeRecurringConsent422ApplicationJwtResponse) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AuthorizeRecurringConsent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent500ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeRecurringConsent529ApplicationJSONCharsetUTF8Response) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeRecurringConsentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AuthorizeRecurringConsentdefaultJSONResponse) VisitAuthorizeRecurringConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(ctx context.Context, request AuthorizeConsentRequestObject) (AuthorizeConsentResponseObject, error)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(ctx context.Context, request PostEnrollmentsRequestObject) (PostEnrollmentsResponseObject, error)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(ctx context.Context, request GetEnrollmentRequestObject) (GetEnrollmentResponseObject, error)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(ctx context.Context, request DeleteEnrollmentRequestObject) (DeleteEnrollmentResponseObject, error)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(ctx context.Context, request EnrollmentRegisterFidoCredentialRequestObject) (EnrollmentRegisterFidoCredentialResponseObject, error)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(ctx context.Context, request EnrollmentCreateFidoRegistrationOptionsRequestObject) (EnrollmentCreateFidoRegistrationOptionsResponseObject, error)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(ctx context.Context, request EnrollmentCreateFidoSigningOptionsRequestObject) (EnrollmentCreateFidoSigningOptionsResponseObject, error)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(ctx context.Context, request RiskSignalsRequestObject) (RiskSignalsResponseObject, error)
	// Autorização de um consentimento de Pix Automático na jornada sem redirecionamento
	// (POST /recurring-consents/{recurringConsentId}/authorise)
	AuthorizeRecurringConsent(ctx context.Context, request AuthorizeRecurringConsentRequestObject) (AuthorizeRecurringConsentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AuthorizeConsent operation middleware
func (sh *strictHandler) AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams) {
	var request AuthorizeConsentRequestObject

	request.ParameterConsentID = parameterConsentID
	request.Params = params

	var body AuthorizeConsentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthorizeConsent(ctx, request.(AuthorizeConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthorizeConsent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthorizeConsentResponseObject); ok {
		if err := validResponse.VisitAuthorizeConsentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostEnrollments operation middleware
func (sh *strictHandler) PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams) {
	var request PostEnrollmentsRequestObject

	request.Params = params

	var body PostEnrollmentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostEnrollments(ctx, request.(PostEnrollmentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostEnrollments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostEnrollmentsResponseObject); ok {
		if err := validResponse.VisitPostEnrollmentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetEnrollment operation middleware
func (sh *strictHandler) GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams) {
	var request GetEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetEnrollment(ctx, request.(GetEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetEnrollmentResponseObject); ok {
		if err := validResponse.VisitGetEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteEnrollment operation middleware
func (sh *strictHandler) DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams) {
	var request DeleteEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body DeleteEnrollmentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteEnrollment(ctx, request.(DeleteEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteEnrollmentResponseObject); ok {
		if err := validResponse.VisitDeleteEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentRegisterFidoCredential operation middleware
func (sh *strictHandler) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams) {
	var request EnrollmentRegisterFidoCredentialRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentRegisterFidoCredentialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentRegisterFidoCredential(ctx, request.(EnrollmentRegisterFidoCredentialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentRegisterFidoCredential")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentRegisterFidoCredentialResponseObject); ok {
		if err := validResponse.VisitEnrollmentRegisterFidoCredentialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams) {
	var request EnrollmentCreateFidoRegistrationOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoRegistrationOptions(ctx, request.(EnrollmentCreateFidoRegistrationOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoRegistrationOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoRegistrationOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoRegistrationOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams) {
	var request EnrollmentCreateFidoSigningOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoSigningOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoSigningOptions(ctx, request.(EnrollmentCreateFidoSigningOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoSigningOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoSigningOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoSigningOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RiskSignals operation middleware
func (sh *strictHandler) RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams) {
	var request RiskSignalsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body RiskSignalsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RiskSignals(ctx, request.(RiskSignalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RiskSignals")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RiskSignalsResponseObject); ok {
		if err := validResponse.VisitRiskSignalsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AuthorizeRecurringConsent operation middleware
func (sh *strictHandler) AuthorizeRecurringConsent(w http.ResponseWriter, r *http.Request, recurringConsentID RecurringConsentID, params AuthorizeRecurringConsentParams) {
	var request AuthorizeRecurringConsentRequestObject

	request.RecurringConsentID = recurringConsentID
	request.Params = params

	var body AuthorizeRecurringConsentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthorizeRecurringConsent(ctx, request.(AuthorizeRecurringConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthorizeRecurringConsent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthorizeRecurringConsentResponseObject); ok {
		if err := validResponse.VisitAuthorizeRecurringConsentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"FwAA//+tpHxGKrsBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
