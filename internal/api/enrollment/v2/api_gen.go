//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/enrollment"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
	OAuth2ClientCredentialsScopes = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseConsentsAuthorizationErrorsCode.
const (
	N422ResponseConsentsAuthorizationErrorsCodeCONTADEBITODIVERGENTECONSENTIMENTOVINCULO N422ResponseConsentsAuthorizationErrorsCode = "CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO"
	N422ResponseConsentsAuthorizationErrorsCodeERROIDEMPOTENCIA                          N422ResponseConsentsAuthorizationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseConsentsAuthorizationErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA      N422ResponseConsentsAuthorizationErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETROINVALIDO                         N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodePARAMETRONAOINFORMADO                     N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseConsentsAuthorizationErrorsCodeRISCO                                     N422ResponseConsentsAuthorizationErrorsCode = "RISCO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSCONSENTIMENTOINVALIDO               N422ResponseConsentsAuthorizationErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseConsentsAuthorizationErrorsCodeSTATUSVINCULOINVALIDO                     N422ResponseConsentsAuthorizationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorCancelEnrollmentErrorsCode.
const (
	N422ResponseErrorCancelEnrollmentErrorsCodeERROIDEMPOTENCIA          N422ResponseErrorCancelEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREJEICAO            N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REJEICAO"
	N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREVOGACAO           N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REVOGACAO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETROINVALIDO         N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCancelEnrollmentErrorsCodePARAMETRONAOINFORMADO     N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCancelEnrollmentErrorsCodeREJEITADOOUTROSEMDETALHES N422ResponseErrorCancelEnrollmentErrorsCode = "REJEITADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeREVOGADOOUTROSEMDETALHES  N422ResponseErrorCancelEnrollmentErrorsCode = "REVOGADO_OUTRO_SEM_DETALHES"
	N422ResponseErrorCancelEnrollmentErrorsCodeSTATUSINVALIDO            N422ResponseErrorCancelEnrollmentErrorsCode = "STATUS_INVALIDO"
)

// Defines values for N422ResponseErrorCreateEnrollmentErrorsCode.
const (
	N422ResponseErrorCreateEnrollmentErrorsCodeCONTAINVALIDA         N422ResponseErrorCreateEnrollmentErrorsCode = "CONTA_INVALIDA"
	N422ResponseErrorCreateEnrollmentErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorCreateEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETROINVALIDO     N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorCreateEnrollmentErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorCreateEnrollmentErrorsCodePERMISSOESINVALIDAS   N422ResponseErrorCreateEnrollmentErrorsCode = "PERMISSOES_INVALIDAS"
)

// Defines values for N422ResponseErrorFidoRegistrationErrorsCode.
const (
	N422ResponseErrorFidoRegistrationErrorsCodeCHALLENGEINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "CHALLENGE_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationErrorsCodeEXTENSIONINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "EXTENSION_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeORIGEMFIDOINVALIDA    N422ResponseErrorFidoRegistrationErrorsCode = "ORIGEM_FIDO_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationErrorsCodePUBLICKEYINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "PUBLIC_KEY_INVALIDA"
	N422ResponseErrorFidoRegistrationErrorsCodeRPIDHASHINVALIDO      N422ResponseErrorFidoRegistrationErrorsCode = "RP_ID_HASH_INVALIDO"
	N422ResponseErrorFidoRegistrationErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoRegistrationOptionsErrorsCode.
const (
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeRPINVALIDA            N422ResponseErrorFidoRegistrationOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoRegistrationOptionsErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoSignOptionsErrorsCode.
const (
	N422ResponseErrorFidoSignOptionsErrorsCodeERROIDEMPOTENCIA            N422ResponseErrorFidoSignOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETROINVALIDO           N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodePARAMETRONAOINFORMADO       N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	N422ResponseErrorFidoSignOptionsErrorsCodeRPINVALIDA                  N422ResponseErrorFidoSignOptionsErrorsCode = "RP_INVALIDA"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSCONSENTIMENTOINVALIDO N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
	N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSVINCULOINVALIDO       N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorRiskSignalsErrorsCode.
const (
	ERROIDEMPOTENCIA                     N422ResponseErrorRiskSignalsErrorsCode = "ERRO_IDEMPOTENCIA"
	FALTAMSINAISOBRIGATORIOSDAPLATAFORMA N422ResponseErrorRiskSignalsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
	PARAMETROINVALIDO                    N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_INVALIDO"
	PARAMETRONAOINFORMADO                N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_NAO_INFORMADO"
	STATUSVINCULOINVALIDO                N422ResponseErrorRiskSignalsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for ConsentAuthorizationDataRiskSignalsGeolocationType.
const (
	COARSE   ConsentAuthorizationDataRiskSignalsGeolocationType = "COARSE"
	FINE     ConsentAuthorizationDataRiskSignalsGeolocationType = "FINE"
	INFERRED ConsentAuthorizationDataRiskSignalsGeolocationType = "INFERRED"
)

// Defines values for EnrollmentFidoOptionsInputDataPlatform.
const (
	EnrollmentFidoOptionsInputDataPlatformANDROID       EnrollmentFidoOptionsInputDataPlatform = "ANDROID"
	EnrollmentFidoOptionsInputDataPlatformBROWSER       EnrollmentFidoOptionsInputDataPlatform = "BROWSER"
	EnrollmentFidoOptionsInputDataPlatformCROSSPLATFORM EnrollmentFidoOptionsInputDataPlatform = "CROSS_PLATFORM"
	EnrollmentFidoOptionsInputDataPlatformIOS           EnrollmentFidoOptionsInputDataPlatform = "IOS"
)

// Defines values for EnrollmentRejectionReason.
const (
	REJEITADODISPOSITIVOINCOMPATIVEL              EnrollmentRejectionReason = "REJEITADO_DISPOSITIVO_INCOMPATIVEL"
	REJEITADOFALHAFIDO                            EnrollmentRejectionReason = "REJEITADO_FALHA_FIDO"
	REJEITADOFALHAHYBRIDFLOW                      EnrollmentRejectionReason = "REJEITADO_FALHA_HYBRID_FLOW"
	REJEITADOFALHAINFRAESTRUTURA                  EnrollmentRejectionReason = "REJEITADO_FALHA_INFRAESTRUTURA"
	REJEITADOMANUALMENTE                          EnrollmentRejectionReason = "REJEITADO_MANUALMENTE"
	REJEITADOMAXIMOCHALLENGESATINGIDO             EnrollmentRejectionReason = "REJEITADO_MAXIMO_CHALLENGES_ATINGIDO"
	REJEITADOOUTRO                                EnrollmentRejectionReason = "REJEITADO_OUTRO"
	REJEITADOSEGURANCAINTERNA                     EnrollmentRejectionReason = "REJEITADO_SEGURANCA_INTERNA"
	REJEITADOTEMPOEXPIRADOACCOUNTHOLDERVALIDATION EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION"
	REJEITADOTEMPOEXPIRADOENROLLMENT              EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ENROLLMENT"
	REJEITADOTEMPOEXPIRADORISKSIGNALS             EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS"
)

// Defines values for EnrollmentRevocationReason.
const (
	REVOGADOFALHAINFRAESTRUTURA EnrollmentRevocationReason = "REVOGADO_FALHA_INFRAESTRUTURA"
	REVOGADOMANUALMENTE         EnrollmentRevocationReason = "REVOGADO_MANUALMENTE"
	REVOGADOOUTRO               EnrollmentRevocationReason = "REVOGADO_OUTRO"
	REVOGADOSEGURANCAINTERNA    EnrollmentRevocationReason = "REVOGADO_SEGURANCA_INTERNA"
	REVOGADOVALIDADEEXPIRADA    EnrollmentRevocationReason = "REVOGADO_VALIDADE_EXPIRADA"
)

// Defines values for EnumAccountPaymentsType.
const (
	CACC EnumAccountPaymentsType = "CACC"
	SVGS EnumAccountPaymentsType = "SVGS"
	TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumEnrollmentCancelledFrom.
const (
	DETENTORA  EnumEnrollmentCancelledFrom = "DETENTORA"
	INICIADORA EnumEnrollmentCancelledFrom = "INICIADORA"
)

// Defines values for EnumEnrollmentPermission.
const (
	PAYMENTSINITIATE EnumEnrollmentPermission = "PAYMENTS_INITIATE"
)

// Defines values for EnumEnrollmentStatus.
const (
	AUTHORISED                      EnumEnrollmentStatus = "AUTHORISED"
	AWAITINGACCOUNTHOLDERVALIDATION EnumEnrollmentStatus = "AWAITING_ACCOUNT_HOLDER_VALIDATION"
	AWAITINGENROLLMENT              EnumEnrollmentStatus = "AWAITING_ENROLLMENT"
	AWAITINGRISKSIGNALS             EnumEnrollmentStatus = "AWAITING_RISK_SIGNALS"
	REJECTED                        EnumEnrollmentStatus = "REJECTED"
	REVOKED                         EnumEnrollmentStatus = "REVOKED"
)

// Defines values for EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform.
const (
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformANDROID       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "ANDROID"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformBROWSER       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "BROWSER"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformCROSSPLATFORM EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "CROSS_PLATFORM"
	EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformIOS           EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "IOS"
)

// N422ResponseConsentsAuthorization defines model for 422ResponseConsentsAuthorization.
type N422ResponseConsentsAuthorization struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseConsentsAuthorizationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
		// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento inválido.
		// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Falta de sinais obrigatórios para a plataforma do usuário.
		// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseConsentsAuthorizationErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseConsentsAuthorizationErrorsCode string

// N422ResponseErrorCancelEnrollment defines model for 422ResponseErrorCancelEnrollment.
type N422ResponseErrorCancelEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos no cancelamento do vínculo de conta:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCancelEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
		// - MOTIVO_REJEICAO: A rejeição do vínculo de conta deve estar associada a um motivo de rejeição.
		// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
		// - MOTIVO_REVOGACAO: A revogação do vínculo de conta deve estar associada a um motivo de revogação.
		// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_INVALIDO: Status inválido.
		// - MOTIVO_REJEICAO: Motivo de rejeição não especificado.
		// - REJEITADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - MOTIVO_REVOGACAO: Motivo de revogação não especificado.
		// - REVOGADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCancelEnrollmentErrorsCode Códigos de erros previstos no cancelamento do vínculo de conta:
// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCancelEnrollmentErrorsCode string

// N422ResponseErrorCreateEnrollment defines model for 422ResponseErrorCreateEnrollment.
type N422ResponseErrorCreateEnrollment struct {
	Errors []struct {
		// Code Códigos de erros previstos na criação do vínculo de conta:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorCreateEnrollmentErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE" ou contêm valores não suportados para esta operação.
		// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - PERMISSOES_INVALIDAS: Permissões inválidas.
		// - CONTA_INVALIDA: Conta inválida.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCreateEnrollmentErrorsCode Códigos de erros previstos na criação do vínculo de conta:
// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCreateEnrollmentErrorsCode string

// N422ResponseErrorFidoRegistration defines model for 422ResponseErrorFidoRegistration.
type N422ResponseErrorFidoRegistration struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoRegistrationErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
		// - RP_INVALIDA: O valor contido no campo [response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
		// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
		// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
		// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - STATUS_VINCULO_INVALIDO: Status inválido do vínculo de conta.
		// - ORIGEM_FIDO_INVALIDA: "Origin" não pode ser verificada.
		// - RP_INVALIDA: "RpIdHash" não pode ser verificado.
		// - CHALLENGE_INVALIDO: Challenge inválido.
		// - PUBLIC_KEY_INVALIDA: Chave pública inválida.
		// - EXTENSION_INVALIDA: Extensões inválidas.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationErrorsCode Códigos de erros previstos:
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationErrorsCode string

// N422ResponseErrorFidoRegistrationOptions defines model for 422ResponseErrorFidoRegistrationOptions.
type N422ResponseErrorFidoRegistrationOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoRegistrationOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationOptionsErrorsCode string

// N422ResponseErrorFidoSignOptions defines model for 422ResponseErrorFidoSignOptions.
type N422ResponseErrorFidoSignOptions struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorFidoSignOptionsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
		// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		// - RP_INVALIDA: Relying party inválida.
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento de pagamento inválido.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoSignOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoSignOptionsErrorsCode string

// N422ResponseErrorRiskSignals defines model for 422ResponseErrorRiskSignals.
type N422ResponseErrorRiskSignals struct {
	Errors []struct {
		// Code Códigos de erros previstos:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Code N422ResponseErrorRiskSignalsErrorsCode `json:"code"`

		// Detail Descrição específica do erro de acordo com o código reportado:
		//
		// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
		// - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
		// - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
		Detail string `json:"detail"`

		// Title Título específico do erro reportado, de acordo com o código enviado:
		//
		// - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
		// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
		// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
		// - PARAMETRO_INVALIDO: Parâmetro inválido.
		// - ERRO_IDEMPOTENCIA: Erro idempotência.
		Title string `json:"title"`
	} `json:"errors"`
	Meta api.Meta `json:"meta"`
}

// N422ResponseErrorRiskSignalsErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorRiskSignalsErrorsCode string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
	Document struct {
		// Identification Número do documento de identificação oficial do titular pessoa jurídica.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ConsentAuthorization defines model for ConsentAuthorization.
type ConsentAuthorization struct {
	// Data Objeto que contém sinais de risco e o id do vínculo de conta para avaliação da autorização de um consentimento de pagamento.
	Data struct {
		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// FidoAssertion Dados da asserção
		FidoAssertion struct {
			// ClientExtensionResults Estrutura para extensão de resultados
			ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

			// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública utilizada no processo de autenticação.
			ID string `json:"id"`

			// RawID Identificador da credencial. Para envio à detentora de conta, o valor deste atributo deve ser idêntico ao valor do atributo id.
			RawID string `json:"rawId"`

			// Response Traz as informações da resposta a asserção.
			Response struct {
				// AuthenticatorData Representa a estrutura de dados do autenticador. Deve ser enviado no formato base64url para a detentora de conta.
				AuthenticatorData string `json:"authenticatorData"`

				// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado no formato base64url para a detentora de conta.
				ClientDataJSON string `json:"clientDataJSON"`

				// Signature Sequência de bytes contendo a assinatura. Deve ser enviado no formato base64url para a detentora de conta.
				Signature string `json:"signature"`

				// UserHandle Nome de usuário que foi enviado durante a criação da credencial. Deve ser enviado no formato base64url para a detentora de conta.
				// Caso o autenticador FIDO2 não retorne este campo, a iniciadora deve enviar uma string vazia à detentora de conta.
				UserHandle string `json:"userHandle"`
			} `json:"response"`

			// Type Tipo da credencial.
			Type string `json:"type"`
		} `json:"fidoAssertion"`

		// RiskSignals Conjunto de sinais extraídos do dispositivo do usuário para ativação do consentimento de pagamento.
		// A obrigatoriedade das informações variam de acordo com a plataforma utilizada.
		RiskSignals struct {
			// AccountTenure Data de cadastro do cliente na iniciadora.
			AccountTenure timeutil.BrazilDate `json:"accountTenure"`

			// AntennaInformation Indica em qual antena o dispositivo está conectado.
			AntennaInformation *string `json:"antennaInformation,omitempty"`

			// DeviceID ID único do dispositivo gerado pela plataforma.
			//
			// Utiliza-se a propriedade do sistema que identifica a combinação de usuário logado, chave de assinatura do aplicativo e dispositivo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor/).
			DeviceID string `json:"deviceId"`

			// ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/SystemClock#elapsedRealtime%28%29).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/kernel/kern/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

			// Geolocation Localização do usuário, obtida com seu consentimento.
			//
			// [Android] Informação obtida através do [link](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-abstract-tasklocation-getlastlocation) considerando as permissões necessárias.
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/corelocation/).
			//
			// [Restrição] A ITP deve solicitar ao usuário a permissão para compartilhamento de sua localização. Este campo poderá ser omitido caso o GPS esteja indisponível, isto é, sem sinal, ou em dispositivos sem o hardware necessário; ou caso o usuário negue o consentimento.
			Geolocation *struct {
				Latitude  *float32                                            `json:"latitude,omitempty"`
				Longitude *float32                                            `json:"longitude,omitempty"`
				Type      *ConsentAuthorizationDataRiskSignalsGeolocationType `json:"type,omitempty"`
			} `json:"geolocation,omitempty"`

			// Integrity Informa a integridade do dispositivo e app.
			//
			// [Android] Conforme documentação Play API Integrity, [link](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
			//
			// [iOS] Conforme documentação App Attest, [link](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity).
			Integrity *struct {
				// AppRecognitionVerdict Informa a integridade do app
				AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

				// DeviceRecognitionVerdict Informa a integridade do dispositivo
				DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
			} `json:"integrity,omitempty"`

			// IsCallInProgress Indica chamada ativa no momento do vínculo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/media/AudioManager#getMode()).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/callkit/).
			//
			// [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
			IsCallInProgress *bool `json:"isCallInProgress,omitempty"`

			// IsCharging Indica se a bateria do dispositivo está sendo carregada.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/BatteryManager).
			//
			// [iOS] Informações obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620045-batterymonitoringenabled/).
			IsCharging *bool `json:"isCharging,omitempty"`

			// IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
			IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

			// IsEmulated Indica se o dispositivo é emulado ou real.
			IsEmulated *bool `json:"isEmulated,omitempty"`

			// IsMockGPS Indica se o dispositivo está usando um GPS falso. Deve ser enviado sempre que exista o campo geolocation com tipo `COARSE` ou `FINE`.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/location/Location.html#isMock()) ou, para versões anteriores à 12, [link](https://developer.android.com/reference/android/location/Location.html#isFromMockProvider()).
			//
			// [iOS] Informação obtida através dos links:
			// sourceInformation, [link](https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation).
			// isSimulatedBySoftware, [link](https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware).
			IsMockGPS *bool `json:"isMockGPS,omitempty"`

			// IsMonkeyRunner Indica o uso do MonkeyRunner.
			IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

			// IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

			// IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
			IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

			// Language Indica o idioma do dispositivo no formato ISO 639-1.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/util/Locale#getLanguage()).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/foundation/locale/languagecode/).
			Language string `json:"language"`

			// OsVersion Versão do sistema operacional.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/Build.VERSION#RELEASE).
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620043-systemversion/).
			OsVersion string `json:"osVersion"`

			// ScreenBrightness Indica o nível de brilho da tela do dispositivo.
			//
			// [Android] O valor é inteiro, tipicamente entre 0 a 255, podendo a faixa de valores variar de acordo com o fabricante do celular. Referência no [link](https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS).
			//
			// [iOS] O valor é ponto flutuante entre “0.0” e “1.0”. Referência no [link](https://developer.apple.com/documentation/uikit/uiscreen/).
			//
			// [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
			ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

			// ScreenDimensions Dimensões que o aplicativo ocupa na tela do dispositivo.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/android/view/WindowMetrics#getBounds()), ou, para versões anteriores à 11, [link](https://developer.android.com/reference/android/util/DisplayMetrics).
			//
			// [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/metal/mtlrasterizationratemap/3088873-screensize/).
			ScreenDimensions struct {
				// Height Altura da tela, em pixels.
				Height int `json:"height"`

				// Width Largura da tela, em pixels.
				Width int `json:"width"`
			} `json:"screenDimensions"`

			// UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]. O formato especificado permite a omissão da parte correspondente aos minutos, caso esta última tenha valor zero. Assim, ambos os valores '-03:00' e '-03' são válidos e representam o mesmo fuso horário.
			//
			// [Android] Informação obtida através do [link](https://developer.android.com/reference/java/time/ZonedDateTime#getOffset()) ou, para versões anteriores à 8.0, [link](https://developer.android.com/reference/java/util/TimeZone#getOffset(long)).
			//
			// [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/foundation/timezone/).
			UserTimeZoneOffset string `json:"userTimeZoneOffset"`
		} `json:"riskSignals"`
	} `json:"data"`
}

// ConsentAuthorizationDataRiskSignalsGeolocationType defines model for ConsentAuthorization.Data.RiskSignals.Geolocation.Type.
type ConsentAuthorizationDataRiskSignalsGeolocationType string

// CreateEnrollment defines model for CreateEnrollment.
type CreateEnrollment struct {
	// Data Objeto contendo as informações para criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser              `json:"loggedUser"`
		Permissions []enrollment.Permission `json:"permissions"`
	} `json:"data"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
type DebtorAccount struct {
	// AccountType Tipos de contas usadas para pagamento via Pix.
	// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
	// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
	// Segue descrição de cada valor do ENUM para o escopo do Pix.
	// CACC - Current - Conta Corrente.
	// SVGS - Savings - Conta de Poupança.
	// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
	AccountType EnumAccountPaymentsType `json:"accountType"`

	// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
	Ispb string `json:"ispb"`

	// Issuer Código da Agência emissora da conta sem dígito.
	// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
	// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
	// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
	Issuer *string `json:"issuer,omitempty"`

	// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
	// se houver valor alfanumérico, este deve ser convertido para 0.
	Number string `json:"number"`
}

// EnrollmentFidoOptionsInput defines model for EnrollmentFidoOptionsInput.
type EnrollmentFidoOptionsInput struct {
	// Data Objeto que contém as informações sobre a Relying Party e a plataforma sobre a qual o usuário está utilizando o serviço da iniciadora para utilização de FIDO2.
	Data struct {
		// Platform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
		// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
		Platform EnrollmentFidoOptionsInputDataPlatform `json:"platform"`

		// Rp Identificador único da Relying Party, que corresponde ao valor do CN do certificado de transporte da iniciadora.
		Rp string `json:"rp"`
	} `json:"data"`
}

// EnrollmentFidoOptionsInputDataPlatform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
type EnrollmentFidoOptionsInputDataPlatform string

// EnrollmentFidoRegistration Objeto que contém a resposta da criação de uma nova credencial FIDO2.
type EnrollmentFidoRegistration struct {
	Data struct {
		// AuthenticatorAttachment Indica a forma de comunicação com o autenticador.
		AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

		// ClientExtensionResults Extensões da credencial, específicas por plataforma
		ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

		// ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública criada no processo de registro do dispositivo.
		ID string `json:"id"`

		// RawID Identificador da credencial. Para envio ao detentor, o valor deste atributo deve ser idêntico ao valor do atributo id.
		RawID    string `json:"rawId"`
		Response struct {
			// AttestationObject Agrega as informações da chave pública da credencial. Deve ser enviado em formato base64url para o detentor.
			AttestationObject string `json:"attestationObject"`

			// ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado em formato base64url para o detentor.
			ClientDataJSON string `json:"clientDataJSON"`
		} `json:"response"`

		// Type Tipo da credencial
		Type *string `json:"type,omitempty"`
	} `json:"data"`
}

// EnrollmentFidoRegistrationOptions defines model for EnrollmentFidoRegistrationOptions.
type EnrollmentFidoRegistrationOptions struct {
	// Data Objeto que contém as informações necessárias para registro de uma nova credencial FIDO2.
	Data struct {
		// Attestation Indica o tipo de attestation que o autenticador pode utilizar.
		Attestation *string `json:"attestation,omitempty"`

		// AttestationFormats Indica as preferências de formato sobre o campo attestation.
		AttestationFormats *[]string `json:"attestationFormats,omitempty"`

		// AuthenticatorSelection Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
		AuthenticatorSelection *FidoAuthenticatorSelectionCriteria `json:"authenticatorSelection,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID       EnrollmentID                         `json:"enrollmentId"`
		ExcludeCredentials *[]FidoPublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions       *map[string]interface{}                  `json:"extensions,omitempty"`
		PubKeyCredParams []FidoPublicKeyCredentialCreationOptions `json:"pubKeyCredParams"`
		Rp               FidoRelyingParty                         `json:"rp"`

		// Timeout Timeout, em milissegundos, para registro da credencial FIDO2.
		Timeout *int     `json:"timeout,omitempty"`
		User    FidoUser `json:"user"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentFidoSignOptions defines model for EnrollmentFidoSignOptions.
type EnrollmentFidoSignOptions struct {
	// Data Objeto que contém as informações necessárias para assinatura com uma credencial FIDO2 previamente registrada.
	Data struct {
		AllowCredentials *[]FidoPublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

		// Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
		Challenge string `json:"challenge"`

		// Extensions Campo de extensão com opções que variam por plataforma.
		Extensions *map[string]interface{} `json:"extensions,omitempty"`

		// RpID Identificador da Relying Party.
		RpID *string `json:"rpId,omitempty"`

		// Timeout Expiração, em milissegundos, do challenge.
		Timeout          *int32  `json:"timeout,omitempty"`
		UserVerification *string `json:"userVerification,omitempty"`
	} `json:"data"`
	Meta api.Meta `json:"meta"`
}

// EnrollmentRejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
//
// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
//
// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
//
// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
//
// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
//
// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
//
// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
//
// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
//
// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
//
// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRejectionReason string

// EnrollmentRevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
//
// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
//
// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
//
// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRevocationReason string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
// CACC - Current - Conta Corrente.
// SVGS - Savings - Conta de Poupança.
// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumEnrollmentCancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
//
//	INICIADORA - Vínculo de conta nos canais da iniciadora.
//
//	DETENTORA - Vínculo de conta nos canais da detentora.
type EnumEnrollmentCancelledFrom string

// EnumEnrollmentPermission Permissões atribuídas ao vínculo de conta:
//
// • PAYMENTS_INITIATE: Iniciação de pagamentos sem redirecionamento à detentora.
type EnumEnrollmentPermission string

// EnumEnrollmentStatus Status do vínculo de conta:
//
// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
//
// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
//
// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
//
// • AUTHORISED: Vínculo de conta pronto para uso.
//
// • REVOKED: Vínculo de conta revogado.
//
// • REJECTED: Vínculo de conta rejeitado.
type EnumEnrollmentStatus string

// FidoAuthenticatorSelectionCriteria Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
type FidoAuthenticatorSelectionCriteria struct {
	// AuthenticatorAttachment Indica os tipos de autenticadores suportados (ex: Sistema Operacional ou Cross-Platform como uma chave USB)
	AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

	// RequireResidentKey Indica o requisito de verificação do usuário.
	RequireResidentKey *bool `json:"requireResidentKey,omitempty"`

	// ResidentKey Indica o requisito de verificação do usuário.
	ResidentKey *string `json:"residentKey,omitempty"`

	// UserVerification Indica o tipo de "discoverability" da credencial.
	UserVerification *string `json:"userVerification,omitempty"`
}

// FidoPublicKeyCredentialCreationOptions defines model for FidoPublicKeyCredentialCreationOptions.
type FidoPublicKeyCredentialCreationOptions struct {
	// Alg Identificador do algoritmo (COSE)
	Alg int `json:"alg"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoPublicKeyCredentialDescriptor defines model for FidoPublicKeyCredentialDescriptor.
type FidoPublicKeyCredentialDescriptor struct {
	// ID Identificador único da credencial.
	ID string `json:"id"`

	// Type Identificador do tipo de credencial.
	Type string `json:"type"`
}

// FidoRelyingParty defines model for FidoRelyingParty.
type FidoRelyingParty struct {
	// ID Identificador único da Relying Party. Esse campo deve ser preenchido com o valor que é enviado na requisição no campo /data/rp.
	ID string `json:"id"`

	// Name Nome amigável da Relying Party para exibição aos usuários. Deve ser obtido através do Software Statement Assertion, atributo software_client_name.
	Name string `json:"name"`
}

// FidoUser defines model for FidoUser.
type FidoUser struct {
	// DisplayName Identificador do usuário para fins de apresentação. Deve ser formado pelo nome social, se existente, ou nome e sobrenome do cadastro do cliente no detentor de contas.
	DisplayName string `json:"displayName"`

	// ID Identificador único do usuário sob registro em formato base64. A conversão deste valor para o formato original (BufferSource ou ArrayBuffer) não deve ultrapassar 64 bytes.
	// O identificador único deve ser opaco, ou seja, não deve carregar dados pessoais sobre o usuário, por exemplo (não exaustivo) um UUID RFC4122 cumpre com os requisitos desse campo
	ID string `json:"id"`

	// Name Identificador do usuário human-readable.
	Name string `json:"name"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
type LoggedUser struct {
	Document struct {
		// Identification Número do documento de identificação oficial do usuário.
		Identification string `json:"identification"`

		// Rel Tipo do documento de identificação oficial do usuário.
		Rel string `json:"rel"`
	} `json:"document"`
}

// ResponseCreateEnrollment defines model for ResponseCreateEnrollment.
type ResponseCreateEnrollment struct {
	// Data Objeto contendo as informações de resposta da criação de vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
		// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
		DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollment defines model for ResponseEnrollment.
type ResponseEnrollment struct {
	// Data Objeto que agrupa as informações de qual foi o usuário logado que solicitou o cancelamento do vínculo de conta.
	Data struct {
		// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
		BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
		Cancellation   *struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`

			// CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do vínculo de conta.
			// Pode estar ausente em cenários de processos automatizados realizarem o cancelamento do vínculo, por exemplo, por data de expiração.
			CancelledBy *struct {
				// Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
				Document struct {
					// Identification Número do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Identification string `json:"identification"`

					// Rel Tipo do documento do usuário responsável pelo cancelamento do vínculo de conta.
					Rel string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`

			// CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
			//
			//   INICIADORA - Vínculo de conta nos canais da iniciadora.
			//
			//   DETENTORA - Vínculo de conta nos canais da detentora.
			CancelledFrom EnumEnrollmentCancelledFrom                 `json:"cancelledFrom"`
			Reason        ResponseEnrollment_Data_Cancellation_Reason `json:"reason"`

			// RejectedAt Instante de rejeição do vínculo de conta no ambiente da detentora.
			RejectedAt *timeutil.DateTime `json:"rejectedAt,omitempty"`
		} `json:"cancellation,omitempty"`

		// CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
		CreationDateTime timeutil.DateTime `json:"creationDateTime"`

		// DailyLimit Limite diário cumulativo para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos para valores tais que, garantidamente, não serão autorizados.
		// Este campo só estará presente quando o usuário, durante a autorização do vínculo, definir um valor máximo diário diferente do seu limite Pix disponível para o dia.
		DailyLimit    *string `json:"dailyLimit,omitempty"`
		DebtorAccount *struct {
			// AccountType Tipos de contas usadas para pagamento via Pix.
			// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
			// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
			// Segue descrição de cada valor do ENUM para o escopo do Pix.
			// CACC - Current - Conta Corrente.
			// SVGS - Savings - Conta de Poupança.
			// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
			AccountType EnumAccountPaymentsType `json:"accountType"`

			// Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
			Ispb string `json:"ispb"`

			// Issuer Código da Agência emissora da conta sem dígito.
			// (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
			// no exercício de atividades da instituição, não podendo ser móvel ou transitória).
			// [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
			Issuer *string `json:"issuer,omitempty"`

			// Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
			// se houver valor alfanumérico, este deve ser convertido para 0.
			Number string `json:"number"`
		} `json:"debtorAccount,omitempty"`

		// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		EnrollmentID EnrollmentID `json:"enrollmentId"`

		// EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
		EnrollmentName *string `json:"enrollmentName,omitempty"`

		// ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
		// Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
		//
		// [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
		// Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
		ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

		// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
		LoggedUser  LoggedUser                 `json:"loggedUser"`
		Permissions []EnumEnrollmentPermission `json:"permissions"`

		// Status Status do vínculo de conta:
		//
		// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
		//
		// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
		//
		// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
		//
		// • AUTHORISED: Vínculo de conta pronto para uso.
		//
		// • REVOKED: Vínculo de conta revogado.
		//
		// • REJECTED: Vínculo de conta rejeitado.
		Status EnumEnrollmentStatus `json:"status"`

		// StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
		StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

		// TransactionLimit Valor máximo, por transação, admitido para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
		// servindo como referência para a iniciadora evitar a criação de consentimentos de valores tais que, garantidamente, não serão autorizados.
		//
		// [Restrição] Campo de preenchimento obrigatório pelos participantes quando o campo `status` for preenchido com os valores `AUTHORISED` ou `AWAITING_ENROLLMENT`.
		TransactionLimit *string `json:"transactionLimit,omitempty"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollmentDataCancellationReason0 Motivo da rejeição do vínculo de conta.
type ResponseEnrollmentDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// ResponseEnrollmentDataCancellationReason1 Motivo da revogação do vínculo de conta.
type ResponseEnrollmentDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// ResponseEnrollment_Data_Cancellation_Reason defines model for ResponseEnrollment.Data.Cancellation.Reason.
type ResponseEnrollment_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`

	// Meta Meta informações referente à API requisitada.
	Meta *api.Meta `json:"meta,omitempty"`
}

// RiskSignals defines model for RiskSignals.
type RiskSignals struct {
	// Data Informa a integridade do dispositivo e app
	Data map[string]any `json:"data"`
}

// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type ConsentIDType = string

// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type EnrollmentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ParameterConsentID defines model for consentId.
type ParameterConsentID = string

// XBcbNfc defines model for x-bcb-nfc.
type XBcbNfc = bool

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200EnrollmentsEnrollmentIDRead defines model for 200EnrollmentsEnrollmentIdRead.
type N200EnrollmentsEnrollmentIDRead = ResponseEnrollment

// N201EnrollmentFidoRegistrationOptions defines model for 201EnrollmentFidoRegistrationOptions.
type N201EnrollmentFidoRegistrationOptions = EnrollmentFidoRegistrationOptions

// N201EnrollmentFidoSignOptions defines model for 201EnrollmentFidoSignOptions.
type N201EnrollmentFidoSignOptions = EnrollmentFidoSignOptions

// N201EnrollmentsCreated defines model for 201EnrollmentsCreated.
type N201EnrollmentsCreated = ResponseCreateEnrollment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// ForbiddenEnrollments defines model for ForbiddenEnrollments.
type ForbiddenEnrollments = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// AuthorizeConsentParams defines parameters for AuthorizeConsent.
type AuthorizeConsentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`

	// XBcbNfc O campo representa uma transação iniciada via NFC. O envio desse campo é obrigatório nesse cenário. As detentoras devem armazenar a informação e correlacioná-la com o consentimento e o pagamento originado.
	XBcbNfc *XBcbNfc `json:"x-bcb-nfc,omitempty"`
}

// PostEnrollmentsParams defines parameters for PostEnrollments.
type PostEnrollmentsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// GetEnrollmentParams defines parameters for GetEnrollment.
type GetEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// DeleteEnrollmentJSONBody defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody struct {
	Data struct {
		Cancellation struct {
			AdditionalInformation *string `json:"additionalInformation,omitempty"`
			CancelledBy           *struct {
				Document struct {
					Identification string `json:"identification"`
					Rel            string `json:"rel"`
				} `json:"document"`
			} `json:"cancelledBy,omitempty"`
			Reason DeleteEnrollmentJSONBody_Data_Cancellation_Reason `json:"reason"`
		} `json:"cancellation"`
	} `json:"data"`
}

// DeleteEnrollmentParams defines parameters for DeleteEnrollment.
type DeleteEnrollmentParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason0 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason0 struct {
	// RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
	//
	// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
	//
	// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
	//
	// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
	//
	// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
	//
	// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
	//
	// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
	//
	// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
	//
	// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason1 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason1 struct {
	// RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
	//
	// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
	//
	// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
	//
	// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
	//
	// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
	//
	// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
	RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// DeleteEnrollmentJSONBody_Data_Cancellation_Reason defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody_Data_Cancellation_Reason struct {
	union json.RawMessage
}

// EnrollmentRegisterFidoCredentialParams defines parameters for EnrollmentRegisterFidoCredential.
type EnrollmentRegisterFidoCredentialParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoRegistrationOptionsParams defines parameters for EnrollmentCreateFidoRegistrationOptions.
type EnrollmentCreateFidoRegistrationOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBody defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBody struct {
	Data struct {
		// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
		// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
		// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
		// seja um identificador de recurso persistente e independente da localização.
		// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
		// - o namespace(urn)
		// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
		// - o identificador específico dentro do namespace (C1DD33123).
		// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
		ConsentIDType ConsentIDType                                          `json:"consentId"`
		Platform      EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform `json:"platform"`
		Rp            string                                                 `json:"rp"`
	} `json:"data"`
}

// EnrollmentCreateFidoSigningOptionsParams defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform string

// RiskSignalsParams defines parameters for RiskSignals.
type RiskSignalsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

	// XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
	XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AuthorizeConsentJSONRequestBody defines body for AuthorizeConsent for application/json ContentType.
type AuthorizeConsentJSONRequestBody = ConsentAuthorization

// PostEnrollmentsJSONRequestBody defines body for PostEnrollments for application/json ContentType.
type PostEnrollmentsJSONRequestBody = CreateEnrollment

// DeleteEnrollmentJSONRequestBody defines body for DeleteEnrollment for application/json ContentType.
type DeleteEnrollmentJSONRequestBody DeleteEnrollmentJSONBody

// EnrollmentRegisterFidoCredentialJSONRequestBody defines body for EnrollmentRegisterFidoCredential for application/json ContentType.
type EnrollmentRegisterFidoCredentialJSONRequestBody = EnrollmentFidoRegistration

// EnrollmentCreateFidoRegistrationOptionsJSONRequestBody defines body for EnrollmentCreateFidoRegistrationOptions for application/json ContentType.
type EnrollmentCreateFidoRegistrationOptionsJSONRequestBody = EnrollmentFidoOptionsInput

// EnrollmentCreateFidoSigningOptionsJSONRequestBody defines body for EnrollmentCreateFidoSigningOptions for application/json ContentType.
type EnrollmentCreateFidoSigningOptionsJSONRequestBody EnrollmentCreateFidoSigningOptionsJSONBody

// RiskSignalsJSONRequestBody defines body for RiskSignals for application/json ContentType.
type RiskSignalsJSONRequestBody = RiskSignals

// AsResponseEnrollmentDataCancellationReason0 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason0
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason0() (ResponseEnrollmentDataCancellationReason0, error) {
	var body ResponseEnrollmentDataCancellationReason0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason0 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason0 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResponseEnrollmentDataCancellationReason1 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason1
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason1() (ResponseEnrollmentDataCancellationReason1, error) {
	var body ResponseEnrollmentDataCancellationReason1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResponseEnrollmentDataCancellationReason1 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResponseEnrollmentDataCancellationReason1 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ResponseEnrollment_Data_Cancellation_Reason) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ResponseEnrollment_Data_Cancellation_Reason) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "consentId" -------------
	var parameterConsentID ParameterConsentID

	err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &parameterConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "consentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthorizeConsentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	// ------------- Optional header parameter "x-bcb-nfc" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-bcb-nfc")]; found {
		var XBcbNfc XBcbNfc
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-bcb-nfc", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-bcb-nfc", valueList[0], &XBcbNfc, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-bcb-nfc", Err: err})
			return
		}

		params.XBcbNfc = &XBcbNfc

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthorizeConsent(w, r, parameterConsentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// PostEnrollments operation middleware
func (siw *ServerInterfaceWrapper) PostEnrollments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params PostEnrollmentsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PostEnrollments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetEnrollment operation middleware
func (siw *ServerInterfaceWrapper) GetEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteEnrollment operation middleware
func (siw *ServerInterfaceWrapper) DeleteEnrollment(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEnrollmentParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteEnrollment(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentRegisterFidoCredential operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentRegisterFidoCredentialParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentRegisterFidoCredential(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoRegistrationOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoRegistrationOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params EnrollmentCreateFidoSigningOptionsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnrollmentCreateFidoSigningOptions(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RiskSignals operation middleware
func (siw *ServerInterfaceWrapper) RiskSignals(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "enrollmentId" -------------
	var enrollmentID EnrollmentID

	err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params RiskSignalsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	// ------------- Required header parameter "x-idempotency-key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found {
		var XIdempotencyKey XIdempotencyKey
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
			return
		}

		params.XIdempotencyKey = XIdempotencyKey

	} else {
		err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RiskSignals(w, r, enrollmentID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/consents/{consentId}/authorise", wrapper.AuthorizeConsent)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments", wrapper.PostEnrollments)
	m.HandleFunc("GET "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.GetEnrollment)
	m.HandleFunc("PATCH "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.DeleteEnrollment)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration", wrapper.EnrollmentRegisterFidoCredential)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration-options", wrapper.EnrollmentCreateFidoRegistrationOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-sign-options", wrapper.EnrollmentCreateFidoSigningOptions)
	m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/risk-signals", wrapper.RiskSignals)

	return m
}

type N200EnrollmentsEnrollmentIDReadJSONResponse ResponseEnrollment

type N201EnrollmentFidoRegistrationOptionsJSONResponse EnrollmentFidoRegistrationOptions

type N201EnrollmentFidoSignOptionsJSONResponse EnrollmentFidoSignOptions

type N201EnrollmentsCreatedJSONResponse ResponseCreateEnrollment

type N204EnrollmentsEnrollmentIDDeleteResponse struct {
}

type N204EnrollmentsFidoRegistrationResponse struct {
}

type N204EnrollmentsRiskSignalsResponse struct {
}

type N204PaymentsConsentsAuthorizedResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsAuthorizationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentCancelApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse struct {
	Body io.Reader

	ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type AuthorizeConsentRequestObject struct {
	ParameterConsentID ParameterConsentID `json:"consentId"`
	Params             AuthorizeConsentParams
	Body               *AuthorizeConsentJSONRequestBody
}

type AuthorizeConsentResponseObject interface {
	VisitAuthorizeConsentResponse(w http.ResponseWriter) error
}

type AuthorizeConsent204Response = N204PaymentsConsentsAuthorizedResponse

func (response AuthorizeConsent204Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AuthorizeConsent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent400ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent401ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent403ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent404ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent405ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent406ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent415ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent422ApplicationJwtResponse struct {
	UnprocessableEntityConsentsAuthorizationApplicationJwtResponse
}

func (response AuthorizeConsent422ApplicationJwtResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type AuthorizeConsent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent500ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent529ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AuthorizeConsentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response AuthorizeConsentdefaultJSONResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type PostEnrollmentsRequestObject struct {
	Params PostEnrollmentsParams
	Body   *PostEnrollmentsJSONRequestBody
}

type PostEnrollmentsResponseObject interface {
	VisitPostEnrollmentsResponse(w http.ResponseWriter) error
}

type PostEnrollments201JSONResponse struct {
	N201EnrollmentsCreatedJSONResponse
}

func (response PostEnrollments201JSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments400ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments401ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments403ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments404ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments405ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments406ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments415ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentApplicationJwtResponse
}

func (response PostEnrollments422ApplicationJwtResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type PostEnrollments500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments500ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollments529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments529ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type PostEnrollmentsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response PostEnrollmentsdefaultJSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       GetEnrollmentParams
}

type GetEnrollmentResponseObject interface {
	VisitGetEnrollmentResponse(w http.ResponseWriter) error
}

type GetEnrollment200JSONResponse struct {
	N200EnrollmentsEnrollmentIDReadJSONResponse
}

func (response GetEnrollment200JSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment400ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment401ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment403ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment404ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment405ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment406ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment500ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment529ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type GetEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response GetEnrollmentdefaultJSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type DeleteEnrollmentRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       DeleteEnrollmentParams
	Body         *DeleteEnrollmentJSONRequestBody
}

type DeleteEnrollmentResponseObject interface {
	VisitDeleteEnrollmentResponse(w http.ResponseWriter) error
}

type DeleteEnrollment204Response = N204EnrollmentsEnrollmentIDDeleteResponse

func (response DeleteEnrollment204Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteEnrollment400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment400ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment401ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment403ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment404ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment405ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment406ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentCancelApplicationJwtResponse
}

func (response DeleteEnrollment422ApplicationJwtResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type DeleteEnrollment500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment500ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollment529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment529ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type DeleteEnrollmentdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response DeleteEnrollmentdefaultJSONResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentRegisterFidoCredentialRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentRegisterFidoCredentialParams
	Body         *EnrollmentRegisterFidoCredentialJSONRequestBody
}

type EnrollmentRegisterFidoCredentialResponseObject interface {
	VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error
}

type EnrollmentRegisterFidoCredential204Response = N204EnrollmentsFidoRegistrationResponse

func (response EnrollmentRegisterFidoCredential204Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse
}

func (response EnrollmentRegisterFidoCredential422ApplicationJwtResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentRegisterFidoCredentialdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentRegisterFidoCredentialdefaultJSONResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoRegistrationOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoRegistrationOptionsParams
	Body         *EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
}

type EnrollmentCreateFidoRegistrationOptionsResponseObject interface {
	VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoRegistrationOptions201JSONResponse struct {
	N201EnrollmentFidoRegistrationOptionsJSONResponse
}

func (response EnrollmentCreateFidoRegistrationOptions201JSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type EnrollmentCreateFidoSigningOptionsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       EnrollmentCreateFidoSigningOptionsParams
	Body         *EnrollmentCreateFidoSigningOptionsJSONRequestBody
}

type EnrollmentCreateFidoSigningOptionsResponseObject interface {
	VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoSigningOptions201JSONResponse struct {
	N201EnrollmentFidoSignOptionsJSONResponse
}

func (response EnrollmentCreateFidoSigningOptions201JSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(201)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type EnrollmentCreateFidoSigningOptionsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response EnrollmentCreateFidoSigningOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type RiskSignalsRequestObject struct {
	EnrollmentID EnrollmentID `json:"enrollmentId"`
	Params       RiskSignalsParams
	Body         *RiskSignalsJSONRequestBody
}

type RiskSignalsResponseObject interface {
	VisitRiskSignalsResponse(w http.ResponseWriter) error
}

type RiskSignals204Response = N204EnrollmentsRiskSignalsResponse

func (response RiskSignals204Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RiskSignals400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response RiskSignals400ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals401ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response RiskSignals403ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response RiskSignals404ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals405ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response RiskSignals406ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals415ApplicationJSONCharsetUTF8Response struct {
	UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response RiskSignals415ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(415)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals422ApplicationJwtResponse struct {
	UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse
}

func (response RiskSignals422ApplicationJwtResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/jwt")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(422)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type RiskSignals500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response RiskSignals500ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignals529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals529ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type RiskSignalsdefaultJSONResponse struct {
	Body       ResponseError
	StatusCode int
}

func (response RiskSignalsdefaultJSONResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Autorização de um consentimento de pagamentos na jornada sem redirecionamento
	// (POST /consents/{consentId}/authorise)
	AuthorizeConsent(ctx context.Context, request AuthorizeConsentRequestObject) (AuthorizeConsentResponseObject, error)
	// Criar vínculo de conta.
	// (POST /enrollments)
	PostEnrollments(ctx context.Context, request PostEnrollmentsRequestObject) (PostEnrollmentsResponseObject, error)
	// Consultar vínculo de conta.
	// (GET /enrollments/{enrollmentId})
	GetEnrollment(ctx context.Context, request GetEnrollmentRequestObject) (GetEnrollmentResponseObject, error)
	// Revogar ou rejeitar vínculo de conta.
	// (PATCH /enrollments/{enrollmentId})
	DeleteEnrollment(ctx context.Context, request DeleteEnrollmentRequestObject) (DeleteEnrollmentResponseObject, error)
	// Associação da credencial FIDO2 ao vínculo de conta.
	// (POST /enrollments/{enrollmentId}/fido-registration)
	EnrollmentRegisterFidoCredential(ctx context.Context, request EnrollmentRegisterFidoCredentialRequestObject) (EnrollmentRegisterFidoCredentialResponseObject, error)
	// Obter parâmetros para criação de credenciais FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-registration-options)
	EnrollmentCreateFidoRegistrationOptions(ctx context.Context, request EnrollmentCreateFidoRegistrationOptionsRequestObject) (EnrollmentCreateFidoRegistrationOptionsResponseObject, error)
	// Obter parâmetros para autenticação FIDO2.
	// (POST /enrollments/{enrollmentId}/fido-sign-options)
	EnrollmentCreateFidoSigningOptions(ctx context.Context, request EnrollmentCreateFidoSigningOptionsRequestObject) (EnrollmentCreateFidoSigningOptionsResponseObject, error)
	// Envio de sinais de risco para iniciação do vínculo de dispositivo
	// (POST /enrollments/{enrollmentId}/risk-signals)
	RiskSignals(ctx context.Context, request RiskSignalsRequestObject) (RiskSignalsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AuthorizeConsent operation middleware
func (sh *strictHandler) AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams) {
	var request AuthorizeConsentRequestObject

	request.ParameterConsentID = parameterConsentID
	request.Params = params

	var body AuthorizeConsentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AuthorizeConsent(ctx, request.(AuthorizeConsentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AuthorizeConsent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AuthorizeConsentResponseObject); ok {
		if err := validResponse.VisitAuthorizeConsentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PostEnrollments operation middleware
func (sh *strictHandler) PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams) {
	var request PostEnrollmentsRequestObject

	request.Params = params

	var body PostEnrollmentsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PostEnrollments(ctx, request.(PostEnrollmentsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PostEnrollments")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PostEnrollmentsResponseObject); ok {
		if err := validResponse.VisitPostEnrollmentsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetEnrollment operation middleware
func (sh *strictHandler) GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams) {
	var request GetEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetEnrollment(ctx, request.(GetEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetEnrollmentResponseObject); ok {
		if err := validResponse.VisitGetEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteEnrollment operation middleware
func (sh *strictHandler) DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams) {
	var request DeleteEnrollmentRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body DeleteEnrollmentJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteEnrollment(ctx, request.(DeleteEnrollmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteEnrollment")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteEnrollmentResponseObject); ok {
		if err := validResponse.VisitDeleteEnrollmentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentRegisterFidoCredential operation middleware
func (sh *strictHandler) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams) {
	var request EnrollmentRegisterFidoCredentialRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentRegisterFidoCredentialJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentRegisterFidoCredential(ctx, request.(EnrollmentRegisterFidoCredentialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentRegisterFidoCredential")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentRegisterFidoCredentialResponseObject); ok {
		if err := validResponse.VisitEnrollmentRegisterFidoCredentialResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams) {
	var request EnrollmentCreateFidoRegistrationOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoRegistrationOptions(ctx, request.(EnrollmentCreateFidoRegistrationOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoRegistrationOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoRegistrationOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoRegistrationOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams) {
	var request EnrollmentCreateFidoSigningOptionsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body EnrollmentCreateFidoSigningOptionsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.EnrollmentCreateFidoSigningOptions(ctx, request.(EnrollmentCreateFidoSigningOptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EnrollmentCreateFidoSigningOptions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(EnrollmentCreateFidoSigningOptionsResponseObject); ok {
		if err := validResponse.VisitEnrollmentCreateFidoSigningOptionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// RiskSignals operation middleware
func (sh *strictHandler) RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams) {
	var request RiskSignalsRequestObject

	request.EnrollmentID = enrollmentID
	request.Params = params

	var body RiskSignalsJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.RiskSignals(ctx, request.(RiskSignalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RiskSignals")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(RiskSignalsResponseObject); ok {
		if err := validResponse.VisitRiskSignalsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y921IbSdYv/iq55ZkYmNYJgW3MRMdsIQksN0hYErhtyxunqhIpTVVmObNKgNuO6Hf4",
	"335fxNffXEx4Ivpix+x9M5dbb9JP8o9cmXVUCYQNbncPfdEGqiqPK9f65Tr+ULC463FGmC8LWz8UPCyw",
	"S3wi4Ld64E+4oO+wTzlTf7CJtAT19K+FBh6R2d+xM+Ho8WBwgDxsi9nfeBkdEOFSn6C3AUFYIksQmzCL",
	"YiqRJG+wi064YMSiNpbIJh5hNmE2RzZHPvU4sgkSxAqE5Ehyh1rUxzYvFAtUdToh2CaiUCww7JLCVmaM",
	"xYIgbwMqiF3Y8kVAigVpTYiL1eBdfL5H2NifFLZq1Y3NYsHDvk+EavTlcHg2HD4bDuWrPxeKBf/CU01L",
	"X1A2Lnz4UCx837aJ63GfMOviO3KxxFoQITnDDn2HbV5GbZswn55QC9tcqAmGE5v9ffY3jsi55QSSTjlS",
	"G4Bk4HHhY4Eworrf2T/U+pUXLcJ5icbjK52Si2UXYqOaN1uLM0mY37bn59lF0UM0+4i4GmBiZrN/MWrB",
	"TprXqEuYzxFBNpkSMfsJSSJQ4KLDXgeV0CGjJ1y4qEckD4RFUAe7pDxkh/BCUTWinquvTyijNkcMo5e9",
	"ncbm2sbaq5WJ73tyq1LxOXdkmRL/pMzFuDLxXaciTiz10qoapeov09OQhVtChBpIr41KQK+zjwj7go6C",
	"2c+2or8R4vAUlo+gYSEQbFhARDWqVl962CIwHSI9Ys1+PqEWVyN31e4xnzC9xbY+DqqxzpCpY6BaoFm6",
	"CAlf0Q+VPmE+QQRRFh4TnyAbI4dbQFrQdHnIGpxJahOB1THCSG8lCgTbGmFmcXK+1VhrNtfX12rramSK",
	"4IjrOYbc4h31icvl1pCVEI8ntxIItqr/lh4ulpJbFKsuE6+r8VEmfeoHNJy6mgcXWE3Q4szHaMWMK7fd",
	"xEIi9UAAQcUdrESTWS0PWRtIRC3F/yUSuYrJ2MTHzgQr9iL5SBCk5+iLINqLqDUJlOkCXaqXAseHD69N",
	"aOUhC4+nh/1JfDjj07Qsd7r/IMmc/pfax5e49K5eelEtPXoV/zgcll79UC2ur31IPF9Z/aY4HJbKW9/+",
	"z7/84fh//PlPfxwOK3+99+qbP8xztmLhvDTmJTPQg5D5N8yIm+oNwgR3HHcBP2gvOP7T2c/MChweb7kl",
	"gFSA4hSFUIviaDs8PMaaU0QcH5dR845nfK08I0kVd2zjNthG6txdxjn+IMhJYatwrxJDuYp+KiupRj7A",
	"eR9ZoxI7sXJFO3Y9jgTxBFHnX1EbRr7ATJqTqk+tjdGUYtTZaZRRFxE2pWptpCSmAYULRoKOsT/7p6Ac",
	"Mf2MsNlPgvIyqst4b8N1xMLF7wjTmCfaGgWNkMWFIA62KGezn0oOhnMyDzB4golwQceUKeS1GDGF65Bc",
	"SsMeR5w7BDO9YI1A+twl4lASUR8T5ucwQWZTCyOOAklECauXzMENZACTRoFP1eG7ZDyW6acUN1JYICDW",
	"qtViwaUs+v1aWPZ8B3tUweYm9sn8ZJrYx4i42Qk4fMwD5BEHo9m/HJ+6GE3Ju4hnAV1wgcuoF5GPDScX",
	"W1wAHlQvqrPxsLZ+9dlQL62WW5rlbKF+wIporYr6xEO16tpDtPZoa2N9a30NHQ4ai9f0BHu0hAN/UrLV",
	"XBfJ20ep1VS/JqTvyj5n7wcBef+M2O8Hk+D9jqDv+9h/3w/YahENh/YPtQ9o5Qlm73fI6P0+Fu/rnni/",
	"jy/ePwnY+yeB874ejN/3ife+a/nvO3z6vkmsVfhw44P5fiv1D1rZ3R+8Pxw0Vv+weAdDumx7ddsWRMq8",
	"E634vyCzv3PUPlDcMNpOSRCRPp0SgbAfYGARRG0yjvYqsalXrHBEutQrYTOY2yPdNvOJwJaaYx4iUTjg",
	"sN0EUttYq9WuJDX10ioKpJk5VzK23dRCBziPYUTMF0rWvg2I9JH6SXqKBZVRA7ieTdCYiIhrabaY4oNw",
	"eOJVRSuWQwnzV4F5SRKgKXZAok8JyJVhQYk0JZH4sKC/jmXiiiRiSsQqYhxZ8eXTNgOTPlYDkxwxNR7A",
	"DoJYZKQAEQ/U/p9wEf8pcE3vlE1nPznU5kWEUyJ4qucHSMzsO413okRtWBOfC+DSgLrCkRiODRdj6WM/",
	"kMjiNkEb1WoZ1ZNLAt1gC6vLLzcjisZoJwZ0FUmmh3ap/CTn2PUc9a39cPPE2iD3S+sPLVzasPF6Cdsn",
	"tdKjUXWzNjp5VKttVgvFAkgnv7BVCAJoOkHe6w8WU/f/elktPcKlk3pp59UPmx9KyV83rvPrWu1DHl/4",
	"oCapaRJ4Qa1abUXiX7YSSKBHMBwcBaqMQMOe51ALlCiVN1Jre5aDGD3TZ9yBHktWqthc5l8M+Min6qEi",
	"EhlYREpeVhePWnUtbnOH2rxHxlT6AgbZhYbljc3i6p4WTkrfoUXiNqNgE+NTHGu+HLTTbnZr+fPq0/Et",
	"zyfZw+XzwIHqm1pmMlj91acinNXVE5INQbBPbp6+dLuXU9nRolvnPG1tLDgbTeKQPFg037Qg01hcLm48",
	"S085usOEfhRWVTE+asN9gkTXJSzVfWnu+OT02KPyVO04dnIwQZ8yfddBgkqLR9xVn7/ZP86pH83iAF/o",
	"LdVQW4a6VmJ/Rrvb2O5pIXoFifwFWRMsJPG/DfyT0uYncCQhuMgjkzqIcSrNRfOEU+RiB9i6jYuIu9Sn",
	"cCuGS73PZUqOy6IWp0zdOC4cjm0lULEv8HT2EVYg/o5hdNjbg3nvcDGitk3YrzbtLvL5KWHquo6ItLin",
	"LnSAcXzABOqAe9yZ/azOPyipyTgQmM3+jmGNppQ72MapySTI7rc+r/KQtRRYWfSqj93R7KOrkB13pgQp",
	"0saSy/CyhNNAJnEdBQjmcSkDCodWYJ+jEXWwwigOwj6dhqB7XulRHjK14oB6GXb6APv0WvxqCw6LqxYW",
	"ESG4Oglj7JMzfKEwWv2grVadceRSS3CpgCqd/Z2rWewTf8LtDvfrjsPPrpQSt0kzoLVxqc0FgiUPEFYs",
	"HIBnqFFTexK4yJ199LkdQmltnLFhPmomlkU8H48c8ivys7Q5SQ2CsgloCxN3Az1SZNMTIrRWkEuwuAHT",
	"cmc/2xQjD2x3wLjh6KjG3gSKihVBYoWpiSAy2QpBh4Od0qZZjx0esF9zX+dNh3rfyDmVPgHKDJk+Vbjf",
	"BVUF7Gaf+qQtu1MiFFf/ValTUh9u6LOftC7SwkIQQBuK0XAvummqeagpSxBdHqcS/oR9ysZw10MOBWOs",
	"O/vpnLqwjYODPho7fISdImJErYrLgVOBoDpkOCXnf5UVaKSutFlUGig4QirRXVXtqpYB0Z/0TDzB4VCP",
	"HNJiPvUvslAmgmSLZnnmLz+rjVotQqu5/SxxdtXmjYhbitCIi6URILP/Y2vFQDgruBBP1fxn/4Wc2T/H",
	"RmgxMp7906JKNEU6caxYc6qr8oIlSkDsK9fF3J1B9oPVX0rQp4fbgOGJDFwXi4vC1qJ3ioUpdgJgoEqg",
	"CFnYeqm6tsEs1ertt/v9bqt/3O4c1ffazXq/oJbRx9RRKyg10zLNXoGX9VqqH2f/cNGwcFB/vt/qDFTb",
	"7UG7PmgNC4qa4IWPRilCZIb1m8sSUXAhPotldSmnPqgSFkz0w6tiwSU+UJJRJTWxTwYUdBe1am29VH1Y",
	"WqsNqptb69WtavWFopkPxesTIJysZe5MXzMBNjCziHMLx1OvDrT+212dvJvlbazTXD9f1zoNWR2dYGcC",
	"30yJAIOg0cXMayy0itHCgQRbkyBvSGhvzOMWHhegAiEp7WMR7hRT8g6AP0xr9hEQ/uznKXGQINC8go5E",
	"uhwNC9YEOw5hYzIsaN5hLI7qHaHXlhukf609X0JvdJNbf4kS6Ws/KUtq2T53ta5QtX3Nq5TRG93GCiW7",
	"+BpXRwaeEvHE3ic2xQPQsP9qdwBtZwDGFCqaQlYTuNHTCJSUCzFQgA28Eo5u/VDwhMIvPtUQLgRfPxSo",
	"T1w5/4KGZHMKzNk/bTrW10jVhESeIFMqffAKGbIS6g/qg8P+8VG70zjc64Y4rruFuosQmlGXGHNR/XDw",
	"uNtr91vNcqK5RrfTb3UGbQXg0o2mnQOSyhiZ2/yzenvQ7uweh/3UB+1uB7rqtfuN7hY6Ao2spkqpRiw4",
	"w3CBlhnFJ3U9YlOBXYRBs4Mj6ZIaFDS+U98b1PeP++1Ovd0/7m732rv1QbfX7vaPm/Xjg736oL7T7e3X",
	"t1A36iiligzdqTwH+xgoImXlNTddNRjCphSQK3GRDDDyua+VzARG0uh2BvXjZmu7PegeN9tHrd5uqzNo",
	"ZZbY7N8WqputsgmyZx9H1Oeh14aNkUccHuvCIsBt09BdYO7bKVUkoL7FHNlUelxSn071Ih3Ue/X91qDX",
	"Pe7U1S7DiqhtPsBi9t8u8YWZaDiC7GcxYSS+iC6K8HKrp95rtvYPuoNWp9GubyF1MDPut+CqQ1jgFrZe",
	"FhaQdKFYuJQ6C8UCkFShWFh29wvFwrW2p1AsLFiz1JPEiOamX3hVTNhFF091zp8wvJXNeZXAb8Y4nuTD",
	"XKsQ044iHFmapSBBDHe7YyR3jOQLMJKXjLvkGPzYXmW82K7NYlJtwed8RGxiQVCEIGPt/WYEOY7PhsA2",
	"lovYUkNhkdm/tDuES5jEY+KiFcvB1EU29vEqsumUiDExlGLeTnhdar2FNcFTUN6meBxamYslMC6KMTtY",
	"qMT55AiLSG+SZRuD2c++OtIp307DMiLWUFzIPQytXsU7+vrw5l4A03LiCn4RN5TmG+lGvhJOsIMdfXiu",
	"zw/uIMP1IMP1js79+9dyios9m15qfB6epkgav4o+46M3xPLVgXMpa2uMvxY9xULgC3hoVJQQHRA+9Gh5",
	"X/29GP+5RF11BnXkmBp7YUz9STAqW9ytOAE9vZhWXG6dlkaYnVaoMWFWsEdDf6V46ObuYTrPG/KV+rsv",
	"cJ/R7naqX2PbzWMaWwlWkQQT8hI+o8GECZxL9gDEtt8dtI+6x73Wk1a7UYfTdJXmipzTMaiXXA725UgA",
	"aB6kWhrUm93j7qEi+H5r/7jZGtT3Hrf6aqiBhGbNt5m3i1qJpsSIUIzX9TCbKNGizmcC6K1g26ZqTbFj",
	"3O3VL6vpGR11d+vRlKZ8jD9jTqqtpaeUfPnzJvT131ISkD1DSuo+cgktJD8wOwVfLFzp27p8/FqXjl//",
	"ICdJM7RtIZw4BeDzG7bxGz7dy000auS3cebvLhS/zwtFDl8w6D/Ns+cO/H7OoTUeKmpMJpxtqWOsw61y",
	"6TMbhLXgVO7nHayFo7n0qF13MHcY/d8Co2c9EL4IRk/54y8C6Hl+JVvoxr1JEnflsJv4MhzfgCnLOKjN",
	"PiIQSr42KWs+dOIE5zoQdfY3XhLEpoJY6rjFCOMrBaILvHjSC3Pj4HFBr18YQX4hSov8lv5xTb+lr5BC",
	"72DT7xU25R+G/LnkUmYjpZfFd2Di3wZM5Dm8fQEHhkutjpepAmYfkY+d2Ecs1ArwyOULGGU6UhBordtr",
	"77b2j3fazW6C8rsmIhb8+22udZEKdb+MgpF1SHET+/hJv9sp60QIcQj02dlZ+Wwdwp8HvcoZGeHAn7BS",
	"rXLP5i5Eyms/a5+LsMmSblKxtDeSs9XQ7Gncb0KHu/CScLDUeFVr5WjQivTVOlLOurD5ZazTE+Cy8Nr2",
	"Yywny0xBWj5Lz6GkGfGlI248ru/ttTq7rbTd9/J1jdz5bnZpjTE5XDXbjDMVsmGejpV44tpwAhE2Nhea",
	"px1u77Ubx9+1nqelOYgZb/avkaMAjObIQKKUZaU4yMMTyqjJjmLHXZiwT+CH3w9anX6720n2IxE59wnT",
	"DI+c+wLPfoaEKpr5xj1RGXVFBfEFfQc5VZIBV/nd/ubcQfLOcqFYUCelefy43n+cfHmeGhXynd9SBX3n",
	"1v/36vhxx4BvnAHf8d473ns7vPfu5vY7V3gv9J+Jw/HymPElbHVY6AKbHBYWsQs8z9uGhZ7hT4s/W8xl",
	"GiETyUj+3BPcSJ/f9NUz7yi24nOYuczeXVT/HS+qibiTL3JfzYCATMZIjHrEuaBsrEjIv4hJ7fJj9MUx",
	"2FeK9BOLGzt750Dk3ykU//ehrTsk83tFMikaDgnWMwSbFO434DJ8J/H/XSR+JsL0TtIbboylpAz7gcDL",
	"xdzIBV706UYDHwIZYwvmbxwuXBU1dgcn7gj4DpPcYZJfMYwpldTuDuX8+6GcTIaIXz95wBXcPEe9nvV7",
	"+noiZ39zhs1rxK//O8aj/7vR5h00uQudvgRz3DHaO6xym1hlO5CUESl1VqucuiAhoax4REqO0ZtAzH62",
	"qYVX4cZHmE7NXJJRHRSWrmzzskfUwgK3eYUOBCHMmhhonOJ3kqTq5sw1BaU3Ahc1OgdPcoZTLhQzyMnm",
	"VpAfPRHfl/Nzy3dm/3KJroQVNsIN5zLfaebJTyjkyIManH7gYIGy4yqnaHUt9V+aRtc2UnUvhkP7h7WN",
	"D7n15wTJEc4DqAJ60yNWq50eZ3qYL+ulF69+yB1nhhgzi65nMU+Tma+iTcyjXpOg64r8XEpI5ZT5Gb0h",
	"PgciDtOWZjNIEKiWtiDFIbDVKXZonDUxpZwwaQoX3wXnCTZbNHD5GmXFwgm1eV1K1VgeRZtKIliJZSJg",
	"gHPda98ebYWnnPWIDBydoD6OTztIfKFLwqT7aUlfBH4gzAIZ15q/hSV2oOAbl4WcvaRX1klM5aXUdQ5B",
	"jRU6GJE4vdsIS/JgIxBA6KZAGz5r29BG2i/B1BizdWkCnRYvJ31yOfccqjavOewDXQhwSiHl3nzm+mI0",
	"HxuSTIdlEeIKR9Se/UMNDEoBmlfjsguI2vljNVfSHMYh8DuFEGmquJ+dqESUJJt5sk15ijVzD1tc3kyj",
	"QUMjNkF2WOImWm6bi8TmGlSiNmd+cw22yUn/nyw4NLrwicxbkrSL3Pyo62NBxjhnaTjCJqHhVHOQMRE8",
	"QAvo8zanIOkYdKw529onbwODsW2CoAUNz3XpyoR69ssMNZBEPMbMzoPdHQ6lR2MAoBb1hNNoQHYgMPOh",
	"uKSgeXlqP38SQwaVv9KUaNLfArDVdbog+N0UbSxmy1dMdQkzyGIbVQed4ncU5x92jWWvWrssIE2TbTHn",
	"ACYJI7XyeVLUNwk78+BEaomXEPGFkCmaVxN8J69rcVnRnUaihoIRzaF/pmYZiQRGqUuN3uPFKZ/SYnjI",
	"6iEQ5YISdeFB9tyZn2JBsTtXmjFxrYoEid7UDI+0LB4wf0BY7lmF8pFQKsLG0tRg1dtMMng6Bc506vNH",
	"pepakopM1cZkNUZdNnG1tLL2slqqvXpf/evLtdKjV6ullfWX1bVX71+u1V69rJYexU/m8VwxdXVRS6lm",
	"XN4W+B11mrrPz73FhK0CZakDzxhOhMQvLCIKxWSwg+ATjNKkoQtCWJwRyzfVTXM0XlNqkVxh3kwUaE42",
	"G/szJ8mgrK7+h5oU1KUIK0zhRXTFERQbdjFwuBgSQ7Iud0RZAjymL0PFWIESs+6MKCKZnF5D9rLObMGp",
	"/Qq1k/VhoXocTpRf4uilQ9lp7ByueJmjKLiMdQuwc4KAW7dFKuavFU/wKbWJqPSJ71M2luU+sQJB7tU7",
	"zV633TxuN1f1SGi3/zmj8DyHwBjCG4FOJxzQU+pXAqo3sLL2oFat3n9UolHN6RMupkrkiYrRK83tPXGw",
	"J4k9oC7pU2aRbc4Xl6v1uFCkpriITxSuXCEucqlDpSTjgNlcruaSn0PHWiXyBfaEy0r/QlFZw+HW6T0z",
	"vx7Bjjpff6xt/rH26FY35ZQIRhz4p2I6SmkBoPantl3MF/xUqwslWMKTAvpdiIZ2IiZr4giiMxLjA5Pi",
	"LjpGplxigASJK3nr7NChUe6EC2T2RL1Iu/2MXKbMf7ARk45iV2MiFO2MCXf4IjXCXrJ4eFJCFcNVhiJ4",
	"JJjLSHgTRCLLY87HZn9C0oiJRf1VvxA9HLuyEs6mshNIYu+Z3w7MKW+ATLrnBeruVMIj6Qts+SUfy9Pw",
	"w9KY+A6Wfvj7Kkwurpmejt9nRN231KKABvrWKNLigkRTyyPJOmoPDswdy6Q4F+p+FVEYjsb9N4MwwBIh",
	"fOpMcAQrZJCtGY9aEVwEz4uwND/XBaOgGhriaPegD8DyjZL2wD4Y2DiKiEqfo9nHIpJEqyicoqJS4ia5",
	"jISnHE2wsM+wIImF5X+BFAe6m1jxS8ZQqjpLeXPIxcE+9QNtgzT0zwJ3pMnf4Wy8+GkILEOjWKNb7/Vb",
	"hWJhp91R/7Q7O61er9VMQMMEsJzXEKhjJ3LVlIZeAI7DS6G0TTFihD0vc7gaHL4kkdbM0NyBgy+gJls7",
	"7LS4HDc2R8pz8EUlGnCFT4mYUnL214nzreeXRiLJfheNoe55qA6BZsXrE7yWh9aEWKcVIn08cqicUDYu",
	"XfBAlLDnlWQpGt9qLmT1vB6x+JiB6ueICJta/jWWHnveYqT1WS0nNrWwHOXIBnactmJj4/yi30a6WxMM",
	"WTvg8gDF+PhcwsovI8NdYlNcqQc25fuY4TER98bE3+c2WVm9VdltYcdRkCpfbkstmJUojtWkmm0lmFZY",
	"pJuEhfECc6GXUglkhygcvlpE3FR6UaMK+aK5vSeh2ohzh2BmdnKCxVjt9KI9BNA9wj4RFM+xAF0bDlQg",
	"YXE4/MVA2TbcyC7MfubvohKKt4WLN+6XRnoILmdU3XbZmDA8coidAcepFW+SqaK7ln7zsnXPW2wFj3mU",
	"INCUAbW5KC/oreUGTlgKebl+Zh8RUR/pinYK5i1qe59bp7sH/etOIZAAXQIXpPQJdiTPUTdJ4nqCaKvY",
	"OYVkQUbsJ0AiID6fehy91tLwtRrzayUQX38ZOoxQUIjtyhPfde7pxVlZXUU8KGp8MyXCJFlS13MKmZFm",
	"/4XWasUb73tHcFf1H+LMa/E4idRo5NaQSR4IiyQUBsXPRIqWE/24vvlgbbO6XtJ90HTuTir71NDt9kWf",
	"n/gKg91c53N9mtE8LFEpw45HF9J0fMlZ3ufslFz0AsaIWHgMeJgBNPn2ojPV49wndhPYzPIHC/sBBusV",
	"idQzbhJg2wT98uN/CM79X378z9/uDTJvwQ7lqMEZI5Z/fWYaKbGQGhAoChPvTClGh/3t/J1yMBsHeEwu",
	"2XVqU+7OycyEGr3d76IH649Ka7fLqt7gKa6ofQI+4RCFfPbM8DVn0HyhdPPo54QHzNY/wjWOVMJ1s7hN",
	"KnOuSZ6fh3G5PCJC5uoE1ANDPjnU+eWgSEAdu3zU6vXb3c69XmuvVe+3bnVlcwHJekmComqql2uhik5a",
	"ghC2Leh44rPLADxHBoHaBI0EhUq4GPnEyZJ1ZqXDnB/gYugTKnhRiWlqYcOkmC8IqiKMavfvF+Eir81o",
	"J5ie6xqKJncgGArEnIfYCR4JamGTEcMiTuBgUUY9tTnGSsduUgkLy3qv3+i1Wp3j7V579/Gg0+r3k2I1",
	"MWePAxdzAj/A8XR/+fE/quXqLz/+J4Kf1+Dna4z5CkrQm/q7UBDaPBiBd9icDkRPskld7VSRQ7n6GQCt",
	"t6CSSSj0uRV4GLFlKPiWeMWUkrPKM8psfrZPfEEtqbjxtmKTcmVV3eGugotrnwwXQQQ0qfQcfGE6T9Lv",
	"LTApl/jYqbi+I7BUk9AuRQIrMvMq69XNzc2H6yW9p5K+iwRCWnMyIYpP5fgTONpmo7ezqK5GHj0njizn",
	"6pbPqO1PcrTKWIyXbyZjoTVDCxvPs8kGkogBdckLzkj35ESSxcYQqDBzQtVwouN0orDjhAtz7BZaaYsh",
	"YzTY4nDQQBy620L/739PJi+3XPdVGcUFHZOpteN4MMQjyIhNzVkrzFdkA+vGXCKXssDnsqjVoOCOPPuX",
	"41NXrSGbYMMJ3xHBy6iuMHURYXfEJeIy4ux/KlXXt6rVPyECP/5Jpwgy/qsSESQiLxc3Um2kluMLwCaf",
	"uqSits4OS2Sr86r3cZnb3Wa5Wvx0vBbSTaJPh7Px7WqsEphNzf4dZzlArVRdv9J9ITICJxFc7oFIwOkc",
	"Fl/MmPuvdHJMOfOlvSKynn1XO0ziBa6+VycVv9RRMnYdyrpGaGNI7JZDctIYzfHI0Zzj8WXejhk3ZVAj",
	"j3wu6nqdr/q8mXr5QzGx4B3s5lyJ0mgkUvV4xns5re1JeZ6MwWuIMkkEFQg748DFifX6G9ynGLg7xSrl",
	"SpJH+mBcZsnKXhZ34S+hA1G0rhkiBzeqZko7nnIwrl4nQsLh4zGxD6VWFFy2vHvxmx+KBXOLD8FOFNaW",
	"9B6J1798EL1+A/4jJFmW/lKH/MypSUw2PYNPP2/NLIVe6X+M59y17UQNNy7omLghMNXJ8+rZs2hcE2b/",
	"dcl3xgz5N0hWh3yB31EbQ42u6NxmveSM4Ex5u2nBGWrzEZEyz1HSGALKqKlZiDDCX4LC33wNEDf2jiPh",
	"oMJxJHqFoxA5pqp55tUsuMwFyxglLyPoFgtcs3EH+EKRk4TPQH/jjfIC4+Y5hIY37f7BNlrJeARz1DdX",
	"F5ugg7g26rbAkjrq9ilX9YYJn1rUC6+N/YM2Wkl8miirSplUjGP234yojyXX91Y1CKajGWRWJK7V1jfu",
	"P3i4meYSm3BsEr8lnf2rpUevftjMD0qgUgZ5SkUTqqpouT4210aizhfXIFYTqlQkOvt5TMEKvRK9OfsI",
	"dOgRZkfOrNKnzNQwxEomGa8+BfQMucmiemh8vLlCyGMisIM0GoxC06RmpHB/9OlUh8dZYvbRpj4vDhnj",
	"iJwTYc1+tqj2CffpFMyQ4B+t1pz6gRYTxTi5AtN5IJE7++eUOOrG6AvMJIX7KwYty7JBMXAAwLo/DhSX",
	"k2A8kHFNDtSoNxpoJSwredDttwfd4/rxUbs/qK8igvpHu/3w+UH38KDeadTn0NHaw4cbc1EeCTJYyyGD",
	"teKC6BRz+b3GIWFhvE1IDbBe4ZXenhew+vJg6CWRx0KgFWkcdMEGQ8VqccgkQRMeTIkwMB87J5gF7uyj",
	"oBYv6tcj73qLs6liGrZZ/OqiY/Oomo1AXGLJatVlImUUj4nWsZjiXHmSJsZ0O9TmJplOm3mB/xnBMHPM",
	"XPKRUBeudG4RknaCDV8Cb8zEvhlDmlbOGO0NEVM6+zvXJyli8LDo5sUIUIbJVOeYuupa9XzJFTUxOnAT",
	"JZeOK+nwHHWbdOExF0/dTirbK6LMcgKczCe7vLtw6CNj3CYLxcJ2r/us3+oVioVGr9vvQ7DnTre3XygW",
	"2t1+js9MsSC8q4JRQlfWzDYWzdZHF+dUaEmjo3WWwo/S+xJ9RBVGI+kNvNpLXHhqG8ON+3SAlSb7bImD",
	"JdBWBCPszP1FYfZM/jtDC/NBhuY8XRISU/d9bE3CK9cCKjWhuSCxAxYBQM0fU7ExafuDWcYisgSXshQt",
	"68Jwl8+M70rQdnJ5isl8ABK8ZGNa/5rCvdQ+z8d6xYkP0yrWWwj6wvE17kuEemXoMpu3/BpBT3NLeVX8",
	"Te4GaUATLUGamnmt446+7/EXrnM6ulhb23dfsOff96qH6z3f/u7JG6vmsGct66z3tD1+cXG477sb606j",
	"8fYdb4/6TcIbh96Td5PKUd+anD3tnO/0aof7laZstJ82n3nexjcVduq0H+7WHh8cvWi0355VN3uPuGux",
	"R6dPxHcHMmh375/Wap2NzrPu9rOnO+39dnu712xsP3hbb9bHrUZ9fLptnY0q6r+nZ/tnjfHz9nf8Rfvd",
	"m2qrftY+233XerG/be3W1w5b9fP9p73a/bXn7pP77dZkMOhvN5/262f7zTrdrW9e7DdbF/vN52f7A/jb",
	"2f4Of9581z7rvGmfdQb75/tv9te6g8P7z97Uz/Z7p2c7Z8+bR0+fNlvn249HtUdstHs4jtp//Pxsv7d/",
	"1noK7/j1M16vf7+/CwOt7jf3d07PWmfPH5uxNupPo3E360+t5tNxvbUXPDvCvnu0f1Lvivvrgwcnk4ff",
	"V2h7/Pa7d/f7DfbdYPuQ7fD1HX80ks7hLt18SnyxxkYX4sH20dvdx2+tJ/T7i+nOA3E0enP/5MXbEd0e",
	"1L/bHo/fTk7fdA+ePm3Wx50n9eb2bp226vd3Md45d5zTrqhtjO7LB0+DyoY1WX8xPvxmfbddn1aam6dv",
	"Nlq7+2O1f98/P8FH9X3y8Mm7ib8u8MYAN777zsOH5943rHfa7lb639GnLw7ejN3JxP6+x3u7O9XnR29a",
	"7efTp7Xxk2n9mf10Z2fvwPL6/pMnz/bYDn/arZ7cnw7WBvfXDirCvb9dv+S/p40nm7S32Xh7YPliw39X",
	"eV5vN+SDUfPs6O2k+c721zmfHB096z0VwcU3rbX6Dmk9Gx/sP5Pt/sbhYZV9I3u7z9bd2nePqu/W7EfB",
	"G3/n4PzCqT9tN5/Q+nb7aDzGh/hx9fvm+aOd2mFXDKqYV2tne9+cv9ntVbbPWWN741n3sHZWfbz5nD5r",
	"1AfBd7WDw2e7B9ybnB3Ik067sd54cbYx2HUa+623a721+9bZ2tn975rjb7/9GiMir88hyMWTKvl+22m/",
	"4dSuHdHn3x9V8e5G8Hz9ifP8+57Tpmf0eW0yGe2eOyPXhvcGR71tcrj2AL/rTfZPX5w/P5x0Lcd7bO0+",
	"enG03nugvhmtP/Fe1JxAvY8f96rW4/0HexeP1u11K7Df7Qej9ScM2l5/MrXWOweW6zD8bIN23ReT0eOO",
	"c/J0qRW+MpJvjj9/TsBeGilon/1TcnG9ML5L4vc+H6gtTPz56deUZESBpqVkVuNrILvEXlzibgC+fKAZ",
	"iN4OzbjJMFLIuWggf4akGWekCE7/glh+EYX/EuYT4QkqSd5JTfS3A0S32CcCQ3KwyGafyAHEzX0tBE2J",
	"RtUYI9VtgoqwdUrsIvI9t4iMNUjRVPyLxCfEv2DEL6ITavNSUDspIjDdFJGaam4ynkyulBR87hOHWOEu",
	"XKa1U8RVz/2yISi4AwOLC2sYLBcxjR0SpdLREX8yXcLEkM+S+FQSF3kKbrPxXNT0FRGXiYC1z8gTQc4t",
	"J7BJA8jfpybwNtrpq9b3ALjId+QibqBp1pCLvK0k4XXjmhcN8AABB5AohQTchbxI0U3CmNz0ZaOcd9vw",
	"gpEZs0Li7mfPGWxpCf6VM3F9F7+qbXMLh0u4TkvlEh74edwdHoC1PxVuWMwyuXzeNu9eECxh2VFD1Had",
	"KyyWnrGTFpIHLGfdc9Mm/QqZkWwdJb8wL1JaZF2ao/omRVUisldRu5JW2c3UiR6NW5rZdWznWFix4/Cz",
	"L3bOfw9s9atgVcJbSruQUt+V8zPcLWAlrXOPGoedPHZicxRtZjkTBbteW8hKjowSPpTUMWYIz13RwBD4",
	"0abS4oHAY2JfDZMj2vrtsY8eeaMxSI9geSmSdHnoImVhZhEHz0Wexe4U6Mj4JHlcSl2cDHIO/vLjf6Ne",
	"60mrPag3u8eD1v5B97j1/UG7p37ttfvfHffbu536Xn8LJagAEle5s5980OoQdf4QRoZ+EONhUs5hof6s",
	"3h60O7uptoaFMuoa7VacqiMKDzMpBqkauuUEs59NGPylY603Gt3DzuD4cXev2eod6wzPg3a387kDX9iw",
	"nkVaKZguw503Ex3BHcA3V8+q1el19/b2W53B504jbml+3LEqm8S7EokRKpM5ba41m/369+397nFUGax/",
	"XFeDgZyOR3MZ0gR5Q6ivrQUwpamRdL723JpiGVP2iQi0HJO5/XYO6zDZ1hZqJA+Hi1kAyudzT8dsa7GI",
	"kUdsU1ItNPXktNts98Fe2j7qHrc7je7+QX3QPmrtbSV9aFLF4BGojX1ucYfDMua0ulPfe1w/bnd2evVW",
	"f9A7HBz26ltoBzsTrHO5nAgcp8BKOj7kNNZv7R726p2GanDQ6nXqS6307L+Qx53Zz4agUiUKSdpsnXC7",
	"4EHa0SIZtY8wm/3kUEkg3ipzxBcuwuPn271283hnr/vs8nEruXgCK+TPPlpMDXtOQ585jCvqG3JOXM/h",
	"W8gXXE8VJ3MBIktdu9WL2FItIZ+fEqaa3qkftNHji5GgNjpx+NnqoinsXEndV499CnlUjcNjELof5CSx",
	"inXrC2irezjodbdQN/AFl0ZiSE2hWqr4GkfBJd/FVJaRli+iiJjJWyV5MZY2xEXDBNRJhM4NC5mKHMuI",
	"lUKxcH2WftlHMZ9LvbWYE2VeixhH6u+LDn7qpbxznPNCgsZznu5khzR3oFNPYX9zTbtJRDE1YYFfEFIc",
	"dXc/kRO7wEDyGbFpVZNCsxVue32xdASXH8rGVAArxu84cigY5BdUz8x0dSPM2bT1+bw5Wz9Wu36m/SGM",
	"R5996VB+Vb4wTxtA04s2N/lw4RlbtMTJh5cdlnz/vVydeexMJVEgFQTRd/E4/GdKMTqg5+Uh2+e2yYkt",
	"kYIrFAQSjaovYL3KqEckdwJNvhvlh/fXjXcYOFG7ngNnwvRp4pFsLItDFnlt2tylFnW0lxr4oWkv/WL4",
	"GcTVEzVaRa+YjQkV6hdDd5kgCHgVEYf4YvZ/lIwqD1kfUsDYiZz+JgNdbGludQ73Q4MMkRbXGYb1WoDj",
	"WQk1AiEI89VP0HGDw+9EdXC020cl1MdTysYyesMm6IAHHpB8ecgGvXoHldBAu3ypw222LvVBtBmemH0s",
	"qb1Jk6EaTaFYUF0WigXVZrr6gXmeSyoxb9UszSH2juA5PkX6pp8IMVMrY3Q6AkI+qIk7A/8nBa5NUBl4",
	"PH06E0ao3Wk32vVmt1dHpRw2w7hUzQMqS3nj6K+brUGrM1ju4ySbSSxwPIBCsRC1t/D4xWuacPCeW9Bk",
	"7nbt1aCLb+OcxYmk0UH9ueIy/eN2pz1o15UoasOEIyJO+MVK4s5jx2QuzvQs59pOU9H84yunr3P952jF",
	"FtcAiGaae93OkzLg1QIZjsYBFjawF3P1m4frsXd3WppcfUfO6zrRYzr/NeMIuyOdBiZXeuVcZnM7MK3a",
	"i5tMTzyzoomL7wrcfFfjERwOHnd77X6rmdexJyAqVjskyjRu+S7/E0GmPMrzF0L3xmDRywYaZDwA8za9",
	"UFxChZF8KQWc43ka+fmd+UkPLvcQL2FNy0nzbLya4TzH0tFYGRPOy0njKJFhmiA7rFcRl6K9It30Er51",
	"l3RrbvWq2xVyvhV55XcTAcU8QA1wrTswrnU6BAFU8+APddjfXv1knzyjVOwRCaEf35GLS+A8vCypzjQX",
	"Oj3PJRfMT/8gbqeHdHrnrA74Cpv5sABa4CkReEQd6l8MC/MZh+N1TaiMU6rkSDG7VC6wJS16865zzvhK",
	"tTxH2BlzQX2Xo5VGt99KEUbpYZ7uPN+ZY67hcM0WLc413DvUTMw7r5ZfoIT5J6eexvJ+x5fmk/41loPa",
	"V61Gykj7WZNPW21QC/KhGfPRouAIDcbfBgQSXYW5zXF4ViNhq9up2NjHFeHlLi7LDXaEqEHs0vHsJ8ic",
	"kXXxN5Uc6Mj0hbmMWIFMWuhGEDWRjOUNUyFBxSOi2DSKQlmLsR9rmLjoWDtEHatxLpltHKa0aOPC4MWM",
	"wVZnFMiP/JyjtHRW8RPKtCAJI71Nks9oEcJKq3ALgDhPUPY5RSRNTIpCL5DBE54SLRzDiNDcBOA5gZ8y",
	"d3+XJ8XEvCQfxd4Dc9bVMqqbkBiTl0n6JtdJKKnD97mgY0gMuLIdnJwQ0YekVWqidSHwhf7jaqiUmBIU",
	"OL7AHpYSC/RgQxuGy0OWLWcbDjkiMw9bHBZQkje4mGjQZPQTpqiELmwTw49E6oGE7hitQAPkHAfSp1O+",
	"igIXHR62m6i309hYq9WQFUCoL5xGGYtIRQfR+c1PW8OuSWKTwMWsJAi28ci51gkopqg67zzspcJ5r6jy",
	"pH0QnCVrPP26lZeSqCS30lImCnptvszS2i2WWcofXuNgJz2s9ZyqSuu/TlWlsHjprSUM0LWA8kNvvkDq",
	"AMtAvTBBRs4MwnBaEoeMzZeAAtupoJddTPPKNTwsrdUG1c2t9epWtfoiW7ih5FM4zpnAws8r5jBY+euW",
	"ejQc2u9rL6trtfVXq1v6b7X1jfvq73O/v1i6AkS0jjdX/6EGFHtTOR4+wUvyLj/ElfkhCJhoLj9IUNeE",
	"oImpeUMSVh07mVAdkoo5BAxGiqlERp3QeGqTTHj/YVxfB0KBEx1ZYT7tOGOQ7rK30yitr68/Koa7o4My",
	"s8GmYRIZSEm0ov6n/mJwTl62siaJdj4nhFtrV6UurKnoIY5FNhMjvloIpmNBW655O8kMITsmWLsoi18H",
	"g42G/TEIStNhNnj5jgVdjwXddBKUq7JO5KrNryotKiMV8/LNG7V09PWhp7b+WiIRTEwBilNpYccniUxg",
	"l5RyvpOLn06Ul3tiz4GbiDwW7HSaVlMUnwcOIdVynrvlHjy4KX/LX9Wt0zFTWejeGZX3/1RsrM4PHovA",
	"w7noOLIe8rmSuOpLU6CEB0vZFG8eP2sj6YJqq7lOA2mH4AZcJ31u0owmnB1IwqYDWyW461Gbf16tbyu0",
	"6m4vLh2iuZYgjtb76+wyc7jt+qs/ZAfchpQkWCAcSGI4qEWYVqCBvdI4i0nt64J9MHfJ0HgsoLTLor5S",
	"2gz9i23KySXwVl7yjOQ1/bLoBTVjGwwpUbXOxO2Xp6s2LlqeeTr8NF1AojsTmqjVlqBwW+o0/DpKgpsc",
	"99esPbCyLhTLY5K09wV0Gjq4QerFwtbL7ELvGw83Y02dSwR2CRsU8575lw91kUv/XH6TzPOcVbpsGlM+",
	"xtebx7w/4LITyXw5P5PMC/NTeQWfvIFs9vVcI6xBjaD0uXSL7rQot48W06czOmG5B/lOTfYbUZNh6lzs",
	"UZfmHL89o0ehWvJYARQLUbxGW/XAmjPvhgYJr4wOBlQLYxymT58rck9D3ysDXiPnq78MGUTzaV9HSNsY",
	"J46fz+xIprrmXlofnKpPZ7xDwoTMPqYQXVc0w6O29jo2NiGpk1zG/kMyncpLzv6pcdnsJ2TMeSROLh8b",
	"i+LU8Zm5JzGYTU4oowIFrrGOubOfzqnLo6W3KaRL1p7KkgTh8h7Q81TprDD9BcVzieeq6r/yWi2DVR6l",
	"8s5tpE8BHIO14tqDD8NhWf1c+7C6+of8wmwZbSt2HCNzr6N3vctz+mXznA7ZS5TQRiKjjo4rWhtP/Ix+",
	"mnEZKmhyfMaKCdc4REKPN0Qyekat8Am1jDnI4E4Hf6eDv9PB3+ng73Twdzr43xdR+mG4CmcLoPdREgZq",
	"vZz+yGRewLapAP3bROKJklefgsNzKz5pXejiZNjE0VeAKCm6jPG65sGvNcG/hpJNWVfKuJTL6xje6AKc",
	"ORjo9RfF33dWna/HqiNEnpMzUX9OS5L0Cxa3ySXp7wlSLSTy5AKSJ8z2OGV+hq3ev38dGGgTH1MnL+N6",
	"HNvnkLG5YHKhHQ21B6M/P67Ps7b41HfyQi1nP/uKtX36OK6zJlm1l9qacGjReuVmk8HnoZBfv0Lkh7Sc",
	"UeUSH2euh6ZSkk/UPa5+0I58SHPzNqmHRPpLAnqdqCFwfFxcBnQncfU8rL4pRPAVKTyzqzm358UvyosM",
	"E8llP4mqT0tak5epkI+IqcSfXw1FV6jKpzETDjznj551/s3SzGapVs1SSuFzceLSkG9b4HfUaeo+b4qy",
	"gKMoxMEYzti1c4OcAJ9jB4qrMXx5Ld+MbY84jvYQ9y/2fLL1A3Ib9Nvan+G/B1XkHlj029rDDeQOsPXt",
	"/T//+c9ryG1hcWKxbx/dX6sidxszW377srb5Sv8Mpf6+ra1tPNzYXH+w8RC5+5b17cPaBnL3mfWt+qTu",
	"eBO8x9n426P2Udf83p9w4Yd/iLOhOS6T3/7wAbkNOVZL8S0LHOdDEeUPfA3GXV3T415/sKbHva4mE497",
	"4xPGXV1PjnvQ3t/u1fvtvdTgk3+9agb5gtVUhJvf52YiliK5uTqbnU4DkEj1phDvoVZylCRkKBLcE5SE",
	"JzasZapudbF2FCosuiPKErUJ0g4hRROFaJNk8sB0Pmby5cuG5lSkJVYgyD1T3+K43bzVmoB51YbvPyqF",
	"K0vECRdTwmwu5ksFVqsYr62NRrWaZa2v23au4s3BniS2Eil9yiyyzfniCFQPPEdAZegTdUtZyWbdW83l",
	"EA6NYom/RE1oXTO44XDr9J6ZX49gR7HAP9Y2/1h7dKs7dkoEIw7881suCRyR0YP1+w+qtYfp/IkPNnLz",
	"J44JD0v955jwuJUeRGyZMusOWdtIkL6h3xDZyPKY87HZsZBYYvJRf9UvRA/HrqyEs6nsBJLYe+a3A8MU",
	"GgAk7pkYTTySvsCWX/KxPA0/LI2J72Dph7+vZvKRyUhxnU2keps0anFBoqnlEWkdtQcHRges/aCwSDmS",
	"JRXupnAmd0Gj4UxwFE4kA4yc5LYbPZApQQRmrZ90MJzRIYHZiqPdgz5okt5gSCgeWRWLiEqfo9lHULtD",
	"QggHQuiIm+Q7Ol0GRxMsbAjbjBeW/0W9brqJpsMghQyfo7w5uOlgn/qBvh/HAdFr98sP1zcfVGs5hbMd",
	"zsY5n2w8LD+qPdh4tJnzSRg7HOWE6dZ7/VahWNhpd9Q/7c5Oq9fT+Q5idm8eLhE6bkC2f/E5SDxzLhvh",
	"nS2iNE2uBw6+gLtiO+x0ybK85jR6Dr6oRAOu8CkRU0rO/jpxvvX80kgkefmiMdQ9D9UhJXzx+mdFS15r",
	"QqzTCpE+HjlUTigbly54IErY80qyFI0vt4w29rwesfiYAW47IsKmln+NpdfXnkTylr368+Neq9Hd7bRf",
	"QAKMBXjvs3q1U6a9uPeXw+GwsN9qDfrHzdZRu9GClFa7vfbguXryakkSlA3sOG3FSseCyMVJ/60JdsGL",
	"1adT8Kxy+Zx34ZdBFi6xKa7UA5vyfczwmIh7Y+Lvc5us3G5daAs7jkKB+WhCargABQbDxDiGdSbdMVbC",
	"W69JURIAQj/hEPlrfAJWi1G5bzWqkDebWP00LDjBjiR5CTqobEywGKudX7SncG8YYUi+MsdbADFKCLg0",
	"cdA2/mLQcRuu9hdmf/N3VQnq24L2G/dLIz0ElzPqc3WACMMjh9hz+P6SHWiSqaLLlv7ysn3IW3zIyKaL",
	"49lEEjblzpRkK7Zd0nsLfLOu0+/sIyLqI5uHYHXZvva5dbp70L/uFAMJ8CtwAWmo9nlOWZ+E3wVkPMCR",
	"eSYBdAG1QhqP11pOa0OMksavvwzdRkguxKflie869/TiLFMrf61WvPG+dwR3Vf8hVr4Wj5QIjBxbQyYh",
	"+UJCU1X8TLRrOdGP65sP1jar6yXdB437UCOlsk8NHW9fhOk/bq7zuT7NaB6WqJRhx6OLMKHINc7+Pmen",
	"5KIXMJaXISHKXRRIEKHJt5c9cz3OfWI3gW0tf/CwH2BHu3CFekM3eYmwCfrlx/8QnPu//Pifv4N78yUL",
	"eChHDc4Y+Jpfl3NF2lakBgga7cQ7U4rRYX97uZ10MBsHeEwuoRJqU+7OyWgWJ0tp97vowfqj0trtsro3",
	"eIorah+BzzhEIa89M3zNWTRfKd08+jrhAbP1j3CVJZVw3Sxuk3mtm+fnAXIuj4jIzx15FKakyaXeLwd9",
	"AurY5aNWr9/udu71Wnuter91qyubC4DWSxLUd1O9XPPru7aRt77SEoSwbUHHE59ddp/gyABim6CRoM4E",
	"vAd94mSpPLPwXeMOPfsIFyUqeFFJfWoZt1QdAlhFGNXu3y9G5dMxOsH0HCe9TKCEisiUVOboBI8EtcIK",
	"+RZxAgcL8GWMPFzYTaqxYZXv9Ru9VqtzvN1r7z4edFr9flJKJ+bsQQrJEyfwAxxP95cf/6Narv7y438i",
	"+HkNfr7GmK8gDL2pvwstKhj9Y0MiD0ZOoqBPrPrRU25SN1HBJ2PRhGdRQZ6UgYRbgQe+2VfT8y0xkikl",
	"Z5VnlNn8bJ/4glpSseptxUPlyqq6YF6FRdc+GYuCfGjq9FGm8yQ13wIHc4mPnYrrOwJLNQldrUFgRXRe",
	"Zb26ubn5cL2k91TSd5G0SOuHJkRxrZwipY62genthBJHHj0njkyJ99r6RjVPFw9WxxwtPBbjJVpdq27m",
	"tJpxAjADD/vKcwYIJBED6pIXEPh4IslltcMtzk6oGl109E4UTJ1wYY5oGoakTAiGiRpYcjhoIA7dbaH/",
	"978nk5dbrvuqjLrRC7FniR3XwseIR2gU/Al9ks0/jrlELmWBz6WJsSAQ12C8VnWMheaa74jgZVRXcL6I",
	"sDviMum596dSdX2rWv0TIvDjnxB0O5395ED2WIIECVPzuZFWJrUcXwBx+dQlFbV1duh3ok6z3sdlLpab",
	"5Wrx06FeSDeJPh3OxrerbEvAvdDHaB6DlKrrV7pqRSb3JPjLPRAJJJ4jAIoZF5crHH9c7L3UI3qF2cXy",
	"tW2N5SPPRaCLoocKCvAFeQ0z1hPIgRArEQMXHfY6qIQOGYXswz2i78Cog10CQRjqhYTzl45E00n6XvZ2",
	"GptrG2vxTvqcO7JMiX9S5mJcmfiuUxEnlnppVY1S9ZfpacjakdlcDaTXRqUwH2mUtF3nkeTwFLzdCRoW",
	"AsGGBURUowy7RHrYIjCdhJNf0USAKGbJIgamRfRhrzNkkrzBqoX06kE4sRUICWxImryaiEBwhkcM27Gz",
	"drQha6TrGpn4lUCwrRFmFifnW421ZnN9fa22rn2lwzyRxloX7qhPXC63hqykoHE4uZVAsFX9t/RwTc0f",
	"Gwr5x2sBufrzqzFFAGrFjCu33ZQ3qQKXQFBxByvRZNRhTCtjXZ0U3sfOBKpe6DSZeo6+CKK9iFqTQJku",
	"0GXodQgRddclNM0XUr6dD1L+YWo7XuLSu3rpRbX06FX843BYevVDtbi+9iHxfGX1m+JwWCpvffs///KH",
	"4//x5z/9cTis/PXeq28W+ozpxJyFhtnNJlQHyYlXWy6V6nRRPv6Ua/18dYLIRmxjrUW9O/Rf5aFPUsXd",
	"uf/scx/jgdwN+JU4g5L4UhEX9S/6QMtwyejWA39SqyeryjVy/fx3nOCcI3g96TahKQjyPSVDbDwuZfgH",
	"kahXUkY98jYgurrVJdXvEqUMctPznzj8LKqWMDfy1B8PhVPYKoTbpx5JIqZElM0+VaBoHkAs7plQiOhA",
	"bKU5pi7oAoWJdeYirb5OBikFbpxtWjOBpDI7DqQuFAtMeCUjcGXMrQ1MStdoyi/0ohrhHmHUjq9LeivS",
	"sVNJ42lYsCeKSdUqkbjsY8RqwcVTNw9e/KbSVGGr0NKlkubIAOsNNVEApjQVajPqU1N0/0OxAMu95KYk",
	"fQTUSzXVgCZZ7WSVqf/81ZLskNU9wqD0VrSjYd+mppa6ymUGZGeZkrorBmE2JfVbfKchyOU25FqChTGV",
	"A2BlNFuKjoyVt3Ix8X89++wRpmEKh5+MbWS+ybLLrdMRZqdlj1tlgalNsVumvFI+I45TOmX8jFU0IZci",
	"XYJJCBX2muxBhzVQdsJ12BPzsXaRIS6EIRXk2wDbpTdcMGzj/6m+PaFMbcpIYEkdJRjKIxHmLt8q7PIp",
	"EcwUKOVITQzt6C/QNnyCfvnx/0OtZFjL/yXqjhekJjvfE/YdLCXFrMyIXzmjp7SiRVqlu6MdflIHAruz",
	"nx1dp1ztnOYx2vED6DtGbnllpaYU5429PGQhW9R5A8BJHKpWhC45Mu2FF5aEUwQsw4JvxoM4J+4zE5mp",
	"waeE4ZzAEc/ljUM2ZPfuoaNEcVKTRYMyCJgPQ9N0wWD1etPoevPrFKw0G71Ks7EP7jChBRYikHXlBxxW",
	"fgBWElAlCqISEIy7BHwHwlIQeiDHgaA6bYsk8ctYuPgdYZA8EdJ+sLiEUFi+L51RIKdub0ctrfaS0iph",
	"GBX4P2IxNmnb9Nya2MdP+t0OWjmhNi+FVfdhLlHJWUlg4tEgzUpGCQHIuS8wgGZ7rl0SvxbLH5ypwAPu",
	"P2GroWorsm6CCoflL2AYj6ZTMCU8wcyOKYQc5j1JotIEs4W4cqJrBFtOgKPCJDbPqeOR6DtMgZLw0c0Y",
	"BPRVgU/T8qPZ2Nf4QMbgWAKjdqhFmAQgY/hH3cPWhKBauTrHEs7OzsoYHgMcNd/Kyl670er0WyX1TRy0",
	"WFCnPg7Ql2CgmOffqJR3zgvFwjQ0VhZq5TXdsuJJ2KOFrcJ6uQoD9LA/AUlSCcFN5YdIr/ChEpETCBsu",
	"8zTcWQ4QuBklUroInhKTOhFAHOgcRkBD5bDXSOttqd5PKJZ8rIslkzBKXclgw9Lz2R9ZWANeccAMXLMJ",
	"ws7s73D44CaNZTHrSJy+LMMJgQj60Ks6mlMimJthdXezzC0mUc/cVOtwZx99bueNSL3rgkLac7CMR4c9",
	"wadwCK4aoTqqQjuCvT6o9wbt+t7e8+N6o9E6GKixYX/2ETiNGoHUSm83ERcfZx4BHT4UpVX3MDKe/dOi",
	"HK08HgwOkCkcqLA82qjVVq8YlKf2SOLEypkMU+HqhVXgXiNdi1ZJuriGbDptX5gmC+5+6qyk6CxmI4ks",
	"rubaqqatIWVc4nT2cUR9HjEnrC2LcUodhtNZjzKzpFMixiSVOypsMqqpqsgkIVrVWiUS9EzV5HxF00q6",
	"Q/gxLPFGrQbkYJnY7deNbmdQP262ttuD7nGzfdTq7bY6g9Zxo9vptzqD9n6rM+geH7U7jcO97mtEwtp+",
	"Ym5vtL3FVNk17Xbq3eODVm+/PWgdH9R369Daa6jQihLrkcxEtnhdijomQOSs9Pzso6CKvNcj5QVO1eM0",
	"5JPO06DuSDrR12tdgSqVTex1MU6wxubGi73ZPyXCEPWQwjblIetKk/xCJnLz8myB0FA5YdL5qOf6NgEu",
	"mdGhcOjbIMY6CThXzCiQiGPyW40Js413JQU/5jC6ASzjihvDrTdUDxBzRQUmL7BLfCLkwgxq8SuV2Irw",
	"oXjlyyllxDIfnO9gj6qvICh22Q8agfS5S0Tbq9s2+Jov+2Wb+UTo3CjLzeg87OtQElEfE5NI7oqvvm/b",
	"xPW4T5h18R25WKqj0sgaldiJVfjwqhjGhm9z+yK8yJhsyNgzzgGcVd6YnKo6h89VGX4MBWT26MPcVeMA",
	"Xzgc28aqcGUFnNgW5YuA6HqOkKwCgESturFoXNF7lVp1IyyGbQYpI7qFhGsb1erVrWxju6eXTX+ydvUn",
	"hwxn+lm/+qMdLkbUtgnTXywxvw73d3jATBf3r/5gn/gTbne4X3ccfhaO7cFSPdUti3g+HjlgNthYu7/M",
	"MsjA87jwib2vWEloc9io1Zb52GBj1aVOxZ7dxJAdFO4vs49tE+HeB3WDTnmivq09uvrbPvVJW3anRCgS",
	"1gtnkxMcOP6NnaN0MpacA6QeIMqI9HQKwpQCF3juQtXty1ApWFyoyUyo8zJ6yFeKc8jAdbG4+AQozi4H",
	"0YViwcdjCdFryVYKr9T0EjkS5eLbwb6GuDFrEdEFKyfBVE8DIPVK3HrixpBbjjhPCB5w6SeuTteWgXdi",
	"bYFYuy1JlS3vdvtSam0ZKbWWICI9xq9YOiUJ/k5Q5QuqJIndSae0dMqx0ryMRU9G1jSAl+eevFBoJKvM",
	"JyNR58RH5YekvPugJjwmVwoTY2fRaa7nC+ZjcZmzw2IDXUKK7JKEELm2DMnkEL6TOXDoXs0x4uoyjLia",
	"YG6txML2CL67L3wWG77jgZ/OAyMW9Il8EPTv1uQKTqfLsAgdvWBUeXk8r4zqRnu1WOvsR1pnRIUg4POr",
	"k3LkAPIhg5ypYY4P8NUBl7A4/AIszGlTOiPuJelgM5xYar2axZlFTB3rVNmZlMaXSB+St4Z+TOCf7M5+",
	"ehtQpvOJSz8sCjU/meHWkA3ZLz/+N+rFHWyhRqrcEcmXJixSUQ8LsYZ/WPhL3GQ4ymyL+cVlZKK9Z/W5",
	"O82wUEw8ifPAgjMbPDCGk0aje9gZHD/u7jVbveOj+l67CUaUYUGNrIFHBOHYKmqDozvoyqn0KQMFuw4D",
	"glWjMlELDPY2Si4uYk0xtsnbIMq0nxaZTeKQFJC/k5q/vZtafrrHTILZTyu8d3OV8z69yvtn1Vb7Ogud",
	"5RUn+5oqjH1dVcLmvlnwZn69Kr1rV+9XfpTGPDRparcyLenHfHpFwbWb0b4vgNOafd8B6s/Sa3y2akID",
	"iDtw/lngvJeDmm9FXVGZ88NarA7v5oBBMH7rmqwpmDlfBWBYAN9UhfF52nHZIPxcFL/YWSWNZVXbsaNH",
	"2t3LxsZH1aLYAae1mjHa40CCwf6qeooeFyYa007VuApcjKbkHfhjwG0DAtWlvpUgQaD5wDUeZsOCNcGO",
	"Q9iYDAuaZ5oIgqQvdx4wTcoQ9RYRO9TmMS3dAdXfmUkh3nC10b3k8byWccHDYvbfLvFFeDk1x84miPHp",
	"/Lm4FRk9P4U7Cf2btTzkbeadoL9RO3nWMK41RotlGeZfChuUOCzGsiZzPvIJ+EAm2dA8k1JSNJ8boUNj",
	"bo8EZ+zebSJDMXjQh/7nWiGX4no4Lv6YDL5zPewrMU2lCZ7S0Uh6UC+frTfiQLyzs7Py2Tp4PQ96lTMy",
	"UiyGlWqVezYFiYPFRcnFpySOhDHrtHqpLNc22eyB6polvhPpv2eRbna5zbzA//VF+nXdCRbR7J1g//0I",
	"9sSe3sn325TvXZCSl4vI6FBTGZ/qm5Hvko5vTq5nrGlxLIyW8nPQxRNkGtZVDoGGjb+o3H+ZFPzXl/tR",
	"LF7pmjK/T8eMsvGduP+dm5qSaY0u40/JyIWC52D/hAs3WYTBFPwpFAvbve6zfqtXKBYavW6/f3ywVx/s",
	"dHv7hWKh3e0n9PYJA5CnmrrctCOguFnYczIj083ZC1K45oa4xS0BHHVA74DN7wPYZPbyDtB8smViAVrJ",
	"HOWbwyiCylPAKGE1x1x40loQL5vjSZlWlmRCGuMq3wkX/oSNg7iJwN+kz8vr0H9JEIuMEiGKkfsSl2Zw",
	"l/eTiS59fbW3zOs8i0GyBuYdtPh9aRKSe/u1BMQl1P2p4d3Jzd+s3Mzs453M/GSZeRPSaTlZCoNVS68Z",
	"fXpualOoyf53ILitnWznEn24viNL2KNlSChXtrhbHgnICAQlfSkbp+T1tAa8cXFXj7nLndBldXFvE9e5",
	"Ro+vouXIdr17/YxAcf6kRUs7P8P6zeQOirtORyl+ePXh/w8AAP//UXmV2R2DAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
