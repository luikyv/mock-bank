//go:build go1.22

// Package customerv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package customerv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for BusinessProcuratorType.
const (
	BusinessProcuratorTypePROCURADOR         BusinessProcuratorType = "PROCURADOR"
	BusinessProcuratorTypeREPRESENTANTELEGAL BusinessProcuratorType = "REPRESENTANTE_LEGAL"
)

// Defines values for EnumAccountTypeCustomers.
const (
	EnumAccountTypeCustomersCONTADEPOSITOAVISTA   EnumAccountTypeCustomers = "CONTA_DEPOSITO_A_VISTA"
	EnumAccountTypeCustomersCONTAPAGAMENTOPREPAGA EnumAccountTypeCustomers = "CONTA_PAGAMENTO_PRE_PAGA"
	EnumAccountTypeCustomersCONTAPOUPANCA         EnumAccountTypeCustomers = "CONTA_POUPANCA"
)

// Defines values for EnumCountrySubDivision.
const (
	AC EnumCountrySubDivision = "AC"
	AL EnumCountrySubDivision = "AL"
	AM EnumCountrySubDivision = "AM"
	AP EnumCountrySubDivision = "AP"
	BA EnumCountrySubDivision = "BA"
	CE EnumCountrySubDivision = "CE"
	DF EnumCountrySubDivision = "DF"
	ES EnumCountrySubDivision = "ES"
	GO EnumCountrySubDivision = "GO"
	MA EnumCountrySubDivision = "MA"
	MG EnumCountrySubDivision = "MG"
	MS EnumCountrySubDivision = "MS"
	MT EnumCountrySubDivision = "MT"
	PA EnumCountrySubDivision = "PA"
	PB EnumCountrySubDivision = "PB"
	PE EnumCountrySubDivision = "PE"
	PI EnumCountrySubDivision = "PI"
	PR EnumCountrySubDivision = "PR"
	RJ EnumCountrySubDivision = "RJ"
	RN EnumCountrySubDivision = "RN"
	RO EnumCountrySubDivision = "RO"
	RR EnumCountrySubDivision = "RR"
	RS EnumCountrySubDivision = "RS"
	SC EnumCountrySubDivision = "SC"
	SE EnumCountrySubDivision = "SE"
	SP EnumCountrySubDivision = "SP"
	TO EnumCountrySubDivision = "TO"
)

// Defines values for EnumCustomerPhoneType.
const (
	EnumCustomerPhoneTypeFIXO  EnumCustomerPhoneType = "FIXO"
	EnumCustomerPhoneTypeMOVEL EnumCustomerPhoneType = "MOVEL"
	EnumCustomerPhoneTypeOUTRO EnumCustomerPhoneType = "OUTRO"
)

// Defines values for EnumFiliationType.
const (
	MAE EnumFiliationType = "MAE"
	PAI EnumFiliationType = "PAI"
)

// Defines values for EnumInformedIncomeFrequency.
const (
	EnumInformedIncomeFrequencyANUAL      EnumInformedIncomeFrequency = "ANUAL"
	EnumInformedIncomeFrequencyBIMESTRAL  EnumInformedIncomeFrequency = "BIMESTRAL"
	EnumInformedIncomeFrequencyDIARIA     EnumInformedIncomeFrequency = "DIARIA"
	EnumInformedIncomeFrequencyMENSAL     EnumInformedIncomeFrequency = "MENSAL"
	EnumInformedIncomeFrequencyOUTROS     EnumInformedIncomeFrequency = "OUTROS"
	EnumInformedIncomeFrequencyQUINZENAL  EnumInformedIncomeFrequency = "QUINZENAL"
	EnumInformedIncomeFrequencySEMANAL    EnumInformedIncomeFrequency = "SEMANAL"
	EnumInformedIncomeFrequencySEMESTRAL  EnumInformedIncomeFrequency = "SEMESTRAL"
	EnumInformedIncomeFrequencyTRIMESTRAL EnumInformedIncomeFrequency = "TRIMESTRAL"
)

// Defines values for EnumInformedRevenueFrequency.
const (
	EnumInformedRevenueFrequencyANUAL      EnumInformedRevenueFrequency = "ANUAL"
	EnumInformedRevenueFrequencyBIMESTRAL  EnumInformedRevenueFrequency = "BIMESTRAL"
	EnumInformedRevenueFrequencyDIARIA     EnumInformedRevenueFrequency = "DIARIA"
	EnumInformedRevenueFrequencyMENSAL     EnumInformedRevenueFrequency = "MENSAL"
	EnumInformedRevenueFrequencyOUTROS     EnumInformedRevenueFrequency = "OUTROS"
	EnumInformedRevenueFrequencyQUINZENAL  EnumInformedRevenueFrequency = "QUINZENAL"
	EnumInformedRevenueFrequencySEMANAL    EnumInformedRevenueFrequency = "SEMANAL"
	EnumInformedRevenueFrequencySEMESTRAL  EnumInformedRevenueFrequency = "SEMESTRAL"
	EnumInformedRevenueFrequencyTRIMESTRAL EnumInformedRevenueFrequency = "TRIMESTRAL"
)

// Defines values for EnumMaritalStatusCode.
const (
	EnumMaritalStatusCodeCASADO                EnumMaritalStatusCode = "CASADO"
	EnumMaritalStatusCodeDIVORCIADO            EnumMaritalStatusCode = "DIVORCIADO"
	EnumMaritalStatusCodeOUTRO                 EnumMaritalStatusCode = "OUTRO"
	EnumMaritalStatusCodeSEPARADOJUDICIALMENTE EnumMaritalStatusCode = "SEPARADO_JUDICIALMENTE"
	EnumMaritalStatusCodeSOLTEIRO              EnumMaritalStatusCode = "SOLTEIRO"
	EnumMaritalStatusCodeUNIAOESTAVEL          EnumMaritalStatusCode = "UNIAO_ESTAVEL"
	EnumMaritalStatusCodeVIUVO                 EnumMaritalStatusCode = "VIUVO"
)

// Defines values for EnumOccupationMainCodeType.
const (
	EnumOccupationMainCodeTypeCBO            EnumOccupationMainCodeType = "CBO"
	EnumOccupationMainCodeTypeOUTRO          EnumOccupationMainCodeType = "OUTRO"
	EnumOccupationMainCodeTypeRECEITAFEDERAL EnumOccupationMainCodeType = "RECEITA_FEDERAL"
)

// Defines values for EnumPartiesParticipationDocumentType.
const (
	CNPJ                 EnumPartiesParticipationDocumentType = "CNPJ"
	CPF                  EnumPartiesParticipationDocumentType = "CPF"
	OUTRODOCUMENTOVIAGEM EnumPartiesParticipationDocumentType = "OUTRO_DOCUMENTO_VIAGEM"
	PASSAPORTE           EnumPartiesParticipationDocumentType = "PASSAPORTE"
)

// Defines values for EnumPersonalOtherDocumentType.
const (
	CNH    EnumPersonalOtherDocumentType = "CNH"
	NIF    EnumPersonalOtherDocumentType = "NIF"
	OUTROS EnumPersonalOtherDocumentType = "OUTROS"
	RG     EnumPersonalOtherDocumentType = "RG"
	RNE    EnumPersonalOtherDocumentType = "RNE"
)

// Defines values for EnumProcuratorsTypePersonal.
const (
	EnumProcuratorsTypePersonalPROCURADOR         EnumProcuratorsTypePersonal = "PROCURADOR"
	EnumProcuratorsTypePersonalREPRESENTANTELEGAL EnumProcuratorsTypePersonal = "REPRESENTANTE_LEGAL"
)

// Defines values for EnumProductServiceType.
const (
	EnumProductServiceTypeCARTAOCREDITO         EnumProductServiceType = "CARTAO_CREDITO"
	EnumProductServiceTypeCONTADEPOSITOAVISTA   EnumProductServiceType = "CONTA_DEPOSITO_A_VISTA"
	EnumProductServiceTypeCONTAPAGAMENTOPREPAGA EnumProductServiceType = "CONTA_PAGAMENTO_PRE_PAGA"
	EnumProductServiceTypeCONTAPOUPANCA         EnumProductServiceType = "CONTA_POUPANCA"
	EnumProductServiceTypeCONTASALARIO          EnumProductServiceType = "CONTA_SALARIO"
	EnumProductServiceTypeCREDENCIAMENTO        EnumProductServiceType = "CREDENCIAMENTO"
	EnumProductServiceTypeINVESTIMENTO          EnumProductServiceType = "INVESTIMENTO"
	EnumProductServiceTypeOPERACAOCREDITO       EnumProductServiceType = "OPERACAO_CREDITO"
	EnumProductServiceTypeOPERACOESCAMBIO       EnumProductServiceType = "OPERACOES_CAMBIO"
	EnumProductServiceTypeOUTROS                EnumProductServiceType = "OUTROS"
	EnumProductServiceTypePREVIDENCIA           EnumProductServiceType = "PREVIDENCIA"
	EnumProductServiceTypeSEGURO                EnumProductServiceType = "SEGURO"
)

// Defines values for EnumSex.
const (
	EnumSexFEMININO  EnumSex = "FEMININO"
	EnumSexMASCULINO EnumSex = "MASCULINO"
	EnumSexOUTRO     EnumSex = "OUTRO"
)

// Defines values for PartiesParticipationPersonType.
const (
	PESSOAJURIDICA PartiesParticipationPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  PartiesParticipationPersonType = "PESSOA_NATURAL"
)

// Defines values for PartiesParticipationType.
const (
	ADMINISTRADOR PartiesParticipationType = "ADMINISTRADOR"
	SOCIO         PartiesParticipationType = "SOCIO"
)

// Defines values for PersonalAccountSubtype.
const (
	CONJUNTASIMPLES   PersonalAccountSubtype = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA PersonalAccountSubtype = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        PersonalAccountSubtype = "INDIVIDUAL"
)

// AreaCode Número de DDD (Discagem Direta à Distância) do telefone do cliente - se houver
type AreaCode = string

// BusinessAccount defines model for BusinessAccount.
type BusinessAccount struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
	//
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
	//
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
	//
	// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
	Type EnumAccountTypeCustomers `json:"type"`
}

// BusinessContacts Conjunto de informações referentes às formas para contatar o cliente.
type BusinessContacts struct {
	// Emails Lista e-mails de contato
	Emails []CustomerEmail `json:"emails"`

	// Phones Lista com telefones de contato da pessoa jurídica
	Phones []CustomerPhone `json:"phones"`

	// PostalAddresses Lista de endereços da pessoa jurídica
	PostalAddresses []BusinessPostalAddress `json:"postalAddresses"`
}

// BusinessFinancialRelationData Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
type BusinessFinancialRelationData struct {
	// Accounts Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora.
	Accounts []BusinessAccount `json:"accounts"`

	// Procurators Lista dos representantes. De preenchimento obrigatório se houver representante.
	Procurators          []BusinessProcurator     `json:"procurators"`
	ProductsServicesType []EnumProductServiceType `json:"productsServicesType"`

	// StartDate Data de início de relacionamento com a Instituição Financeira. Deve trazer o menor valor entre a informação reportada ao BACEN pelo DOC 3040 e CCS.
	StartDate timeutil.DateTime `json:"startDate"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// BusinessIdentificationData Conjunto de informações relativas a Identificação ou seja a ação e o efeito de identificar de forma única a pessoa jurídica através de seus dados cadastrais
type BusinessIdentificationData struct {
	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// BusinessID Um identificador único e imutável usado para identificar o recurso cliente pessoa jurídica. Este identificador não tem significado para o cliente que deu o consentimento
	BusinessID string `json:"businessId"`

	// CnpjNumber Número completo do CNPJ da Empresa consultada  - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CnpjNumber string `json:"cnpjNumber"`

	// CompaniesCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompaniesCnpj []string `json:"companiesCnpj"`

	// CompanyName Razão social da empresa consultada é o termo registrado sob o qual uma pessoa jurídica (PJ) se individualiza e exerce suas atividades. Também pode ser chamada por denominação social ou firma empresarial
	CompanyName string `json:"companyName"`

	// Contacts Conjunto de informações referentes às formas para contatar o cliente.
	Contacts BusinessContacts `json:"contacts"`

	// IncorporationDate Data de constituição da empresa, conforme especificação RFC-3339.
	IncorporationDate timeutil.DateTime `json:"incorporationDate"`

	// OtherDocuments Relação dos demais documentos
	OtherDocuments *[]BusinessOtherDocument `json:"otherDocuments,omitempty"`

	// Parties Lista relativa às informações das partes envolvidas, como: sócio e/ou administrador. Objeto de envio obrigatório para todos os CNPJs que possuam sócios e/ou administradores no cadastro do QSA (Quadro de Sócios e Administradores)
	Parties []PartiesParticipation `json:"parties"`

	// TradeName Nome fantasia da pessoa jurídica, se houver. (É o nome popular da empresa, utilizado para divulgação da empresa e melhor fixação com o público). De preenchimento obrigatório se houver
	TradeName *string `json:"tradeName,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// BusinessInformedPatrimony defines model for BusinessInformedPatrimony.
type BusinessInformedPatrimony struct {
	// Amount Valor do patrimônio informado
	Amount InformedPatrimonyAmount `json:"amount"`

	// Date Data de referência do Patrimônio, conforme especificação RFC-3339.
	Date timeutil.BrazilDate `json:"date"`
}

// BusinessOtherDocument defines model for BusinessOtherDocument.
type BusinessOtherDocument struct {
	// Country Pais de emissão do tipo de documento informado. Código do pais de acordo com o código alpha3 do ISO-3166
	Country string `json:"country"`

	// ExpirationDate Data vigência do tipo de  documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// Number Número do outro documento. De preenchimento obrigatório, para a Pessoa jurídica com domicílio ou sede no exterior, desobrigada de inscrição no CNPJ
	Number string `json:"number"`

	// Type Número do Tipo de documento informado. De preenchimento obrigatório, para a Pessoa jurídica com domicílio ou sede no exterior, desobrigada de inscrição no CNPJ
	Type string `json:"type"`
}

// BusinessPostalAddress defines model for BusinessPostalAddress.
type BusinessPostalAddress struct {
	// AdditionalInfo Alguns logradouros ainda necessitam ser especificados por meio de complemento
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Address Corresponde ao endereço comercial do cliente.
	Address *string `json:"address,omitempty"`

	// Country Nome do país
	Country string `json:"country"`

	// CountryCode Código do pais de acordo com o código alpha3 do ISO-3166
	CountryCode string `json:"countryCode"`

	// CountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
	CountrySubDivision *EnumCountrySubDivision `json:"countrySubDivision,omitempty"`

	// DistrictName Bairro é uma comunidade ou região localizada em uma cidade ou município de acordo com as suas subdivisões geográficas. Preenchimento obrigatório, se houver.
	DistrictName *string `json:"districtName,omitempty"`

	// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
	GeographicCoordinates *GeographicCoordinates `json:"geographicCoordinates,omitempty"`

	// IbgeTownCode Código IBGE de Município. A Tabela de Códigos de Municípios do IBGE apresenta a lista dos municípios brasileiros associados a um código composto de 7 dígitos, sendo os dois primeiros referentes ao código da Unidade da Federação.
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// IsMain Indica se o endereço informado é o principal
	IsMain bool `json:"isMain"`

	// PostCode Código de Endereçamento Postal: Composto por um conjunto numérico de oito dígitos, o objetivo principal do CEP é orientar e acelerar o encaminhamento, o tratamento e a entrega de objetos postados nos Correios, por meio da sua atribuição a localidades, logradouros, unidades dos Correios, serviços, órgãos públicos, empresas e edifícios. p.ex. '01311000'
	PostCode *string `json:"postCode,omitempty"`

	// TownName Localidade: O nome da localidade corresponde à designação da cidade ou município no qual o endereço está localizado.
	TownName string `json:"townName"`
}

// BusinessProcurator defines model for BusinessProcurator.
type BusinessProcurator struct {
	// CivilName Nome civil completo ou Razão Social
	CivilName string `json:"civilName"`

	// CnpjCpfNumber Identificação do Representante Legal ou Procurador. Número do cadastro nas Receita Federal  (Preencher com CPF ou CNPJ sem formatação)
	CnpjCpfNumber string `json:"cnpjCpfNumber"`

	// SocialName Nome social da pessoa natural, se houver. Aquele pelo qual travestis e transexuais se reconhecem,
	// bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local.
	SocialName *string `json:"socialName,omitempty"`

	// Type Tipo de representante.
	// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
	// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
	Type BusinessProcuratorType `json:"type"`
}

// BusinessProcuratorType Tipo de representante.
// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
type BusinessProcuratorType string

// BusinessQualificationData Objeto que reúne as informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
type BusinessQualificationData struct {
	// EconomicActivities Lista dos demais códigos relativos às demais atividades econômicas da empresa, segundo padrão CNAE (Classificação Nacional de Atividades Econômicas). De preenchimento obrigatório, se houver
	EconomicActivities *[]EconomicActivity        `json:"economicActivities,omitempty"`
	InformedPatrimony  *BusinessInformedPatrimony `json:"informedPatrimony,omitempty"`
	InformedRevenue    *InformedRevenue           `json:"informedRevenue,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// CustomerEmail defines model for CustomerEmail.
type CustomerEmail struct {
	// Email Endereço de email
	Email openapi_types.Email `json:"email"`

	// IsMain Indica se o email informado é o principal
	IsMain bool `json:"isMain"`
}

// CustomerPhone defines model for CustomerPhone.
type CustomerPhone struct {
	// AdditionalInfo Informação complementar relativa ao tipo de telefone selecionado. [Restrição] De preenchimento obrigatório quando selecionado o tipo 'OUTRO'.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AreaCode Número de DDD (Discagem Direta à Distância) do telefone do cliente - se houver
	AreaCode AreaCode `json:"areaCode"`

	// CountryCallingCode Número de DDI (Discagem Direta Internacional) para telefone de acesso ao Cliente - se houver
	//
	// [Restrição] O preenchimento é obrigatório quando for diferente de 55.
	CountryCallingCode *string `json:"countryCallingCode,omitempty"`

	// IsMain Indica se o telefone informado é o principal
	IsMain bool `json:"isMain"`

	// Number Número de telefone do cliente
	Number string `json:"number"`

	// PhoneExtension Número do ramal. De preenchimento obrigatório se fizer parte da identificação do número do telefone informado
	PhoneExtension *string `json:"phoneExtension,omitempty"`

	// Type Identificação do Tipo de telefone do cliente.
	Type EnumCustomerPhoneType `json:"type"`
}

// EconomicActivity defines model for EconomicActivity.
type EconomicActivity struct {
	// Code Traz o código do ramo da atividade principal da empresa consultada, segundo padrão CNAE (Classificação Nacional de Atividades Econômicas)
	//
	// [Observação] O campo sempre deve ser enviado com 7 caracteres, seguindo a classificação “CNAE-Subclasse 2.3”. Em casos em que o valor inicie com zeros, ele deve conter todos os caracteres, incluindo os zeros.
	Code string `json:"code"`

	// IsMain Indica se é o ramo principal de atividade da empresa quando true e se é o ramo secundário quando false. [Restrição] Somente uma ocorrência relativa ao código da atividade econômica principal deve trazer o valor true.
	IsMain bool `json:"isMain"`
}

// EnumAccountTypeCustomers Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
//
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
//
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
//
// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
type EnumAccountTypeCustomers string

// EnumCountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
type EnumCountrySubDivision string

// EnumCustomerPhoneType Identificação do Tipo de telefone do cliente.
type EnumCustomerPhoneType string

// EnumFiliationType Tipo de filiação.
type EnumFiliationType string

// EnumInformedIncomeFrequency Traz a frequência ou período da renda informada.
type EnumInformedIncomeFrequency string

// EnumInformedRevenueFrequency Traz a frequência ou período do faturamento informado.
// "O faturamento é calculado a partir de todos os benefícios que a empresa conseguiu com sua atividade econômica em um determinado período. Esses benefícios são os rendimentos ou ganhos da organização através de suas vendas ou serviços prestados".
type EnumInformedRevenueFrequency string

// EnumMaritalStatusCode Estado marital do cliente.
type EnumMaritalStatusCode string

// EnumOccupationMainCodeType Traz a relação dos códigos relativos à ocupação.
type EnumOccupationMainCodeType string

// EnumPartiesParticipationDocumentType Tipo do documento informado.
type EnumPartiesParticipationDocumentType string

// EnumPersonalOtherDocumentType Relação dos Códigos dos demais documentos pessoa natural.
type EnumPersonalOtherDocumentType string

// EnumProcuratorsTypePersonal Tipo de representante.
// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
type EnumProcuratorsTypePersonal string

// EnumProductServiceType Lista com a relação dos produtos e serviços com contrato vigente.
type EnumProductServiceType string

// EnumSex "Conjunto de características anatomofisiológicas que distinguem o homem e a mulher: Sexo masculino; sexo feminino".
// No caso de não ser feminino nem masculino é classificado como 'OUTRO'
type EnumSex string

// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
type GeographicCoordinates struct {
	// Latitude Informação da Latitude referente a geolocalização informada. Entre -90 e 90.p.ex. '-23.5475000'. (2 casas antes da vírgula, 11 posições)
	Latitude string `json:"latitude"`

	// Longitude Informação da Longitude referente a geolocalização informada. Entre -180 e 180. p.ex '-46.6361100'. (3 casas antes da vírgula, 11 posições)
	Longitude string `json:"longitude"`
}

// InformedIncome defines model for InformedIncome.
type InformedIncome struct {
	// Amount Valor total da renda informada
	Amount InformedIncomeAmount `json:"amount"`

	// Date Data da renda, conforme especificação RFC-3339.
	Date timeutil.BrazilDate `json:"date"`

	// Frequency Traz a frequência ou período da renda informada.
	Frequency EnumInformedIncomeFrequency `json:"frequency"`
}

// InformedIncomeAmount Valor total da renda informada
type InformedIncomeAmount struct {
	// Amount Valor total da renda informada. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Renda primária indica os montantes a pagar ou a receber em troca do uso temporário de recursos financeiros, trabalho ou ativos não financeiros não produzidos, a saber, remuneração de trabalhadores, renda de investimentos e demais rendas primárias.
	// Fazem parte da primeira a remuneração do trabalho assalariado (salários e ordenados); da segunda, renda de investimento direto, renda de investimento em carteira, renda de outros investimentos e renda de ativos de reserva; e da terceira, tributos sobre a produção e importação, subsídios e aluguéis.
	// Fonte: Banco Central do Brasil – Departamento Econômico
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// InformedPatrimonyAmount Valor do patrimônio informado
type InformedPatrimonyAmount struct {
	// Amount Valor do patrimônio informado. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Patrimônio é o conjunto de bens vinculado a uma pessoa ou a uma entidade.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// InformedRevenue defines model for InformedRevenue.
type InformedRevenue struct {
	// Amount Valor do patrimônio informado
	Amount InformedRevenueAmount `json:"amount"`

	// Frequency Traz a frequência ou período do faturamento informado.
	// "O faturamento é calculado a partir de todos os benefícios que a empresa conseguiu com sua atividade econômica em um determinado período. Esses benefícios são os rendimentos ou ganhos da organização através de suas vendas ou serviços prestados".
	Frequency *EnumInformedRevenueFrequency `json:"frequency,omitempty"`

	// FrequencyAdditionalInfo Texto livre para complementar informação relativa ao patrimonio.
	//
	// [Restrição] Preencher quando frequency for igual OUTROS.
	FrequencyAdditionalInfo *string `json:"frequencyAdditionalInfo,omitempty"`

	// Year Ano de referência da Renda, conforme especificação RFC-3339.
	Year *float32 `json:"year,omitempty"`
}

// InformedRevenueAmount Valor do patrimônio informado
type InformedRevenueAmount struct {
	// Amount Valor do patrimônio informado. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Patrimônio é o conjunto de bens vinculado a uma pessoa ou a uma entidade.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// Nationality Objeto que agrupa informações relativas à nacionalidade da Pessoa Natural
type Nationality struct {
	// Documents Lista que traz relação de documentos complementares de pessoas com nacionalidade diferente de brasileira
	Documents []NationalityOtherDocument `json:"documents"`

	// OtherNationalitiesInfo Campo de preenchimento obrigatório caso o cliente não possua nacionalidade brasileira. Preencher indicando todas suas demais nacionalidades utilizando o código de pais de acordo com o código alpha3 do ISO-3166.p.ex.'CAN'
	OtherNationalitiesInfo string `json:"otherNationalitiesInfo"`
}

// NationalityOtherDocument defines model for NationalityOtherDocument.
type NationalityOtherDocument struct {
	// AdditionalInfo Campo livre de preenchimento quando necessário.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Country Nome do país.
	Country *string `json:"country,omitempty"`

	// ExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// IssueDate Data de emissão do documento, conforme especificação RFC-3339.
	IssueDate *timeutil.BrazilDate `json:"issueDate,omitempty"`

	// Number Número de identificação do documento. Campo livre, de preenchimento obrigatório quando a nacionalidade for diferente de brasileira. Informar o número do documento e demais informações complementares para se identificar o documento de pessoa estrangeira
	Number string `json:"number"`

	// Type Tipo de documento. Campo livre, de preenchimento obrigatório quando a nacionalidade for diferente de brasileira. Informar tipo e número do documento, além da, vigência e demais informações complementares para se identificar o documento de pessoa estrangeira
	Type string `json:"type"`
}

// PartiesParticipation Lista relativa às informações das partes envolvidas, como: sócio e /ou administrador
type PartiesParticipation struct {
	// CivilName Nome civil completo da pessoa natural (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	//
	// [Restrição] O campo civilName deve ser obrigatoriamente preenchido quando personType for PESSOA_NATURAL.
	CivilName *string `json:"civilName,omitempty"`

	// CompanyName Razão social da empresa consultada é o termo registrado sob o qual uma pessoa jurídica (PJ) se individualiza e exerce suas atividades. Também pode ser chamada por denominação social ou firma empresarial
	//
	// [Restrição] o campo companyName deve ser obrigatoriamente preenchido quando personType for PESSOA_JURIDICA.
	CompanyName *string `json:"companyName,omitempty"`

	// DocumentAdditionalInfo Campo livre, de preenchimento obrigatório quando o documento informado tiver informações complementares relevantes para a sua identificação
	DocumentAdditionalInfo *string `json:"documentAdditionalInfo,omitempty"`

	// DocumentCountry País de emissão do documento. Código do pais de acordo com o código alpha3 do ISO-3166.
	DocumentCountry *string `json:"documentCountry,omitempty"`

	// DocumentExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	DocumentExpirationDate *timeutil.BrazilDate `json:"documentExpirationDate,omitempty"`

	// DocumentIssueDate Data de emissão do documento, conforme especificação RFC-3339.
	DocumentIssueDate *timeutil.BrazilDate `json:"documentIssueDate,omitempty"`

	// DocumentNumber Número do documento informado. Campo Texto Livre para preencher número e dígito do documento se houver
	DocumentNumber string `json:"documentNumber"`

	// DocumentType Tipo do documento informado.
	DocumentType EnumPartiesParticipationDocumentType `json:"documentType"`

	// PersonType Indica se a pessoa da parte envolvida é uma pessoa natural ou juridica
	PersonType PartiesParticipationPersonType `json:"personType"`

	// Shareholding Percentual de participação societária (informar com 6 casas decimais). O Sócio só deve ser informado se sua participação societária for igual ou superior a 25%. p.ex: 0.250000 (Este valor  representa 25%. O valor '1 'representa 100%).
	//
	// [Restrição]: Campo obrigatório caso o type for igual a SOCIO e este tiver participação societária maior que 25%.
	Shareholding *string `json:"shareholding,omitempty"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local).
	SocialName *string `json:"socialName,omitempty"`

	// StartDate Data de início da participação, conforme especificação RFC-3339.
	StartDate *timeutil.DateTime `json:"startDate,omitempty"`

	// TradeName Nome fantasia da pessoa jurídica, se houver. (É o nome popular da empresa, utilizado para divulgação da empresa e melhor fixação com o público). De preenchimento obrigatório se houver
	TradeName *string `json:"tradeName,omitempty"`

	// Type Indica o perfil de atuação na empresa. Vide Enum
	// O administrador é o responsável por desempenhar todas as funções administrativas da empresa. É ele quem conduz o dia a dia do negócio, assinando documentos, respondendo legalmente pela sociedade, realizando empréstimos e outras ações gerenciais. Apesar de estar na linha de frente da empresa, ele é denominado sócio por também possuir sua parcela de participação no Capital Social.
	// Sócio não tem qualquer envolvimento nas atividades administrativas da sociedade.
	Type PartiesParticipationType `json:"type"`
}

// PartiesParticipationPersonType Indica se a pessoa da parte envolvida é uma pessoa natural ou juridica
type PartiesParticipationPersonType string

// PartiesParticipationType Indica o perfil de atuação na empresa. Vide Enum
// O administrador é o responsável por desempenhar todas as funções administrativas da empresa. É ele quem conduz o dia a dia do negócio, assinando documentos, respondendo legalmente pela sociedade, realizando empréstimos e outras ações gerenciais. Apesar de estar na linha de frente da empresa, ele é denominado sócio por também possuir sua parcela de participação no Capital Social.
// Sócio não tem qualquer envolvimento nas atividades administrativas da sociedade.
type PartiesParticipationType string

// PaychecksBankLink defines model for PaychecksBankLink.
type PaychecksBankLink struct {
	// AccountOpeningDate Data de abertura da conta salário.
	AccountOpeningDate timeutil.BrazilDate `json:"accountOpeningDate"`

	// EmployerCnpjCpf Documento do empregador (CNPJ/CPF), conforme registrado na abertura da conta salário.
	EmployerCnpjCpf string `json:"employerCnpjCpf"`

	// EmployerName Nome do empregador conforme registrado na abertura da conta salário. O empregador pode ser pessoa natural ou pessoa jurídica, quando se tratar de pessoa jurídica, deve haver o envio da razão social.
	EmployerName string `json:"employerName"`

	// PaycheckBankCnpj CNPJ da instituição financeira contratada para prestar serviço de pagamento de salário (banco-folha).
	PaycheckBankCnpj string `json:"paycheckBankCnpj"`

	// PaycheckBankIspb Número ISPB (Identificador do Sistema de Pagamentos Brasileiros) do instituição financeira contratada para prestar serviço de pagamento de salário (banco-folha).
	PaycheckBankIspb string `json:"paycheckBankIspb"`
}

// PersonalAccount Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
type PersonalAccount struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares.
	Subtype PersonalAccountSubtype `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
	//
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
	//
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
	//
	// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
	Type EnumAccountTypeCustomers `json:"type"`
}

// PersonalAccountSubtype Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares.
type PersonalAccountSubtype string

// PersonalContacts Conjunto de informações referentes às formas para contatar o cliente.
type PersonalContacts struct {
	// Emails Lista e-mails de contato
	Emails []CustomerEmail `json:"emails"`

	// Phones Lista com telefones de contato da pessoa natural
	Phones []CustomerPhone `json:"phones"`

	// PostalAddresses Lista de endereços da pessoa natural
	PostalAddresses []PersonalPostalAddress `json:"postalAddresses"`
}

// PersonalDocument Objeto agrupador de informações relativas a Documentos da pessoa natural
type PersonalDocument struct {
	// CpfNumber Número completo do CPF.
	// Atributo que corresponde às informações mínimas exigidas pela Regulamentação em vigor.
	// O CPF é o Cadastro de Pessoa natural. Ele é um documento feito pela Receita Federal e serve para identificar os contribuintes. O CPF é uma numeração com 11 dígitos, que só mudam por decisão judicial. O documento é emitido pela receita federal.
	//
	// [Restrição] Preenchimento obrigatório quando não for informado o passport.
	CpfNumber *string `json:"cpfNumber,omitempty"`

	// Passport Documento concedido aos viajantes por uma autoridade administrativa nacional a fim de certificar sua identidade perante autoridades estrangeiras.
	//
	// [Restrição] Aplicável somente à Pessoa natural residente no exterior desobrigada de inscrição no CPF.
	//
	// [Restrição] Preenchimento obrigatório quando não for informado o cpfNumber.
	Passport *PersonalPassport `json:"passport,omitempty"`
}

// PersonalFinancialRelationData Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
type PersonalFinancialRelationData struct {
	// Accounts Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora.
	Accounts []PersonalAccount `json:"accounts"`

	// PaychecksBankLink Lista de informações de contas salário relacionadas com vínculos empregatícios, existentes ou que já existiram, firmados entre o cliente pessoa natural e um ou mais empregadores. Cada vínculo é associado a uma conta salário aberta mantida no banco-folha (instituição transmissora).
	//
	// Obs: como empregadores antigos podem não ter solicitado o fechamento da conta salário, não é possível garantir que os dados informados sejam do empregador atual.
	PaychecksBankLink *[]PaychecksBankLink `json:"paychecksBankLink,omitempty"`

	// PortabilitiesReceived Lista de informações de empregador recebidos através de portabilidade de salário solicitada pelo cliente da transmissora à instituição detentora(s) de sua conta salário, ativos ou que já estiveram ativos,. Cada vínculo é associado a uma portabilidade de salário recebida pela transmissora.
	//
	// Obs.: a portabilidade não é explicitamente encerrada, ou seja, a IF para a qual o salário foi portado não é avisado quando a conta salário se encerra ou o salário é portado para outra IF. Não é possível garantir que os dados informados sejam de uma portabilidade ativa, nem que o vínculo com o banco folha ainda exista. A transmissora terá tais informações apenas quando o pedido da portabilidade tiver sido solicitado em seus canais.
	PortabilitiesReceived *[]PortabilitiesReceived `json:"portabilitiesReceived,omitempty"`

	// Procurators Lista dos representantes.
	// [Restrição] De preenchimento obrigatório se houver representante.
	Procurators          []PersonalProcurator     `json:"procurators"`
	ProductsServicesType []EnumProductServiceType `json:"productsServicesType"`

	// ProductsServicesTypeAdditionalInfo Informações adicionais do tipo de serviço.
	// [Restrição] Campo obrigatório quando productsServicesType for 'OUTROS'.
	ProductsServicesTypeAdditionalInfo *string `json:"productsServicesTypeAdditionalInfo,omitempty"`

	// StartDate Data de início de relacionamento com a Instituição Financeira. Deve trazer o menor valor entre a informação reportada ao BACEN pelo DOC 3040 e CCS.
	StartDate timeutil.DateTime `json:"startDate"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PersonalIdentificationData Conjunto de informações relativas a Identificação ou seja a ação e o efeito de identificar de forma única a pessoa natural através de seus dados cadastrais.
type PersonalIdentificationData struct {
	// BirthDate Data de nascimento, conforme especificação RFC-3339
	BirthDate timeutil.BrazilDate `json:"birthDate"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CivilName Nome civil completo da pessoa natural (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	CivilName string `json:"civilName"`

	// CompaniesCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompaniesCnpj []string `json:"companiesCnpj"`

	// Contacts Conjunto de informações referentes às formas para contatar o cliente.
	Contacts PersonalContacts `json:"contacts"`

	// Documents Objeto agrupador de informações relativas a Documentos da pessoa natural
	Documents PersonalDocument `json:"documents"`
	Filiation *[]struct {
		// CivilName Nome civil completo da pessoa relativa à filiação.
		// (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento,
		// com o qual será identificada por toda a sua vida, bem como após a sua morte).
		CivilName string `json:"civilName"`

		// SocialName Nome social da pessoa natural, se houver.
		// (aquele pelo qual travestis e transexuais se reconhecem,
		// bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local).
		SocialName *string `json:"socialName,omitempty"`

		// Type Tipo de filiação.
		Type EnumFiliationType `json:"type"`
	} `json:"filiation,omitempty"`

	// HasBrazilianNationality Informa se o Cliente tem nacionalidade brasileira.
	HasBrazilianNationality bool `json:"hasBrazilianNationality"`

	// MaritalStatusAdditionalInfo Campo livre para complementar a informação relativa ao estado marital.
	//
	// [Restrição] Preenchimento obrigatório quando selecionado o tipo 'OUTRO'.
	MaritalStatusAdditionalInfo *string `json:"maritalStatusAdditionalInfo,omitempty"`

	// MaritalStatusCode Estado marital do cliente.
	MaritalStatusCode *EnumMaritalStatusCode `json:"maritalStatusCode,omitempty"`
	Nationality       *[]Nationality         `json:"nationality,omitempty"`

	// OtherDocuments Relação dos demais documentos
	OtherDocuments *[]PersonalOtherDocument `json:"otherDocuments,omitempty"`

	// PersonalID Um identificador único e imutável usado para identificar o recurso cliente pessoa natural. Este identificador não tem significado para o cliente que deu o consentimento
	PersonalID string `json:"personalId"`

	// Sex "Conjunto de características anatomofisiológicas que distinguem o homem e a mulher: Sexo masculino; sexo feminino".
	// No caso de não ser feminino nem masculino é classificado como 'OUTRO'
	Sex *EnumSex `json:"sex,omitempty"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local)
	SocialName *string `json:"socialName,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PersonalInformedPatrimony defines model for PersonalInformedPatrimony.
type PersonalInformedPatrimony struct {
	// Amount Valor do patrimônio informado
	Amount InformedPatrimonyAmount `json:"amount"`

	// Year Ano de referência da Renda, conforme especificação RFC-3339.
	Year float32 `json:"year"`
}

// PersonalOtherDocument defines model for PersonalOtherDocument.
type PersonalOtherDocument struct {
	// AdditionalInfo Para documentos em que se aplique o uso do local de emissão o mesmo deve ser enviado mandatoriamente, com a informação de órgão e UF. Exemplo: RG, local de emissão: SSP/RS.
	// [Restrição] Obrigatório quando o Local de Emissão do Documento for relevante.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// CheckDigit Dígito verificador do documento informado. De preenchimento obrigatório se o documento informado tiver dígito verificador
	CheckDigit *string `json:"checkDigit,omitempty"`

	// ExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// Number Identificação/Número do documento informado
	Number string `json:"number"`

	// Type Relação dos Códigos dos demais documentos pessoa natural.
	Type EnumPersonalOtherDocumentType `json:"type"`

	// TypeAdditionalInfo Campo livre de preenchimento obrigatório se selecionada a opção OUTROS tipos de documentos
	TypeAdditionalInfo *string `json:"typeAdditionalInfo,omitempty"`
}

// PersonalPassport Documento concedido aos viajantes por uma autoridade administrativa nacional a fim de certificar sua identidade perante autoridades estrangeiras.
//
// [Restrição] Aplicável somente à Pessoa natural residente no exterior desobrigada de inscrição no CPF.
//
// [Restrição] Preenchimento obrigatório quando não for informado o cpfNumber.
type PersonalPassport struct {
	// Country Pais de emissão do passaporte. Código do pais de acordo com o código 'alpha3' do ISO-3166.
	Country string `json:"country"`

	// ExpirationDate Data vigência do Passaporte, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// IssueDate Data de emissão do passaporte, conforme especificação RFC-3339.
	IssueDate *timeutil.BrazilDate `json:"issueDate,omitempty"`

	// Number Número do Passaporte.
	Number string `json:"number"`
}

// PersonalPostalAddress defines model for PersonalPostalAddress.
type PersonalPostalAddress struct {
	// AdditionalInfo Alguns logradouros ainda necessitam ser especificados por meio de complemento.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Address Corresponde ao endereço residencial do cliente.
	Address string `json:"address"`

	// Country Nome do país
	Country string `json:"country"`

	// CountryCode Código do país de acordo com o código alpha3 do ISO-3166.
	CountryCode *string `json:"countryCode,omitempty"`

	// CountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
	CountrySubDivision *EnumCountrySubDivision `json:"countrySubDivision,omitempty"`

	// DistrictName Bairro é uma comunidade ou região localizada em uma cidade ou município de acordo com as suas subdivisões geográficas.
	// [Restrição] De preenchimento obrigatório, se houver.
	DistrictName *string `json:"districtName,omitempty"`

	// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
	GeographicCoordinates *GeographicCoordinates `json:"geographicCoordinates,omitempty"`

	// IbgeTownCode Código IBGE de Município. A Tabela de Códigos de Municípios do IBGE apresenta a lista dos municípios brasileiros associados a um código composto de 7 dígitos, sendo os dois primeiros referentes ao código da Unidade da Federação.
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// IsMain Indica se o endereço informado é o principal.
	IsMain bool `json:"isMain"`

	// PostCode Código de Endereçamento Postal: Composto por um conjunto numérico de oito dígitos, o objetivo principal do CEP é orientar e acelerar o encaminhamento, o tratamento e a entrega de objetos postados nos Correios, por meio da sua atribuição a localidades, logradouros, unidades dos Correios, serviços, órgãos públicos, empresas e edifícios. p.ex. '01311000'.
	PostCode string `json:"postCode"`

	// TownName Localidade: O nome da localidade corresponde à designação da cidade ou município no qual o endereço está localizado.
	TownName string `json:"townName"`
}

// PersonalProcurator defines model for PersonalProcurator.
type PersonalProcurator struct {
	// CivilName Nome civil completo da pessoa natural. (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	CivilName string `json:"civilName"`

	// CpfNumber Número completo do CPF. O CPF é o Cadastro de Pessoa natural. Ele é um documento feito pela Receita Federal e serve para identificar os contribuintes. O CPF é uma numeração com 11 dígitos, que só mudam por decisão judicial. O documento é emitido pela receita federal
	CpfNumber string `json:"cpfNumber"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Nº 51.180, de 14 de janeiro de 2010)
	SocialName *string `json:"socialName,omitempty"`

	// Type Tipo de representante.
	// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
	// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
	Type EnumProcuratorsTypePersonal `json:"type"`
}

// PersonalQualificationData Conjunto de informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
type PersonalQualificationData struct {
	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj       string                     `json:"companyCnpj"`
	InformedIncome    *InformedIncome            `json:"informedIncome,omitempty"`
	InformedPatrimony *PersonalInformedPatrimony `json:"informedPatrimony,omitempty"`

	// OccupationCode Traz a relação dos códigos relativos à ocupação.
	OccupationCode *EnumOccupationMainCodeType `json:"occupationCode,omitempty"`

	// OccupationDescription Campo livre, de preenchimento obrigatório. Se selecionada a opção *occupationCode* "RECEITA_FEDERAL" ou "CBO", informar o código desta lista padronizada.
	// Se selecionada *occupationCode* "OUTRO", informar o descritivo da ocupação quando a IF não segue a lista padronizada da Receita Federal e nem da CBO.
	OccupationDescription *string `json:"occupationDescription,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PortabilitiesReceived defines model for PortabilitiesReceived.
type PortabilitiesReceived struct {
	// EmployerCnpjCpf Número de inscrição (CPF/CNPJ) do empregador (contratante dos serviços de pagamento), conforme recebido pela comunicação de portabilidade.
	EmployerCnpjCpf string `json:"employerCnpjCpf"`

	// EmployerName Nome do empregador conforme recebido pela comunicação de portabilidade. O empregador pode ser pessoa natural ou pessoa jurídica, quando se tratar de pessoa jurídica, deve haver o envio da razão social.
	EmployerName string `json:"employerName"`

	// PaycheckBankDetainerCnpj Número de inscrição no Cadastro Nacional da Pessoa Jurídica (CNPJ) do banco folha (instituição financeira detentora da conta salário) conforme recebido pela comunicação de portabilidade.
	PaycheckBankDetainerCnpj string `json:"paycheckBankDetainerCnpj"`

	// PaycheckBankDetainerIspb Número do ISPB do Banco Folha (instituição financeira detentora da conta salário) conforme recebido pela comunicação de portabilidade.
	PaycheckBankDetainerIspb string `json:"paycheckBankDetainerIspb"`

	// PortabilityApprovalDate Data de aprovação da portabilidade, conforme recebido pela comunicação de portabilidade.
	//
	// Obs.: somente devem ser compartilhadas solicitações aprovadas, mesmo que de forma compulsória.
	PortabilityApprovalDate timeutil.BrazilDate `json:"portabilityApprovalDate"`
}

// ResponseBusinessCustomersFinancialRelation defines model for ResponseBusinessCustomersFinancialRelation.
type ResponseBusinessCustomersFinancialRelation struct {
	// Data Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
	Data  BusinessFinancialRelationData `json:"data"`
	Links api.Links                     `json:"links"`
	Meta  api.Meta                      `json:"meta"`
}

// ResponseBusinessCustomersIdentification defines model for ResponseBusinessCustomersIdentification.
type ResponseBusinessCustomersIdentification struct {
	Data  []BusinessIdentificationData `json:"data"`
	Links api.Links                    `json:"links"`
	Meta  api.Meta                     `json:"meta"`
}

// ResponseBusinessCustomersQualification defines model for ResponseBusinessCustomersQualification.
type ResponseBusinessCustomersQualification struct {
	// Data Objeto que reúne as informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
	Data  BusinessQualificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePersonalCustomersFinancialRelation defines model for ResponsePersonalCustomersFinancialRelation.
type ResponsePersonalCustomersFinancialRelation struct {
	// Data Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
	Data  PersonalFinancialRelationData `json:"data"`
	Links api.Links                     `json:"links"`
	Meta  api.Meta                      `json:"meta"`
}

// ResponsePersonalCustomersIdentification defines model for ResponsePersonalCustomersIdentification.
type ResponsePersonalCustomersIdentification struct {
	Data  []PersonalIdentificationData `json:"data"`
	Links api.Links                    `json:"links"`
	Meta  api.Meta                     `json:"meta"`
}

// ResponsePersonalCustomersQualification defines model for ResponsePersonalCustomersQualification.
type ResponsePersonalCustomersQualification struct {
	// Data Conjunto de informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
	Data  PersonalQualificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Default defines model for Default.
type Default = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// Locked defines model for Locked.
type Locked = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// OKResponseBusinessCustomersFinancialRelation defines model for OKResponseBusinessCustomersFinancialRelation.
type OKResponseBusinessCustomersFinancialRelation = ResponseBusinessCustomersFinancialRelation

// OKResponseBusinessCustomersIdentification defines model for OKResponseBusinessCustomersIdentification.
type OKResponseBusinessCustomersIdentification = ResponseBusinessCustomersIdentification

// OKResponseBusinessCustomersQualification defines model for OKResponseBusinessCustomersQualification.
type OKResponseBusinessCustomersQualification = ResponseBusinessCustomersQualification

// OKResponsePersonalCustomersFinancialRelation defines model for OKResponsePersonalCustomersFinancialRelation.
type OKResponsePersonalCustomersFinancialRelation = ResponsePersonalCustomersFinancialRelation

// OKResponsePersonalCustomersIdentification defines model for OKResponsePersonalCustomersIdentification.
type OKResponsePersonalCustomersIdentification = ResponsePersonalCustomersIdentification

// OKResponsePersonalCustomersQualification defines model for OKResponsePersonalCustomersQualification.
type OKResponsePersonalCustomersQualification = ResponsePersonalCustomersQualification

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseError

// CustomersGetBusinessFinancialRelationsParams defines parameters for CustomersGetBusinessFinancialRelations.
type CustomersGetBusinessFinancialRelationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetBusinessIdentificationsParams defines parameters for CustomersGetBusinessIdentifications.
type CustomersGetBusinessIdentificationsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetBusinessQualificationsParams defines parameters for CustomersGetBusinessQualifications.
type CustomersGetBusinessQualificationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalFinancialRelationsParams defines parameters for CustomersGetPersonalFinancialRelations.
type CustomersGetPersonalFinancialRelationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalIdentificationsParams defines parameters for CustomersGetPersonalIdentifications.
type CustomersGetPersonalIdentificationsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalQualificationsParams defines parameters for CustomersGetPersonalQualifications.
type CustomersGetPersonalQualificationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa jurídica.
	// (GET /business/financial-relations)
	CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessFinancialRelationsParams)
	// Obtém os registros de identificação da pessoa jurídica.
	// (GET /business/identifications)
	CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessIdentificationsParams)
	// Obtém os registros de qualificação da pessoa jurídica.
	// (GET /business/qualifications)
	CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessQualificationsParams)
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa natural.
	// (GET /personal/financial-relations)
	CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalFinancialRelationsParams)
	// Obtém os registros de identificação da pessoa natural.
	// (GET /personal/identifications)
	CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalIdentificationsParams)
	// Obtém os registros de qualificação da pessoa natural.
	// (GET /personal/qualifications)
	CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalQualificationsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CustomersGetBusinessFinancialRelations operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessFinancialRelationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessFinancialRelations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetBusinessIdentifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessIdentificationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessIdentifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetBusinessQualifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessQualificationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessQualifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalFinancialRelations operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalFinancialRelationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalFinancialRelations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalIdentifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalIdentificationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalIdentifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalQualifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalQualificationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalQualifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/business/financial-relations", wrapper.CustomersGetBusinessFinancialRelations)
	m.HandleFunc("GET "+options.BaseURL+"/business/identifications", wrapper.CustomersGetBusinessIdentifications)
	m.HandleFunc("GET "+options.BaseURL+"/business/qualifications", wrapper.CustomersGetBusinessQualifications)
	m.HandleFunc("GET "+options.BaseURL+"/personal/financial-relations", wrapper.CustomersGetPersonalFinancialRelations)
	m.HandleFunc("GET "+options.BaseURL+"/personal/identifications", wrapper.CustomersGetPersonalIdentifications)
	m.HandleFunc("GET "+options.BaseURL+"/personal/qualifications", wrapper.CustomersGetPersonalQualifications)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type OKResponseBusinessCustomersFinancialRelationJSONResponse ResponseBusinessCustomersFinancialRelation

type OKResponseBusinessCustomersIdentificationJSONResponse ResponseBusinessCustomersIdentification

type OKResponseBusinessCustomersQualificationJSONResponse ResponseBusinessCustomersQualification

type OKResponsePersonalCustomersFinancialRelationJSONResponse ResponsePersonalCustomersFinancialRelation

type OKResponsePersonalCustomersIdentificationJSONResponse ResponsePersonalCustomersIdentification

type OKResponsePersonalCustomersQualificationJSONResponse ResponsePersonalCustomersQualification

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseError

type CustomersGetBusinessFinancialRelationsRequestObject struct {
	Params CustomersGetBusinessFinancialRelationsParams
}

type CustomersGetBusinessFinancialRelationsResponseObject interface {
	VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessFinancialRelations200JSONResponse struct {
	OKResponseBusinessCustomersFinancialRelationJSONResponse
}

func (response CustomersGetBusinessFinancialRelations200JSONResponse) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessFinancialRelationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetBusinessIdentificationsRequestObject struct {
	Params CustomersGetBusinessIdentificationsParams
}

type CustomersGetBusinessIdentificationsResponseObject interface {
	VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessIdentifications200JSONResponse struct {
	OKResponseBusinessCustomersIdentificationJSONResponse
}

func (response CustomersGetBusinessIdentifications200JSONResponse) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications422ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessIdentificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetBusinessQualificationsRequestObject struct {
	Params CustomersGetBusinessQualificationsParams
}

type CustomersGetBusinessQualificationsResponseObject interface {
	VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessQualifications200JSONResponse struct {
	OKResponseBusinessCustomersQualificationJSONResponse
}

func (response CustomersGetBusinessQualifications200JSONResponse) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessQualificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalFinancialRelationsRequestObject struct {
	Params CustomersGetPersonalFinancialRelationsParams
}

type CustomersGetPersonalFinancialRelationsResponseObject interface {
	VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalFinancialRelations200JSONResponse struct {
	OKResponsePersonalCustomersFinancialRelationJSONResponse
}

func (response CustomersGetPersonalFinancialRelations200JSONResponse) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalFinancialRelationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalIdentificationsRequestObject struct {
	Params CustomersGetPersonalIdentificationsParams
}

type CustomersGetPersonalIdentificationsResponseObject interface {
	VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalIdentifications200JSONResponse struct {
	OKResponsePersonalCustomersIdentificationJSONResponse
}

func (response CustomersGetPersonalIdentifications200JSONResponse) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications422ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalIdentificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalQualificationsRequestObject struct {
	Params CustomersGetPersonalQualificationsParams
}

type CustomersGetPersonalQualificationsResponseObject interface {
	VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalQualifications200JSONResponse struct {
	OKResponsePersonalCustomersQualificationJSONResponse
}

func (response CustomersGetPersonalQualifications200JSONResponse) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalQualificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa jurídica.
	// (GET /business/financial-relations)
	CustomersGetBusinessFinancialRelations(ctx context.Context, request CustomersGetBusinessFinancialRelationsRequestObject) (CustomersGetBusinessFinancialRelationsResponseObject, error)
	// Obtém os registros de identificação da pessoa jurídica.
	// (GET /business/identifications)
	CustomersGetBusinessIdentifications(ctx context.Context, request CustomersGetBusinessIdentificationsRequestObject) (CustomersGetBusinessIdentificationsResponseObject, error)
	// Obtém os registros de qualificação da pessoa jurídica.
	// (GET /business/qualifications)
	CustomersGetBusinessQualifications(ctx context.Context, request CustomersGetBusinessQualificationsRequestObject) (CustomersGetBusinessQualificationsResponseObject, error)
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa natural.
	// (GET /personal/financial-relations)
	CustomersGetPersonalFinancialRelations(ctx context.Context, request CustomersGetPersonalFinancialRelationsRequestObject) (CustomersGetPersonalFinancialRelationsResponseObject, error)
	// Obtém os registros de identificação da pessoa natural.
	// (GET /personal/identifications)
	CustomersGetPersonalIdentifications(ctx context.Context, request CustomersGetPersonalIdentificationsRequestObject) (CustomersGetPersonalIdentificationsResponseObject, error)
	// Obtém os registros de qualificação da pessoa natural.
	// (GET /personal/qualifications)
	CustomersGetPersonalQualifications(ctx context.Context, request CustomersGetPersonalQualificationsRequestObject) (CustomersGetPersonalQualificationsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// CustomersGetBusinessFinancialRelations operation middleware
func (sh *strictHandler) CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessFinancialRelationsParams) {
	var request CustomersGetBusinessFinancialRelationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessFinancialRelations(ctx, request.(CustomersGetBusinessFinancialRelationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessFinancialRelations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessFinancialRelationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessFinancialRelationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetBusinessIdentifications operation middleware
func (sh *strictHandler) CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessIdentificationsParams) {
	var request CustomersGetBusinessIdentificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessIdentifications(ctx, request.(CustomersGetBusinessIdentificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessIdentifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessIdentificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessIdentificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetBusinessQualifications operation middleware
func (sh *strictHandler) CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessQualificationsParams) {
	var request CustomersGetBusinessQualificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessQualifications(ctx, request.(CustomersGetBusinessQualificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessQualifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessQualificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessQualificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalFinancialRelations operation middleware
func (sh *strictHandler) CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalFinancialRelationsParams) {
	var request CustomersGetPersonalFinancialRelationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalFinancialRelations(ctx, request.(CustomersGetPersonalFinancialRelationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalFinancialRelations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalFinancialRelationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalFinancialRelationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalIdentifications operation middleware
func (sh *strictHandler) CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalIdentificationsParams) {
	var request CustomersGetPersonalIdentificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalIdentifications(ctx, request.(CustomersGetPersonalIdentificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalIdentifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalIdentificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalIdentificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalQualifications operation middleware
func (sh *strictHandler) CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalQualificationsParams) {
	var request CustomersGetPersonalQualificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalQualifications(ctx, request.(CustomersGetPersonalQualificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalQualifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalQualificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalQualificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9y3MbOZY3+q/gcuYLSx0kRVKS9Zi4MR9NUR7WWKJKpGrutOWxwUyIgp0JZAGZ8qOs",
	"iNrO+tvORJTvLDrcEV7V9KaXw/+k/pIvcABkIh98SLLL3V2qhUskM/E8OOfgPH7nh5rHw4gzwmJZ2/+h",
	"FmGBQxITAZ+6SXzJBX2HY8qZ+sIn0hM00h9rPTwhsz/g4JKjfxqPT1CEfTH7L95EJ0SENCbo+4QgLJEn",
	"iE+YRzGVSJKXOEQXXDDiUR9L5JOIMJ8wnyOfo5hGHPkECeIlQnIkeUA9GmOf1+o1qjq9JNgnolavMRyS",
	"2n5hjPWaIN8nVBC/th+LhNRr0rskIVaDD/GbJ4RN48vafqe1tVuvRTiOiVCNPj0/f31+/i/n5/LZ72r1",
	"Wvw2Uk3LWFA2rV1fq0enpLwAx7M/h0Rw5GMUzT5MKcMwZSLj2QckYU4wHKlmgNEaR1c44AKeFzQkVGQv",
	"zj6i9nrTzvL7hIi32SShe3cuPrnASRDX9tv12gUXIY5r+zXK4s1Ora4mSsMkrO132ls7W7ubD7d26rWQ",
	"Mv1lO50fZTGZEpFOcETfVUzy2wSzmPrYJyjmMQ709kypjAWXKOLCTkEuGn1DqsYrp9DZXjSHdqvVWmX0",
	"lAEFNF6Rt+U5DHzCYnpBPeyr5Qf6usQh9nEdJTEN6Dvsc6SIH5ErGmOBMPI4i/GUhOpx87BEmCPC/IhT",
	"FiM/EZjFBGGku5/9QRH//DVwR/i56PJNL5ExD4k4k0R0p4TFFZNnPvUw4iiRRDSwegjIVH2RzD4Iyu0a",
	"NOcdsjcNz/TTyBqZN4m22bD0881mdIgjqg71AY4rqPEAxxiRsDiBgE95giISYDT7cxDTEKMr8g55PETq",
	"DHokirloolMSCSIJg+PoE4Q9LnwOj2H09PSwt9PZbD9bu4zjSO5vbMScB7JJSXzR5GK6cRmHwYa48NRD",
	"683+GxJGAd9Ho4TVUbuFRiRCnVZ7B7X39rc29zfb6Gzcm7+iFziiDZzElw1fzXQeRezl1lJ9zBbz39aO",
	"OHs/Tsj7fyH++/Fl8v5Q0PcjHL8fJWy9js7P/R8612jtG8zeH5LJ+yMs3ncj8f4Iv33/TcLef5ME77vJ",
	"9P2IRO+HXvz+mF+9PyDeOry4dW3e38/9D609Phq/Pxv31v9+/v5ZqhxEXd8XRMryRg7VQSKCzP7A0eBE",
	"8f50MyWwUHpFBMJxgoOQqGMW8Ck2e+Vs6ZL1TcmWRg1shvLlyHbAYiKwp2Y48MtTPgvR2dngAAhtq93p",
	"LCU09dA6SqSZN0dJiAYHwJC4ECTQLAcRFgsCkobIGKm/ZMSZJE3Uw6GWp1Mi7MOIsCvKEZ8IOsXx7Ge1",
	"4nBw7JpitOYFlLB4HakzJklixRa5IkgSgX758T+IjEhwiX3+y4//qV+PBWYypFJCC5KIKyLWEePIy9QE",
	"3wxOxlgNTnLE1JiUUgDdT6jPEU8UBVxwkX2VhGYIlF3NPgTU53VU6BEGp6Yp1NNm+2m2IQ3qw9LEXLDZ",
	"h0bAEcPpYAxVgRYzinGcSNTjPkFbrVYTdZ2VgV6wh5WIsNI8HaWfH9Iy2swPbqHqQt7gMArUu/7O7oW3",
	"RbYbmzsebmz5eLOB/YtOY2/S2u1MLvY6nd1WzZGnSQJNO3S++XA+mf/b01ZjDzcuuo3DZz/sXjfcj1s3",
	"+djuXFexh2s1SU2cwBIeYf9Uk636pCSukWA4igLqgbzceCk5+wclgoUk8f+bxBeNXfVItjp/L8hFbb/2",
	"dxuZLruhf5Ubp6a7vhBc6BHkD2XXqmj6eFxwikIcwPop7YCHNKZKkcOxoJMk5jJ3cmRdEy9T2sPbgGNf",
	"kS+OBb6afZQgYtL3GEZnp0+atet67cDqPl9p0uoHRJk6xAL7HMZ0yMWE+j5hX21UQxTzV4ShmISISI9H",
	"aozA6WLgCkmIUcSD2adY6TO+4kVTpYPN/oBh364oD7CP1WQe45i8xm/HNCQ8+Xrr/Lg77v9L91/ReHDU",
	"H56NUQMVyI1ZmsMxYT4FrYTFQt+FiGLeAYWrFJExnpBAXZq4miCIGoaDEfBZPYCvtm+wR2p/EFGExTia",
	"6vVXLLF7MlCbxzgKqSe4VJKBzv4As3jCvVfE/2oDN91f12tHJL7k/jGPu0HAX3/FIQ3VvUMmIVUXFdW9",
	"YicekRIEjr0WK3GVhCicfYy5b4VoEnEBN+Xrek3NxFNCC08C8hV5q72/a2pXg6DsEquxO1qBHiny6QUR",
	"oOr5XIIlABhoOPvkU4wisClQ9ROwAtXYy4TFoFR4WAlSIoh0WyHobHzY2DXrccgT9jX3tWzS0PtG3lAZ",
	"EzgilhlQJexDuKbAbg7/2bb/KJGKbUurYMtDyjDzKA5OSZCaaRbM8OZTWqHLivkeYLVTkk9AMw2wR7nS",
	"ftR+RURKjtHLRKid9fCSGWZ3919neoX+lsyNpk9rEr/h5L5NcPArzi3f3ZKpfW8fXmVmJ0RIznDwKxLm",
	"Cl3ejDB9bCd5Mfskl0/xC1Pmsv5uR5lmas0lc/uyhLmku5sRZuW2jWhMBnJ4RYRSyr+qQJdGf5t90OP3",
	"sBAEbBkEYcSj9GquWL+SEhJuHhGn0qiGlE3hYmyVwXD24Q0NQfKNT0ZoGvAJDuqIESVIQg7UDBs85vwI",
	"s7fmjiW/oiKweJphQmMsXW3hT0RNXuAQXRD4zerFRMl+n8RKHWBgtSVi9olru0G6QnpJtL3BqtuqSY/r",
	"CwWLSX5x1WqdMWycCV+RXno5awlO1AhSUseJVEPfSM0gatL60pR+pWcSCQ5a4yQgfRbT+O3XVAIpi/Eb",
	"og5q7vJDtOVF3e9wHYVYZhpQxKWcfboiAbITEQhLRJmMRWL20phyiWyCBc4MCPxWguAe9xd5bAg6ODhA",
	"awdUemDkP6BqFGj2EzqgMp79/0qOrOtbWEAuOFNKKdJmMYIaSBJ0yZMrsOpkxpn2XsHUkrfd5k23YE6t",
	"b15X2VHrNSu6u57HE71lkVCHKKbadDIRmHmX1bPszX726RQ4Y3c6+6OaCxwZpm1YxrfRRGvpr7OPCBtX",
	"XPq8jNUBwwhzczvVUhJzaRdC1tWP0ezPk4B6HJEQDHCB4mtcIiwl9yjwbbBYAguI6RXWn8Xso09jXlc3",
	"Q/KGCG/2yaOa6GN6BQ4nqcaq9pzGiaaZuiaRiGuPoSQChbOfFZ2ogyAwkxQMM3j9nD09JWo94b1naKit",
	"NlxQHJrrgbFmRoIQ5l2q0/R9ghkwWg8Mp+ewL+c1MEbmLhawgCgSs48owlPcPGc5QnjY2enkSWErt/na",
	"vl658d4l8V4d0Cmt8OQczD5NqVZUYACFXrfyXd7AgF0HNzBZTE0050TTdq3ZJ+DAAUePMPM46ikurRgv",
	"R48EljRAs5+ku4VwcLGIqUcjDFzY52g0PkVrI3UNCsGuM1YbeUFESopIHXVxheV6c4h6aqi55+EbJq0+",
	"QFDvEiQeImiYgJvyBEezj1SuK0JPQiTNu98nrp6ESMptwG2dtapGPcHMm30QFMsm6gdEtSQydxIHT6i6",
	"ltqzR1AsZn+UyNebJqEzMItrWz4t+iRVB9qgCPZGKWlYRx4uHoFsIMAlE6p6ZYavkTdekEh6xXOE0Wq1",
	"S4ypQI2b1dTIknBCxELPdxUldra2t1udre18r51WqdvdeqdV3bP+YrHs6bMkNAxy/DYiqTZZ04Zma01/",
	"6lB3OqXcSTPdPUvHwScviRe7jLinpunFFZ6snmOIoAwsx4ZkBDEsQ8IxgJ+kdjPDqmkvgmGmzVq9wOJJ",
	"iGlQ0eETqgQnacDPKTeKIUQiJqFctmx2nfqqgWyta1gI/FZ9ji45I3M79niYSkW3e0cRzy6JNxzSieq5",
	"ckhcxjgw3sT5Y/NJ5laUdxmQ3fYTt9/ywAp0VhxlupR1u5mLSKx0fz3AMa7wnE5ekpgDOxFk9mdGtGaU",
	"J7zASFrMS7fcTI/RZDv7CQ1cBtNEPc4k9YnADVm6JJf6UuPQxjkMRrlL4hHFz6RPrDxNtwFsmwF432cf",
	"02GUhfyEhKnDk0L4AvBIrpQ+7oM3RfNSCvsMQTeBbp6HxPUaq8cS6XBqdRpLJw1rJrKIrIDIIVxp9rOk",
	"etmu1I/qCpNE2gtBQBswZi4x+9hQHyUKdQSN1JLSTpsVGXvOeQgc9UakalXFqtMjuJcIpf3MnyIvrlIT",
	"HZBUOdJzyjmNUx04/17zxkcsHdycofuJF8uR2m2PyLGRCyt1oQTEiW7AvA+vX4NYGugW2h3Q0u2n8ghk",
	"jEW8IBoF2H6qvBaOiw4tyZ0vpM85oQKrJb5SigJ+R5QoCAnjwriVtVcfO6ftv9RZ1kZ+0MofdXv9Y01T",
	"B8Me2mxttRBBvd6omRfGrU6r0dppdNrj1u7+Zmu/1fq96yL2cUwaMQ3JQmm9pnXW9cZa+2mr0Xn2vvWP",
	"T9uNvWfrjbXNp632s/dP251nT1uNveyX8do/7qufzs/9952nrXZn89n6vv6us7m1rb4vff59WRmo1940",
	"prxhvlQDTWIaNNWOjPWo098bNFTroyMZ1SRqUxpfJpOmx8ONIKGv3l5thNx71Zhg9mqDGh/ahm0T+HkS",
	"qQVJW58TgYQuzVUKeA19Z3VPdTlSdweJzs/Pk1Zr03tuA8aem29IXTETtfwEERkRz7FlnR72Gpubm3t1",
	"rSzEHJ2Ne030reajjr9AMZBEab9qNFeUeUmgqCJrT7M/zNEk4B6vK30yCalA5hU7AVKaAKicMhZZyEnM",
	"fV684dwT1Q2IqqAlFCjM5TBz+F2eg9czebVIncibi6t1iUW6a6pCoEHBlAwROi8xwigNKuKIXBBqGkof",
	"h3sNtIpmf2bqilXWyHLREiCsfayPEZAhpmVxPRGY+ce46nQeK/nvY3SEhYcddglc0r14IsbRMCLMcuMm",
	"OiUeDwnzQesxEZFCXcfCSOhY5tQqVQdeLUOOGPRHUAj9OZdiZo0IPkc+FcQITavookNBCfODt0h78JGa",
	"Dloz0cwStsz8tF48e0MxxSw9sd38Cdtt3eTaP0lppTJcLX9HhS1Um03DJJ59uCKBiU2DG427646n2ig7",
	"xV1vor6MSaED4G8xUffzKTPf6sazhtQ++CRB4E1WOodWTXILtL2z24ik39hph/7DvZ32q5eXjY6/1S4a",
	"SBZF/P3bU9x41238XjGf7M/Gsx9a9b29OaYbFr08XnJhVkpKQLQa3js++UbRal8RmMxpx6iBzO9gH5UR",
	"Zz5wc5YZMClTHZg4Eo56lm37BJ3o1f4mW22lZyi6jolAOCIMS8SlbU3a0QC1o3D2QXpY4Pyath7ubm8+",
	"7LRaD3d2NgsLWbZuteeZt3gYYUaJ7LHo5c2WKa8smzgyTYZwutMF+Mxrd85us3j5M/vUWb9We3O7VncX",
	"dHt7W3HyVKWtWnXz1u1WfaF+q7fkbTU/PcXvILiEq3up2gVSJtbZR6SOrQi5TQxQ51byCQKLaqADt4ps",
	"f+3km3V1h1D3uyvqayUEEW0LJkgmSvSkluAmGuNwMvsYgu0X7LYmKB8Mbz5hPLQx+Ha0PEEXVMkeM2ZB",
	"cZCj6SeJ7vIRYS9xSBnqqlu75II6+4+exD7Or/xO62am1cxytMp9KLU0XddrEP8WcWFF+II7iNoQ53xk",
	"W7WCulm6MLQbre3b6HZfVXPn8SURB9xLQlJ5lz9NI6a1TyLEVB1e/TyXN723Dt3ulp4y0D3mG66sumXs",
	"5a4m5mubYUwkIuyKB+pEyDpo5/tIzn5WF0+ywROE/ZAyc/xEExk7kV8d8a2kqlLsgZUp9iVTFSfBoWlX",
	"VjRMpNZtLMfk6NtRF619m2BfM9CRfRV18++tr27TONGrdWIVNh0WUF5V1TRZoAleYBZjSXGVKbCeWTCa",
	"aG3278hocxGPkgCL3AkqJAn59CoJprh40hBBIQkuuUAX9E0a8xaizEe2vrJRJXcijxKm48v7AYkFZ9qQ",
	"eWuOdH/FXfGK+1fIBgt3TUfBr5cvntlFKqe9FtW0vI5QJZUy/ubIu4WXU00d/om6MoWcvS17uHFoPd+L",
	"OEWpoW5oraD+QnkJzhnrYeRIvz/7b0b5HQRmkT4+t/VjZUPGI4Hf0cDszZcjL7NHZq0XbXheWpY2G+wZ",
	"oiJ18wSENEEkpFKa42uzhFPZbSWmz5soDX5QvFq/66T58dRBi4PoEm+qxwajYWOz/fBhbk973eNFPtO1",
	"8/PXP2xer//Qrta4yZuILtXarug0I0A7qapZfTGKbP/1U+QKTmqOeKJ1FbOyS6RwXUt5bO+C2aVFkZDP",
	"Q+rNPgXUGMJ8okNYYiIoF3XkE6kb83HVVfP45Jt80FBnd7Ozu7W9uYhXLJPo1ls+dwHGi47MX85i9AfH",
	"t1+GAm+KteU08/cbFrOIS+XdvWWR5PtUrS0OlNgpL3g3mCZMooBPlcqbCC4RpszHiBGPSAkuUnV1zQ6x",
	"b3LoQ6LdR9rwUTZpHSoNUBY40o1IBM/LxO3lrSRZWq7HQyL0vT+LUigoSd0rdIwnieDoX18RiV/ROmp3",
	"dloFLrPdWhAJ5w58js1ojmzQxl7F52efZG5YOvjoLpZR0+mSALu7yZhHp92FMuZpt/H7Zz/MCxE0Ixwl",
	"kwN6RaWJ017mDu2V31KqkrqlUS+uvko9wlQIrmOn4NgnTANC8AQsPuo0B9wDHRtuQ/q59Bn1vDf7FJnw",
	"PifpXmo7j0wmvhoN3HenhE/F7IM6HbKJThYwpuz+VqBKCEPj+bXdvtH2wyBwdEm9HufCpwzHZOmt9XHl",
	"S9f1Gp1MyZi/ZoupafDocV8t0FG6XE3URWM8IYEOc9PPyfwzYH+EV7H1wiOMgtSpHzpPTuBYECry4ZnY",
	"DVyDeUltONhJo9dsWBp0R6XFL+G5ICecUb6P0ZkhEh+jQ+Lb8O+8nrK5vd3abO0WLrPuRimNZKdax6Ly",
	"CFM2F/BCglcq5WapvNP2ykhQ5tEobxHUedemownnAcHMRh8t4QQE9U1XxvOvRck+BCfCetoAQetyY0k4",
	"+yioBy9z8J2li60o/SWJ6ZUzULAz909g+EIxYyyQOk0kgKx3NVcPh5Rd6gGoRmKBYzMcgrAOKZgCLUHz",
	"IHtkDDTAuEQgCSCpORNJWJ1Q49gyghubww6G2bor7erIcAYJpJe1l8bq1NHsZzGd/Zfq2thEZN3aTyQi",
	"iPj0AoIpZBNFTfKmiR602pvtdqvVelA45e2d7VarFNu4Ww4ynBNhyF+zan73JJ3ePhoaF5876ZxjYfaT",
	"UnLolGXmoErOx4wx3KVJnRWSss6SCeIIC6Vb4TInu600LehI5gg5i5GJ27wMXKg1ZRE85YsdvaLBAgsd",
	"/J75e3iCjMthBEb8vHYYvMPoiAaEYTSKyQVmb9GY0DeEirtZ6Fn0shddzPPdFd3fPneAZFhM0BMy1e4G",
	"sxBgfnWU79TcxLBEp8QjNLY8MUBozYg4IkAm9k4OVVPgwJIkNFYy3fV6bjl2Nh/u7Oxutttbu8s9Q+3r",
	"v3+/0EeknSYLdirzARlLKsNxInCQs6N2v09IQLRDDsg9FviKyJiqsw0BbuRNooHAkCAmXDCsn7M05A8u",
	"+a5fWCvIigs5mgdRWoYkieZSemjOLfmAeIAaACe5eKqKpCPlXYin+uo1ToHM3NC4c5YnnAAIp4FgfXv5",
	"k+CnN65jvc4m4tOmvYCORSw0l4FHyAzRs4/AuCDNTK8UjnnqJFKSpW7jOCAFw+NMSQvXeUZkjOMk/ap5",
	"zjL6Rg3Vg9rh7xMiLEUURliaAQkRDqZJiBiZgpegjkLiUw2jlcSA42ZzgzxBQYPRgRZmD1kSKrZ12j85",
	"7Y/6x+Pu8bj//En/cfdJrV47OR32zk67B8NTxa2y/Xa+X/HOmGcIdYeJLWKDuSTGzxO7a/IRgJTyaY+F",
	"KN1CTuTiKF1cSslQqqNHsagjfIUD+MPm1NN3oGd4AZYyDe+w0Rg6vPGCMisZtSNSxwBr7KCIiAuqU/Go",
	"hPAROMo4wkZMKi4w+++QerxxkUZGloPhPc54SL2uF9MrusiV5jj3PKsxm0XlOhDf/OrkGaVjwDLn95Fk",
	"Cq4XA22IesfdPlrrpWuhV/tYR3zCJLtZo/2s0fWlRhbX8bNabGt+Qd5WucdolZV9Fd9m2TzvtHZKrghL",
	"yKqWefv4vePpt+R4Kmx1Fd/M56GUNEdivy5gF6XaM3gFMM3riK+woAxfqOExn8jGbvt/T0QTBtxkJHbX",
	"0b7sGmDKi7jqRVM1dodL5jzFXA9y0fLpnJkb2yoHblx5ZnbEIotFwJlXIk2DlQBCxBkYjvMplos92yYX",
	"xHkfmeYfDM/Gp8MHecvAICe+sE/hJQogo7fW1bCTGLyIdaUJxI4hEAcBZdMV0ooH5bRig9akpcS6Cb5I",
	"E4uJRvjhar175RTjc1bKZS2ss6K1iqUuZa1ubxdZzfb2sjTVdn3r9taXdI53Mb4sde+QqiTtPEfd293Z",
	"bm8WcnLbRXNrq7H37IeH9fY8iyskc/XfxITJSkBk58oncIiDFYI9Lug7pT5jYfKgyldNljVaXs7cLPeK",
	"E9yu2M3tu6Vb5piOTqaZa1LQunR65tKdrGJmJW2mwkNcdfLGAr9zDO565blWHowi5lrQquIXP6OWB0d1",
	"OIFc5fSs6jBwE0aeZp0TdkUtnumOA2ClR6MhBx2lWw/hlx//Q42tMUom8BNBnebmLz/+ZxP1Q+RhyWWG",
	"jWsBM6lHtZ7+joCFTl3PYRSABiGyIDB3DJR5gR4El/rFIudoPbS2twKJ3dpYC5wBds/ZMAcNwN09w+EU",
	"y4AUP+dlSbyE+RpJ1jJCHEhSlFYjHqaaHve4sLEgrvRzrNnZMLK7Qm6gbh6XXns1uuaNJb+nz4pZr8qz",
	"Mi/tudIKkaXoyiY64r413KrRplJVcSnIZpQazPWUSB4kmui2mjvbmwZ4AWgmjAJYVpMSmWrIEJTIdHQN",
	"+IVpQI1t2fEIm7dIiEJOfPWXjAVmU7DEIAut4FhYGYDaELX7AYnF7L8ZRLR/R8HmnoT76tT10o5LCZpg",
	"Tcsa1dJVxywr7UNfFHmYhE10TAJcRxz5lF0SKjgCWIDZT3Bl9amMuMUuARGuzrHEkKWAM1uIBeBBfSlN",
	"ordevCkRirwskoa0qQ0+Ue1aC5GdS5ZV2gBIFE9QiHYGkHIZ0xCCFGHDpOSQpwOvCBI20TCbguIG+trO",
	"7GgiIE4KK0YhuhQgDwx8rjNCiDJFVBKWQivQzDukHjQD+j4BoHQvwAI30dDalZyV/OXH//AEkR755cf/",
	"RGvqVbKOCFMnNOZmgNMECx+A8VKIkp4OHLB7GhMx+5BbQ0AI/KOmp9kfZZqvw1Tf2n5kftZsMR2QBpiW",
	"ANxrNgCuYg4tVSTzgmKmpUVvcNo7e9I9Rcf/82e02Xy426qjR71HEMPTabU36xpV5UGGpDL7CZE3xEvS",
	"xQSDaBrn63Zoj4dL80gQ42IFgkUTLMEMegGxAWkMvK+lgCDpubYXVgMQKR/krWm94fG4+/ygfzIcDcbD",
	"593n3w1G426tbn44GZ6ddI97zhfdx92j/vF4+PzktA+f8va2ue2VhMIch3TFnS8JU/yo1OGoBKRaVkmn",
	"AdgLkszjeJF5HIsoHxp4yAJGac+3IkFtj6+v5qixvqlu70ETjQxr1OY4qBOgs0Sw1IOzR12arnOeWGcn",
	"ur1avQa2zO6J+ueoVq89goXv1+q1g8NavdYf1eq1x8NavXakfjgaq3/Ud0ePa/Xaifru5BEYQ9U/6rWT",
	"Qa1eO/1G/XOs/lEPn6oGTtUjI9XlSPU2Ug+Ph/m9hF+q962kCa7iOBkX75N+DgDDLsTh4P+DKQ6/66vV",
	"gAtifmDmicqhHSrBo8YwXmibv1CPZU5p0/VRFxatOygYkbuDed1ZQ9eAeTwkhwDEzry3c5RVjC7UE0bb",
	"gKoFBsDMx4alWvUeu+M6GHRPB13Yp6PuMRDJt2eD49/39d9H/eMR/PFocNQfjU/h7/Gp82HUz/7uHp91",
	"04UdOVpG9cyMCe8OU1NKWJwIXIw9O2fntWHut9lH5OEANApAjsAippBHmiqqE8KI8RHrEjM5pV5pzwnw",
	"R+24rlDbIEClEkQOhDbJdwEOKbAhZ1KHJ2iK2aXGGOG5fMxcOmui9CO1p1I7WyxihRouMILzWp4Xf+Fd",
	"zug57ahy44+woDEONBZ+tc2jr5loqJ8sh4iZCY2GT8b9AfCbXnfUPVB/fDc4+24IYz3pnnYPhs+/OTsY",
	"9AbdJ0qqAKcbfDc87Q3002fHg+7weX807s5lBvqrOXMZel6iM0iURq0mM4ctaBIWuSyhSg8C4qpFzTkK",
	"fqlefzDuPj/sH/T1FvQeDauHXH60cvBViTA2inoRd+OVkZ55sX9yCIxuNOqeDE9h3WGczw+GvTMt378b",
	"dB/3lRCCQM15XMKieeZCvKsHl0/BygKaqvKxCm7mwuCP/0lJMCXzjgeHINv6y/lZFqgAefV24Pfu279W",
	"9226rUWIlwXYVcUjXgkppB5M1/SKTosKymfQmRVDPB13h897p/2DwRj4xEn/tNvLfTXqPz4D3nZy2v9u",
	"cNA/7gHXHhx/1x+NB9Bk+uKwP3re6x49GgzTfkfdJ91T/fm0r99O36mQCmlvles8Im/KC3ueA5GwRqTZ",
	"JxmDNxUzHPOQXyjNPpj9PIUvIYmfqmvRVF0cObrkIQkhRi1Mgksi9tGIvFHCRXpJQBn/ByTV5wsSUkYZ",
	"B6l5zMHkpXo1VWRE+gBi6gJl39ZgU9aUZovpGLdDjjIP+0eD48GxVq9HvbMn+u8q/TN7srRWj+cFj64I",
	"vlGHBXJMICEAaoJVySSEeqphwuCy4QbMAginwInipx5VHBXYgwOW6OY9/cvj0e5WydWuBF2cVMn8nM/I",
	"x+iJeTJ3J5sSbi9K+sFMnUV9ADVq7LUQQXutprlENTqbze0tiOZ70ERrHbWvQDqxhgC9mn0S0yTAddRu",
	"I2OD+ZPNJ822xGlmoaG/8Y/aFN65Pj9v6j/nIDoEnE1XXQr76E3Xor2rFqO929J3SvSgsfWw+XDzYbut",
	"V2PztquRNbPSamxmq1EZMFkwU6ZE4q5SlbUyfzu6a5qfbmW1HD9znbpPnlqUPHXh3umWeX/m3XSLxJE1",
	"Wl8hRbByb0t7+p22qesSlKWbchnS71bNNFH/jdJ/JKhd2owfckZi7U9QWgHjKJx9YjTkyDIqor/UoOxb",
	"5kvLf0FrZKbkp8ZtpaYio1Rta7A9XUUSCygfpUuKEaHGEAvuYV0ez5QEEnosWZVUidK4KS7rKBZ4Avjh",
	"UIkKriwaVzt7yKAoK8XnHfXVSxhJPCGijgQJE5aazrSNUjWnU/jrZsFAYkFcp9HVidXfhb7tppNV8z/E",
	"70iYOTnT2qe42BvPBo+lxAEW4CNbkziASat+jNzjcv0fIDodrLF4zsA09BKf9ysJlcISq8E4j3CNGVyc",
	"YPq7WdQMlvgfEMwrJsLTTaU1v3TBAqyX2mJl6VOLDdalTCZy9snXk8NBMk1mH4FqDjmLyf5cYOVffvw/",
	"6ICoRTWGk9QRyYtx8i31X7O1VZQEnXwgeZXzv71txUJnXiCAlwhRbRQ6Agu2Iw956Ug57k6OQu6TQOdK",
	"bXXaO81CstSTRclSNldqueRKGVI68EVMqZhXPoehgPc4zSDPOehvwpfmNfNl+JKT864dYm5NpQlhmW+P",
	"Q45QGvkNTMq9wDZXJrn2ApKzqshvnuicCMu7KEummUxbupWwLxl/3Ya6S6LMxuRNzFFArwSxwNdOpFkB",
	"2zRzvEfm1FHtkct77rN8Cevft6OBkCc6TXCA9O22SJfzosoqgOFWjyp7S3BFeFKX8RLMBEant9FIOy2l",
	"aqYlsff29vbSYZiYmjn0tgKR3fO1e772pfnaMdY8wgR2zc2JwFORRHhuQsTsJ2SDKFNHb95EWSJLfz4c",
	"mLYIqm5jgd+5RkHiWqFdhmW89CbgAqgzPx432jJ18a4MOu8sUwlcrBjaD2Bn2QuUyGoGnJaAXhCHCGY0",
	"B5hcl1iRMsGF+WVTajpcWF9nIB6L+zal21wHcu9Li6NliqxkubM3zKLXhqMHve5xMSe0BNuyVSw6MXp6",
	"fi7Pz0erpEfOWeS6Q1ZLyH0J7M2yIG29e1p8lvbQSD+NLQEM4FcIoV4NjKHIN++Ox7ASoI5PFE80Z5Hf",
	"I+nc1BhEpUzI4vV1cZjS9b1f1TvhE5GquG8HrMjhAvUlrDytuJFn3KVUAJeTGz4hUC7YPDs8qW0nL5cL",
	"gtFERBZwoLNWUsHpBnzm61d1Nvc6e529vUUc/G7puF9hUSHIlFSubB3hYPYxROpGkGGB/VrLPRr2Bt0n",
	"aNTvLTpzd4BcqhKNlcCeXwgTFZWwS0Eq3QmfoJT9jtYOqADk+4uE+WCKc5Pk6xZVVLcz+4iwzpB3oOJn",
	"PxXb1NVzUjhlbqDxEcPSoynHDS2+soSoWCdn3oT4ch8jjd+h1scpq4Oj2c/S/BRyEZP1qiQjnbiQLlCW",
	"u8CLtfTKJfQiCK0Yv430MTnpj0bD7vPj7vjstPukqB18k2CG/hlTpYv3gtmHxKccHdoUvrtpK78hbOvy",
	"HtoaBM4yfIZd/ObsdHAw6HWL2/jrwGlbFtddXXVekb9XKowmTnwhLxYkIFfajWOw8tTBKsj0/DUFwpdu",
	"b3KyA+3Nh82cfZJz9bW7oGQ2l924Nm8zkf69ev/lFVG7YIN7Nf8Lru7xcjjSauBaYFjaYP4kM5hHqZ0l",
	"LfJpgcLyTVVDh88FCerciuGMV8wTXRq3el2vZdJlUVpgKl51rlFMMo3PIhIWtCeeKFFMTblHG9qVV0Eg",
	"OSInzSqDRuUlFuSSB776XGaySpqzONGJiml1oUxQa7ssRmvU3gYUd31YsFivN9HQoOYr3TWT0JkQkho1",
	"ZUEXmeeDJ0gmEWTbIYw62/9LBxbto1azA4BpaA1q72jrsRPiqp8dmh8etNED57d2q/W/1svOmH1DtlX2",
	"xNjqDXpcGKkbxxBBMXxi5OqCGYVYzUDphGpcxfTT5jbY4nN8hSeTgJTQ4ByzfB4bTpcRA3v8wy+JibWG",
	"bweKhb4gJlapqNQ/A27GXRSzm9RJLJLyr1mj5LdY1PC+Tsbng3Yzook7yFY4Tsw0WDpJJ0P5nA3zdgiT",
	"rp4rYQU3PUnCiLBLLIwrBUt0kbDUgm+bMFX0nb5m/w6J/ZCH63HmJ++QToDFNg02i9nHUlIGN57MzVVH",
	"abq1z3Vig7kUkgBrtqx4TN3moDJITIjE7KOMaagDs5JYqCGb0U6JIMyjmMom6kbqigp6peISapUCyi6B",
	"J1wIWwQ4pSKiy6tnCa3WpANWjfSuLGVChZWLngHJLQgUKO4VQYbSyKZBGFGbVptL0yCMYqHJjeXu6FWL",
	"n65KMeOpBwH33YOjwfFgNE5TGlaynTlKUUHrKmmY1fa1t1DXXD7C7NUTyl5V+Jw0dMAwIoyy6WKGjSdE",
	"KIGWFnpHNhRPz/lvXacnYRTwt0T0NCBgxUJlBld9IMgUDvha7/jkm43eyeG6I9ocCxLDS9d2eam39ym0",
	"Z6XHzIx9UaHM3JhvPk40dN9PrVdlfbwsU1I4KA1SLByDtfMUqMKX+IpofOMrrTsI13BXWqzdAuH94/9z",
	"fi7XXV7/9N/U/6ohfsz5UcenukRhdTnCDLnQpg2lYA0611OkyUX5RH+1ZGY50doEM483LnhwiddXJYJl",
	"sxjIaDL/MjoYnTxCa4NcGU4/ly9yYocqTeQpRBCvq6d+9SUo6u+NvWc/rJKskDsK5VNdse0Va1iv4pyV",
	"PNikFdqC7H8xReWRMSlABpa6byhBGyt9Q13TGPGoXyirWuEwmQjMvMslaOgYddPSNiRWLTn8o4nW0l8B",
	"IsMnEWF++ryFy8Ac4ThNuoYUKDNNWYcgQaMsQs4TYCkTeMhBtoc1VqO3UpsgT8w++jTmdQ1LQ4SX1m53",
	"xH3xgNdtVIxWkBSXC2c/K8WNJ3qNKWimeL3kRyma2dPrfdnebu3150BU57Wyi9EAuIjZR6CK4i3uYWen",
	"swzRbV7kmSL2AzqlFQR7YO1NZgcLvRbr6t7UQ0MWU1O+SLDjOAPKnxcfr52GOZRbt/4zlE0YjU/RmsPr",
	"xmojnXjNNMJfrjeHgORPcs/DNxrBRceN9S7J9wlR2vBQJxGc4Gj2kcp1bapC0rxbgCQhFugXzqaXtapG",
	"rTiiSaVQ9xrVUmaX8bO6Alk0VSxmf5RpNQHoTM2CaGNCfjl9Ah1kFR7U7SCsa2SVPCtJB2J0b9VrapN8",
	"4wWJpFd5N0cJnH+zRI2b1dS4NGaimhI7W9vbrc7W9sJbP9QEqHdac2w+yaT63jdKJhYNU5/CtSt7wVvf",
	"t6hBmccPNZxlMqWz1WIGWNiHTVgqRpKq8UvUQLoKj0Qh1/cQSwSZcJVgI1SMCGoJaaQfCws0Jx1bkfbw",
	"YDgCmDcNgqXBvlKWXB4SD6ivd7uhuXSYYochL3nJpZ2NOlgwGjMOURp8WgSeSh4A4h6VgPShSyZr+nyJ",
	"nUg2qC2fn0IGEZD2m793DY4PBt8NDjTkRW94/M0ZJEAPjk6eAGhO9tXwyeAA0C9yGb25928NkFgJzFbG",
	"eLNMz61PlTHgFDzREuMiNaPn1Bdevbp/WrRF8Un4SdoAfRaDQp4D5qmA5p0bUksa8HN6UKCU1UoBsHlE",
	"4IqoV0DglIuy+y2wkNt92T570wFpjN2qAbkFwxZgkpMMTErefjh2y/NlykrDKlBbcYzpMtbtRi4iLzd4",
	"tTJwWwdtG1kyF8seHWQh1VXzL0TlzK/GUVki/uSwec66Ju2umD1fET+kMwqwROQNnVotGqNTMk0CbFnX",
	"f+mkBDrlonnOhlCZAwx3FeXiLUiJldBJ6HjmLiA+yPSQr/5hJTMcvVwsl9S3KDpJqDqn6q5tBpCEGLmA",
	"aIrs222nehAw1NnPKEx8HBrLokfBifAy8SncmtHQGeDsIyIhjalvRinMKA0m2vwcnAXRFDrnlLteLA5I",
	"gxEXcQnyfHt3p9PZ7rQ3dwq6ZLuylEn1pVe3vfIhss9fXy8g/0MQvBQHp0DLn6uwg/oAsYSp8cje4DTH",
	"nv2EBq7yVSj3UHh9cbmHtCCDDitLoxnNGcxHO9lhlC9AqTcqCU3IvzYWzEFQUUNQtKSa56HBwtc3IAhm",
	"k3lwHVnOKNKSVP7l3J+bNyhgXrABVImOKlPtnIkWoh/Tmad2k5QgLDjk1ewT85IAsCDBQhdrOLN6VuQA",
	"MMnUNr2cfdDfUoHDug4sAxRJQKjIFqdg1yOKEniiEVQzO6DiVQDbaYcA6qO9k5sEq7whUdsYsd0TdTN3",
	"7EBobf6WaJf0cCL3NW26w0CqtSm36qmx9wtQbT2qISDRBfEu7SEsDstc+tVdm0s5+6Su+1MsVLPaMQ2y",
	"zOcy43ESNNmwYFkF2r8J9ZRI4xr82AP9crtKDxExnlCdpAJC5koJ/9UJyhktoA9QKAzoYNmlPdg6L+nm",
	"peuJ82fJx3nr0+ynwtlKTUNrct3A5ZV2wCTbu5QqIXQAh+a3+grkNn/wZrJYC77CaQfKau6jYgOWLMib",
	"SE/d8DXmESHggpNic2E0OLRRgQZWNO37glNkMFnTJvEVldh3Ys4LJ0Wm3Wj80vQHoFLdlgYbTWKhOm+i",
	"41sTMalYPJBhdQBYMkDjdt21CxcOLtIHVxe/BdaCm6ibJweN5RuXI90NeGpqE4uIT7VbNz8SB8HXOdI6",
	"BkIiDzOdDbryoas8QksPXgYpt6ggUV7WNYvq1IrO7hIe3Y0vDlmlvuvKufiJF0sDpCZtaNZq9Yiqgdiu",
	"QZ2z69dZvpqlEXRXLmSST3Nzi6pbtaS08BXRSzb2uWIooM9q3LDRg1VzyyvHsTD61xZxnFMP+SaBNiVV",
	"USPg5XRLdJgal5roIAdkHxLGhQkI09oALibta6YD1vpH3V7/WMuAg2EPbba2WoigXm90H7tzBx/0fdGs",
	"L1w067dHVItrdbkcZo5QqGe3s7wIXGRJyrzM8+/Ri0yWmS2pCCxutC2EkbXbII6INrv4+Ry51BYNJnmM",
	"StHDOfxmpUho5cgQoUmfLrhEqYgvFzPkfObWksOWh5zY291rtDYbnc3fQLzNRGDmLwpYwegICyiFYOUO",
	"iBvXs6duj8OIMCvWmuiUeDwkzAfTiQlRFGmlCLCVWNW4jgxirSn7TFAI/TleR2a9tL6BF9NqgzUVo0NB",
	"CfODt0idGCIQZF2tdZP4kgsqgfbNT+t5uTjM4Yh375Itf5/VCFmNnynLcIk+prPrKJHVAUOVBuvKIKJ8",
	"QKii69TS3EDmJdeujZ2EbcUuVa9O2GPJSJ0m4TXPmdLz1HGIibAXLsAFhOakHaN20IWzD9LDouBsfVpr",
	"tXd2NjtbO61Wq91S7Mn5YvvhphIG6dXhdoFMCy8LnuP4WuXykzrKrut5XJhVXnaxWC5sfYnc5egz5RU7",
	"Wc9uhYpz9pWO5Dn7vGeyosa9B6T+OY/kZ0ncOGe3zdz4ouXMy2FxN1qaVR3Z+SIq8wplLyyMvfD0XmKp",
	"9QiK2UJ8KHOv1hUlbX3MmITzsYlc+oLab1VlJUO3xMUNkokrYOzwfCA7kquScStH2oKKqYWj1A2xpBqc",
	"za0CeSPNIayq/LGMVsrlQq7rNZbf1JsiYC0lIO5CK8lltSZK5SVuajorIXItNmSld57ywM7CQgyWiQ4i",
	"iIZJrKV/IlNDbh7hw2D+zvHJNBGk9uWbTxMdJJ0yC4Fvas/ZZgCRnySoEP+ZLxa7s9uIpN/YaYf+w72d",
	"9quXl42Ov9XeqjBmOUl3eQ/uU9x41238Xl08sj8bz35o1ffmgLBLXXVgGQ2OyJu/8ZS9vDYLI6S6fvCh",
	"UgzwnZAy7q1M91amX9nK5PBI9+bvahV1x7biKu3z1QfnWlC8mS20TRXhnu+KvVvEjf7Lxok1g1u0QndE",
	"MjyBfNAsBiyN+0Q4Cqj2JCYSTiJUzMiBUFibTKl6coiZ78TW1417I6eO+QTNfhZTbRY8O2yi/htIANlH",
	"p4/r5c720Wh0snE6as4J5C9Axjyx7/cdxIwsK+wC/OkGHqbITVRHUGDx1traKkH7V0S4qT2V2BNL/Y+L",
	"sHH8cke5aRZm2LmHffwrASgsmNk3FiOY5K3W25299l5r93NA+S31Os+tP2ca6d4FZbV4ErLrGEYY8UhT",
	"kfYJw+1M5gGE82BJp/1uA2qx3lJRuzngXjHacUEKq8eZp2MtoNwUxS8NqBVkmNiIfB0FkkuHTq/iCKML",
	"CoEjnhIN+tKSgWHpcvxEOCkKOt3KrQFecUnuRgH19MVImrLts58KobdIEEl1tXCn3jjyidQ7aMt/5I2k",
	"EDj8mYJb06DlZhXO4HykLloC6oKC3Gq3yOpIXQ80VNeD22N1Ke71+ofN6/Uf5mUUr8KMMyBLn6OTdCKr",
	"cOC5yvY99O58Crlf2Dui77pUWlypne3O9ubWw92dra3tva3dTuthp7XwarfI9lrg3Vnij2ENC9l3LuPj",
	"xtp3N5gmTKKATwX2eSK4NLF5OuUKwsRBr04pyBoswDABAcfW4FlAGT+E6vMFtnIjOY+zWRWDAXK+rqwc",
	"u2H12pCTLyCeGUOv0DGeJIKjf31FJH5F66jd2SnWwtv+AuDnnxn53HS6JOPa9H0TIMdCRYjuQtFgS0Ks",
	"//2CMRaK+C9T3CpK/1/Xa7oivxdX2/AeYSoEt2kwjimNJ+DFUnwvrdNvSn1j5KXPqOe92afIZHxnS2UL",
	"F8hk4qvRGBCbrLTmzYI2846kvBQmLBZ3MtJP5xUYXbTi1VVJleiZTMmYv2aLKWzw6HFfLdlRuoBN1EVj",
	"PDHAO1kxZ/cZ8CTDqziFksMoSONiQ+fJSQYv4ebwYze7GeYldVjPjpPypHOXoTsqbYU5nkt0xE7FCYzO",
	"WFpCROdiaTdrbqM2t7dbm8U7zI67UUoi7lQrS1QeYcoWIRu6HC3TIyHDLBKUeTTCQW5AsUgqXVlqRZaw",
	"B4L6pi8TB6oFyj6ksMOC2jRyG4DFknD2UVAPXuYQSZWutiL1lySmV85IIWSgfwLjF1Q7xtQBIwERWMO3",
	"eDikzGRbqEYAI8RizGMdYDrVJfggnUpJIF0mHzEuEYgDSGHJBBM2Vf4hT84U4DfnH24WdVfm1ZFhFrri",
	"eNZemrVUt6YimaJLyLoFppKIIOLTC51Io1EVm+hBq73ZbkPp2mKxIChFW0yB3y3nolcTUMxfs2oe+CSd",
	"3z4amkAld9aF5Ed1B6JTlsGwVXJDxm1+QkaVRMazDxk75RW++9mngOLb87KCTmQOTaYTOMvg0PmKOlMW",
	"7P75wjNSR9vfYIRUP3iH0RENCMNoFJMLzN6iMaFvTOmA26Ow3zybF/2G021Xw++9QWbs36RP9Ph//oy2",
	"2832bgvg3dtb6t+XmCm5r/7stNqtPHn3sAi4/ByAkCvkwdiI6PHbiFiGNDeKJj0fyyJqbEvfJjj4HJHU",
	"3ALPwGPf21arUo7zPy5JOcYl7B2l/nkUizrCVziAPzwssBcTAZghxKnQ72BPGIfOBc1qrJEsoZkDnWQ4",
	"nIJKiKMAisIRNoKOpJVxGxmOSoWFDook/LaCOGvbrYe725sPO0pR2dy+NeIcLVV5X72au/t+zv+6SlhO",
	"2XF7Xa9xz0s05viqEUzD9A2lgKi3rAMha+vApYjbl5tootE8L8Lv8gP/HTqvnfZ7/cG4+/ywf9A/7T45",
	"rym17bzWezQ8r9URzUo3ZfhP6m6lb1gR9gVncBNunrNCtxWdgRej0K6eJuj6PkZcvaIHm2aoDg61PVyS",
	"aUJQRd/aoV2UxIyE6ofeo2EJ3Lt9p+IY96EsXziU5S84psRl4pUCdF6efBHgaAnu63E1y17rnRxuKJ67",
	"XsSDtZCYkBgPGdYWKMPFwsyjxeo0fK0jagXJy2IacrnQXx8x9gZj/dtGjT0gMaZMk87KdOOK+mPrS82q",
	"22bVk9ZS4nLz7NfmIrGW0TdTxID1L0tqq67TYnxa30DU+hbo8fDrT3hlFFoXluNtN4oEv8LBEsBteCi1",
	"1OQGcnveYHEsrPNcHRDt8AF+KWIaXAJyjMVRyJR2foWhtJ4OwNJhwiaDUr2bBBJgT38LcOB3ARXOcYUF",
	"B2E+yVRJs1N91yCPEkkZkTJFHCyhVpVFnG9ujYs0Y9tuNQjWdb0WUPYKWnM3Ake0+QR+uPvy44jCrTkk",
	"erTFfo7U95+rm8IGwwrZOZoh3GgX8gnP87dgpTwE23pFFvWyZIT7XVq0Szlbyt3OSdksc7/6+dXvC1Fl",
	"jifqa7konXKZe0u1oC9Ps08X4LUCRwbc2wo3mO3tG1U+U+w5qJDYJFPfAjLVwEoRF+gyCTEDvV7G5XEV",
	"b1NbuzcyQNI4qCpvPPsUJ8FdxnGTNSmB2YJHRg8tXa/KfMAMCGhzCcv6GrRsiHAR+aapxJ9Z0C5Gm7xn",
	"Ikt24bMK2gVwJfeC9i679BkE7Xz/x/3qexrJVhIvETR+O1JLpld22E3iy87I/FAWH4dB8oYjeMrBYDc5",
	"ot+DTVddOKNYw/axS4ywdhrhFDxwMXAqOiVQYSvvbxLEp4I44GQQFK5OnZcZMxOZGIxQmzCkY3rCFLiw",
	"qW6eAX+tIyE1zsq7nPU/9+WZCGr7tcs4juT+xob6CXzComlsoxu5p2v1mvR4ZLSQFNF9v9ZXX/PyepmV",
	"mf2EuieDFBUGHMpgA+SBNgBa5US6Ulmi2Ufjv76iWPvTpKScyaYOCXlFlo8fnsqhGquHOqqBYUSYTknm",
	"8FePM0a8uNxkU9GlIstmxL2mwNSnOGxSvtF8TYKg8Yrx12xDtUH9hsfZBZ0mwq6X7dXtQRM0NcGpJkUv",
	"hZJXJyNuwAG4UOv3v9W7qnfKphPR5ELd9RlYJWuP+RUARMz+ABHmLtKPLf3xy4//B/Vdu/yfAEwiyc3S",
	"6aKhI8+a5nRSvoEFwT6RuiAc8bnY0KpgLqb2ZACZHgV4KHBQmjI1iwZ4iCVBneY5U+1o3OiYC4YzPM45",
	"bZIUmSoPKllHlHlBQnUJRFP9plCEvF528zrGs3rBpSv5RJBCL+mofI33DI+U8KzTNnPQ1jY5b259Ij89",
	"0ufn5+xEl8+QZCqILSKpQQhLQMRFGzC8b3hOLqHdHQ4c15irTrlEL9ID+QIsZn+HhjqMTS/GOeuiF6c8",
	"IC9QAfjJLToIK+RgMUOMj149AvwAKmm8OOgeDEcv9CTnDcI48sxLkSBXUDQjNWgD+vILOOsvHNAyji4V",
	"6Qr0ouuyMd0ZgAPAK2ACFBpNFwtnyBziJHNLtvbCfB74L9YNRjNfUmkq3cm6DVbSsQFU9QlhJt8nFCqB",
	"arLnddWgmqxODJWxplYuz5kmZmeIELjgDCp373OegzkP7XGSRGjzqK4erWWWBT9PsdEVMbtNuyuTue2x",
	"iUrNrdPV7EOgVoaYGC0JcBjoRfds/E/D08Gof6B3YfbvaRFLV3rovi2+g7MM2nmks4FjgWNeRyT21qGM",
	"8kuMfKqGpO99izdlLUUlliREE/59QqhmE2kJTDhS5B02k0irkDrFWP5E5EZu4hJgme0TPpfrMM1uoGbo",
	"U9ATJHrhCLMXbqkXaWjRonPn8HwzHGAfI09Qx8mZW3t3m3L0ajiB5U4QTyzJNKFiyaAMZrNDIIaOSKiL",
	"I6Vn9QVY6p1TrvnH36GTrPHKtnMKgnoHmAE0DgFt6sH4UmacoI6wXlQ1DNA/JFp7ofWTF+spKr80Luaw",
	"MD9tvTdrLZU6NoHqVj6W+3rIf4debNi0/A2auwDJF+cMoYark+yrb9R3j/vjffS73/XORuPhUf909Pyk",
	"fzoaHnefPB8c9I/Hg8NBrzseDI9Hz0/73YPf/a7U1feuPl/VU3Xr3YPBWLXbfTI4PhzOa/zCXqobwtyq",
	"bzeXhb1NjAnwLqv26Gw0OO6PRktWLe1q6aot72m1Od1xBZf1BvcajzAJyrrR87oR9i6VhtQqqW6vX79u",
	"YvhZqYYb5l258WTQ6x+P+g31TmYsq+WOGWpUaWS1eu2KCJ23Uus0O802hP5EhKnL2H5ts9mCccB5VINc",
	"uDbqgSmpSLU9mn1Uot6A70xiQPTWob6yjNUsKxUmx9dJ9Ds59ayigLcV2csuaTWYsVbj1SWhli7aYxLP",
	"dQUBAiwWOCQxXIyeVt/gs0c2copJ7bq+9IU3hzii6i1whK36gh39IMoKJa325kBdRLBn1mGVt2xfZ5KI",
	"7hQAop6p+7u2hABBdFqtedaN9LmN4T/fwKV3Xa9trdLoI+yDKixj/Up7+StnzF6CNQT+Vmtz+UuHXEyo",
	"7xMzsq3lbxzz+JAnzHSxvfyFIxJfcv+Yx90g4K/t2B6u1FPX80gU40kAYX1bnRVm9IR7r0wnnb3lj485",
	"P8LsrVlsyK3aXmWDBsbyo1FhtYsE3l1hCR/jmLzGb8c0JDyBDd5eZagjGpOBHF4REXDs6zn65AInQbz8",
	"5QPzoGtugoNfNDQ9rRlNbD/VyGp1x4ryLLNIPK1pa0LtmTo5MglDLN5CYaVYaTxwAfjinFKxwBhPFRfL",
	"mF/tmZrnXAF/E2ZfnEXhdn4H5r0S7x4URn7PuKsY9/K3Ijwlqz43ou9WfZZqxMTGK/L284uPgovkXnbc",
	"SXZ0VlkGW9N3EpA+iw2k5b3c+auWOytw7JWESP7qdhcZUrDmfmn9/9v8wO9FyK+h++c9p/e8+17v/63y",
	"3+XcbhH7XWQS/Msw2liX1udg2XODiu7Z9hdh2ysEh92z7nvWfW+y+Xx8ciVm/6sYbL4E47631/xm7DXL",
	"QlrvBce9veZe6HxOe81NJMivYK35EvLj3lbzFZT+e1vNvcJ/z3tX4XVzWS8MWS2zZlN5Jgt1iKGWBUFQ",
	"bx5aL8UI4Yg2ASKh6fGwOREQ790wAd8b6fQ2rjrAOOb38U885AE38cdV3Vyu3M+zdL7FDoeRhpf7EzHB",
	"gYChMwWEnCLQVs8JC08L4mXx8dlKXj+7/r8BAAD//3etkaLgOQEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
