//go:build go1.22

// Package customerv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package customerv2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luikyv/mock-bank/internal/api"
	"github.com/luikyv/mock-bank/internal/timeutil"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for BusinessProcuratorType.
const (
	BusinessProcuratorTypePROCURADOR         BusinessProcuratorType = "PROCURADOR"
	BusinessProcuratorTypeREPRESENTANTELEGAL BusinessProcuratorType = "REPRESENTANTE_LEGAL"
)

// Defines values for EnumAccountTypeCustomers.
const (
	EnumAccountTypeCustomersCONTADEPOSITOAVISTA   EnumAccountTypeCustomers = "CONTA_DEPOSITO_A_VISTA"
	EnumAccountTypeCustomersCONTAPAGAMENTOPREPAGA EnumAccountTypeCustomers = "CONTA_PAGAMENTO_PRE_PAGA"
	EnumAccountTypeCustomersCONTAPOUPANCA         EnumAccountTypeCustomers = "CONTA_POUPANCA"
)

// Defines values for EnumCountrySubDivision.
const (
	AC EnumCountrySubDivision = "AC"
	AL EnumCountrySubDivision = "AL"
	AM EnumCountrySubDivision = "AM"
	AP EnumCountrySubDivision = "AP"
	BA EnumCountrySubDivision = "BA"
	CE EnumCountrySubDivision = "CE"
	DF EnumCountrySubDivision = "DF"
	ES EnumCountrySubDivision = "ES"
	GO EnumCountrySubDivision = "GO"
	MA EnumCountrySubDivision = "MA"
	MG EnumCountrySubDivision = "MG"
	MS EnumCountrySubDivision = "MS"
	MT EnumCountrySubDivision = "MT"
	PA EnumCountrySubDivision = "PA"
	PB EnumCountrySubDivision = "PB"
	PE EnumCountrySubDivision = "PE"
	PI EnumCountrySubDivision = "PI"
	PR EnumCountrySubDivision = "PR"
	RJ EnumCountrySubDivision = "RJ"
	RN EnumCountrySubDivision = "RN"
	RO EnumCountrySubDivision = "RO"
	RR EnumCountrySubDivision = "RR"
	RS EnumCountrySubDivision = "RS"
	SC EnumCountrySubDivision = "SC"
	SE EnumCountrySubDivision = "SE"
	SP EnumCountrySubDivision = "SP"
	TO EnumCountrySubDivision = "TO"
)

// Defines values for EnumCustomerPhoneType.
const (
	EnumCustomerPhoneTypeFIXO  EnumCustomerPhoneType = "FIXO"
	EnumCustomerPhoneTypeMOVEL EnumCustomerPhoneType = "MOVEL"
	EnumCustomerPhoneTypeOUTRO EnumCustomerPhoneType = "OUTRO"
)

// Defines values for EnumFiliationType.
const (
	MAE EnumFiliationType = "MAE"
	PAI EnumFiliationType = "PAI"
)

// Defines values for EnumInformedIncomeFrequency.
const (
	EnumInformedIncomeFrequencyANUAL      EnumInformedIncomeFrequency = "ANUAL"
	EnumInformedIncomeFrequencyBIMESTRAL  EnumInformedIncomeFrequency = "BIMESTRAL"
	EnumInformedIncomeFrequencyDIARIA     EnumInformedIncomeFrequency = "DIARIA"
	EnumInformedIncomeFrequencyMENSAL     EnumInformedIncomeFrequency = "MENSAL"
	EnumInformedIncomeFrequencyOUTROS     EnumInformedIncomeFrequency = "OUTROS"
	EnumInformedIncomeFrequencyQUINZENAL  EnumInformedIncomeFrequency = "QUINZENAL"
	EnumInformedIncomeFrequencySEMANAL    EnumInformedIncomeFrequency = "SEMANAL"
	EnumInformedIncomeFrequencySEMESTRAL  EnumInformedIncomeFrequency = "SEMESTRAL"
	EnumInformedIncomeFrequencyTRIMESTRAL EnumInformedIncomeFrequency = "TRIMESTRAL"
)

// Defines values for EnumInformedRevenueFrequency.
const (
	EnumInformedRevenueFrequencyANUAL      EnumInformedRevenueFrequency = "ANUAL"
	EnumInformedRevenueFrequencyBIMESTRAL  EnumInformedRevenueFrequency = "BIMESTRAL"
	EnumInformedRevenueFrequencyDIARIA     EnumInformedRevenueFrequency = "DIARIA"
	EnumInformedRevenueFrequencyMENSAL     EnumInformedRevenueFrequency = "MENSAL"
	EnumInformedRevenueFrequencyOUTROS     EnumInformedRevenueFrequency = "OUTROS"
	EnumInformedRevenueFrequencyQUINZENAL  EnumInformedRevenueFrequency = "QUINZENAL"
	EnumInformedRevenueFrequencySEMANAL    EnumInformedRevenueFrequency = "SEMANAL"
	EnumInformedRevenueFrequencySEMESTRAL  EnumInformedRevenueFrequency = "SEMESTRAL"
	EnumInformedRevenueFrequencyTRIMESTRAL EnumInformedRevenueFrequency = "TRIMESTRAL"
)

// Defines values for EnumMaritalStatusCode.
const (
	EnumMaritalStatusCodeCASADO                EnumMaritalStatusCode = "CASADO"
	EnumMaritalStatusCodeDIVORCIADO            EnumMaritalStatusCode = "DIVORCIADO"
	EnumMaritalStatusCodeOUTRO                 EnumMaritalStatusCode = "OUTRO"
	EnumMaritalStatusCodeSEPARADOJUDICIALMENTE EnumMaritalStatusCode = "SEPARADO_JUDICIALMENTE"
	EnumMaritalStatusCodeSOLTEIRO              EnumMaritalStatusCode = "SOLTEIRO"
	EnumMaritalStatusCodeUNIAOESTAVEL          EnumMaritalStatusCode = "UNIAO_ESTAVEL"
	EnumMaritalStatusCodeVIUVO                 EnumMaritalStatusCode = "VIUVO"
)

// Defines values for EnumOccupationMainCodeType.
const (
	EnumOccupationMainCodeTypeCBO            EnumOccupationMainCodeType = "CBO"
	EnumOccupationMainCodeTypeOUTRO          EnumOccupationMainCodeType = "OUTRO"
	EnumOccupationMainCodeTypeRECEITAFEDERAL EnumOccupationMainCodeType = "RECEITA_FEDERAL"
)

// Defines values for EnumPartiesParticipationDocumentType.
const (
	CNPJ                 EnumPartiesParticipationDocumentType = "CNPJ"
	CPF                  EnumPartiesParticipationDocumentType = "CPF"
	OUTRODOCUMENTOVIAGEM EnumPartiesParticipationDocumentType = "OUTRO_DOCUMENTO_VIAGEM"
	PASSAPORTE           EnumPartiesParticipationDocumentType = "PASSAPORTE"
)

// Defines values for EnumPersonalOtherDocumentType.
const (
	CNH    EnumPersonalOtherDocumentType = "CNH"
	NIF    EnumPersonalOtherDocumentType = "NIF"
	OUTROS EnumPersonalOtherDocumentType = "OUTROS"
	RG     EnumPersonalOtherDocumentType = "RG"
	RNE    EnumPersonalOtherDocumentType = "RNE"
)

// Defines values for EnumProcuratorsTypePersonal.
const (
	EnumProcuratorsTypePersonalPROCURADOR         EnumProcuratorsTypePersonal = "PROCURADOR"
	EnumProcuratorsTypePersonalREPRESENTANTELEGAL EnumProcuratorsTypePersonal = "REPRESENTANTE_LEGAL"
)

// Defines values for EnumProductServiceType.
const (
	EnumProductServiceTypeCARTAOCREDITO         EnumProductServiceType = "CARTAO_CREDITO"
	EnumProductServiceTypeCONTADEPOSITOAVISTA   EnumProductServiceType = "CONTA_DEPOSITO_A_VISTA"
	EnumProductServiceTypeCONTAPAGAMENTOPREPAGA EnumProductServiceType = "CONTA_PAGAMENTO_PRE_PAGA"
	EnumProductServiceTypeCONTAPOUPANCA         EnumProductServiceType = "CONTA_POUPANCA"
	EnumProductServiceTypeCONTASALARIO          EnumProductServiceType = "CONTA_SALARIO"
	EnumProductServiceTypeCREDENCIAMENTO        EnumProductServiceType = "CREDENCIAMENTO"
	EnumProductServiceTypeINVESTIMENTO          EnumProductServiceType = "INVESTIMENTO"
	EnumProductServiceTypeOPERACAOCREDITO       EnumProductServiceType = "OPERACAO_CREDITO"
	EnumProductServiceTypeOPERACOESCAMBIO       EnumProductServiceType = "OPERACOES_CAMBIO"
	EnumProductServiceTypeOUTROS                EnumProductServiceType = "OUTROS"
	EnumProductServiceTypePREVIDENCIA           EnumProductServiceType = "PREVIDENCIA"
	EnumProductServiceTypeSEGURO                EnumProductServiceType = "SEGURO"
)

// Defines values for EnumSex.
const (
	EnumSexFEMININO  EnumSex = "FEMININO"
	EnumSexMASCULINO EnumSex = "MASCULINO"
	EnumSexOUTRO     EnumSex = "OUTRO"
)

// Defines values for PartiesParticipationPersonType.
const (
	PESSOAJURIDICA PartiesParticipationPersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  PartiesParticipationPersonType = "PESSOA_NATURAL"
)

// Defines values for PartiesParticipationType.
const (
	ADMINISTRADOR PartiesParticipationType = "ADMINISTRADOR"
	SOCIO         PartiesParticipationType = "SOCIO"
)

// Defines values for PersonalAccountSubtype.
const (
	CONJUNTASIMPLES   PersonalAccountSubtype = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA PersonalAccountSubtype = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        PersonalAccountSubtype = "INDIVIDUAL"
)

// AreaCode Número de DDD (Discagem Direta à Distância) do telefone do cliente - se houver
type AreaCode = string

// BusinessAccount defines model for BusinessAccount.
type BusinessAccount struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
	//
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
	//
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
	//
	// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
	Type EnumAccountTypeCustomers `json:"type"`
}

// BusinessContacts Conjunto de informações referentes às formas para contatar o cliente.
type BusinessContacts struct {
	// Emails Lista e-mails de contato
	Emails []CustomerEmail `json:"emails"`

	// Phones Lista com telefones de contato da pessoa jurídica
	Phones []CustomerPhone `json:"phones"`

	// PostalAddresses Lista de endereços da pessoa jurídica
	PostalAddresses []BusinessPostalAddress `json:"postalAddresses"`
}

// BusinessFinancialRelationData Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
type BusinessFinancialRelationData struct {
	// Accounts Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora.
	Accounts []BusinessAccount `json:"accounts"`

	// Procurators Lista dos representantes. De preenchimento obrigatório se houver representante.
	Procurators          []BusinessProcurator     `json:"procurators"`
	ProductsServicesType []EnumProductServiceType `json:"productsServicesType"`

	// StartDate Data de início de relacionamento com a Instituição Financeira. Deve trazer o menor valor entre a informação reportada ao BACEN pelo DOC 3040 e CCS.
	StartDate timeutil.DateTime `json:"startDate"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// BusinessIdentificationData Conjunto de informações relativas a Identificação ou seja a ação e o efeito de identificar de forma única a pessoa jurídica através de seus dados cadastrais
type BusinessIdentificationData struct {
	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// BusinessID Um identificador único e imutável usado para identificar o recurso cliente pessoa jurídica. Este identificador não tem significado para o cliente que deu o consentimento
	BusinessID string `json:"businessId"`

	// CnpjNumber Número completo do CNPJ da Empresa consultada  - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CnpjNumber string `json:"cnpjNumber"`

	// CompaniesCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompaniesCnpj []string `json:"companiesCnpj"`

	// CompanyName Razão social da empresa consultada é o termo registrado sob o qual uma pessoa jurídica (PJ) se individualiza e exerce suas atividades. Também pode ser chamada por denominação social ou firma empresarial
	CompanyName string `json:"companyName"`

	// Contacts Conjunto de informações referentes às formas para contatar o cliente.
	Contacts BusinessContacts `json:"contacts"`

	// IncorporationDate Data de constituição da empresa, conforme especificação RFC-3339.
	IncorporationDate timeutil.DateTime `json:"incorporationDate"`

	// OtherDocuments Relação dos demais documentos
	OtherDocuments *[]BusinessOtherDocument `json:"otherDocuments,omitempty"`

	// Parties Lista relativa às informações das partes envolvidas, como: sócio e/ou administrador. Objeto de envio obrigatório para todos os CNPJs que possuam sócios e/ou administradores no cadastro do QSA (Quadro de Sócios e Administradores)
	Parties []PartiesParticipation `json:"parties"`

	// TradeName Nome fantasia da pessoa jurídica, se houver. (É o nome popular da empresa, utilizado para divulgação da empresa e melhor fixação com o público). De preenchimento obrigatório se houver
	TradeName *string `json:"tradeName,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// BusinessInformedPatrimony defines model for BusinessInformedPatrimony.
type BusinessInformedPatrimony struct {
	// Amount Valor do patrimônio informado
	Amount InformedPatrimonyAmount `json:"amount"`

	// Date Data de referência do Patrimônio, conforme especificação RFC-3339.
	Date timeutil.BrazilDate `json:"date"`
}

// BusinessOtherDocument defines model for BusinessOtherDocument.
type BusinessOtherDocument struct {
	// Country Pais de emissão do tipo de documento informado. Código do pais de acordo com o código alpha3 do ISO-3166
	Country string `json:"country"`

	// ExpirationDate Data vigência do tipo de  documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// Number Número do outro documento. De preenchimento obrigatório, para a Pessoa jurídica com domicílio ou sede no exterior, desobrigada de inscrição no CNPJ
	Number string `json:"number"`

	// Type Número do Tipo de documento informado. De preenchimento obrigatório, para a Pessoa jurídica com domicílio ou sede no exterior, desobrigada de inscrição no CNPJ
	Type string `json:"type"`
}

// BusinessPostalAddress defines model for BusinessPostalAddress.
type BusinessPostalAddress struct {
	// AdditionalInfo Alguns logradouros ainda necessitam ser especificados por meio de complemento
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Address Corresponde ao endereço comercial do cliente.
	Address *string `json:"address,omitempty"`

	// Country Nome do país
	Country string `json:"country"`

	// CountryCode Código do pais de acordo com o código alpha3 do ISO-3166
	CountryCode string `json:"countryCode"`

	// CountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
	CountrySubDivision *EnumCountrySubDivision `json:"countrySubDivision,omitempty"`

	// DistrictName Bairro é uma comunidade ou região localizada em uma cidade ou município de acordo com as suas subdivisões geográficas. Preenchimento obrigatório, se houver.
	DistrictName *string `json:"districtName,omitempty"`

	// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
	GeographicCoordinates *GeographicCoordinates `json:"geographicCoordinates,omitempty"`

	// IbgeTownCode Código IBGE de Município. A Tabela de Códigos de Municípios do IBGE apresenta a lista dos municípios brasileiros associados a um código composto de 7 dígitos, sendo os dois primeiros referentes ao código da Unidade da Federação.
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// IsMain Indica se o endereço informado é o principal
	IsMain bool `json:"isMain"`

	// PostCode Código de Endereçamento Postal: Composto por um conjunto numérico de oito dígitos, o objetivo principal do CEP é orientar e acelerar o encaminhamento, o tratamento e a entrega de objetos postados nos Correios, por meio da sua atribuição a localidades, logradouros, unidades dos Correios, serviços, órgãos públicos, empresas e edifícios. p.ex. '01311000'
	PostCode *string `json:"postCode,omitempty"`

	// TownName Localidade: O nome da localidade corresponde à designação da cidade ou município no qual o endereço está localizado.
	TownName string `json:"townName"`
}

// BusinessProcurator defines model for BusinessProcurator.
type BusinessProcurator struct {
	// CivilName Nome civil completo ou Razão Social
	CivilName string `json:"civilName"`

	// CnpjCpfNumber Identificação do Representante Legal ou Procurador. Número do cadastro nas Receita Federal  (Preencher com CPF ou CNPJ sem formatação)
	CnpjCpfNumber string `json:"cnpjCpfNumber"`

	// SocialName Nome social da pessoa natural, se houver. Aquele pelo qual travestis e transexuais se reconhecem,
	// bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local.
	SocialName *string `json:"socialName,omitempty"`

	// Type Tipo de representante.
	// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
	// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
	Type BusinessProcuratorType `json:"type"`
}

// BusinessProcuratorType Tipo de representante.
// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
type BusinessProcuratorType string

// BusinessQualificationData Objeto que reúne as informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
type BusinessQualificationData struct {
	// EconomicActivities Lista dos demais códigos relativos às demais atividades econômicas da empresa, segundo padrão CNAE (Classificação Nacional de Atividades Econômicas). De preenchimento obrigatório, se houver
	EconomicActivities *[]EconomicActivity        `json:"economicActivities,omitempty"`
	InformedPatrimony  *BusinessInformedPatrimony `json:"informedPatrimony,omitempty"`
	InformedRevenue    *InformedRevenue           `json:"informedRevenue,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// CustomerEmail defines model for CustomerEmail.
type CustomerEmail struct {
	// Email Endereço de email
	Email openapi_types.Email `json:"email"`

	// IsMain Indica se o email informado é o principal
	IsMain bool `json:"isMain"`
}

// CustomerPhone defines model for CustomerPhone.
type CustomerPhone struct {
	// AdditionalInfo Informação complementar relativa ao tipo de telefone selecionado. [Restrição] De preenchimento obrigatório quando selecionado o tipo 'OUTRO'.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// AreaCode Número de DDD (Discagem Direta à Distância) do telefone do cliente - se houver
	AreaCode AreaCode `json:"areaCode"`

	// CountryCallingCode Número de DDI (Discagem Direta Internacional) para telefone de acesso ao Cliente - se houver
	//
	// [Restrição] O preenchimento é obrigatório quando for diferente de 55.
	CountryCallingCode *string `json:"countryCallingCode,omitempty"`

	// IsMain Indica se o telefone informado é o principal
	IsMain bool `json:"isMain"`

	// Number Número de telefone do cliente
	Number string `json:"number"`

	// PhoneExtension Número do ramal. De preenchimento obrigatório se fizer parte da identificação do número do telefone informado
	PhoneExtension *string `json:"phoneExtension,omitempty"`

	// Type Identificação do Tipo de telefone do cliente.
	Type EnumCustomerPhoneType `json:"type"`
}

// EconomicActivity defines model for EconomicActivity.
type EconomicActivity struct {
	// Code Traz o código do ramo da atividade principal da empresa consultada, segundo padrão CNAE (Classificação Nacional de Atividades Econômicas)
	//
	// [Observação] O campo sempre deve ser enviado com 7 caracteres, seguindo a classificação “CNAE-Subclasse 2.3”. Em casos em que o valor inicie com zeros, ele deve conter todos os caracteres, incluindo os zeros.
	Code string `json:"code"`

	// IsMain Indica se é o ramo principal de atividade da empresa quando true e se é o ramo secundário quando false. [Restrição] Somente uma ocorrência relativa ao código da atividade econômica principal deve trazer o valor true.
	IsMain bool `json:"isMain"`
}

// EnumAccountTypeCustomers Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
//
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
//
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
//
// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
type EnumAccountTypeCustomers string

// EnumCountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
type EnumCountrySubDivision string

// EnumCustomerPhoneType Identificação do Tipo de telefone do cliente.
type EnumCustomerPhoneType string

// EnumFiliationType Tipo de filiação.
type EnumFiliationType string

// EnumInformedIncomeFrequency Traz a frequência ou período da renda informada.
type EnumInformedIncomeFrequency string

// EnumInformedRevenueFrequency Traz a frequência ou período do faturamento informado.
// "O faturamento é calculado a partir de todos os benefícios que a empresa conseguiu com sua atividade econômica em um determinado período. Esses benefícios são os rendimentos ou ganhos da organização através de suas vendas ou serviços prestados".
type EnumInformedRevenueFrequency string

// EnumMaritalStatusCode Estado marital do cliente.
type EnumMaritalStatusCode string

// EnumOccupationMainCodeType Traz a relação dos códigos relativos à ocupação.
type EnumOccupationMainCodeType string

// EnumPartiesParticipationDocumentType Tipo do documento informado.
type EnumPartiesParticipationDocumentType string

// EnumPersonalOtherDocumentType Relação dos Códigos dos demais documentos pessoa natural.
type EnumPersonalOtherDocumentType string

// EnumProcuratorsTypePersonal Tipo de representante.
// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
type EnumProcuratorsTypePersonal string

// EnumProductServiceType Lista com a relação dos produtos e serviços com contrato vigente.
type EnumProductServiceType string

// EnumSex "Conjunto de características anatomofisiológicas que distinguem o homem e a mulher: Sexo masculino; sexo feminino".
// No caso de não ser feminino nem masculino é classificado como 'OUTRO'
type EnumSex string

// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
type GeographicCoordinates struct {
	// Latitude Informação da Latitude referente a geolocalização informada. Entre -90 e 90.p.ex. '-23.5475000'. (2 casas antes da vírgula, 11 posições)
	Latitude string `json:"latitude"`

	// Longitude Informação da Longitude referente a geolocalização informada. Entre -180 e 180. p.ex '-46.6361100'. (3 casas antes da vírgula, 11 posições)
	Longitude string `json:"longitude"`
}

// InformedIncome defines model for InformedIncome.
type InformedIncome struct {
	// Amount Valor total da renda informada
	Amount InformedIncomeAmount `json:"amount"`

	// Date Data da renda, conforme especificação RFC-3339.
	Date timeutil.BrazilDate `json:"date"`

	// Frequency Traz a frequência ou período da renda informada.
	Frequency EnumInformedIncomeFrequency `json:"frequency"`
}

// InformedIncomeAmount Valor total da renda informada
type InformedIncomeAmount struct {
	// Amount Valor total da renda informada. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Renda primária indica os montantes a pagar ou a receber em troca do uso temporário de recursos financeiros, trabalho ou ativos não financeiros não produzidos, a saber, remuneração de trabalhadores, renda de investimentos e demais rendas primárias.
	// Fazem parte da primeira a remuneração do trabalho assalariado (salários e ordenados); da segunda, renda de investimento direto, renda de investimento em carteira, renda de outros investimentos e renda de ativos de reserva; e da terceira, tributos sobre a produção e importação, subsídios e aluguéis.
	// Fonte: Banco Central do Brasil – Departamento Econômico
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// InformedPatrimonyAmount Valor do patrimônio informado
type InformedPatrimonyAmount struct {
	// Amount Valor do patrimônio informado. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Patrimônio é o conjunto de bens vinculado a uma pessoa ou a uma entidade.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// InformedRevenue defines model for InformedRevenue.
type InformedRevenue struct {
	// Amount Valor do patrimônio informado
	Amount InformedRevenueAmount `json:"amount"`

	// Frequency Traz a frequência ou período do faturamento informado.
	// "O faturamento é calculado a partir de todos os benefícios que a empresa conseguiu com sua atividade econômica em um determinado período. Esses benefícios são os rendimentos ou ganhos da organização através de suas vendas ou serviços prestados".
	Frequency *EnumInformedRevenueFrequency `json:"frequency,omitempty"`

	// FrequencyAdditionalInfo Texto livre para complementar informação relativa ao patrimonio.
	//
	// [Restrição] Preencher quando frequency for igual OUTROS.
	FrequencyAdditionalInfo *string `json:"frequencyAdditionalInfo,omitempty"`

	// Year Ano de referência da Renda, conforme especificação RFC-3339.
	Year *float32 `json:"year,omitempty"`
}

// InformedRevenueAmount Valor do patrimônio informado
type InformedRevenueAmount struct {
	// Amount Valor do patrimônio informado. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	// Patrimônio é o conjunto de bens vinculado a uma pessoa ou a uma entidade.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// Nationality Objeto que agrupa informações relativas à nacionalidade da Pessoa Natural
type Nationality struct {
	// Documents Lista que traz relação de documentos complementares de pessoas com nacionalidade diferente de brasileira
	Documents []NationalityOtherDocument `json:"documents"`

	// OtherNationalitiesInfo Campo de preenchimento obrigatório caso o cliente não possua nacionalidade brasileira. Preencher indicando todas suas demais nacionalidades utilizando o código de pais de acordo com o código alpha3 do ISO-3166.p.ex.'CAN'
	OtherNationalitiesInfo string `json:"otherNationalitiesInfo"`
}

// NationalityOtherDocument defines model for NationalityOtherDocument.
type NationalityOtherDocument struct {
	// AdditionalInfo Campo livre de preenchimento quando necessário.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Country Nome do país.
	Country *string `json:"country,omitempty"`

	// ExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// IssueDate Data de emissão do documento, conforme especificação RFC-3339.
	IssueDate *timeutil.BrazilDate `json:"issueDate,omitempty"`

	// Number Número de identificação do documento. Campo livre, de preenchimento obrigatório quando a nacionalidade for diferente de brasileira. Informar o número do documento e demais informações complementares para se identificar o documento de pessoa estrangeira
	Number string `json:"number"`

	// Type Tipo de documento. Campo livre, de preenchimento obrigatório quando a nacionalidade for diferente de brasileira. Informar tipo e número do documento, além da, vigência e demais informações complementares para se identificar o documento de pessoa estrangeira
	Type string `json:"type"`
}

// PartiesParticipation Lista relativa às informações das partes envolvidas, como: sócio e /ou administrador
type PartiesParticipation struct {
	// CivilName Nome civil completo da pessoa natural (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	//
	// [Restrição] O campo civilName deve ser obrigatoriamente preenchido quando personType for PESSOA_NATURAL.
	CivilName *string `json:"civilName,omitempty"`

	// CompanyName Razão social da empresa consultada é o termo registrado sob o qual uma pessoa jurídica (PJ) se individualiza e exerce suas atividades. Também pode ser chamada por denominação social ou firma empresarial
	//
	// [Restrição] o campo companyName deve ser obrigatoriamente preenchido quando personType for PESSOA_JURIDICA.
	CompanyName *string `json:"companyName,omitempty"`

	// DocumentAdditionalInfo Campo livre, de preenchimento obrigatório quando o documento informado tiver informações complementares relevantes para a sua identificação
	DocumentAdditionalInfo *string `json:"documentAdditionalInfo,omitempty"`

	// DocumentCountry País de emissão do documento. Código do pais de acordo com o código alpha3 do ISO-3166.
	DocumentCountry *string `json:"documentCountry,omitempty"`

	// DocumentExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	DocumentExpirationDate *timeutil.BrazilDate `json:"documentExpirationDate,omitempty"`

	// DocumentIssueDate Data de emissão do documento, conforme especificação RFC-3339.
	DocumentIssueDate *timeutil.BrazilDate `json:"documentIssueDate,omitempty"`

	// DocumentNumber Número do documento informado. Campo Texto Livre para preencher número e dígito do documento se houver
	DocumentNumber string `json:"documentNumber"`

	// DocumentType Tipo do documento informado.
	DocumentType EnumPartiesParticipationDocumentType `json:"documentType"`

	// PersonType Indica se a pessoa da parte envolvida é uma pessoa natural ou juridica
	PersonType PartiesParticipationPersonType `json:"personType"`

	// Shareholding Percentual de participação societária (informar com 6 casas decimais). O Sócio só deve ser informado se sua participação societária for igual ou superior a 25%. p.ex: 0.250000 (Este valor  representa 25%. O valor '1 'representa 100%).
	//
	// [Restrição]: Campo obrigatório caso o type for igual a SOCIO e este tiver participação societária maior que 25%.
	Shareholding *string `json:"shareholding,omitempty"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local).
	SocialName *string `json:"socialName,omitempty"`

	// StartDate Data de início da participação, conforme especificação RFC-3339.
	StartDate *timeutil.DateTime `json:"startDate,omitempty"`

	// TradeName Nome fantasia da pessoa jurídica, se houver. (É o nome popular da empresa, utilizado para divulgação da empresa e melhor fixação com o público). De preenchimento obrigatório se houver
	TradeName *string `json:"tradeName,omitempty"`

	// Type Indica o perfil de atuação na empresa. Vide Enum
	// O administrador é o responsável por desempenhar todas as funções administrativas da empresa. É ele quem conduz o dia a dia do negócio, assinando documentos, respondendo legalmente pela sociedade, realizando empréstimos e outras ações gerenciais. Apesar de estar na linha de frente da empresa, ele é denominado sócio por também possuir sua parcela de participação no Capital Social.
	// Sócio não tem qualquer envolvimento nas atividades administrativas da sociedade.
	Type PartiesParticipationType `json:"type"`
}

// PartiesParticipationPersonType Indica se a pessoa da parte envolvida é uma pessoa natural ou juridica
type PartiesParticipationPersonType string

// PartiesParticipationType Indica o perfil de atuação na empresa. Vide Enum
// O administrador é o responsável por desempenhar todas as funções administrativas da empresa. É ele quem conduz o dia a dia do negócio, assinando documentos, respondendo legalmente pela sociedade, realizando empréstimos e outras ações gerenciais. Apesar de estar na linha de frente da empresa, ele é denominado sócio por também possuir sua parcela de participação no Capital Social.
// Sócio não tem qualquer envolvimento nas atividades administrativas da sociedade.
type PartiesParticipationType string

// PaychecksBankLink defines model for PaychecksBankLink.
type PaychecksBankLink struct {
	// AccountOpeningDate Data de abertura da conta salário.
	AccountOpeningDate timeutil.BrazilDate `json:"accountOpeningDate"`

	// EmployerCnpjCpf Documento do empregador (CNPJ/CPF), conforme registrado na abertura da conta salário.
	EmployerCnpjCpf string `json:"employerCnpjCpf"`

	// EmployerName Nome do empregador conforme registrado na abertura da conta salário. O empregador pode ser pessoa natural ou pessoa jurídica, quando se tratar de pessoa jurídica, deve haver o envio da razão social.
	EmployerName string `json:"employerName"`

	// PaycheckBankCnpj CNPJ da instituição financeira contratada para prestar serviço de pagamento de salário (banco-folha).
	PaycheckBankCnpj string `json:"paycheckBankCnpj"`

	// PaycheckBankIspb Número ISPB (Identificador do Sistema de Pagamentos Brasileiros) do instituição financeira contratada para prestar serviço de pagamento de salário (banco-folha).
	PaycheckBankIspb string `json:"paycheckBankIspb"`
}

// PersonalAccount Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
type PersonalAccount struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares.
	Subtype PersonalAccountSubtype `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum:
	//
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante.
	//
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado.
	//
	// Conta de pagamento pré-paga - segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'.
	Type EnumAccountTypeCustomers `json:"type"`
}

// PersonalAccountSubtype Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares.
type PersonalAccountSubtype string

// PersonalContacts Conjunto de informações referentes às formas para contatar o cliente.
type PersonalContacts struct {
	// Emails Lista e-mails de contato
	Emails []CustomerEmail `json:"emails"`

	// Phones Lista com telefones de contato da pessoa natural
	Phones []CustomerPhone `json:"phones"`

	// PostalAddresses Lista de endereços da pessoa natural
	PostalAddresses []PersonalPostalAddress `json:"postalAddresses"`
}

// PersonalDocument Objeto agrupador de informações relativas a Documentos da pessoa natural
type PersonalDocument struct {
	// CpfNumber Número completo do CPF.
	// Atributo que corresponde às informações mínimas exigidas pela Regulamentação em vigor.
	// O CPF é o Cadastro de Pessoa natural. Ele é um documento feito pela Receita Federal e serve para identificar os contribuintes. O CPF é uma numeração com 11 dígitos, que só mudam por decisão judicial. O documento é emitido pela receita federal.
	//
	// [Restrição] Preenchimento obrigatório quando não for informado o passport.
	CpfNumber *string `json:"cpfNumber,omitempty"`

	// Passport Documento concedido aos viajantes por uma autoridade administrativa nacional a fim de certificar sua identidade perante autoridades estrangeiras.
	//
	// [Restrição] Aplicável somente à Pessoa natural residente no exterior desobrigada de inscrição no CPF.
	//
	// [Restrição] Preenchimento obrigatório quando não for informado o cpfNumber.
	Passport *PersonalPassport `json:"passport,omitempty"`
}

// PersonalFinancialRelationData Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
type PersonalFinancialRelationData struct {
	// Accounts Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora.
	Accounts []PersonalAccount `json:"accounts"`

	// PaychecksBankLink Lista de informações de contas salário relacionadas com vínculos empregatícios, existentes ou que já existiram, firmados entre o cliente pessoa natural e um ou mais empregadores. Cada vínculo é associado a uma conta salário aberta mantida no banco-folha (instituição transmissora).
	//
	// Obs: como empregadores antigos podem não ter solicitado o fechamento da conta salário, não é possível garantir que os dados informados sejam do empregador atual.
	PaychecksBankLink *[]PaychecksBankLink `json:"paychecksBankLink,omitempty"`

	// PortabilitiesReceived Lista de informações de empregador recebidos através de portabilidade de salário solicitada pelo cliente da transmissora à instituição detentora(s) de sua conta salário, ativos ou que já estiveram ativos,. Cada vínculo é associado a uma portabilidade de salário recebida pela transmissora.
	//
	// Obs.: a portabilidade não é explicitamente encerrada, ou seja, a IF para a qual o salário foi portado não é avisado quando a conta salário se encerra ou o salário é portado para outra IF. Não é possível garantir que os dados informados sejam de uma portabilidade ativa, nem que o vínculo com o banco folha ainda exista. A transmissora terá tais informações apenas quando o pedido da portabilidade tiver sido solicitado em seus canais.
	PortabilitiesReceived *[]PortabilitiesReceived `json:"portabilitiesReceived,omitempty"`

	// Procurators Lista dos representantes.
	// [Restrição] De preenchimento obrigatório se houver representante.
	Procurators          []PersonalProcurator     `json:"procurators"`
	ProductsServicesType []EnumProductServiceType `json:"productsServicesType"`

	// ProductsServicesTypeAdditionalInfo Informações adicionais do tipo de serviço.
	// [Restrição] Campo obrigatório quando productsServicesType for 'OUTROS'.
	ProductsServicesTypeAdditionalInfo *string `json:"productsServicesTypeAdditionalInfo,omitempty"`

	// StartDate Data de início de relacionamento com a Instituição Financeira. Deve trazer o menor valor entre a informação reportada ao BACEN pelo DOC 3040 e CCS.
	StartDate timeutil.DateTime `json:"startDate"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PersonalIdentificationData Conjunto de informações relativas a Identificação ou seja a ação e o efeito de identificar de forma única a pessoa natural através de seus dados cadastrais.
type PersonalIdentificationData struct {
	// BirthDate Data de nascimento, conforme especificação RFC-3339
	BirthDate timeutil.BrazilDate `json:"birthDate"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CivilName Nome civil completo da pessoa natural (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	CivilName string `json:"civilName"`

	// CompaniesCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompaniesCnpj []string `json:"companiesCnpj"`

	// Contacts Conjunto de informações referentes às formas para contatar o cliente.
	Contacts PersonalContacts `json:"contacts"`

	// Documents Objeto agrupador de informações relativas a Documentos da pessoa natural
	Documents PersonalDocument `json:"documents"`
	Filiation *[]struct {
		// CivilName Nome civil completo da pessoa relativa à filiação.
		// (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento,
		// com o qual será identificada por toda a sua vida, bem como após a sua morte).
		CivilName string `json:"civilName"`

		// SocialName Nome social da pessoa natural, se houver.
		// (aquele pelo qual travestis e transexuais se reconhecem,
		// bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local).
		SocialName *string `json:"socialName,omitempty"`

		// Type Tipo de filiação.
		Type EnumFiliationType `json:"type"`
	} `json:"filiation,omitempty"`

	// HasBrazilianNationality Informa se o Cliente tem nacionalidade brasileira.
	HasBrazilianNationality bool `json:"hasBrazilianNationality"`

	// MaritalStatusAdditionalInfo Campo livre para complementar a informação relativa ao estado marital.
	//
	// [Restrição] Preenchimento obrigatório quando selecionado o tipo 'OUTRO'.
	MaritalStatusAdditionalInfo *string `json:"maritalStatusAdditionalInfo,omitempty"`

	// MaritalStatusCode Estado marital do cliente.
	MaritalStatusCode *EnumMaritalStatusCode `json:"maritalStatusCode,omitempty"`
	Nationality       *[]Nationality         `json:"nationality,omitempty"`

	// OtherDocuments Relação dos demais documentos
	OtherDocuments *[]PersonalOtherDocument `json:"otherDocuments,omitempty"`

	// PersonalID Um identificador único e imutável usado para identificar o recurso cliente pessoa natural. Este identificador não tem significado para o cliente que deu o consentimento
	PersonalID string `json:"personalId"`

	// Sex "Conjunto de características anatomofisiológicas que distinguem o homem e a mulher: Sexo masculino; sexo feminino".
	// No caso de não ser feminino nem masculino é classificado como 'OUTRO'
	Sex *EnumSex `json:"sex,omitempty"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Local)
	SocialName *string `json:"socialName,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PersonalInformedPatrimony defines model for PersonalInformedPatrimony.
type PersonalInformedPatrimony struct {
	// Amount Valor do patrimônio informado
	Amount InformedPatrimonyAmount `json:"amount"`

	// Year Ano de referência da Renda, conforme especificação RFC-3339.
	Year float32 `json:"year"`
}

// PersonalOtherDocument defines model for PersonalOtherDocument.
type PersonalOtherDocument struct {
	// AdditionalInfo Para documentos em que se aplique o uso do local de emissão o mesmo deve ser enviado mandatoriamente, com a informação de órgão e UF. Exemplo: RG, local de emissão: SSP/RS.
	// [Restrição] Obrigatório quando o Local de Emissão do Documento for relevante.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// CheckDigit Dígito verificador do documento informado. De preenchimento obrigatório se o documento informado tiver dígito verificador
	CheckDigit *string `json:"checkDigit,omitempty"`

	// ExpirationDate Data de validade do documento informado, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// Number Identificação/Número do documento informado
	Number string `json:"number"`

	// Type Relação dos Códigos dos demais documentos pessoa natural.
	Type EnumPersonalOtherDocumentType `json:"type"`

	// TypeAdditionalInfo Campo livre de preenchimento obrigatório se selecionada a opção OUTROS tipos de documentos
	TypeAdditionalInfo *string `json:"typeAdditionalInfo,omitempty"`
}

// PersonalPassport Documento concedido aos viajantes por uma autoridade administrativa nacional a fim de certificar sua identidade perante autoridades estrangeiras.
//
// [Restrição] Aplicável somente à Pessoa natural residente no exterior desobrigada de inscrição no CPF.
//
// [Restrição] Preenchimento obrigatório quando não for informado o cpfNumber.
type PersonalPassport struct {
	// Country Pais de emissão do passaporte. Código do pais de acordo com o código 'alpha3' do ISO-3166.
	Country string `json:"country"`

	// ExpirationDate Data vigência do Passaporte, conforme especificação RFC-3339.
	ExpirationDate *timeutil.BrazilDate `json:"expirationDate,omitempty"`

	// IssueDate Data de emissão do passaporte, conforme especificação RFC-3339.
	IssueDate *timeutil.BrazilDate `json:"issueDate,omitempty"`

	// Number Número do Passaporte.
	Number string `json:"number"`
}

// PersonalPostalAddress defines model for PersonalPostalAddress.
type PersonalPostalAddress struct {
	// AdditionalInfo Alguns logradouros ainda necessitam ser especificados por meio de complemento.
	AdditionalInfo *string `json:"additionalInfo,omitempty"`

	// Address Corresponde ao endereço residencial do cliente.
	Address string `json:"address"`

	// Country Nome do país
	Country string `json:"country"`

	// CountryCode Código do país de acordo com o código alpha3 do ISO-3166.
	CountryCode *string `json:"countryCode,omitempty"`

	// CountrySubDivision Enumeração referente a cada sigla da unidade da federação que identifica o estado ou o distrito federal, no qual o endereço está localizado. p.ex. 'AC'. São consideradas apenas as siglas para os estados brasileiros
	CountrySubDivision *EnumCountrySubDivision `json:"countrySubDivision,omitempty"`

	// DistrictName Bairro é uma comunidade ou região localizada em uma cidade ou município de acordo com as suas subdivisões geográficas.
	// [Restrição] De preenchimento obrigatório, se houver.
	DistrictName *string `json:"districtName,omitempty"`

	// GeographicCoordinates Conjunto de informações, que correspondem aos valores das coordenadas geográficas em graus decimais, no Sistema de referência WGS84
	GeographicCoordinates *GeographicCoordinates `json:"geographicCoordinates,omitempty"`

	// IbgeTownCode Código IBGE de Município. A Tabela de Códigos de Municípios do IBGE apresenta a lista dos municípios brasileiros associados a um código composto de 7 dígitos, sendo os dois primeiros referentes ao código da Unidade da Federação.
	IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

	// IsMain Indica se o endereço informado é o principal.
	IsMain bool `json:"isMain"`

	// PostCode Código de Endereçamento Postal: Composto por um conjunto numérico de oito dígitos, o objetivo principal do CEP é orientar e acelerar o encaminhamento, o tratamento e a entrega de objetos postados nos Correios, por meio da sua atribuição a localidades, logradouros, unidades dos Correios, serviços, órgãos públicos, empresas e edifícios. p.ex. '01311000'.
	PostCode string `json:"postCode"`

	// TownName Localidade: O nome da localidade corresponde à designação da cidade ou município no qual o endereço está localizado.
	TownName string `json:"townName"`
}

// PersonalProcurator defines model for PersonalProcurator.
type PersonalProcurator struct {
	// CivilName Nome civil completo da pessoa natural. (Direito fundamental da pessoa, o nome civil é aquele atribuído à pessoa natural desde o registro de seu nascimento, com o qual será identificada por toda a sua vida, bem como após a sua morte)
	CivilName string `json:"civilName"`

	// CpfNumber Número completo do CPF. O CPF é o Cadastro de Pessoa natural. Ele é um documento feito pela Receita Federal e serve para identificar os contribuintes. O CPF é uma numeração com 11 dígitos, que só mudam por decisão judicial. O documento é emitido pela receita federal
	CpfNumber string `json:"cpfNumber"`

	// SocialName Nome social da pessoa natural, se houver. (aquele pelo qual travestis e transexuais se reconhecem, bem como são identificados por sua comunidade e em seu meio social, conforme Decreto Nº 51.180, de 14 de janeiro de 2010)
	SocialName *string `json:"socialName,omitempty"`

	// Type Tipo de representante.
	// Representante legal - Nome Civil completo da Pessoa Natural que represente uma entidade ou uma empresa e é nomeado em seu ato constitutivo, ou seja, no contrato social ou estatuto social.
	// Procurador - é qualquer pessoa que represente a Pessoa Natural em algum negócio, mediante autorização escrita do mesmo.
	Type EnumProcuratorsTypePersonal `json:"type"`
}

// PersonalQualificationData Conjunto de informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
type PersonalQualificationData struct {
	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica.
	// Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj       string                     `json:"companyCnpj"`
	InformedIncome    *InformedIncome            `json:"informedIncome,omitempty"`
	InformedPatrimony *PersonalInformedPatrimony `json:"informedPatrimony,omitempty"`

	// OccupationCode Traz a relação dos códigos relativos à ocupação.
	OccupationCode *EnumOccupationMainCodeType `json:"occupationCode,omitempty"`

	// OccupationDescription Campo livre, de preenchimento obrigatório. Se selecionada a opção *occupationCode* "RECEITA_FEDERAL" ou "CBO", informar o código desta lista padronizada.
	// Se selecionada *occupationCode* "OUTRO", informar o descritivo da ocupação quando a IF não segue a lista padronizada da Receita Federal e nem da CBO.
	OccupationDescription *string `json:"occupationDescription,omitempty"`

	// UpdateDateTime Data e hora da atualização dos campos \<_endpoint_\>, conforme especificação RFC-3339, formato UTC. Quando não existente uma data vinculada especificamente ao bloco, assumir a data e hora de atualização do cadastro como um todo.
	UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// PortabilitiesReceived defines model for PortabilitiesReceived.
type PortabilitiesReceived struct {
	// EmployerCnpjCpf Número de inscrição (CPF/CNPJ) do empregador (contratante dos serviços de pagamento), conforme recebido pela comunicação de portabilidade.
	EmployerCnpjCpf string `json:"employerCnpjCpf"`

	// EmployerName Nome do empregador conforme recebido pela comunicação de portabilidade. O empregador pode ser pessoa natural ou pessoa jurídica, quando se tratar de pessoa jurídica, deve haver o envio da razão social.
	EmployerName string `json:"employerName"`

	// PaycheckBankDetainerCnpj Número de inscrição no Cadastro Nacional da Pessoa Jurídica (CNPJ) do banco folha (instituição financeira detentora da conta salário) conforme recebido pela comunicação de portabilidade.
	PaycheckBankDetainerCnpj string `json:"paycheckBankDetainerCnpj"`

	// PaycheckBankDetainerIspb Número do ISPB do Banco Folha (instituição financeira detentora da conta salário) conforme recebido pela comunicação de portabilidade.
	PaycheckBankDetainerIspb string `json:"paycheckBankDetainerIspb"`

	// PortabilityApprovalDate Data de aprovação da portabilidade, conforme recebido pela comunicação de portabilidade.
	//
	// Obs.: somente devem ser compartilhadas solicitações aprovadas, mesmo que de forma compulsória.
	PortabilityApprovalDate timeutil.BrazilDate `json:"portabilityApprovalDate"`
}

// ResponseBusinessCustomersFinancialRelation defines model for ResponseBusinessCustomersFinancialRelation.
type ResponseBusinessCustomersFinancialRelation struct {
	// Data Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
	Data  BusinessFinancialRelationData `json:"data"`
	Links api.Links                     `json:"links"`
	Meta  api.Meta                      `json:"meta"`
}

// ResponseBusinessCustomersIdentification defines model for ResponseBusinessCustomersIdentification.
type ResponseBusinessCustomersIdentification struct {
	Data  []BusinessIdentificationData `json:"data"`
	Links api.Links                    `json:"links"`
	Meta  api.Meta                     `json:"meta"`
}

// ResponseBusinessCustomersQualification defines model for ResponseBusinessCustomersQualification.
type ResponseBusinessCustomersQualification struct {
	// Data Objeto que reúne as informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
	Data  BusinessQualificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePersonalCustomersFinancialRelation defines model for ResponsePersonalCustomersFinancialRelation.
type ResponsePersonalCustomersFinancialRelation struct {
	// Data Objeto que reúne as informações relativas ao relacionamento do cliente junto à Instituição. Considera-se relacionamento as informações que permitam conhecer desde quando a pessoa consultada é cliente da instituição, bem como um indicador dos produtos e serviços que ela consome atualmente e seus representantes
	Data  PersonalFinancialRelationData `json:"data"`
	Links api.Links                     `json:"links"`
	Meta  api.Meta                      `json:"meta"`
}

// ResponsePersonalCustomersIdentification defines model for ResponsePersonalCustomersIdentification.
type ResponsePersonalCustomersIdentification struct {
	Data  []PersonalIdentificationData `json:"data"`
	Links api.Links                    `json:"links"`
	Meta  api.Meta                     `json:"meta"`
}

// ResponsePersonalCustomersQualification defines model for ResponsePersonalCustomersQualification.
type ResponsePersonalCustomersQualification struct {
	// Data Conjunto de informações relativas ao processo de qualificação. Considera-se qualificação as informações que permitam as instituições apreciar, avaliar, caracterizar e classificar o cliente com a finalidade de conhecer o seu perfil de risco e sua capacidade econômico-financeira
	Data  PersonalQualificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Default defines model for Default.
type Default = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// Locked defines model for Locked.
type Locked = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// OKResponseBusinessCustomersFinancialRelation defines model for OKResponseBusinessCustomersFinancialRelation.
type OKResponseBusinessCustomersFinancialRelation = ResponseBusinessCustomersFinancialRelation

// OKResponseBusinessCustomersIdentification defines model for OKResponseBusinessCustomersIdentification.
type OKResponseBusinessCustomersIdentification = ResponseBusinessCustomersIdentification

// OKResponseBusinessCustomersQualification defines model for OKResponseBusinessCustomersQualification.
type OKResponseBusinessCustomersQualification = ResponseBusinessCustomersQualification

// OKResponsePersonalCustomersFinancialRelation defines model for OKResponsePersonalCustomersFinancialRelation.
type OKResponsePersonalCustomersFinancialRelation = ResponsePersonalCustomersFinancialRelation

// OKResponsePersonalCustomersIdentification defines model for OKResponsePersonalCustomersIdentification.
type OKResponsePersonalCustomersIdentification = ResponsePersonalCustomersIdentification

// OKResponsePersonalCustomersQualification defines model for OKResponsePersonalCustomersQualification.
type OKResponsePersonalCustomersQualification = ResponsePersonalCustomersQualification

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseError

// CustomersGetBusinessFinancialRelationsParams defines parameters for CustomersGetBusinessFinancialRelations.
type CustomersGetBusinessFinancialRelationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetBusinessIdentificationsParams defines parameters for CustomersGetBusinessIdentifications.
type CustomersGetBusinessIdentificationsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetBusinessQualificationsParams defines parameters for CustomersGetBusinessQualifications.
type CustomersGetBusinessQualificationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalFinancialRelationsParams defines parameters for CustomersGetPersonalFinancialRelations.
type CustomersGetPersonalFinancialRelationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalIdentificationsParams defines parameters for CustomersGetPersonalIdentifications.
type CustomersGetPersonalIdentificationsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// CustomersGetPersonalQualificationsParams defines parameters for CustomersGetPersonalQualifications.
type CustomersGetPersonalQualificationsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa jurídica.
	// (GET /business/financial-relations)
	CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessFinancialRelationsParams)
	// Obtém os registros de identificação da pessoa jurídica.
	// (GET /business/identifications)
	CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessIdentificationsParams)
	// Obtém os registros de qualificação da pessoa jurídica.
	// (GET /business/qualifications)
	CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessQualificationsParams)
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa natural.
	// (GET /personal/financial-relations)
	CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalFinancialRelationsParams)
	// Obtém os registros de identificação da pessoa natural.
	// (GET /personal/identifications)
	CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalIdentificationsParams)
	// Obtém os registros de qualificação da pessoa natural.
	// (GET /personal/qualifications)
	CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalQualificationsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// CustomersGetBusinessFinancialRelations operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessFinancialRelationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessFinancialRelations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetBusinessIdentifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessIdentificationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessIdentifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetBusinessQualifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetBusinessQualificationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetBusinessQualifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalFinancialRelations operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalFinancialRelationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalFinancialRelations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalIdentifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalIdentificationsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalIdentifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CustomersGetPersonalQualifications operation middleware
func (siw *ServerInterfaceWrapper) CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "customers"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersGetPersonalQualificationsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CustomersGetPersonalQualifications(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/business/financial-relations", wrapper.CustomersGetBusinessFinancialRelations)
	m.HandleFunc("GET "+options.BaseURL+"/business/identifications", wrapper.CustomersGetBusinessIdentifications)
	m.HandleFunc("GET "+options.BaseURL+"/business/qualifications", wrapper.CustomersGetBusinessQualifications)
	m.HandleFunc("GET "+options.BaseURL+"/personal/financial-relations", wrapper.CustomersGetPersonalFinancialRelations)
	m.HandleFunc("GET "+options.BaseURL+"/personal/identifications", wrapper.CustomersGetPersonalIdentifications)
	m.HandleFunc("GET "+options.BaseURL+"/personal/qualifications", wrapper.CustomersGetPersonalQualifications)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type OKResponseBusinessCustomersFinancialRelationJSONResponse ResponseBusinessCustomersFinancialRelation

type OKResponseBusinessCustomersIdentificationJSONResponse ResponseBusinessCustomersIdentification

type OKResponseBusinessCustomersQualificationJSONResponse ResponseBusinessCustomersQualification

type OKResponsePersonalCustomersFinancialRelationJSONResponse ResponsePersonalCustomersFinancialRelation

type OKResponsePersonalCustomersIdentificationJSONResponse ResponsePersonalCustomersIdentification

type OKResponsePersonalCustomersQualificationJSONResponse ResponsePersonalCustomersQualification

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseError

type CustomersGetBusinessFinancialRelationsRequestObject struct {
	Params CustomersGetBusinessFinancialRelationsParams
}

type CustomersGetBusinessFinancialRelationsResponseObject interface {
	VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessFinancialRelations200JSONResponse struct {
	OKResponseBusinessCustomersFinancialRelationJSONResponse
}

func (response CustomersGetBusinessFinancialRelations200JSONResponse) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelations529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessFinancialRelations529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessFinancialRelationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessFinancialRelationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetBusinessIdentificationsRequestObject struct {
	Params CustomersGetBusinessIdentificationsParams
}

type CustomersGetBusinessIdentificationsResponseObject interface {
	VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessIdentifications200JSONResponse struct {
	OKResponseBusinessCustomersIdentificationJSONResponse
}

func (response CustomersGetBusinessIdentifications200JSONResponse) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications422ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessIdentifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessIdentificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessIdentificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetBusinessQualificationsRequestObject struct {
	Params CustomersGetBusinessQualificationsParams
}

type CustomersGetBusinessQualificationsResponseObject interface {
	VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error
}

type CustomersGetBusinessQualifications200JSONResponse struct {
	OKResponseBusinessCustomersQualificationJSONResponse
}

func (response CustomersGetBusinessQualifications200JSONResponse) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetBusinessQualifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetBusinessQualificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetBusinessQualificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetBusinessQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalFinancialRelationsRequestObject struct {
	Params CustomersGetPersonalFinancialRelationsParams
}

type CustomersGetPersonalFinancialRelationsResponseObject interface {
	VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalFinancialRelations200JSONResponse struct {
	OKResponsePersonalCustomersFinancialRelationJSONResponse
}

func (response CustomersGetPersonalFinancialRelations200JSONResponse) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelations529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalFinancialRelations529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalFinancialRelationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalFinancialRelationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalFinancialRelationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalIdentificationsRequestObject struct {
	Params CustomersGetPersonalIdentificationsParams
}

type CustomersGetPersonalIdentificationsResponseObject interface {
	VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalIdentifications200JSONResponse struct {
	OKResponsePersonalCustomersIdentificationJSONResponse
}

func (response CustomersGetPersonalIdentifications200JSONResponse) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications422ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalIdentifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalIdentificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalIdentificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalIdentificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type CustomersGetPersonalQualificationsRequestObject struct {
	Params CustomersGetPersonalQualificationsParams
}

type CustomersGetPersonalQualificationsResponseObject interface {
	VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error
}

type CustomersGetPersonalQualifications200JSONResponse struct {
	OKResponsePersonalCustomersQualificationJSONResponse
}

func (response CustomersGetPersonalQualifications200JSONResponse) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications400ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications401ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications403ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications404ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications405ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications406ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications423ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications429ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications500ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications504ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualifications529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response CustomersGetPersonalQualifications529ApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type CustomersGetPersonalQualificationsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response CustomersGetPersonalQualificationsdefaultApplicationJSONCharsetUTF8Response) VisitCustomersGetPersonalQualificationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa jurídica.
	// (GET /business/financial-relations)
	CustomersGetBusinessFinancialRelations(ctx context.Context, request CustomersGetBusinessFinancialRelationsRequestObject) (CustomersGetBusinessFinancialRelationsResponseObject, error)
	// Obtém os registros de identificação da pessoa jurídica.
	// (GET /business/identifications)
	CustomersGetBusinessIdentifications(ctx context.Context, request CustomersGetBusinessIdentificationsRequestObject) (CustomersGetBusinessIdentificationsResponseObject, error)
	// Obtém os registros de qualificação da pessoa jurídica.
	// (GET /business/qualifications)
	CustomersGetBusinessQualifications(ctx context.Context, request CustomersGetBusinessQualificationsRequestObject) (CustomersGetBusinessQualificationsResponseObject, error)
	// Obtém os registros de relacionamentos com a instituição financeira e de representantes da pessoa natural.
	// (GET /personal/financial-relations)
	CustomersGetPersonalFinancialRelations(ctx context.Context, request CustomersGetPersonalFinancialRelationsRequestObject) (CustomersGetPersonalFinancialRelationsResponseObject, error)
	// Obtém os registros de identificação da pessoa natural.
	// (GET /personal/identifications)
	CustomersGetPersonalIdentifications(ctx context.Context, request CustomersGetPersonalIdentificationsRequestObject) (CustomersGetPersonalIdentificationsResponseObject, error)
	// Obtém os registros de qualificação da pessoa natural.
	// (GET /personal/qualifications)
	CustomersGetPersonalQualifications(ctx context.Context, request CustomersGetPersonalQualificationsRequestObject) (CustomersGetPersonalQualificationsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// CustomersGetBusinessFinancialRelations operation middleware
func (sh *strictHandler) CustomersGetBusinessFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessFinancialRelationsParams) {
	var request CustomersGetBusinessFinancialRelationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessFinancialRelations(ctx, request.(CustomersGetBusinessFinancialRelationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessFinancialRelations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessFinancialRelationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessFinancialRelationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetBusinessIdentifications operation middleware
func (sh *strictHandler) CustomersGetBusinessIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessIdentificationsParams) {
	var request CustomersGetBusinessIdentificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessIdentifications(ctx, request.(CustomersGetBusinessIdentificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessIdentifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessIdentificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessIdentificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetBusinessQualifications operation middleware
func (sh *strictHandler) CustomersGetBusinessQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetBusinessQualificationsParams) {
	var request CustomersGetBusinessQualificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetBusinessQualifications(ctx, request.(CustomersGetBusinessQualificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetBusinessQualifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetBusinessQualificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetBusinessQualificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalFinancialRelations operation middleware
func (sh *strictHandler) CustomersGetPersonalFinancialRelations(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalFinancialRelationsParams) {
	var request CustomersGetPersonalFinancialRelationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalFinancialRelations(ctx, request.(CustomersGetPersonalFinancialRelationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalFinancialRelations")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalFinancialRelationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalFinancialRelationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalIdentifications operation middleware
func (sh *strictHandler) CustomersGetPersonalIdentifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalIdentificationsParams) {
	var request CustomersGetPersonalIdentificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalIdentifications(ctx, request.(CustomersGetPersonalIdentificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalIdentifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalIdentificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalIdentificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CustomersGetPersonalQualifications operation middleware
func (sh *strictHandler) CustomersGetPersonalQualifications(w http.ResponseWriter, r *http.Request, params CustomersGetPersonalQualificationsParams) {
	var request CustomersGetPersonalQualificationsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CustomersGetPersonalQualifications(ctx, request.(CustomersGetPersonalQualificationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CustomersGetPersonalQualifications")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CustomersGetPersonalQualificationsResponseObject); ok {
		if err := validResponse.VisitCustomersGetPersonalQualificationsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9y3MbOZY3+q/gcuYLSx0kRVKS9Zi4MR9NUR7WWKJKpGrutOWxwUyIgp0JZAGZ8qOs",
	"iNrO+tvORJTvLDrcEV7V9KaXw/+k/pIvcABkIh98SLLL3V2qhUskM/E8ODjP3/mh5vEw4oywWNb2f6hF",
	"WOCQxETAp24SX3JB3+GYcqa+8In0BI30x1oPT8jsDzi45OifxuMTFGFfzP6LN9EJESGNCfo+IQhL5Ani",
	"E+ZRTCWS5CUO0QUXjHjUxxL5JCLMJ8znyOcophFHPkGCeImQHEkeUI/G2Oe1eo2qTi8J9omo1WsMh6S2",
	"XxhjvSbI9wkVxK/txyIh9Zr0LkmI1eBD/OYJYdP4srbfaW3t1msRjmMiVKNPz89fn5//y/m5fPa7Wr0W",
	"v41U0zIWlE1r19fq0SkpL8Dx7M8hERz5GEWzD1PKMEyZyHj2AUmYEwxHqhlgtMbRFQ64gOcFDQkV2Yuz",
	"j6i93rSz/D4h4m02SejenYtPLnASxLX9dr12wUWI49p+jbJ4s1Orq4nSMAlr+5321s7W7ubDrZ16LaRM",
	"f9lO50dZTKZEpBMc0XcVk/w2wSymPvYJinmMA709UypjwSWKuLBTkItG35Cq8copdLYXzaHdarVWGT1l",
	"QAGNV+RteQ4Dn7CYXlAP+2r5gb4ucYh9XEdJTAP6DvscKeJH5IrGWCCMPM5iPCWhetw8LBHmiDA/4pTF",
	"yE8EZjFBGOnuZ39QxD9/DdwRfi66fNNLZMxDIs4kEd0pYXHF5JlPPYw4SiQRDaweAjJVXySzD4JyuwbN",
	"eYfsTcMz/TSyRuZNom02LP18sxkd4oiqQ32A4wpqPMAxRiQsTiDgU56giAQYzf4cxDTE6Iq8Qx4PkTqD",
	"HoliLprolESCSMLgOPoEYY8Ln8NjGD09PeztdDbbz9Yu4ziS+xsbMeeBbFISXzS5mG5cxmGwIS489dB6",
	"s/+GhFHA99EoYXXUbqERiVCn1d5B7b39rc39zTY6G/fmr+gFjmgDJ/Flw1cznUcRe7m1VB+zxfy3tSPO",
	"3o8T8v5fiP9+fJm8PxT0/QjH70cJW6+j83P/h841WvsGs/eHZPL+CIv33Ui8P8Jv33+TsPffJMH7bjJ9",
	"PyLR+6EXvz/mV+8PiLcOL25dm/f3c/9Da4+Pxu/Pxr31v5+/f5YqB1HX9wWRsryRQ3WQiCCzP3A0OFG8",
	"P91MCSyUXhGBcJzgICTqmAV8is1eOVu6ZH1TsqVRA5uhfDmyHbCYCOypGQ788pTPQnR2NjgAQttqdzpL",
	"CU09tI4SaebNURKiwQEwJC4ECTTLQYTFgsBNQ2SM1F8y4kySJurhUN+nUyLsw4iwK8oRnwg6xfHsZ7Xi",
	"cHDsmmK05gWUsHgdqTMmSWKvLXJFkCQC/fLjfxAZkeAS+/yXH/9Tvx4LzGRIpYQWJBFXRKwjxpGXiQm+",
	"GZyMsRqc5IipMSmhALqfUJ8jnigKuOAi+yoJzRAou5p9CKjP66jQIwxOTVOop83202xDGtSHpYm5YLMP",
	"jYAjhtPBGKoCKWYU4ziRqMd9grZarSbqOisDvWAPqyvC3ubpKP38kJbRZn5wC0UX8gaHUaDe9Xd2L7wt",
	"st3Y3PFwY8vHmw3sX3Qae5PWbmdysdfp7LZqzn2aJNC0Q+ebD+eT+b89bTX2cOOi2zh89sPudcP9uHWT",
	"j+3OdRV7uFaT1MQJLOER9k812apP6sY1NxiOooB6cF9uvJSc/YO6goUk8f+bxBeNXfVItjp/L8hFbb/2",
	"dxuZLLuhf5Ubp6a7vhBc6BHkD2XXimj6eFxwikIcwPop6YCHNKZKkMOxoJMk5jJ3cmRdEy9T0sPbgGNf",
	"kS+OBb6afZRwxaTvMYzOTp80a9f12oGVfb7SpNUPiDJ1iAX2OYzpkIsJ9X3CvtqohijmrwhDMQkRkR6P",
	"1BiB08XAFZIQo4gHs0+xkmd8xYumSgab/QHDvl1RHmAfq8k8xjF5jd+OaUh48vXW+XF33P+X7r+i8eCo",
	"PzwbowYqkBuzNIdjwnwKUgmLhdaFiGLeAQVVisgYT0iglCauJghXDcPBCPisHsBX2zfYI7U/iCjCYhxN",
	"9forltg9GajNYxyF1BNcqpuBzv4As3jCvVfE/2oDN91f12tHJL7k/jGPu0HAX3/FIQ2V3iGTkCpFRXWv",
	"2IlHpIQLx6rF6rpKQhTOPsbct5doEnEBmvJ1vaZm4qlLC08C8hV5q9XfNbWrQVB2idXYHalAjxT59III",
	"EPV8LsESAAw0nH3yKUYR2BSo+glYgWrsZcJiECo8rC5SIoh0WyHobHzY2DXrccgT9jX3tWzS0PtG3lAZ",
	"EzgilhlQddmHoKbAbg7/2bb/KJGKbUsrYMtDyjDzKA5OSZCaaRbM8OZTWqHLivkeYLVTkk9AMg2wR7mS",
	"ftR+RURKjtHLRKid9fCSGWa6+68zvUJ/S+ZG06c1id9wct8mOPgV55bvbsnUvrcPrzKzEyIkZzj4FQlz",
	"hS5vRpg+tpO8mH2Sy6f4hSlzWX+3o0wzteaSuX1ZwlzS3c0Is3LbRjQmAzm8IkIJ5V/1QpdGfpt90OP3",
	"sBAEbBkEYcSjVDVXrF/dEhI0j4hTaURDyqagGFthMJx9eENDuPnGJyM0DfgEB3XEiLpIQg7UDBs85vwI",
	"s7dGx5JfURBYPM0woTGWrrTwJ6ImL3CILgj8ZuViou5+n8RKHGBgtSVi9olru0G6QnpJtL3BituqSY9r",
	"hYLFJL+4arXOGDbOhK9IL72ctQQnagQpqeNEqqFvpGYQNWmtNKVf6ZlEgoPUOAlIn8U0fvs1hUDKYvyG",
	"qIOaU36Itrwo/Q7XUYhlJgFFXMrZpysSIDsRgbBElMlYJGYvjSmXyCZY4MyAwG8lCO5xf5HHhqCDgwO0",
	"dkClB0b+A6pGgWY/oQMq49n/r+6Rda2FBeSCMyWUIm0WI6iBJEGXPLkCq05mnGnvFUwtedtt3nQL5tT6",
	"5nWVHbVes1d31/N4orcsEuoQxVSbTiYCM++yepa92c8+nQJn7E5nf1RzgSPDtA3L+DaaaC39dfYRYeOK",
	"S5+XsTpgGGFutFN9S2Iu7ULIuvoxmv15ElCPIxKCAS5QfI1LhKXkHgW+DRZLYAExvcL6s5h99GnM60oz",
	"JG+I8GafPKqJPqZX4HCSaqxqz2mcaJqpaxKJuPYYSiJQOPtZ0Yk6CAIzScEwg9cRQufs6SlRSwqvPkND",
	"bbjhguLQaAjGoBkJQph3qQ7U9wlmwGs9sJ2ew9ac18AemdMtYA1RJGYfUYSnuHnOcrTwsLPTyVPDVm7/",
	"tYm9cu+9S+K9OqBTWuHMOZh9mlItq8AACr1u5bu8gQ27Dp5gspigaM6Ppk1bs0/AhAOOHmHmcdRTjFrx",
	"Xo4eCSxpgGY/SXcX4exiEVOPRhgYsc/RaHyK1kZKEwrBtDNWe3lBREqNSJ12cYXlenOIemqouefhGyat",
	"SEBQ7xIuPUTQMAFP5QmOZh+pXFe0noRImne/T1xRCZGU4YDnOmtVjXqCmTf7ICiWTdQPiGpJZB4lDs5Q",
	"pZna40dQLGZ/lMjXmyahM7CMa3M+LbolVQfapggmRylpWEceLp6CbCDAKBOqemWGtZE3XpBIesVzhNFq",
	"tUu8qUCNm9XUyJJwQsRC53cVJXa2trdbna3tfK+dVqnb3XqnVd2z/mLx9dNnSWh45PhtRFKBsqZtzdag",
	"/tSh7nRKuZNmunuWjoNPXhIvdnlxT03TiyucWT3HFkEZGI8NyQhiWIaEYwA/Se1phlXTjgTDT5u1eoHL",
	"kxDToKLDJ1TdnaQBP6fcKIYoiZiEctmy2XXqqwayta5hIfBb9Tm65IzM7djjYXoxut07snimJ95wSCeq",
	"58ohcRnjwDgU54/NJ5lnUd5lQHbbT9x+ywMr0FlxlOlS1u1mLiKxkgp7gGNc4TydvCQxB3YiyOzPjGjh",
	"KE94gblsMS8pupkoo8l29hMauAymiXqcSeoTgRuypCeX+lLj0PY5DHa5S+IRxc+kT+x9mm4DmDcDcMDP",
	"PqbDKN/zExKmPk8KEQzAI7mS+7gPDhXNSynsM8TdBLp5HhLXcaweS6TDqdVpLJ00rJnIIrICIoeIpdnP",
	"kuplu1I/Ki0mibQjgoA0YCxdYvaxoT5KFOogGqlvSjttVmTsOf8hAhnmpuRqJcaqEyS4lwglAc2fJi+u",
	"VBMdkFRA0vPK+Y5TUTj/XvPGxywd3Jyh+4kXy5HacY/IsbkbVupCXRInugHzPrx+DVfTQLfQ7oCwbj+V",
	"RyBjLOIFQSnA+lMZtnBkdIRJ7owhfdYJVTt9oCTRWOB3RF0HIWFcGO+ydu5j58T9lzrP2tYPwvmjbq9/",
	"rOnqYNhDm62tFiKo1xs18xdyq9NqtHYanfa4tbu/2dpvtX7veop9HJNGTEOy8MZe03LremOt/bTV6Dx7",
	"3/rHp+3G3rP1xtrm01b72fun7c6zp63GXvbLeO0f99VP5+f++87TVruz+Wx9X3/X2dzaVt+XPv++LBDU",
	"a28aU94wX6qBJjENmmpHxnrU6e8NGqr10QGNahK1KY0vk0nT4+FGkNBXb682Qu69akwwe7VBjSttw7YJ",
	"PD2J1IKkrc8JREKXRqMCfkPfWflT6UhKf5Do/Pw8abU2vec2buy5+YbUFUNRy08QkRHxHJPW6WGvsbm5",
	"uVfXAkPM0dm410Tfal7quA0UE0mUBKxGc0WZlwSKKrL2NAvEHE0C7vG6kimTkApkXrETIKUJgNgpY5FF",
	"nsTc50Ut556obkBUBUmhQGEuh5nD7/IcvJ7dWYtEirzVuFqeWCS/pmIEGhQsyhCo8xIjjNLYIo7IBaGm",
	"ofRx0G2gVTT7M1NqVlkqywVNwIXtY32MgAwxLV/ZE4GZf4yrTuexkgF8jI6w8LDDLoFLusonYhwNI8Is",
	"N26iU+LxkDAfJB8TGCmUShZGQoc0p8apOvBqGXLEoD+CQujPUYyZNST4HPlUEHNpWmEXHQpKmB+8RdqR",
	"j9R00JoJapawZean9eLZG4opZumJ7eZP2G7rJqr/JKWVyqi1vJ4KW6g2m4ZJPPtwRQITogZajbvrjsPa",
	"CDzFXW+ivoxJoQPgbzFROvqUmW9141lDah98kiBwKiuZQ4smuQXa3tltRNJv7LRD/+HeTvvVy8tGx99q",
	"F40kiwL//u0pbrzrNn6vmE/2Z+PZD6363t4c8w2LXh4vUZqVkBIQLYr3jk++UbTaVwQmcxIyaiDzO5hJ",
	"ZcSZD9ycZXZMylQHJpyEo55l2z5BJ3q1v8lWW8kZiq5jIhCOCMMScWlbk3Y0QO0onH2QHhY4v6ath7vb",
	"mw87rdbDnZ3NwkKWLVzteSYuHkaYUSJ7LHp5s2XKC8wmnEyTIZzudAE+99qds9usXv7QPnUWsNXe3K7V",
	"3RXd3t5WrDyVaauW3bx1u2VfKODqPXlbzVBP8TsIMuFKOVXbQMrUOvuI1LkVIbcJAurgSj5BYFYNdABX",
	"ke+vnXyzrpQIpeRdUV9LIYhomzBBMlF3T2oRbqIxDiezjyHYgMF4a4LzwfrmE8ZDG4tvR8sTdEHV5WPG",
	"LCgOckT9JNFdPiLsJQ4pQ12luksuqEMA6Ens4/zK77RuZl/NzEerKESpuem6XoM4uIgLe4cvUELUhjgH",
	"JNuqFeTNksbQbrS2byPcfVXRnceXRBxwLwlJpUJ/mkZOa99EiKk6vPp5Lm+quA7d7paeMhA+5luvrLxl",
	"jOauKOZrw2FMJCLsigfqRMg6iOf7SM5+Vpon2eAJwn5ImTl+oomMscivjvxW16qS7IGVKfYlUxknwaFp",
	"V1Y0TKQWbizL5OjbURetfZtgX3PQkX0VdfPvra9u1DjRq3ViJTYdHlBeVdU0WSAKXmAWY0lxlT2wnpkw",
	"mmht9u/IiHMRj5IAi9wJKiQL+fQqCaa4eNIQQSEJLrlAF/RNGvsWosxXtr6yVSV3Io8SpuPM+wGJBWfa",
	"mnlrjnSv466o4/4VssGCsulI+PWy5plpUjnxtSin5WWEqlsp42/OfbdQO9XU4Z8onSnk7G3Z041D6wFf",
	"xClKDXVDawb1F96X4KGxbkaO9Puz/2aU3+HCLNLH5zZ/rGzJeCTwOxqYvfly5GX2yKz1og3P35alzQaD",
	"hqhI4TyBS5ogElIpzfG12cLp3W1vTJ83URoEoXi1ftdJ9+OplxYH0SXeVI8NRsPGZvvhw9ye9rrHixyn",
	"a+fnr3/YvF7/oV0tcZM3EV0qtV3RaUaAdlJVs/piFNn+66fIFTzVHPFEyypmZZfcwnV9y2OrDGZKiyIh",
	"n4fUm30KqLGE+USHssREUC7qyCdSN+bjKl3z+OSbfPBQZ3ezs7u1vbmIVyy70a3LfO4CjBcdmb+cxegP",
	"jm+/DAXeFGvTaeb0NyxmEZfK+3zLV5LvU7W2OFDXTnnBu8E0YRIFfKpE3kRwiTBlPkaMeERK8JMq1TU7",
	"xL7JpQ+J9h9py0fZpnWoJEBZ4Eg3IhE8LyO3lzeTZOm5Hg+J0Hp/FqpQEJK6V+gYTxLB0b++IhK/onXU",
	"7uy0Clxmu7UgIs4d+Byj0Zy7QVt7FZ+ffZK5YekIpLuYRk2nSwLt7nbHPDrtLrxjnnYbv3/2w7xQQTPC",
	"UTI5oFdUmnjtZf7QXvktJSopLY16cbUq9QhTIbgOoIJjnzANDMETsPio0xxwD2Rs0Ib0c+kz6nlv9iky",
	"YX5O8r3Udh6ZTHw1GtB3p4RPxeyDOh2yiU4WMKZMfytQJcSi8fzabt9o+2EQOLqkXo9z4VOGY7JUa31c",
	"+dJ1vUYnUzLmr9liaho8etxXC3SULlcTddEYT0igY930czL/DNgf4VVs3fAIoyD16ofOkxM4FoSKfJgm",
	"dqPXYF5SGw520hA2G5sG3VFpcUx4LtIJZ5TvY3RmiMTH6JD4Ngw8L6dsbm+3Nlu7BWXW3SglkexUy1hU",
	"HmHK5gJfSHBLpdwsve+0vTISlHk0ylsEdf616WjCeUAwsyFISzgBQX3TlXH966tkHyIUYT1tlKD1ubEk",
	"nH0U1IOXOTjP0sVWlP6SxPTKGSjYmfsnMHyhmDEWSJ0mEkD2u5qrh0PKLvUAVCOxwLEZDkFYxxRMgZag",
	"ebh7ZAw0wLhEcBNAcnN2JWF1Qo1ny1zc2Bx2MMzW3duujgxnkEB6WXtpwE4dzX4W09l/qa6NTUTWrf1E",
	"IoKITy8gmkI2UdQkb5roQau92W63Wq0HhVPe3tlutUoBjrvlSMM5YYb8Navmd0/S6e2jofHxuZPOeRZm",
	"Pykhh05ZZg6q5HzMGMNdmtTZISnr5E0T+ONYfrBQ0hUu87Lb3qcFKckcImc5sgs3fwsulJuyIJ6yakev",
	"aLDARge/Zy4fniDjdBiBGT8vHwbvMDqiAWEYjWJygdlbNCb0DaHibjZ6Fr3sRRfz3HdFD7jPHUgZFhP0",
	"hEy1w8EsBBhgHfE7NTgxLNEp8QiNLVcMEFozlxwRcCv2Tg5VU+DDkiQ0djLd9XpuOXY2H+7s7G6221u7",
	"y31D7eu/f7/QS6TdJgt2KvMCGVsqw3EicJCzpHa/T0hAtE8OCD4W+IrImKrTDXFu5E2iIcGQICZqMKyj",
	"c5aG/oGe7/qGtYysGJEjfBAlaEiSaEalx+YoygfEAwABOMxFAaFIO1LehXqqta9ximnmhsedszzlBEA5",
	"DQQL3MsfBT9Vuo71QpvIT5sBA2IWsShdBikhs0XPPgLvgowzvVI45qmfSF0udRvLAdkYHmfqwnD9Z0TG",
	"OE7Sr5rnLCNw1FA9qC3+PiHCkkRhhKUZkBDhYJqEiJEpOArqKCQ+1YhaSQyQbjZNyBMUhBgdbGH2kCWh",
	"4lun/ZPT/qh/PO4ej/vPn/Qfd5/U6rWT02Hv7LR7MDxV7Crbb+f7FdXGPEeoO1xsER/M5TN+nhhek5cA",
	"pJTPgCxE6xbSIxdH6+JSaoaSHj2KRR3hKxzAHza9nr4DUcMLsJRpiIeNyNAhjheU2ctR+yJ1LLCGEYqI",
	"uKA6K49KCCGBo4wjbG5KxQZm/x1Sjzcu0ujIclC8xxkPqdf1YnpFF3nTHP+eZ4Vms6hcB+SbX52Uo3QM",
	"WOZcP5JMwftiUA5R77jbR2u9dC30ah/rqE+YZDdrtJ81ur7UzuL6flaLb80vyNsqDxmtMrSv4t4sW+id",
	"1k7JFWEJWdU4bx+/9z39lnxPha2u4pv5fJSS6Ejs1wUYo1SABscApnkh8RUWlOELNTzmE9nYbf/viWjC",
	"gJuMxO462pddG0x5EVfVNVVjd9Az50nmepCLlk/nztzYXDlwY8szyyMWWTgCzhwTaUasBDwizkBhyada",
	"LnZum5wQ531kmn8wPBufDh/kjQOD3PWFfQovUcAbvbWshp0c4UWsK80ldmyBOAgom66QYTwoZxgb4CZ9",
	"S6yb+Is0x5hosB+u1rtXzjY+Z6Wc1sI6K1qrWOpS9ur2drOoYm5vL8tXbde3bm+BSSd5FwPMUhcPqUrY",
	"zrPUvd2d7fZmITm3XTS5thp7z354WG/Ps7pCVlf/TUyYrARHdpQ+gUMcrBDwcUHfKfkZC5MQVVY2WdZo",
	"eTlzs9wrTnC7Yje375Z3meM6OqNmrlFBC9PpoUt3soqblcSZCi9x1dEbC/zOMbrrledaejCSmGtFq4ph",
	"/IxiHpzV4QSSltPDqmPBTSx5mn5O2BW12KY7DpiVHo2GH3Skbj2EX378DzW2xiiZwE8EdZqbv/z4n03U",
	"D5GHJZcZTq4Fz6Qe1YL6OwJWOqWgwygAGUJkgWDuGCjzAj0ILvWLRSml9dDa3wokdmuDLXAG2D1nwxxk",
	"AHf3DItTLANy/ZyXJfES5mtUWcsJcSBJ8boa8TAV9bjHhY0Hca8/x6KdDSNTFnIDdZO59Nqr0TVvfPV7",
	"+qyY9ao8K/PynyvNEFmurmyiI+5b460abXqtKi4FaY1SA7ueEsmDRBPdVnNne9OAMADNhFEAy2pyI1MR",
	"GQITmY6wAd8wDaixLzteYfMWCVHIia/+krHAbAqmGGQxFhwrKwOAG6J2PyCxmP03g9Ds7yjY3ZNwX526",
	"XtpxKVMT7GlZo/p61XHLSvzQmiIPk7CJjkmA64gjn7JLQgVHgA8w+wl0Vp/KiFscE7jD1TmWGFIVcGYM",
	"sWA8qC+lyfjWizclQpGXRdWQNr/BJ6pdayKyc8nSSxsAj+IJChHPAFguYxpCoCJsmJQcknXgFUHCJhpm",
	"U1DcQOvtzI4mAuKksGIUIkwB+8BA6TojhEhTRCVhKcYCzTxE6kEzoO8TAE33AixwEw2tYclZyV9+/A9P",
	"EOmRX378T7SmXiXriDB1QmNuBjhNsPABJC+FK+np4AG7pzERsw+5NQS0wD9qepr9UaZJO0z1rQ1I5mfN",
	"FtMBabBpCSC+ZgNAF3NoqSKrFyQzfVv0Bqe9syfdU3T8P39Gm82Hu606etR7BHE8nVZ7s64RVh5kqCqz",
	"nxB5Q7wkXUwwiaaxvm6H9ni4NI8EMW5WIFg0wRLsoBcQH5DGwfv6FhAkPddWYzVgkfJB3pzWGx6Pu88P",
	"+ifD0WA8fN59/t1gNO7W6uaHk+HZSfe453zRfdw96h+Ph89PTvvwKW9wm9te6VKY45SuUPqSMMWSSp2O",
	"6oJUyyrpNACDQZJ5HS8yr2MR7kODEFnwKO39ViSoLfL1FZ01xj/V7T1oopFhjdoeBzUDdKYIlnpw9qhL",
	"03XOG+vsRLdXq9fAmNk9Uf8c1eq1R7Dw/Vq9dnBYq9f6o1q99nhYq9eO1A9HY/WP+u7oca1eO1HfnTwC",
	"a6j6R712MqjVa6ffqH+O1T/q4VPVwKl6ZKS6HKneRurh8TC/l/BL9b6VJMFVXCfjokLp55Aw7EIcDv4/",
	"mOLwu75aDdAQ8wMzT1QO7VBdPGoM44XG+Qv1WOaYNl0fdWHRuoOCFbk7mNedtXQNmMdDcgig7Mx7O0dY",
	"xehCPWGkDahgYMDMfGxYqhXvsTuug0H3dNCFfTrqHgORfHs2OP59X/991D8ewR+PBkf90fgU/h6fOh9G",
	"/ezv7vFZN13YkSNlVM/M2PDuMDUlhMWJwMX4s3N2Xhvmfpt9RB4OQKIACAksYgrJpKmgOiGMGD+xLjeT",
	"E+qV9JwAf9TO6wqxDYJUKgHl4NIm+S7AIwVG5OzW4QmaYnapwUZ4Likzl9OaKPlI7anU3hYLXaGGC4zg",
	"vJbnxV94lzN6Tjuq3PgjLGiMA42LX2306GsmGuony2FiZkKj4ZNxfwD8ptcddQ/UH98Nzr4bwlhPuqfd",
	"g+Hzb84OBr1B94m6VYDTDb4bnvYG+umz40F3+Lw/GnfnMgP91Zy5DD0v0VkkSqJWk5nDFjQJi1ymUKUL",
	"AXHVouYcBcdUrz8Yd58f9g/6egt6j4bVQy4/Wjn4qmQYG0m9iLvx6mjP/L1/cgicbjTqngxPYeFhoM8P",
	"hr0zfcF/N+g+7qtbCKI157EJC+2Zi/OuHl0+DyuLaqpKyip4mgtCy/E/qStMXXrHg0O43PrLGVoWqwDZ",
	"9Xbg9w7cv1YHbrqtRaCXBShWxTNeCS6kHkzX9IpOixLKZxCaFUc8HXeHz3un/YPBGBjFSf+028t9Neo/",
	"PgPmdnLa/25w0D/uAdseHH/XH40H0GT64rA/et7rHj0aDNN+R90n3VP9+bSv307fqbgW0t4q13lE3pQX",
	"9jwHJWGtSLNPMgZ/KmY45iG/UKJ9MPt5Cl9CKj9VetFUaY4cXfKQhBCoFibBJRH7aETeqNtFeklAGf8H",
	"JNXnCxJSRhk/ryledszB6KW6NTVlRPoEYkqFsq9r3ClrTLOldYznIUeah/2jwfHgWAvYo97ZE/13lQSa",
	"PVlarMfzQkhXxOCowwo5RpAQ4DXBrmTSQj3VMGGgbrhhswDJKXCiGKpHFUsF/uDgJrrZT//yeLS7VfK2",
	"q6suTqpu/ZzbyMfoiXkyp5VNCbeqkn4wE2hRH7CNGnstRNBeq2nUqEZns7m9BTF9D5poraP2FWgn1oCg",
	"V7NPYpoEuI7abWSsMH+yWaXZljjNLDT1N/5RG8M71+fnTf3nHGCHgLPpqkthH73pWrR31WK0d1taq0QP",
	"GlsPmw83H7bbejU2b7saWTMrrcZmthqVYZMFQ2VKJO4qVdkr8/rRXZP9dCurZfoZheo+hWpRCtWFq9Ut",
	"8//M03WLxJE1Wl8hUbByb0t7+p22quuClCVduYzud6tmmqj/RglAEuQubcgPOSOx9igosYBxFM4+MRpy",
	"ZBkV0V9qiPYt86Xlv+qqOtW2UkFDjeFKTYFGqRrXoHu6qCQWUE1KVxgjQg0iFtzDulqeqRAk9GCyoqkS",
	"pbFTXNZRLPAE4MShMBVoLRpmO3vIgCor0ecd9dVLGEk8IaKOBAkTllrPtJlSNacz+etmxeDKguBOI60T",
	"K8ELrfCmk5XNc3aI35Ew83OmpVBxsTeeDR5LiQMswE22JnEAk1b9mIuPy/V/gCB1MMjiOQPTEEx83q8k",
	"VCJLrAbjPMI1fnBxgunvZlEziOJ/QDCvmAhPN5WWANP1C7BeaouZpY8tNriXMpnI2SdfTw4HyTSZfaSw",
	"apzFZH8uyPIvP/4fdEDUohrbSeqL5MVw+Zb6r9naKl4FnXw0eZX/v71t74XOvFgALxGi2i50BEZs50Lk",
	"pTPleDw5CrlPAp0ytdVp7zQLOVNPFuVM2ZSp5VdXypHSgS/iSsX08jkcBRzIaSJ5zkd/E8Y0r5kvwZjO",
	"mZP6rn1ibomlCWGZe49DqlAa/g1MylVhmyuTXHsByVlZ5DdPdE6U5V2kJdNMJi7d6rYv2X/dhrpLIs3G",
	"5E3MUUCvBLEg2E60WQHjNPO9R+bUUe2Uyzvvs6QJ6+K3o4GwJzpNcIC0fluky3mRZRUAcatHlr0luCJC",
	"qct4CW0Co9PbiKSdlpI10wrZe3t7e+kwTFjNHHpbgcju+do9X/vSfO0Yax5hYrvm5kXgqUgiPDcpYvYT",
	"soGUqa83b6QskaU/HxVM2wRVt7HA71yzIHHt0C7DMo56E3MB1JkfjxtxmXp5Vwagd5aphDFWDO8HzLPs",
	"BUpkNQNOK0IvCEUEO5oDUq4rrkiZ4ML8sik1HS6s1RkIyeK+zew26kDufWnhtEzBlSyF9obJ9Npy9KDX",
	"PS6mhpbQW7aKBShGT8/P5fn5aJUcyTmLXHfIagm5L0G/WRaorXdPX5+lPTS3n4aYAAbwK4RRr4bJUOSb",
	"d4dlWAlXxyeKJ5qzyO8BdW5qDaJSJmTx+rpwTOn63q/qnWCKSFXot4NZ5HCB+hJWnlbfyDPuUjqAy8kN",
	"nxAoF2+eHZ7UtpO/lwsXowmKLOBBZ62kF6cb85mvZdXZ3Ovsdfb2FnHwu6XkfoVFhThTUrmydYSD2ccQ",
	"KY0ggwT7tZZ7NOwNuk/QqN9bdObugLxUdTVW4nt+IWhUVIIwhVvpTiAFpRR4tHZABSDgXyTMB1Ocmylf",
	"t+Ciup3ZR4R1mrwDGT/7qdimrqSToipzA5GPGJYeTTluaGGWJQTGOnnzJsqX+xhpGA+1Pk6JHRzNfpbm",
	"p5CLmKxXJRrp3IV0gbL0BV6sq1cupxdBcMX4baSPyUl/NBp2nx93x2en3SdF6eCbBDP0z5gqWbwXzD4k",
	"PuXo0Kbx3U1a+Q1BXJf30NYicJbhM+ziN2eng4NBr1vcxl8HVduyuO7qovOK/L1SYDSh4gt5sSABudJu",
	"HAOZpw5W4U7PqykQwHR7k5MdaG8+eubsk5wrr90FLLO5TOPavM1E+vfi/ZcXRO2CDe7F/C+4usfLUUmr",
	"8WuBYWmD+ZPMYB6ldpa04KfFC8s3VY0gPhcpqHMrhjNeMVV0aejqdb2W3S6LMgPT61WnG8Ukk/gsMGFB",
	"euKJuoqpKf1oY7vyIgjkR+Rus8qwUXmJBbnkga8+l5msus1ZnOhcxbTKUHZRa7ssRmvUagOKuz4sWKzX",
	"m2howPOV7Jrd0NklJDVyyoIuMs8HT5BMIki4Qxh1tv+XjizaR61mB3DT0BrU4NHWYyfIVT87ND88aKMH",
	"zm/tVut/rZedMfuGbKvsibGVG/S4MFIaxxBBbXxi7tUFMwqxmoGSCdW4ihmozW2wxef4Ck8mASmBwjlm",
	"+TxEnC4nBvb4h18SGGsN3xIZ6wviYq03UQly7p8BPuMustlNSiYWqfnXrFbyW6xveF8x4/MhvJnbiTsA",
	"VzhOzDRYOkknT/mcDfOmCJO0nqtmBcqeJGFE2CUWxpuCJbpIWGrEt02YuvpOX7N/h/R+yMb1OPOTd0in",
	"wWKbDJsF7mMpKQOlJ/N01VGadO1znd1g9EISYM2ZFZup20xUBtkJkZh9lDENdWxWEgs1ZDPaKRGEeRSi",
	"4LqR0lJBtFRcQq1SQNkl8IQLYWsCp1REdLX1LK3VWnXAsJGqy1ImVNir0TNwuYU7Bep8RZCnNLK5EOa2",
	"TQvPpbkQRrbQ5MZyanrV4qerUsx76kHUfffgaHA8GI3TvIaVzGeOXFQQvEpCZrWJ7S2UOZePMHv1hLJX",
	"FW4nDSAwjAijbLqYYeMJEepOS+u+IxuNp+f8ty7WkzAK+FsiehoXsGKhMpurPhBkCgd8rXd88s1G7+Rw",
	"3bnaHCMSw0vXdnnRt/cpxGel08yMfVHNzNyYbz5ONHTfTw1YZZG8fKekqFAarlg4NmvnKZCGL/EV0UjH",
	"V1p2EK7trrRYuwXC+8f/5/xcrru8/um/qf9VA/2Y86OOT3W1wurKhBmAoc0dSiEbdManSDOM8un+asnM",
	"cqK1CWYeb1zw4BKvr0oEy2YxkNFkvj46GJ08QmuDXEVOP5czcmKHKk3wKQQRr6unfvUlKIrwjb1nP6yS",
	"sJA7CuVTXbHtFWtYr+KclTzY5Bba2ux/MTXmkbEqQBqWUjnURRsreUNpaox41C9UWK3wmUwEZt7lElx0",
	"jLppkRsSq5Yc/tFEa+mvAJThk4gwP33egmZgjnCcpl5DGpSZpqxDnKARFiHvCTCVCTzkYNzDGqvR21ub",
	"IE/MPvo05nUNTkOEl5Zxd6774gGv28AYLSApLhfOflaCG0/0GlOQTPE6qFYFb0rR2J4q+WWru7XanwNd",
	"ndfKjkaD5CJmH4Ewisrxw85OZxm027z4M0XvB3RKK2j2wFqdzCYWei1W2b2pn4YsJqh8yWDHfQbEPy9K",
	"XrsOc3i3bjVoqKEwGp+iNYfdjdVeOlGbaZy/XG8OAdaf5J6HbzSUi44e612S7xOiBOKhTiU4wdHsI5Xr",
	"2mCFpHm3gE1CLOQvHE8va1WNWjFFk1ChVBvVUmad8bMiA1lMVSxmf5RpaQHoTM2CaJNCfjl9Ah1k5R6U",
	"ghDWNcRKnpukAzHit+o1tUy+8YJE0qu8s6OE1L9ZosbNampcGjlRTYmdre3tVmdre6HiDwUC6p3WHMtP",
	"MqlW/UbJxOJi6lO4dmV1vPV9ZPGDMscfajjrZCppq9UMsLAPm+hUjCRVE5CogXRNHolCrnURSwXZBSvB",
	"VKiYEVQW0pg/FiBoTl62ou3hwXAEgG8aDkvDfqVsuTwkHlBfb3dDc+owRRFDXvKSSzsbdbJgNGYcojT4",
	"tCY8lTwA7D0qAfNDF1DWBPoSOwFtUGo+P4UMKyDtN697DY4PBt8NDjT4RW94/M0ZZEIPjk6eAHxO9tXw",
	"yeAAcDBymb25928NlVgJ0VZGe7Ncz61WlXHgFEbRUuMiUaPnVBtevdh/WsJFMUr4Sdo4fRaDUJ6D6KlA",
	"6Z0bWUsa8HN6UqCw1UpxsHlw4IrgV8DilIvS/C3EkNt92Ux70wFpuN2qAbnlwxbAk5MMVkrefjh2y/NF",
	"y0rDKlBbcYzpMtbtRi4iLzeGtTJ+W8dum8tkLqw9Osgiq6vmXwjOmV+Zo7Ji/MlhE52zrkm/K6bRV8QR",
	"6cwCLBF5Q6dWlMbolEyTAFve9V86OYFOuVDND6FOB5jvKurHW7wSe0knoeOiu4BAIdNFvhaIvZzh8OWC",
	"uqTWpegkoeqkKo3bDCAJMXLB0RTht9tONSFgqbOfUZj4ODT2RY+CN+Fl4lPQndHQGeDsIyIhjalvRinM",
	"KA0+2vxknAVhFTr5lLvuLA6ogxEXcQn/fHt3p9PZ7rQ3dwriZLuysEm16qvbXvkY2eevrxccgEO4eikO",
	"ToGaP1eVB/UBggpTE5LV4zTPnv2EBq78Vaj9UHh9ce2HtDqDji9LwxrNKcyHPdlhlNWg1C2VhCb2X5sM",
	"5oCpqCEoWlLN89AA42slCKLaZB5nR5ZTi/RdKv9ytOjmDQqaFywBVZdHlcF2zkQLYZDpzFPrSUoQFijy",
	"avaJeUkAuJBgp4s1tFk9q3gA+GRqm17OPuhvqcBhXUeYAaIkYFVki1Ow7hFFCTzRaKqZNVDxKoDwtEMA",
	"AdJq5ibTKm9O1JZGbPdE6eeONQitzd8S7ZseTuS+pk13GEi1NuVWQDVWfwHCrUc1HCS6IN6lPYTFYRnV",
	"X6nbXMrZJ6X0T7FQzWoPNdxmPpcZj5Mgy4YF+yrQ/k2op0Qa1+DQHuiX21WSiIjxhOpsFbhkrtT1vzpB",
	"OaMFGAIKhQIdXLu0B1v0Jd28dD1x/iz5OG+Dmv1UOFupgWhNrhvovNIOmKx7l1IlxBDg0PxWX4Hc5g/e",
	"TBbri69w2oGymvuo2IAlC/Im0lM3fI15RAhQcVKYLowGhzY80ECMpn1fcIoMPmvaJL6iEvtO8HnhpMi0",
	"G41lmv4AVKrb0sCjSSxU5010fGsiJhWLB3dYHaCWDOi4XXftyIWDi/TB1cVwgbXgJurmyUHj+sblkHcD",
	"pJqaxSLiU+3czY/EQfN1jrQOhpDIw0ynha586CqP0NKDl6HLLapOlL/rmiVD4Yo+7xI23Y11h6xw33Xl",
	"ZPzEi6UBVZM2SGu16kTVoGzXIM/ZBewsX87SCLorlzXJJ7y5VdatXNIsLnxFHJONgq4YCgi0GkJs9GDV",
	"LPPKcSyMA7Y1HecUSL5JvE1JVtRoeDnhEh2m9qUmOsih2oeEcWFCw7Q4gIvp+5rrgNH+UbfXP9aXwMGw",
	"hzZbWy1EUK83ug/huYMr+r6E1hcuofXbI6rFlbtcDjPnUqhn6ln+DlxkTMqczfMV6UVWy8ycVEQZN+IW",
	"wshabhBHRNtd/Hy2XGqOBqs8RqU44hyYs5IktHRkiNAkUhc8o1TEl4sZcj6Ha8lhy4NP7O3uNVqbjc7m",
	"byDsZiIw8xfFrWB0hAXURbD3Dlw3rndPqY/DiDB7rTXRKfF4SJgPthMTqSjSshFgLLGycR0Z9FpTB5qg",
	"EPpzPI/Memp9AzSmxQZrLUaHghLmB2+ROjFEIMi/Wusm8SUXVALtm5/W8/fiMAcq3r1L3vx9fiPkN36m",
	"fMMl8pjOs6NEVscNVdqsK2OJ8nGhiq5TU3MDmZdcyzZ2UrcVu1S9OtGPJSt1mo6nFBAl6KnzEBNhVS6A",
	"CIT2pB2kdtKFsw/Sw6LgcX1aa7V3djY7WzutVqvdUvzJ+WL74aa6DVLd4XYBTQu1Bc9xfq2i/aTOsut6",
	"HiJmlZddWJYLW20ipx19phRjJwHarVdxzr7WmTxnn/dUNstF7z0g9s95KD9PEsc5u3UaxxctcF6OkLvR",
	"4qzqz85XVZlXOnthqeyFB/gSSy1LUMwWokUZ3VqXmLQVM2MSzkcqcikMisFV1ZkM3ZoXN0gtrgC1w/Nh",
	"7UiubMatvGkLaqgWDlM3xJJqqDa3LOSNpIewqhTIMlop1w+5rtdYflNvioe1lIC4C7Qkl9WeKJWbuKn5",
	"rITPtdiYleo95YGdhYVYLBMkRBANk1hLAIlMrbl5vA+DADzHMdNEkOiXbz7NeZB0yiwivilGZ5sBhH6S",
	"oEIoaL567M5uI5J+Y6cd+g/3dtqvXl42Ov5We6vCoOWk4OXduE9x41238XulfGR/Np790KrvzcFkl7oK",
	"wTIaHJE3f+MJfHmJFkZIdUXhQyUb4DvhZtxbmu4tTb+ypcnhka7270oVdce+4srt88UHRzMoamcL7VNF",
	"8Oe7IvEWUaT/slFjzeAWrdAdcQ1PIDU0CwVLwz8RjgKq3YmJhJMIBTRykBTWLlMqpxxi5jsx9nXj4siJ",
	"Yz5Bs5/FVJsGzw6bqP8GckH20enjermzfTQanWycjppzAvoLADJP7Pt9Bz8jSxC7AKe6AYspchPVEVRc",
	"vLW0tkrw/hURbpZPJRLFUh/kIqQcv9xRbpqFGXbuQSD/SuAKC6b2jcV4JnnL9XZnr73X2v0cwH5LPc9z",
	"69GZRrp3wVwtnoRMHcMIIx5pKtJ+YdDOZB5OOA+ddNrvNqA46y0FtZvD7xVDHhdks3qceTrgAqpPUfzS",
	"QFxBpokNzNehILnM6FQVRxhdUIge8dTVoJWWDBpL1+cnwslU0JlXblHwJipryd0ooJ7WjKQp5D77qRCA",
	"iwSRVNcPdyqQI59IvYW2GkjeUnpy+PlCXNPg5WYV7OB84C5awu2CEt1qu8jqwF0PNHLXg9tDdyn29fqH",
	"zev1H+ZlF6/CjTNcS5+jk3Qiq7DgudL2PRLvfAq5X9g7gvG6VNosQuTsbHe2N7ce7u5sbW3vbe12Wg87",
	"rYXK3SLra4F7ZxlAhjcsZOC51I8by9/dYJowiQI+FdjnieDShOjp3CuIFgfJOiUha7IA0wTEHVuTZwF1",
	"/BAK0hf4yo1uepzNqhgSkPN4ZRXaDa/Xppx8TfHMHHqFjvEkERz96ysi8StaR+3OTrE43vYXAEP/zEjo",
	"ptMl6dem75sAOxYqRHQX3g22RMT63y8YY6Gu/zLRrVd+67pe00X6vbjaivcIUyG4zYZxjGk8AVeWYnxp",
	"6X5T/RsjL31GPe/NPkUm/TtbKlvIQCYTX43GINpktTabNwrddA2KxWuYsFjcyUw/nVdxdNGKV5cpVXfP",
	"ZErG/DVbTGGDR4/7asmO0gVsoi4a44lB4cnKO7vPgDsZXsUptBxGQRoeGzpPTjKsCTehH7t5zjAvqYN7",
	"dpzMJ53FDN1RaSvO8VzGI3YqUGB0xtKSIjolS/tacxu1ub3d2ixqMTvuRqkrcadaWqLyCFO2COnQ5WiZ",
	"IAmJZpGgzKMRDnIDikVS6cxSK7KEPRDUN32ZaFB9oexDMjssqE0ot2FYLAlnHwX14GUO8VTpaitSf0li",
	"euWMFOIG+icwfkG1a0wdMBIQgTWWi4dDykzShWoEAEMs5jzWYaZTXZIPsqrUDaQr5yPGJYLrADJZsosJ",
	"m8L/kC5navKb8w+6Rd298+rIMAtdgzxrL01eqltjkUyhJmTdolRJRBDx6YXOp9Eoi030oNXebLehlm2x",
	"eBDUpi0mw++Ws9KrCSjmr1k1D3ySzm8fDU24kjvrQhKkUoLolGWYbJXckHGbppBRJZHx7EPGTnmF/372",
	"KaD49rysIBOZQ5PJBM4yOHS+osyUhbx/vhiN1NX2Nxgn1Q/eYXREA8IwGsXkArO3aEzoG1NK4Pao7LdI",
	"6/0NZ92uhud7gwTZv0mv6PH//Bltt5vt3RbAvbe31L8vMVP3vvqz02q38uTdwyLg8nOgQ66QDWPjosdv",
	"I2IZ0tw4mvR8LIupsS19m+Dgc8RTcwtBA499b1utyjzO/7gk8xiXUHiU+OdRLOoIX+EA/vCwwF5MBICH",
	"EKdkvwNCYVw6FzSruUayvGYOdJKBcgoqIZICKApH2Fx0JK2U28gAVSpMdFA04TcWylnbbj3c3d582FGS",
	"yub2rfHnaKnu++r13d33cy7YVSJzyr7b63qNe16iQchXDWIapm8oCUS9ZX0IWVsHLkncvv5EE43mORJ+",
	"lx/479B57bTf6w/G3eeH/YP+affJeU3Jbee13qPhea2OaFbLKYOCUsqVVrEi7AvOQBXWANCFniv6A19G",
	"oWk9U5D3fYy4ekWPN01WHRxqo7gk04Sgiu61W7t4GzMSqh96j4YlwO/2nQpm3Ae0fOGAlr/gyBKXkVde",
	"ovNS5otoR0uAYI+r2fZa7+RwQ7Hd9SJArMXIhBx5SLa2mBkuOGYePlZn5Gs5UQtJXhbZkEuL/voQsjcY",
	"6982jOwBiTFlmnRWphv3uj+2HtWs4m1WUWktJS435X5tLjRrGY4zBQ9Y/7Kktuo6LQas9Q1mrW9hHw+/",
	"/oRXhqV1ETredqNI8CscLEHghodSa01uILfnDRbSwnrQ1QHRTh/glyKmwSWAyFhIhUxw51cYyu3pMCwd",
	"LGxyKdW7SSABB/W3gA9+F5ThHFdYcBDmk0zVbXaq9Q3yKJGUESlT+MESgFX5ivON5rhIOLbtVuNhXddr",
	"AWWvoDV3I3BEm0/gh7svP44oaM4h0aMt9nOkvv9c3RQ2GFbIztEM4Ua7kE99nr8FK2Uj2NYr8qmXpSTc",
	"79KiXcrZU+52TsqmmfvVz69+X4gqkzxRX8tFeZXLXFyqBa08zT5dgOcKnBmgtxU0mO3tG1VDU+w5qLix",
	"SSa+BWSqMZYiLtBlEmIGcr2My+MqalNbuzcyQtI4qCp5PPsUJ8FdxnGTNSkh24JXRg8tXa/KrMAMEmhz",
	"Ccv6GrRsiHAR+aY5xZ/5ol0MPHnPRJbswme9aBcAl9xftHfZpc9w0c73gdyvvqdBbSXxEkHjtyO1ZHpl",
	"h90kvuyMzA/l6+MwSN5wBE85gOwmU/R7sOkqhTOKNYIfu8QIa8cRTnEEF2OoolMCJbfyPidBfCqIA1MG",
	"oeHq1HmZMTORiYELtWlDOq4nTDEMm0rzDPhrHQ2pEVfe5RwAuS/PRFDbr13GcST3NzbUT+AXFk1jG93I",
	"PV2r16THIyOFpPDu+7W++pqX18uszOwn1D0ZpPgw4FQGGyAPtAHQCifSvZUlmn00PuwrirVPTUrKmWzq",
	"sJBXZPn44akcwLF6qKMaGEaE6cRkDn/1OGPEi8tNNhVdKrJsRtxrCkx9isMm5RvN1yQIGq8Yf802VBvU",
	"b3icXdBpIux62V7dHjRBUxOgahL1Ulx5dTLiBhyAC7V+/1u9q3qnbDoRTS6Urs/AKll7zK8AKGL2Bwgz",
	"dzF/bCGQX378P6jv2uX/BKASSW6WThcNHX3WNKeT8g0sCPaJ1BXiiM/FhhYFc3G1JwPI9ygARYGT0tSt",
	"WTTAQywJ6jTPmWpHQ0jHXDCcQXPOaZOkGFV5fMk6oswLEqprIppyOIXC5PWyq9cxntULbl3JJ4IUeklH",
	"5WvoZ3ikBG2dtplDubYpenMLFvnpkT4/P2cnupaGJFNBbFVJDUdYwiQu2oDhfcNzcmnt7nDguMZcdcol",
	"epEeyBdgMfs7NNShbHoxzlkXvTjlAXmBChBQbhVCWCEHlhnifPTqEeAHUFbjxUH3YDh6oSc5bxDGl2de",
	"igS5ggoaqUEbgJhfwFl/4cCXcXSpSFegF12XjenOACIAXgEToNDAulg4Q+YQK5lbsrUX5vPAf7Fu4Jr5",
	"ktJT6U7WbcCSjg+gqk8INfk+oVAaVJM9r6sG1WR1eqiMNbVyic6ZpmZnjBC94Iwqp/g5z8Gkh/Y8SSK0",
	"fVSXlNaXlgVCT3HSFTW7TbtLk/nusQlNzS3U1exDoJaGmEAtCagY6EX3bPxPw9PBqH+gt2H272lZS/f6",
	"0H1bmAdnHbT3SCcFxwLHvI5I7K1DbeWXGPlUDUkrfot3ZS1FKJYkRBP+fUKo5hNpUUw4U+QdNpNI65I6",
	"pVn+RORGbuISIJrtEz6X6zDNbqBm6FMQFCR64dxmL9zCL9IQo0XqzmH7ZpjAPkaeoI6XM7f27jblCNaw",
	"AsueIKhYkmlCxZJBGfxmh0AMHZFQ10pKD+sLMNU7x1wzkL9DJ1njlW3nJAT1DnADaByi2tSD8aXMWEEd",
	"Yb2oahgggEi09kILKC/WU4R+aXzMYWF+2nxv1loqeWwCxa58LPf1kP8Ovdiw2fkbNKcByRfnDKGGK5Ts",
	"q2/Ud4/74330u9/1zkbj4VH/dPT8pH86Gh53nzwfHPSPx4PDQa87HgyPR89P+92D3/2u1NX3rkBf1VN1",
	"692DwVi1230yOD4czmv8wmrVDWHU6tvNZWFvE2MDvMuqPTobDY77o9GSVUu7Wrpqy3tabU53XMFlvYFi",
	"4xEmQVo3gl43wt6lEpFaJdnt9evXTQw/K9lww7wrN54Mev3jUb+h3smsZbXcMUONKpGsVq9dEaGTV2qd",
	"ZqfZhvCfiDClje3XNpstGAecRzXIhWujHpiSiozbo9lHddcbDJ5JDODeOt5XlmGbZaXE5Dg7iX4nJ59V",
	"lPS2d/YyLa0GM9ZyvNISaumiPSbxXF8QgMFigUMSg2b0tFqFzx7ZyEkmtev60hfeHOKIqrfAE7bqC3b0",
	"gygrm7TamwOliWDPrMMqb9m+ziQR3SngRD1TCrw2hQBBdFqteeaN9LmN4T/fwKd3Xa9trdLoI+yDLCxj",
	"/Up7+StnzGrBGg5/q7W5/KVDLibU94kZ2dbyN455fMgTZrrYXv7CEYkvuX/M424Q8Nd2bA9X6qnreSSK",
	"8SSA0L6tzgozesK9V6aTzt7yx8ecH2H21iw2JFhtr7JBA2P60QCx2kcC766whI9xTF7jt2MaEp7ABm+v",
	"MtQRjclADq+ICDj29Rx9coGTIF7+8oF50LU3wcEvWpqe1owktp9KZLW6Y0Z5lpkknta0OaH2TJ0cmYQh",
	"Fm+hyFKsJB5QAL44p1QsMMZTxcUy5ld7puY594K/CbMvzqKgnt+Bea/EuweFkd8z7irGvfytCE/Jqs+N",
	"6LtVn6UaOLHxirz9/NdHwUdyf3fc6e7orLIMtsTvJCB9Fhtky/t756/63lmBY690ieRVt7vcIQVz7peW",
	"/7/ND/z+Cvk1ZP+86/Sed9/L/b9V/ruc2y1iv4tMgn8ZRhvr0/ocLHtuVNE92/4ibHuF6LB71n3Puu9N",
	"Np+PT67E7H8Vg82XYNz39prfjL1mWUzr/cVxb6+5v3Q+p73mJjfIr2Ct+RL3x72t5isI/fe2mnuB/573",
	"rsLr5rJeGLJaZs2m8kwWShJDSQuCoPQ8tF6KEcIRbQJGQtPjYXMiIOC7YSK+N9LpbVx1gHHM7+OfeMgD",
	"bgKQq7q5XLmfZ+l8ix0OI40x9ydiggMBRGcKEDlFtK2eExee1sXLAuSzlbx+dv1/AwAA//+8CZzRBDoB",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
