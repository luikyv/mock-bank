package middleware

import (
	"context"
	"encoding/json"
	"errors"
	"log/slog"
	"net/http"

	"github.com/luikyv/go-open-finance/internal/errorutil"
	"github.com/luikyv/go-open-finance/internal/logutil"
)

const headerIdempotencyID = "X-Idempotency-Key"

// IdempotencyMiddleware ensures that requests with the same idempotency ID
// are not processed multiple times, returning a cached response if available.
func IdempotencyMiddleware(next http.Handler, service IdempotencyService) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		idempotencyID := r.Header.Get(headerIdempotencyID)
		if idempotencyID == "" {
			errorutil.WriteAPIError(w, errorutil.NewAPIError("ERRO_IDEMPOTENCIA", http.StatusUnprocessableEntity, "missing idempotency id header"))
			return
		}

		// Try to fetch a cached response for the idempotency ID.
		idempotentResp, err := service.FetchIdempotentResponse(r.Context(), idempotencyID, request)

		// If a cached response exists, write it to the response writer and
		// exit early.
		if err == nil {
			Logger(ctx).Info("return cached idempotency response")
			writeIdempotencyResp(w, r, idempotentResp)
			// returning the response as nil guarantees that the cached
			// response won't be overwritten.
			return nil, nil
		}
		// If the error was not due to "idempotency not found", return an
		// idempotency error.
		if !errors.Is(err, errIdempotencyNotFound) {
			return nil, NewError("ERRO_IDEMPOTENCIA", http.StatusUnprocessableEntity,
				err.Error())
		}

		// The idempotency record was not found, then process the request
		// and cache the response for next requests with the same idempotency ID.
		response, err = f(ctx, w, r, request)
		if err != nil {
			return nil, err
		}
		_ = service.CreateIdempotency(r.Context(), idempotencyID, request, response)
		return response, nil
	})
}

var errIdempotencyNotFound = errors.New("idempotency not found")

type IdempotencyService struct {
	storage IdempotencyStorage
}

func NewIdempotencyService(storage IdempotencyStorage) IdempotencyService {
	return IdempotencyService{
		storage: storage,
	}
}

func (s IdempotencyService) FetchIdempotentResponse(ctx context.Context, id string, req any) (resp string, err error) {
	record, err := s.storage.record(ctx, id)
	if err != nil {
		logutil.Debug(ctx, "error fetching the idempotency record", slog.String("error", err.Error()))
		return "", err
	}

	payload, err := json.Marshal(req)
	if err != nil {
		logutil.Error(ctx, "could not marshal the request", slog.String("error", err.Error()), slog.Any("request", req))
		return "", err
	}

	if string(payload) != record.Request {
		logutil.Debug(ctx, "requested payload doesn't match the previous one sent for idempotency")
		return "", errors.New("requested payload doesn't match the previous one sent for idempotency")
	}

	return record.Response, nil
}

func (s IdempotencyService) CreateIdempotency(ctx context.Context, id string, req any, resp any) error {
	reqPayload, err := json.Marshal(req)
	if err != nil {
		return err
	}

	respPayload, err := json.Marshal(resp)
	if err != nil {
		return err
	}

	logutil.Info(ctx, "requested payload doesn't match the previous one sent for idempotency")
	if err := s.storage.save(ctx, idempotencyRecord{
		ID:       id,
		Request:  string(reqPayload),
		Response: string(respPayload),
	}); err != nil {
		logutil.Error(ctx, "could not save the idempotency record", slog.String("error", err.Error()))
		return err
	}

	return nil
}

type idempotencyRecord struct {
	ID       string
	Request  string
	Response string
}

type IdempotencyStorage struct {
	records map[string]idempotencyRecord
}

func NewIdempotencyStorage() IdempotencyStorage {
	return IdempotencyStorage{
		records: make(map[string]idempotencyRecord),
	}
}

func (s IdempotencyStorage) save(ctx context.Context, record idempotencyRecord) error {
	s.records[record.ID] = record
	return nil
}

func (s IdempotencyStorage) record(ctx context.Context, id string) (idempotencyRecord, error) {
	rec, ok := s.records[id]
	if !ok {
		return idempotencyRecord{}, errIdempotencyNotFound
	}

	return rec, nil
}
