//go:build go1.22

// Package v3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.1-0.20240908200014-2be24b11ae0f DO NOT EDIT.
package v3

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for ResponseResourceListDataStatus.
const (
	AVAILABLE              ResponseResourceListDataStatus = "AVAILABLE"
	PENDINGAUTHORISATION   ResponseResourceListDataStatus = "PENDING_AUTHORISATION"
	TEMPORARILYUNAVAILABLE ResponseResourceListDataStatus = "TEMPORARILY_UNAVAILABLE"
	UNAVAILABLE            ResponseResourceListDataStatus = "UNAVAILABLE"
)

// Defines values for ResponseResourceListDataType.
const (
	ACCOUNT                    ResponseResourceListDataType = "ACCOUNT"
	BANKFIXEDINCOME            ResponseResourceListDataType = "BANK_FIXED_INCOME"
	CREDITCARDACCOUNT          ResponseResourceListDataType = "CREDIT_CARD_ACCOUNT"
	CREDITFIXEDINCOME          ResponseResourceListDataType = "CREDIT_FIXED_INCOME"
	EXCHANGE                   ResponseResourceListDataType = "EXCHANGE"
	FINANCING                  ResponseResourceListDataType = "FINANCING"
	FUND                       ResponseResourceListDataType = "FUND"
	INVOICEFINANCING           ResponseResourceListDataType = "INVOICE_FINANCING"
	LOAN                       ResponseResourceListDataType = "LOAN"
	TREASURETITLE              ResponseResourceListDataType = "TREASURE_TITLE"
	UNARRANGEDACCOUNTOVERDRAFT ResponseResourceListDataType = "UNARRANGED_ACCOUNT_OVERDRAFT"
	VARIABLEINCOME             ResponseResourceListDataType = "VARIABLE_INCOME"
)

// ResponseErrorWithAbleAdditionalProperties defines model for ResponseErrorWithAbleAdditionalProperties.
type ResponseErrorWithAbleAdditionalProperties struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseResourceList defines model for ResponseResourceList.
type ResponseResourceList struct {
	// Data Lista de recursos e seus respectivos status.
	Data []struct {
		// ResourceID Identifica o recurso reportado pelo participante do Open Finance, no caso de:
		// - Contas de depósito à vista, de poupança ou de pagamento pré-paga : corresponde ao accountId;
		// - Conta de pagamento pós-paga: corresponde ao  creditCardAccountId;
		// - Empréstimos, Financiamentos, Direitos creditórios descontados e Adiantamento a depositantes: corresponde ao contractId
		// - Renda Fixa Bancária, Renda Fixa Crédito, Renda Variável, Título do Tesouro Direto e Fundo de Investimento: corresponde ao investmentId;
		// - Câmbio: corresponde ao operationId.
		ResourceID string `json:"resourceId"`

		// Status Tipo de status de recurso (vide Enum):
		// Available - Disponível
		// Unavailable - Indisponível
		// Temporarily Unavailable - Temporariamente Indisponível
		// Pending Authorisation - Pendente de Autorização
		Status ResponseResourceListDataStatus `json:"status"`

		// Type Tipo de recurso (vide Enum):
		//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
		//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
		//   - Loan - Empréstimo
		//   - Financing - Financiamento
		//   - Unarranged Account Overdraft - Cheque Especial
		//   - Invoice Financing - Financiamento de Fatura
		//   - Bank Fixed Income - Renda Fixa Bancária
		//   - Credit Fixed Income - Renda Fixa Crédito
		//   - Variabel Income - Renda Variável
		//   - Treasure Title - Título do Tesouro Direto
		//   - Fund - Fundo de Investimento
		//   - Exchange - Câmbio
		Type ResponseResourceListDataType `json:"type"`
	} `json:"data"`
	Links api.Links `json:"links"`
	Meta  api.Meta  `json:"meta"`
}

// ResponseResourceListDataStatus Tipo de status de recurso (vide Enum):
// Available - Disponível
// Unavailable - Indisponível
// Temporarily Unavailable - Temporariamente Indisponível
// Pending Authorisation - Pendente de Autorização
type ResponseResourceListDataStatus string

// ResponseResourceListDataType Tipo de recurso (vide Enum):
//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
//   - Loan - Empréstimo
//   - Financing - Financiamento
//   - Unarranged Account Overdraft - Cheque Especial
//   - Invoice Financing - Financiamento de Fatura
//   - Bank Fixed Income - Renda Fixa Bancária
//   - Credit Fixed Income - Renda Fixa Crédito
//   - Variabel Income - Renda Variável
//   - Treasure Title - Título do Tesouro Direto
//   - Fund - Fundo de Investimento
//   - Exchange - Câmbio
type ResponseResourceListDataType string

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorWithAbleAdditionalProperties

// Default defines model for Default.
type Default = ResponseErrorWithAbleAdditionalProperties

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorWithAbleAdditionalProperties

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorWithAbleAdditionalProperties

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorWithAbleAdditionalProperties

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorWithAbleAdditionalProperties

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorWithAbleAdditionalProperties

// NotFound defines model for NotFound.
type NotFound = ResponseErrorWithAbleAdditionalProperties

// OKResponseResourceList defines model for OKResponseResourceList.
type OKResponseResourceList = ResponseResourceList

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorWithAbleAdditionalProperties

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorWithAbleAdditionalProperties

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorWithAbleAdditionalProperties

// ResourcesGetResourcesParams defines parameters for ResourcesGetResources.
type ResourcesGetResourcesParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	// A transmissora deve considerar entrada como 25, caso seja informado algum valor menor pela receptora.
	// Enquanto houver mais que 25 registros a enviar, a transmissora deve considerar o mínimo por página como 25.
	// Somente a última página retornada (ou primeira, no caso de página única) pode conter menos de 25 registros.
	// Mais informações, acesse Especificações de APIs > Padrões > Paginação.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ResourcesGetResources operation middleware
func (siw *ServerInterfaceWrapper) ResourcesGetResources(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "resources"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ResourcesGetResourcesParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ResourcesGetResources(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/resources", wrapper.ResourcesGetResources)

	return m
}

type N202ResponseResourceResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type OKResponseResourceListJSONResponse ResponseResourceList

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ResourcesGetResourcesRequestObject struct {
	Params ResourcesGetResourcesParams
}

type ResourcesGetResourcesResponseObject interface {
	VisitResourcesGetResourcesResponse(w http.ResponseWriter) error
}

type ResourcesGetResources200JSONResponse struct {
	OKResponseResourceListJSONResponse
}

func (response ResourcesGetResources200JSONResponse) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources202Response = N202ResponseResourceResponse

func (response ResourcesGetResources202Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.WriteHeader(202)
	return nil
}

type ResourcesGetResources400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources400ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources401ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources403ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources404ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources405ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources406ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources429ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources500ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources504ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResources529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources529ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorWithAbleAdditionalProperties
	StatusCode int
}

func (response ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de recursos consentidos pelo cliente.
	// (GET /resources)
	ResourcesGetResources(ctx context.Context, request ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ResourcesGetResources operation middleware
func (sh *strictHandler) ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams) {
	var request ResourcesGetResourcesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ResourcesGetResources(ctx, request.(ResourcesGetResourcesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResourcesGetResources")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ResourcesGetResourcesResponseObject); ok {
		if err := validResponse.VisitResourcesGetResourcesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
