//go:build go1.22

// Package v2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.1-0.20240908200014-2be24b11ae0f DO NOT EDIT.
package v2

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/luiky/mock-bank/internal/api"
	"github.com/luiky/mock-bank/internal/timex"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	OAuth2SecurityScopes = "OAuth2Security.Scopes"
	OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for EnumAccountSubType.
const (
	CONJUNTASIMPLES   EnumAccountSubType = "CONJUNTA_SIMPLES"
	CONJUNTASOLIDARIA EnumAccountSubType = "CONJUNTA_SOLIDARIA"
	INDIVIDUAL        EnumAccountSubType = "INDIVIDUAL"
)

// Defines values for EnumAccountType.
const (
	CONTADEPOSITOAVISTA   EnumAccountType = "CONTA_DEPOSITO_A_VISTA"
	CONTAPAGAMENTOPREPAGA EnumAccountType = "CONTA_PAGAMENTO_PRE_PAGA"
	CONTAPOUPANCA         EnumAccountType = "CONTA_POUPANCA"
)

// Defines values for EnumCompletedAuthorisedPaymentIndicator.
const (
	LANCAMENTOFUTURO     EnumCompletedAuthorisedPaymentIndicator = "LANCAMENTO_FUTURO"
	TRANSACAOEFETIVADA   EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_EFETIVADA"
	TRANSACAOPROCESSANDO EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_PROCESSANDO"
)

// Defines values for EnumCreditDebitIndicator.
const (
	CREDITO EnumCreditDebitIndicator = "CREDITO"
	DEBITO  EnumCreditDebitIndicator = "DEBITO"
)

// Defines values for EnumPartiePersonType.
const (
	PESSOAJURIDICA EnumPartiePersonType = "PESSOA_JURIDICA"
	PESSOANATURAL  EnumPartiePersonType = "PESSOA_NATURAL"
)

// Defines values for EnumTransactionTypes.
const (
	BOLETO                        EnumTransactionTypes = "BOLETO"
	CARTAO                        EnumTransactionTypes = "CARTAO"
	CONVENIOARRECADACAO           EnumTransactionTypes = "CONVENIO_ARRECADACAO"
	DEPOSITO                      EnumTransactionTypes = "DEPOSITO"
	DOC                           EnumTransactionTypes = "DOC"
	ENCARGOSJUROSCHEQUEESPECIAL   EnumTransactionTypes = "ENCARGOS_JUROS_CHEQUE_ESPECIAL"
	FOLHAPAGAMENTO                EnumTransactionTypes = "FOLHA_PAGAMENTO"
	OPERACAOCREDITO               EnumTransactionTypes = "OPERACAO_CREDITO"
	OUTROS                        EnumTransactionTypes = "OUTROS"
	PACOTETARIFASERVICOS          EnumTransactionTypes = "PACOTE_TARIFA_SERVICOS"
	PIX                           EnumTransactionTypes = "PIX"
	PORTABILIDADESALARIO          EnumTransactionTypes = "PORTABILIDADE_SALARIO"
	RENDIMENTOAPLICFINANCEIRA     EnumTransactionTypes = "RENDIMENTO_APLIC_FINANCEIRA"
	RESGATEAPLICFINANCEIRA        EnumTransactionTypes = "RESGATE_APLIC_FINANCEIRA"
	SAQUE                         EnumTransactionTypes = "SAQUE"
	TARIFASERVICOSAVULSOS         EnumTransactionTypes = "TARIFA_SERVICOS_AVULSOS"
	TED                           EnumTransactionTypes = "TED"
	TRANSFERENCIAMESMAINSTITUICAO EnumTransactionTypes = "TRANSFERENCIA_MESMA_INSTITUICAO"
)

// AccountBalancesData Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountBalancesData struct {
	// AutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AutomaticallyInvestedAmount AccountBalancesDataAutomaticallyInvestedAmount `json:"automaticallyInvestedAmount"`

	// AvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	AvailableAmount AccountBalancesDataAvailableAmount `json:"availableAmount"`

	// BlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	BlockedAmount AccountBalancesDataBlockedAmount `json:"blockedAmount"`

	// UpdateDateTime Data e hora da última atualização do saldo. É esperado que a instituição informe a última vez que capturou o saldo para compartilhamento no Open Finance. Dessa forma, é possível que:
	// - Caso a instituição capture dados de forma síncrona essa informação seja de poucos momentos;
	// - Caso a instituição capture dados de forma assíncrona essa informação seja de horas ou dias no passado;
	// - Quando não existente uma data vinculada especificamente ao bloco, se assume a data e hora de atualização do cadastro como um todo.
	//
	// De toda forma, é preciso continuar respeitando o prazo máximo de tempestividade da API de Contas.
	UpdateDateTime timex.DateTime `json:"updateDateTime"`
}

// AccountBalancesDataAutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAutomaticallyInvestedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataAvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAvailableAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountBalancesDataBlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataBlockedAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountData defines model for AccountData.
type AccountData struct {
	// AccountID Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
	AccountID string `json:"accountId"`

	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de CONTA_PAGAMENTO_PRE_PAGA.
	BranchCode *string `json:"branchCode,omitempty"`

	// BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
	BrandName string `json:"brandName"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
	CompanyCnpj string `json:"companyCnpj"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
	CompeCode string `json:"compeCode"`

	// Number Número da conta
	Number string `json:"number"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountIdentificationData Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountIdentificationData struct {
	// BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	//
	// [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré-paga.
	BranchCode *string `json:"branchCode,omitempty"`

	// CheckDigit Dígito da conta
	CheckDigit string `json:"checkDigit"`

	// CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	CompeCode string `json:"compeCode"`

	// Currency Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
	// Todos os saldos informados estão representados com a moeda vigente do Brasil
	Currency string `json:"currency"`

	// Number Número da conta
	Number string `json:"number"`

	// Subtype Subtipo de conta (vide Enum):
	// Conta individual - possui um único titular
	// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
	// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
	Subtype EnumAccountSubType `json:"subtype"`

	// Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
	// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
	// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
	// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
	Type EnumAccountType `json:"type"`
}

// AccountOverdraftLimitsData Conjunto de informações da Conta de: depósito à vista
type AccountOverdraftLimitsData struct {
	// OverdraftContractedLimit Valor do limite contratado do cheque especial.
	OverdraftContractedLimit *AccountOverdraftLimitsDataOverdraftContractedLimit `json:"overdraftContractedLimit,omitempty"`

	// OverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
	OverdraftUsedLimit *AccountOverdraftLimitsDataOverdraftUsedLimit `json:"overdraftUsedLimit,omitempty"`

	// UnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
	UnarrangedOverdraftAmount *AccountOverdraftLimitsDataUnarrangedOverdraftAmount `json:"unarrangedOverdraftAmount,omitempty"`
}

// AccountOverdraftLimitsDataOverdraftContractedLimit Valor do limite contratado do cheque especial.
type AccountOverdraftLimitsDataOverdraftContractedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataOverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
type AccountOverdraftLimitsDataOverdraftUsedLimit struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataUnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
type AccountOverdraftLimitsDataUnarrangedOverdraftAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// AccountTransactionsData defines model for AccountTransactionsData.
type AccountTransactionsData struct {
	// CompletedAuthorisedPaymentType Indicador da transação:
	//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
	//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
	//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
	CompletedAuthorisedPaymentType EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

	// CreditDebitType Indicador do tipo de lançamento:
	// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
	// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
	CreditDebitType EnumCreditDebitIndicator `json:"creditDebitType"`

	// PartieBranchCode Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
	PartieBranchCode *string `json:"partieBranchCode,omitempty"`

	// PartieCheckDigit Dígito da conta da pessoa envolvida na transação
	PartieCheckDigit *string `json:"partieCheckDigit,omitempty"`

	// PartieCnpjCpf Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação). Com a IN BCB nº 371, a partir de 02/05/23, o envio das informações de identificação de contraparte tornou-se obrigatória para transações de pagamento. Para maiores detalhes, favor consultar a página `Orientações - Contas`.
	//
	// [Restrição] Quando o "type“ for preenchido com valor FOLHA_PAGAMENTO e a transmissora for a responsável pelo pagamento de salário (banco-folha), o partieCnpjCpf informado deve ser do empregador relacionado.
	PartieCnpjCpf *string `json:"partieCnpjCpf,omitempty"`

	// PartieCompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
	PartieCompeCode *string `json:"partieCompeCode,omitempty"`

	// PartieNumber Número da conta da pessoa envolvida na transação
	PartieNumber *string `json:"partieNumber,omitempty"`

	// PartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
	// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
	// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
	PartiePersonType *EnumPartiePersonType `json:"partiePersonType,omitempty"`

	// TransactionAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
	TransactionAmount AccountTransactionsDataAmount `json:"transactionAmount"`

	// TransactionDateTime Data e hora original da transação.
	TransactionDateTime string `json:"transactionDateTime"`

	// TransactionID Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
	// O ideal é que o `transactionId` seja imutável.
	// No entanto, o `transactionId` deve obedecer, no mínimo, as regras de imutabilidade propostas conforme tabela “Data de imutabilidade por tipo de transação” presente nas orientações desta API.
	TransactionID string `json:"transactionId"`

	// TransactionName Literal usada na instituição financeira para identificar a transação. A informação apresentada precisa ser a mesma utilizada nos canais eletrônicos da instituição (extrato). Em casos onde a descrição da transação é apresentada com múltiplas linhas, todas as linhas devem ser enviadas (concatenadas) neste atributo, não sendo obrigatória a concatenação das informações já enviadas em outros atributos (ex: valor, data) do mesmo endpoint.
	TransactionName string `json:"transactionName"`

	// Type O campo deve classificar a transação em um dos tipos descritos.
	// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
	// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
	// Por exemplo no caso de recebimento de pensão alimentícia.
	Type EnumTransactionTypes `json:"type"`
}

// AccountTransactionsDataAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountTransactionsDataAmount struct {
	// Amount Valor relacionado ao objeto.
	Amount string `json:"amount"`

	// Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
	Currency string `json:"currency"`
}

// EnumAccountSubType Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
type EnumAccountSubType string

// EnumAccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type EnumAccountType string

// EnumCompletedAuthorisedPaymentIndicator Indicador da transação:
//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
type EnumCompletedAuthorisedPaymentIndicator string

// EnumCreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type EnumCreditDebitIndicator string

// EnumPartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
type EnumPartiePersonType string

// EnumTransactionTypes O campo deve classificar a transação em um dos tipos descritos.
// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
// Por exemplo no caso de recebimento de pensão alimentícia.
type EnumTransactionTypes string

// ResponseAccountBalances defines model for ResponseAccountBalances.
type ResponseAccountBalances struct {
	// Data Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountBalancesData `json:"data"`
	Links api.Links           `json:"links"`
	Meta  api.Meta            `json:"meta"`
}

// ResponseAccountIdentification defines model for ResponseAccountIdentification.
type ResponseAccountIdentification struct {
	// Data Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  AccountIdentificationData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseAccountList defines model for ResponseAccountList.
type ResponseAccountList struct {
	// Data Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
	Data  []AccountData `json:"data"`
	Links api.Links     `json:"links"`
	Meta  api.Meta      `json:"meta"`
}

// ResponseAccountOverdraftLimits defines model for ResponseAccountOverdraftLimits.
type ResponseAccountOverdraftLimits struct {
	// Data Conjunto de informações da Conta de: depósito à vista
	Data  AccountOverdraftLimitsData `json:"data"`
	Links api.Links                  `json:"links"`
	Meta  api.Meta                   `json:"meta"`
}

// ResponseAccountTransactions defines model for ResponseAccountTransactions.
type ResponseAccountTransactions struct {
	// Data Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga
	Data  []AccountTransactionsData `json:"data"`
	Links api.Links                 `json:"links"`
	Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorMetaSingle defines model for ResponseErrorMetaSingle.
type ResponseErrorMetaSingle struct {
	Errors []struct {
		// Code Código de erro específico do endpoint
		Code string `json:"code"`

		// Detail Descrição legível por humanos deste erro específico
		Detail string `json:"detail"`

		// Title Título legível por humanos deste erro específico
		Title string `json:"title"`
	} `json:"errors"`
	Meta *api.Meta `json:"meta,omitempty"`
}

// Authorization defines model for Authorization.
type Authorization = string

// AccountID defines model for accountId.
type AccountID = string

// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type AccountType = EnumAccountType

// CreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type CreditDebitIndicator = EnumCreditDebitIndicator

// FromBookingDate defines model for fromBookingDate.
type FromBookingDate = timex.Date

// FromBookingDateMaxLimited defines model for fromBookingDateMaxLimited.
type FromBookingDateMaxLimited = timex.Date

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// ToBookingDate defines model for toBookingDate.
type ToBookingDate = timex.Date

// ToBookingDateMaxLimited defines model for toBookingDateMaxLimited.
type ToBookingDateMaxLimited = timex.Date

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorMetaSingle

// BadRequestWithAdditionalProperties defines model for BadRequestWithAdditionalProperties.
type BadRequestWithAdditionalProperties = ResponseError

// Default defines model for Default.
type Default = ResponseErrorMetaSingle

// DefaultWithAdditionalProperties defines model for DefaultWithAdditionalProperties.
type DefaultWithAdditionalProperties = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorMetaSingle

// ForbiddenWithAdditionalProperties defines model for ForbiddenWithAdditionalProperties.
type ForbiddenWithAdditionalProperties = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorMetaSingle

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorMetaSingle

// InternalServerErrorWithAdditionalProperties defines model for InternalServerErrorWithAdditionalProperties.
type InternalServerErrorWithAdditionalProperties = ResponseError

// Locked defines model for Locked.
type Locked = ResponseErrorMetaSingle

// LockedWithAdditionalProperties defines model for LockedWithAdditionalProperties.
type LockedWithAdditionalProperties = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorMetaSingle

// MethodNotAllowedWithAdditionalProperties defines model for MethodNotAllowedWithAdditionalProperties.
type MethodNotAllowedWithAdditionalProperties = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorMetaSingle

// NotAcceptableWithAdditionalProperties defines model for NotAcceptableWithAdditionalProperties.
type NotAcceptableWithAdditionalProperties = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseErrorMetaSingle

// NotFoundWithAdditionalProperties defines model for NotFoundWithAdditionalProperties.
type NotFoundWithAdditionalProperties = ResponseError

// OKResponseAccountBalances defines model for OKResponseAccountBalances.
type OKResponseAccountBalances = ResponseAccountBalances

// OKResponseAccountIdentification defines model for OKResponseAccountIdentification.
type OKResponseAccountIdentification = ResponseAccountIdentification

// OKResponseAccountList defines model for OKResponseAccountList.
type OKResponseAccountList = ResponseAccountList

// OKResponseAccountOverdraftLimits defines model for OKResponseAccountOverdraftLimits.
type OKResponseAccountOverdraftLimits = ResponseAccountOverdraftLimits

// OKResponseAccountTransactions defines model for OKResponseAccountTransactions.
type OKResponseAccountTransactions = ResponseAccountTransactions

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorMetaSingle

// SiteIsOverloadedWithAdditionalProperties defines model for SiteIsOverloadedWithAdditionalProperties.
type SiteIsOverloadedWithAdditionalProperties = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorMetaSingle

// TooManyRequestsWithAdditionalProperties defines model for TooManyRequestsWithAdditionalProperties.
type TooManyRequestsWithAdditionalProperties = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorMetaSingle

// UnauthorizedWithAdditionalProperties defines model for UnauthorizedWithAdditionalProperties.
type UnauthorizedWithAdditionalProperties = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorMetaSingle

// UnprocessableEntityWithAdditionalProperties defines model for UnprocessableEntityWithAdditionalProperties.
type UnprocessableEntityWithAdditionalProperties = ResponseError

// AccountsGetAccountsParams defines parameters for AccountsGetAccounts.
type AccountsGetAccountsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
	AccountType *AccountType `form:"accountType,omitempty" json:"accountType,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDParams defines parameters for AccountsGetAccountsAccountID.
type AccountsGetAccountsAccountIDParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDBalancesParams defines parameters for AccountsGetAccountsAccountIDBalances.
type AccountsGetAccountsAccountIDBalancesParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDOverdraftLimitsParams defines parameters for AccountsGetAccountsAccountIDOverdraftLimits.
type AccountsGetAccountsAccountIDOverdraftLimitsParams struct {
	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsParams defines parameters for AccountsGetAccountsAccountIDTransactions.
type AccountsGetAccountsAccountIDTransactionsParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDate `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDate `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsCurrentParams defines parameters for AccountsGetAccountsAccountIDTransactionsCurrent.
type AccountsGetAccountsAccountIDTransactionsCurrentParams struct {
	// Page Número da página que está sendo requisitada (o valor da primeira página é 1).
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Quantidade total de registros por páginas.
	PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

	// FromBookingDate Data inicial de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	FromBookingDate *FromBookingDateMaxLimited `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

	// ToBookingDate Data final de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
	// [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado.
	// Caso não seja informado, deve ser assumido o dia atual.
	ToBookingDate *ToBookingDateMaxLimited `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

	// CreditDebitIndicator Indicador do tipo de lançamento
	CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

	// PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
	PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

	// Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
	Authorization Authorization `json:"Authorization"`

	// XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
	XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

	// XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
	XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

	// XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
	XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

	// XCustomerUserAgent Indica o user-agent que o usuário utiliza.
	XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountsGetAccounts operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "accountType" -------------

	err = runtime.BindQueryParameter("form", true, false, "accountType", r.URL.Query(), &params.AccountType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountType", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountID operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountID(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDBalancesParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDBalances(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDOverdraftLimitsParams

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDOverdraftLimits(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactions(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "accountId" -------------
	var accountID AccountID

	err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accountId", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

	ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountsGetAccountsAccountIDTransactionsCurrentParams

	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &params.Page)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page", Err: err})
		return
	}

	// ------------- Optional query parameter "page-size" -------------

	err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &params.PageSize)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page-size", Err: err})
		return
	}

	// ------------- Optional query parameter "fromBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &params.FromBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "toBookingDate" -------------

	err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &params.ToBookingDate)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
		return
	}

	// ------------- Optional query parameter "creditDebitIndicator" -------------

	err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &params.CreditDebitIndicator)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
		return
	}

	// ------------- Optional query parameter "pagination-key" -------------

	err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &params.PaginationKey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "pagination-key", Err: err})
		return
	}

	headers := r.Header

	// ------------- Required header parameter "Authorization" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found {
		var Authorization Authorization
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Authorization", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Authorization", Err: err})
			return
		}

		params.Authorization = Authorization

	} else {
		err := fmt.Errorf("Header parameter Authorization is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "Authorization", Err: err})
		return
	}

	// ------------- Optional header parameter "x-fapi-auth-date" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found {
		var XFapiAuthDate XFapiAuthDate
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
			return
		}

		params.XFapiAuthDate = &XFapiAuthDate

	}

	// ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found {
		var XFapiCustomerIPAddress XFapiCustomerIPAddress
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
			return
		}

		params.XFapiCustomerIPAddress = &XFapiCustomerIPAddress

	}

	// ------------- Required header parameter "x-fapi-interaction-id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found {
		var XFapiInteractionID XFapiInteractionID
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
			return
		}

		params.XFapiInteractionID = XFapiInteractionID

	} else {
		err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
		return
	}

	// ------------- Optional header parameter "x-customer-user-agent" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found {
		var XCustomerUserAgent XCustomerUserAgent
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
			return
		}

		params.XCustomerUserAgent = &XCustomerUserAgent

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AccountsGetAccountsAccountIDTransactionsCurrent(w, r, accountID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       *http.ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m *http.ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m *http.ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/accounts", wrapper.AccountsGetAccounts)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}", wrapper.AccountsGetAccountsAccountID)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/balances", wrapper.AccountsGetAccountsAccountIDBalances)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/overdraft-limits", wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions", wrapper.AccountsGetAccountsAccountIDTransactions)
	m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions-current", wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)

	return m
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type DefaultWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type OKResponseAccountBalancesJSONResponse ResponseAccountBalances

type OKResponseAccountIdentificationJSONResponse ResponseAccountIdentification

type OKResponseAccountListJSONResponse ResponseAccountList

type OKResponseAccountOverdraftLimitsJSONResponse ResponseAccountOverdraftLimits

type OKResponseAccountTransactionsJSONResponse ResponseAccountTransactions

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type AccountsGetAccountsRequestObject struct {
	Params AccountsGetAccountsParams
}

type AccountsGetAccountsResponseObject interface {
	VisitAccountsGetAccountsResponse(w http.ResponseWriter) error
}

type AccountsGetAccounts200JSONResponse struct {
	OKResponseAccountListJSONResponse
}

func (response AccountsGetAccounts200JSONResponse) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccounts529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDParams
}

type AccountsGetAccountsAccountIDResponseObject interface {
	VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountID200JSONResponse struct {
	OKResponseAccountIdentificationJSONResponse
}

func (response AccountsGetAccountsAccountID200JSONResponse) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDBalancesRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDBalancesParams
}

type AccountsGetAccountsAccountIDBalancesResponseObject interface {
	VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDBalances200JSONResponse struct {
	OKResponseAccountBalancesJSONResponse
}

func (response AccountsGetAccountsAccountIDBalances200JSONResponse) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDOverdraftLimitsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDOverdraftLimitsParams
}

type AccountsGetAccountsAccountIDOverdraftLimitsResponseObject interface {
	VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse struct {
	OKResponseAccountOverdraftLimitsJSONResponse
}

func (response AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response struct {
	BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response struct {
	NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response struct {
	LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseError
	StatusCode int
}

func (response AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsParams
}

type AccountsGetAccountsAccountIDTransactionsResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactions200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactions200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

type AccountsGetAccountsAccountIDTransactionsCurrentRequestObject struct {
	AccountID AccountID `json:"accountId"`
	Params    AccountsGetAccountsAccountIDTransactionsCurrentParams
}

type AccountsGetAccountsAccountIDTransactionsCurrentResponseObject interface {
	VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse struct {
	OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response struct {
	BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response struct {
	UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(401)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response struct {
	ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(403)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response struct {
	NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response struct {
	MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(405)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response struct {
	NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(406)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response struct {
	UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(422)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response struct {
	LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(423)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response struct {
	TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(429)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response struct {
	InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(500)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response struct {
	GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(504)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response struct {
	SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(529)

	return json.NewEncoder(w).Encode(response)
}

type AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response struct {
	Body       ResponseErrorMetaSingle
	StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.WriteHeader(response.StatusCode)

	return json.NewEncoder(w).Encode(response.Body)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Obtém a lista de contas consentidas pelo cliente.
	// (GET /accounts)
	AccountsGetAccounts(ctx context.Context, request AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error)
	// Obtém os dados de identificação da conta identificada por accountId.
	// (GET /accounts/{accountId})
	AccountsGetAccountsAccountID(ctx context.Context, request AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error)
	// Obtém os saldos da conta identificada por accountId.
	// (GET /accounts/{accountId}/balances)
	AccountsGetAccountsAccountIDBalances(ctx context.Context, request AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error)
	// Obtém os limites da conta identificada por accountId.
	// (GET /accounts/{accountId}/overdraft-limits)
	AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error)
	// Obtém a lista de transações da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions)
	AccountsGetAccountsAccountIDTransactions(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error)
	// Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
	// (GET /accounts/{accountId}/transactions-current)
	AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// AccountsGetAccounts operation middleware
func (sh *strictHandler) AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams) {
	var request AccountsGetAccountsRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccounts(ctx, request.(AccountsGetAccountsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccounts")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountID operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams) {
	var request AccountsGetAccountsAccountIDRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountID(ctx, request.(AccountsGetAccountsAccountIDRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountID")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams) {
	var request AccountsGetAccountsAccountIDBalancesRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDBalances(ctx, request.(AccountsGetAccountsAccountIDBalancesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDBalances")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDBalancesResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDBalancesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams) {
	var request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDOverdraftLimits(ctx, request.(AccountsGetAccountsAccountIDOverdraftLimitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDOverdraftLimits")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDOverdraftLimitsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams) {
	var request AccountsGetAccountsAccountIDTransactionsRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactions(ctx, request.(AccountsGetAccountsAccountIDTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactions")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams) {
	var request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject

	request.AccountID = accountID
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.AccountsGetAccountsAccountIDTransactionsCurrent(ctx, request.(AccountsGetAccountsAccountIDTransactionsCurrentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AccountsGetAccountsAccountIDTransactionsCurrent")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsCurrentResponseObject); ok {
		if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//zqKHYEDVAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
