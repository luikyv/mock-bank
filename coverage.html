
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>account: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/luikyv/mock-bank/internal/account/model.go (0.0%)</option>

				<option value="file1">github.com/luikyv/mock-bank/internal/account/service.go (0.0%)</option>

				<option value="file2">github.com/luikyv/mock-bank/internal/api/accountv2/api.go (0.0%)</option>

				<option value="file3">github.com/luikyv/mock-bank/internal/api/accountv2/api_gen.go (0.0%)</option>

				<option value="file4">github.com/luikyv/mock-bank/internal/api/app/api.go (0.0%)</option>

				<option value="file5">github.com/luikyv/mock-bank/internal/api/app/api_gen.go (0.0%)</option>

				<option value="file6">github.com/luikyv/mock-bank/internal/api/app/middleware.go (0.0%)</option>

				<option value="file7">github.com/luikyv/mock-bank/internal/api/autopaymentv2/api.go (0.0%)</option>

				<option value="file8">github.com/luikyv/mock-bank/internal/api/autopaymentv2/api_gen.go (0.0%)</option>

				<option value="file9">github.com/luikyv/mock-bank/internal/api/consentv3/api.go (0.0%)</option>

				<option value="file10">github.com/luikyv/mock-bank/internal/api/consentv3/api_gen.go (0.0%)</option>

				<option value="file11">github.com/luikyv/mock-bank/internal/api/enrollmentv2/api.go (0.0%)</option>

				<option value="file12">github.com/luikyv/mock-bank/internal/api/enrollmentv2/api_gen.go (0.0%)</option>

				<option value="file13">github.com/luikyv/mock-bank/internal/api/error.go (0.0%)</option>

				<option value="file14">github.com/luikyv/mock-bank/internal/api/middleware/auth.go (0.0%)</option>

				<option value="file15">github.com/luikyv/mock-bank/internal/api/middleware/idempotency.go (0.0%)</option>

				<option value="file16">github.com/luikyv/mock-bank/internal/api/middleware/jwt.go (0.0%)</option>

				<option value="file17">github.com/luikyv/mock-bank/internal/api/middleware/permission.go (0.0%)</option>

				<option value="file18">github.com/luikyv/mock-bank/internal/api/middleware/util.go (0.0%)</option>

				<option value="file19">github.com/luikyv/mock-bank/internal/api/model.go (0.0%)</option>

				<option value="file20">github.com/luikyv/mock-bank/internal/api/oidc/api.go (0.0%)</option>

				<option value="file21">github.com/luikyv/mock-bank/internal/api/paymentv4/api.go (0.0%)</option>

				<option value="file22">github.com/luikyv/mock-bank/internal/api/paymentv4/api_gen.go (0.0%)</option>

				<option value="file23">github.com/luikyv/mock-bank/internal/api/resourcev3/api.go (0.0%)</option>

				<option value="file24">github.com/luikyv/mock-bank/internal/api/resourcev3/api_gen.go (0.0%)</option>

				<option value="file25">github.com/luikyv/mock-bank/internal/api/util.go (0.0%)</option>

				<option value="file26">github.com/luikyv/mock-bank/internal/autopayment/model.go (0.0%)</option>

				<option value="file27">github.com/luikyv/mock-bank/internal/autopayment/service.go (0.0%)</option>

				<option value="file28">github.com/luikyv/mock-bank/internal/autopayment/util.go (0.0%)</option>

				<option value="file29">github.com/luikyv/mock-bank/internal/client/model.go (0.0%)</option>

				<option value="file30">github.com/luikyv/mock-bank/internal/client/service.go (0.0%)</option>

				<option value="file31">github.com/luikyv/mock-bank/internal/consent/model.go (0.0%)</option>

				<option value="file32">github.com/luikyv/mock-bank/internal/consent/service.go (0.0%)</option>

				<option value="file33">github.com/luikyv/mock-bank/internal/consent/util.go (0.0%)</option>

				<option value="file34">github.com/luikyv/mock-bank/internal/directory/service.go (0.0%)</option>

				<option value="file35">github.com/luikyv/mock-bank/internal/enrollment/model.go (0.0%)</option>

				<option value="file36">github.com/luikyv/mock-bank/internal/enrollment/service.go (0.0%)</option>

				<option value="file37">github.com/luikyv/mock-bank/internal/enrollment/util.go (0.0%)</option>

				<option value="file38">github.com/luikyv/mock-bank/internal/errorutil/error.go (0.0%)</option>

				<option value="file39">github.com/luikyv/mock-bank/internal/idempotency/model.go (0.0%)</option>

				<option value="file40">github.com/luikyv/mock-bank/internal/idempotency/service.go (0.0%)</option>

				<option value="file41">github.com/luikyv/mock-bank/internal/jwtutil/util.go (0.0%)</option>

				<option value="file42">github.com/luikyv/mock-bank/internal/oidc/authn_session.go (0.0%)</option>

				<option value="file43">github.com/luikyv/mock-bank/internal/oidc/client.go (0.0%)</option>

				<option value="file44">github.com/luikyv/mock-bank/internal/oidc/dcr.go (0.0%)</option>

				<option value="file45">github.com/luikyv/mock-bank/internal/oidc/grant_session.go (0.0%)</option>

				<option value="file46">github.com/luikyv/mock-bank/internal/oidc/policy.go (0.0%)</option>

				<option value="file47">github.com/luikyv/mock-bank/internal/oidc/util.go (0.0%)</option>

				<option value="file48">github.com/luikyv/mock-bank/internal/page/page.go (0.0%)</option>

				<option value="file49">github.com/luikyv/mock-bank/internal/payment/model.go (0.0%)</option>

				<option value="file50">github.com/luikyv/mock-bank/internal/payment/service.go (0.0%)</option>

				<option value="file51">github.com/luikyv/mock-bank/internal/payment/util.go (0.0%)</option>

				<option value="file52">github.com/luikyv/mock-bank/internal/resource/model.go (0.0%)</option>

				<option value="file53">github.com/luikyv/mock-bank/internal/resource/service.go (0.0%)</option>

				<option value="file54">github.com/luikyv/mock-bank/internal/session/model.go (0.0%)</option>

				<option value="file55">github.com/luikyv/mock-bank/internal/session/service.go (0.0%)</option>

				<option value="file56">github.com/luikyv/mock-bank/internal/testutil/test.go (0.0%)</option>

				<option value="file57">github.com/luikyv/mock-bank/internal/timeutil/time.go (97.1%)</option>

				<option value="file58">github.com/luikyv/mock-bank/internal/user/model.go (100.0%)</option>

				<option value="file59">github.com/luikyv/mock-bank/internal/user/service.go (80.0%)</option>

				<option value="file60">github.com/luikyv/mock-bank/internal/webhook/service.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package account

import (
        "crypto/rand"
        "errors"
        "math/big"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/resource"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

const (
        TransactionIDLength int = 80
        letterBytes             = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
)

var (
        Scope = goidc.NewScope("accounts")
)

type ConsentAccount struct {
        ConsentID uuid.UUID
        AccountID uuid.UUID
        OwnerID   uuid.UUID
        Status    resource.Status
        Account   *Account

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (ConsentAccount) TableName() string <span class="cov0" title="0">{
        return "consent_accounts"
}</span>

type Account struct {
        ID                          uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        OwnerID                     uuid.UUID
        Number                      string
        Type                        Type
        SubType                     SubType `gorm:"column:subtype"`
        AvailableAmount             string
        BlockedAmount               string
        AutomaticallyInvestedAmount string
        OverdraftLimitContracted    string
        OverdraftLimitUsed          string
        OverdraftLimitUnarranged    string

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

type Query struct {
        ID     string
        Number string
}

type Type string

const (
        TypeCheckingAccount Type = "CONTA_DEPOSITO_A_VISTA"
        TypeSavingsAccount  Type = "CONTA_POUPANCA"
        TypePrepaidPayment  Type = "CONTA_PAGAMENTO_PRE_PAGA"
)

type SubType string

const (
        SubTypeIndividual    SubType = "INDIVIDUAL"
        SubTypeJointSimple   SubType = "CONJUNTA_SIMPLES"
        SubTypeJointSolidary SubType = "CONJUNTA_SOLIDARIA"
)

type Transaction struct {
        ID               string `gorm:"primaryKey"`
        AccountID        uuid.UUID
        Status           TransactionStatus
        MovementType     MovementType
        Name             string
        Type             TransactionType
        Amount           string
        PartieBranchCode *string
        PartieCheckDigit *string
        PartieCNPJCPF    *string `gorm:"column:partie_cnpj_cpf"`
        PartieCompeCode  *string
        PartieNumber     *string
        PartiePersonType *PersonType

        OrgID     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (Transaction) TableName() string <span class="cov0" title="0">{
        return "account_transactions"
}</span>

func (t *Transaction) BeforeCreate(_ *gorm.DB) error <span class="cov0" title="0">{
        t.ID = newTransactionID()
        return nil
}</span>

type TransactionStatus string

const (
        TransactionStatusCompleted   TransactionStatus = "TRANSACAO_EFETIVADA"
        TransactionStatusFutureEntry TransactionStatus = "LANCAMENTO_FUTURO"
        TransactionStatusProcessing  TransactionStatus = "TRANSACAO_PROCESSANDO"
)

type TransactionType string

const (
        TransactionTypeTed                       TransactionType = "TED"
        TransactionTypeDoc                       TransactionType = "DOC"
        TransactionTypePix                       TransactionType = "PIX"
        TransactionTypeTransferSameInstitution   TransactionType = "TRANSFERENCIAMESMAINSTITUICAO"
        TransactionTypeBoleto                    TransactionType = "BOLETO"
        TransactionTypeAgreementCollection       TransactionType = "CONVENIOARRECADACAO"
        TransactionTypeServicePackageFee         TransactionType = "PACOTETARIFASERVICOS"
        TransactionTypeSingleServiceFee          TransactionType = "TARIFASERVICOSAVULSOS"
        TransactionTypePayroll                   TransactionType = "FOLHAPAGAMENTO"
        TransactionTypeDeposit                   TransactionType = "DEPOSITO"
        TransactionTypeWithdrawal                TransactionType = "SAQUE"
        TransactionTypeCard                      TransactionType = "CARTAO"
        TransactionTypeOverdraftInterestCharges  TransactionType = "ENCARGOSJUROSCHEQUEESPECIAL"
        TransactionTypeFinancialInvestmentIncome TransactionType = "RENDIMENTOAPLICFINANCEIRA"
        TransactionTypeSalaryPortability         TransactionType = "PORTABILIDADESALARIO"
        TransactionTypeFinancialInvestmentRescue TransactionType = "RESGATEAPLICFINANCEIRA"
        TransactionTypeCreditOperation           TransactionType = "OPERACAOCREDITO"
        TransactionTypeOthers                    TransactionType = "OUTROS"
)

type MovementType string

const (
        MovementTypeCredit MovementType = "CREDITO"
        MovementTypeDebit  MovementType = "DEBITO"
)

type PersonType string

const (
        PersonTypeIndividual PersonType = "PESSOA_NATURAL"
        PersonTypeCompany    PersonType = "PESSOA_JURIDICA"
)

type TransactionFilter struct {
        from         timeutil.BrazilDate
        to           timeutil.BrazilDate
        movementType MovementType
}

func (f TransactionFilter) WithMovementType(mt MovementType) TransactionFilter <span class="cov0" title="0">{
        f.movementType = mt
        return f
}</span>

func NewTransactionFilter(from, to *timeutil.BrazilDate, current bool) (TransactionFilter, error) <span class="cov0" title="0">{
        brazilNow := timeutil.BrazilDateNow()
        filter := TransactionFilter{
                from: brazilNow,
                to:   brazilNow.AddDate(0, 0, 1),
        }

        if from != nil </span><span class="cov0" title="0">{
                if to == nil </span><span class="cov0" title="0">{
                        return TransactionFilter{}, errors.New("to booking date is required if from booking date is informed")
                }</span>
                <span class="cov0" title="0">filter.from = *from</span>
        }

        <span class="cov0" title="0">if to != nil </span><span class="cov0" title="0">{
                if from == nil </span><span class="cov0" title="0">{
                        return TransactionFilter{}, errors.New("from booking date is required if to booking date is informed")
                }</span>

                <span class="cov0" title="0">filter.to = *to</span>
        }

        <span class="cov0" title="0">if current </span><span class="cov0" title="0">{
                nowMinus7Days := brazilNow.AddDate(0, 0, -7)
                if filter.from.Before(nowMinus7Days) </span><span class="cov0" title="0">{
                        return TransactionFilter{}, errors.New("from booking date too far in the past")
                }</span>

                <span class="cov0" title="0">if filter.to.Before(nowMinus7Days) </span><span class="cov0" title="0">{
                        return TransactionFilter{}, errors.New("to booking date too far in the past")
                }</span>
        }

        <span class="cov0" title="0">return filter, nil</span>
}

func newTransactionID() string <span class="cov0" title="0">{
        b := make([]byte, TransactionIDLength)
        for i := range b </span><span class="cov0" title="0">{
                n, err := rand.Int(rand.Reader, big.NewInt(int64(len(letterBytes))))
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">b[i] = letterBytes[n.Int64()]</span>
        }
        <span class="cov0" title="0">return "TX" + string(b)</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package account

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/resource"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type Service struct {
        db        *gorm.DB
        mockOrgID string
}

func NewService(db *gorm.DB, mockOrgID string) Service <span class="cov0" title="0">{
        return Service{db: db, mockOrgID: mockOrgID}
}</span>

func (s Service) WithTx(tx *gorm.DB) Service <span class="cov0" title="0">{
        return NewService(tx, s.mockOrgID)
}</span>

func (s Service) Authorize(ctx context.Context, accIDs []string, consentID, orgID string) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txService := s.WithTx(tx)
                for _, accID := range accIDs </span><span class="cov0" title="0">{
                        acc, err := txService.Account(ctx, Query{ID: accID}, orgID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">status := resource.StatusAvailable
                        if acc.SubType == SubTypeJointSimple </span><span class="cov0" title="0">{
                                status = resource.StatusPendingAuthorization
                        }</span>

                        <span class="cov0" title="0">if err := txService.createConsent(ctx, &amp;ConsentAccount{
                                ConsentID: uuid.MustParse(consentID),
                                AccountID: uuid.MustParse(accID),
                                OwnerID:   acc.OwnerID,
                                Status:    status,
                                OrgID:     orgID,
                        }); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("could not create resource for account: %w", err)
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
}

func (s Service) Create(ctx context.Context, acc *Account) error <span class="cov0" title="0">{
        now := timeutil.DateTimeNow()
        acc.CreatedAt = now
        acc.UpdatedAt = now
        tx := s.db.WithContext(ctx).Create(acc)
        if err := tx.Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) Update(ctx context.Context, acc *Account) error <span class="cov0" title="0">{
        acc.UpdatedAt = timeutil.DateTimeNow()
        tx := s.db.WithContext(ctx).
                Model(&amp;Account{}).
                Omit("ID", "CreatedAt", "OrgID").
                Clauses(clause.Returning{Columns: []clause.Column{{Name: "created_at"}}}).
                Where("id = ? AND org_id = ?", acc.ID, acc.OrgID).
                Updates(acc)

        if err := tx.Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">if tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) UpdateConsent(ctx context.Context, consentID, accountID uuid.UUID, orgID string, status resource.Status) error <span class="cov0" title="0">{
        tx := s.db.WithContext(ctx).
                Model(&amp;ConsentAccount{}).
                Where("consent_id = ? AND account_id = ? AND org_id = ?", consentID, accountID, orgID).
                Updates(map[string]any{
                        "status":     status,
                        "updated_at": timeutil.DateTimeNow(),
                })

        if tx.Error != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update consent account: %w", tx.Error)
        }</span>

        <span class="cov0" title="0">if tx.RowsAffected == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no matching consent account found for consent_id=%s account_id=%s", consentID, accountID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) Account(ctx context.Context, query Query, orgID string) (*Account, error) <span class="cov0" title="0">{
        dbQuery := s.db.WithContext(ctx).Where("org_id = ? OR org_id = ?", orgID, s.mockOrgID)
        if query.ID != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("id = ?", query.ID)
        }</span>
        <span class="cov0" title="0">if query.Number != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("number = ?", query.Number)
        }</span>

        <span class="cov0" title="0">acc := &amp;Account{}
        if err := dbQuery.First(acc).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("could not fetch account: %w", err)</span>
        }
        <span class="cov0" title="0">return acc, nil</span>
}

func (s Service) Accounts(ctx context.Context, ownerID, orgID string, pag page.Pagination) (page.Page[*Account], error) <span class="cov0" title="0">{
        query := s.db.WithContext(ctx).Where("owner_id = ? AND (org_id = ? OR org_id = ?)", ownerID, orgID, s.mockOrgID)

        var accounts []*Account
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;accounts).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Account]{}, fmt.Errorf("could not find consented accounts: %w", err)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Account]{}, fmt.Errorf("count failed: %w", err)
        }</span>

        <span class="cov0" title="0">return page.New(accounts, pag, int(total)), nil</span>
}

func (s Service) ConsentedAccount(ctx context.Context, accountID, consentID, orgID string) (*Account, error) <span class="cov0" title="0">{
        consentAcc := &amp;ConsentAccount{}
        if err := s.db.WithContext(ctx).
                Preload("Account").
                Where(`account_id = ? AND consent_id = ? AND org_id = ?`, accountID, consentID, orgID).
                First(consentAcc).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotAllowed
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("could not fetch consent account: %w", err)</span>
        }

        <span class="cov0" title="0">if err := s.runConsentPostCreationAutomations(ctx, consentAcc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if consentAcc.Status != resource.StatusAvailable </span><span class="cov0" title="0">{
                return nil, ErrJointAccountPendingAuthorization
        }</span>

        <span class="cov0" title="0">return consentAcc.Account, nil</span>
}

func (s Service) ConsentedAccounts(ctx context.Context, consentID, orgID string, pag page.Pagination) (page.Page[*Account], error) <span class="cov0" title="0">{
        query := s.db.WithContext(ctx).
                Model(&amp;ConsentAccount{}).
                Preload("Account").
                Where(`org_id = ? AND consent_id = ?`, orgID, consentID).
                // Only return accounts that are available or accounts that are pending authorization and were updated more than 3 minutes ago.
                Where("status = ? OR (status = ? AND updated_at &lt; ?)", resource.StatusAvailable, resource.StatusPendingAuthorization, timeutil.DateTimeNow().Add(-3*time.Minute))

        var consentAccs []*ConsentAccount
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;consentAccs).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Account]{}, fmt.Errorf("failed to find consented accounts: %w", err)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Account]{}, fmt.Errorf("failed to count consented accounts: %w", err)
        }</span>

        <span class="cov0" title="0">var accs []*Account
        for _, consentAcc := range consentAccs </span><span class="cov0" title="0">{
                if err := s.runConsentPostCreationAutomations(ctx, consentAcc); err != nil </span><span class="cov0" title="0">{
                        return page.Page[*Account]{}, err
                }</span>
                <span class="cov0" title="0">accs = append(accs, consentAcc.Account)</span>
        }
        <span class="cov0" title="0">return page.New(accs, pag, int(total)), nil</span>
}

func (s Service) Delete(ctx context.Context, id uuid.UUID, orgID string) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Where("id = ? AND org_id = ?", id, orgID).Delete(&amp;Account{}).Error
}</span>

func (s Service) Transactions(ctx context.Context, accID, orgID string, pag page.Pagination, filter TransactionFilter) (page.Page[*Transaction], error) <span class="cov0" title="0">{
        query := s.db.WithContext(ctx).
                Model(&amp;Transaction{}).
                Where("account_id = ? AND created_at &gt;= ? AND created_at &lt;= ? AND (org_id = ? OR org_id = ?)",
                        accID, filter.from.Time, filter.to.Time, orgID, s.mockOrgID)

        if filter.movementType != "" </span><span class="cov0" title="0">{
                query = query.Where("movement_type = ?", filter.movementType)
        }</span>

        <span class="cov0" title="0">var txs []*Transaction
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;txs).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Transaction]{}, err
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Transaction]{}, err
        }</span>

        <span class="cov0" title="0">return page.New(txs, pag, int(total)), nil</span>
}

func (s Service) ConsentedTransactions(ctx context.Context, accID, consentID, orgID string, pag page.Pagination, filter TransactionFilter) (page.Page[*Transaction], error) <span class="cov0" title="0">{
        consentAcc, err := s.ConsentedAccount(ctx, accID, consentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return page.Page[*Transaction]{}, err
        }</span>

        <span class="cov0" title="0">return s.Transactions(ctx, consentAcc.ID.String(), orgID, pag, filter)</span>
}

func (s Service) createConsent(ctx context.Context, consentAcc *ConsentAccount) error <span class="cov0" title="0">{
        now := timeutil.DateTimeNow()
        consentAcc.CreatedAt = now
        consentAcc.UpdatedAt = now
        return s.db.WithContext(ctx).Create(consentAcc).Error
}</span>

func (s Service) runConsentPostCreationAutomations(ctx context.Context, consentAcc *ConsentAccount) error <span class="cov0" title="0">{
        // Allow access to joint account if consent is pending authorization for more than 3 minutes.
        if consentAcc.Status == resource.StatusPendingAuthorization &amp;&amp;
                timeutil.DateTimeNow().After(consentAcc.UpdatedAt.Add(3*time.Minute).Time) </span><span class="cov0" title="0">{
                consentAcc.Status = resource.StatusAvailable
                return s.UpdateConsent(ctx, consentAcc.ConsentID, consentAcc.AccountID, consentAcc.OrgID, resource.StatusAvailable)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=accountv2 -o=./api_gen.go ./swagger.yml
package accountv2

import (
        "context"
        "errors"
        "net/http"
        "strings"

        "github.com/luikyv/mock-bank/internal/api/middleware"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var _ StrictServerInterface = Server{}

type BankConfig interface {
        Host() string
        Brand() string
        CNPJ() string
        ISPB() string
        IBGETownCode() string
        Currency() string
        AccountCompeCode() string
        AccountBranch() string
        AccountCheckDigit() string
}

type Server struct {
        config         BankConfig
        baseURL        string
        service        account.Service
        consentService consent.Service
        op             *provider.Provider
}

func NewServer(
        config BankConfig,
        service account.Service,
        consentService consent.Service,
        op *provider.Provider,
) Server <span class="cov0" title="0">{
        return Server{
                config:         config,
                baseURL:        config.Host() + "/open-banking/accounts/v2",
                service:        service,
                consentService: consentService,
                op:             op,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        accountMux := http.NewServeMux()

        authCodeAuthMiddleware := middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID, consent.ScopeID)
        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{ return "PARAMETRO_INVALIDO" }</span>)

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err, !strings.Contains(r.URL.Path, "/transactions-current"))
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{
                        swaggerMiddleware,
                        middleware.FAPIID(nil),
                },
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.AccountsGetAccounts)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts", handler)

        handler = http.HandlerFunc(wrapper.AccountsGetAccountsAccountID)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts/{accountId}", handler)

        handler = http.HandlerFunc(wrapper.AccountsGetAccountsAccountIDBalances)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsBalanceRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts/{accountId}/balances", handler)

        handler = http.HandlerFunc(wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsOverdraftLimitsRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts/{accountId}/overdraft-limits", handler)

        handler = http.HandlerFunc(wrapper.AccountsGetAccountsAccountIDTransactions)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsTransactionsRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts/{accountId}/transactions", handler)

        handler = http.HandlerFunc(wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)
        handler = middleware.Permission(s.consentService, consent.PermissionAccountsTransactionsRead)(handler)
        handler = authCodeAuthMiddleware(handler)
        accountMux.Handle("GET /accounts/{accountId}/transactions-current", handler)

        mux.Handle("/open-banking/accounts/v2/", http.StripPrefix("/open-banking/accounts/v2", accountMux))</span>
}

func (s Server) AccountsGetAccounts(ctx context.Context, req AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)

        accs, err := s.service.ConsentedAccounts(ctx, consentID, orgID, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseAccountList{
                Data:  []AccountData{},
                Meta:  *api.NewPaginatedMeta(accs),
                Links: *api.NewPaginatedLinks(s.baseURL+"/accounts", accs),
        }
        defaultBranch := s.config.AccountBranch()
        for _, acc := range accs.Records </span><span class="cov0" title="0">{
                resp.Data = append(resp.Data, AccountData{
                        AccountID:   acc.ID.String(),
                        BranchCode:  &amp;defaultBranch,
                        BrandName:   s.config.Brand(),
                        CheckDigit:  s.config.AccountCheckDigit(),
                        CompanyCnpj: s.config.CNPJ(),
                        CompeCode:   s.config.AccountCompeCode(),
                        Number:      acc.Number,
                        Type:        EnumAccountType(acc.Type),
                })
        }</span>

        <span class="cov0" title="0">return AccountsGetAccounts200JSONResponse{OKResponseAccountListJSONResponse: OKResponseAccountListJSONResponse(resp)}, nil</span>
}

func (s Server) AccountsGetAccountsAccountID(ctx context.Context, req AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)

        acc, err := s.service.ConsentedAccount(ctx, req.AccountID, consentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defaultBranch := s.config.AccountBranch()
        resp := ResponseAccountIdentification{
                Data: AccountIdentificationData{
                        BranchCode: &amp;defaultBranch,
                        CheckDigit: s.config.AccountCheckDigit(),
                        CompeCode:  s.config.AccountCompeCode(),
                        Currency:   s.config.Currency(),
                        Number:     acc.Number,
                        Subtype:    EnumAccountSubType(acc.SubType),
                        Type:       EnumAccountType(acc.Type),
                },
                Meta:  *api.NewSingleRecordMeta(),
                Links: *api.NewLinks(s.baseURL + "/accounts/" + req.AccountID),
        }
        return AccountsGetAccountsAccountID200JSONResponse{OKResponseAccountIdentificationJSONResponse(resp)}, nil</span>
}

func (s Server) AccountsGetAccountsAccountIDBalances(ctx context.Context, req AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)

        acc, err := s.service.ConsentedAccount(ctx, req.AccountID, consentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseAccountBalances{
                Data: AccountBalancesData{
                        AutomaticallyInvestedAmount: AccountBalancesDataAutomaticallyInvestedAmount{
                                Amount:   acc.AvailableAmount,
                                Currency: s.config.Currency(),
                        },
                        AvailableAmount: AccountBalancesDataAvailableAmount{
                                Amount:   acc.AvailableAmount,
                                Currency: s.config.Currency(),
                        },
                        BlockedAmount: AccountBalancesDataBlockedAmount{
                                Amount:   acc.BlockedAmount,
                                Currency: s.config.Currency(),
                        },
                        UpdateDateTime: acc.UpdatedAt,
                },
                Meta:  *api.NewSingleRecordMeta(),
                Links: *api.NewLinks(s.baseURL + "/accounts/" + req.AccountID + "/balances"),
        }
        return AccountsGetAccountsAccountIDBalances200JSONResponse{OKResponseAccountBalancesJSONResponse(resp)}, nil</span>
}

func (s Server) AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, req AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)

        acc, err := s.service.ConsentedAccount(ctx, req.AccountID, consentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseAccountOverdraftLimits{
                Meta:  *api.NewSingleRecordMeta(),
                Links: *api.NewLinks(s.baseURL + "/accounts/" + req.AccountID + "/overdraft-limits"),
        }
        if acc.OverdraftLimitContracted != "" </span><span class="cov0" title="0">{
                resp.Data.OverdraftContractedLimit = &amp;AccountOverdraftLimitsDataOverdraftContractedLimit{
                        Amount:   acc.OverdraftLimitContracted,
                        Currency: s.config.Currency(),
                }
        }</span>
        <span class="cov0" title="0">if acc.OverdraftLimitUsed != "" </span><span class="cov0" title="0">{
                resp.Data.OverdraftUsedLimit = &amp;AccountOverdraftLimitsDataOverdraftUsedLimit{
                        Amount:   acc.OverdraftLimitUsed,
                        Currency: s.config.Currency(),
                }
        }</span>
        <span class="cov0" title="0">if acc.OverdraftLimitUnarranged != "" </span><span class="cov0" title="0">{
                resp.Data.UnarrangedOverdraftAmount = &amp;AccountOverdraftLimitsDataUnarrangedOverdraftAmount{
                        Amount:   acc.OverdraftLimitUnarranged,
                        Currency: s.config.Currency(),
                }
        }</span>

        <span class="cov0" title="0">return AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse{OKResponseAccountOverdraftLimitsJSONResponse(resp)}, nil</span>
}

func (s Server) AccountsGetAccountsAccountIDTransactions(ctx context.Context, req AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        filter, err := account.NewTransactionFilter(req.Params.FromBookingDate, req.Params.ToBookingDate, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Params.CreditDebitIndicator != nil </span><span class="cov0" title="0">{
                filter = filter.WithMovementType(account.MovementType(*req.Params.CreditDebitIndicator))
        }</span>

        <span class="cov0" title="0">txs, err := s.service.ConsentedTransactions(ctx, req.AccountID, consentID, orgID, pag, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseAccountTransactions{
                Data:  []AccountTransactionsData{},
                Meta:  *api.NewMeta(),
                Links: *api.NewPaginatedLinks(s.baseURL+"/accounts/"+req.AccountID+"/transactions", txs),
        }
        for _, tx := range txs.Records </span><span class="cov0" title="0">{
                data := AccountTransactionsData{
                        CompletedAuthorisedPaymentType: EnumCompletedAuthorisedPaymentIndicator(tx.Status),
                        CreditDebitType:                EnumCreditDebitIndicator(tx.MovementType),
                        PartieBranchCode:               tx.PartieBranchCode,
                        PartieCheckDigit:               tx.PartieCheckDigit,
                        PartieCnpjCpf:                  tx.PartieCNPJCPF,
                        PartieCompeCode:                tx.PartieCompeCode,
                        PartieNumber:                   tx.PartieNumber,
                        TransactionAmount: AccountTransactionsDataAmount{
                                Amount:   tx.Amount,
                                Currency: s.config.Currency(),
                        },
                        TransactionDateTime: tx.CreatedAt.Format(timeutil.DateTimeMillisFormat),
                        TransactionID:       tx.ID,
                        TransactionName:     tx.Name,
                        Type:                EnumTransactionTypes(tx.Type),
                }
                if tx.PartiePersonType != nil </span><span class="cov0" title="0">{
                        partiePersonType := EnumPartiePersonType(*tx.PartiePersonType)
                        data.PartiePersonType = &amp;partiePersonType
                }</span>
                <span class="cov0" title="0">resp.Data = append(resp.Data, data)</span>
        }
        <span class="cov0" title="0">return AccountsGetAccountsAccountIDTransactions200JSONResponse{OKResponseAccountTransactionsJSONResponse(resp)}, nil</span>
}

func (s Server) AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, req AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        filter, err := account.NewTransactionFilter(req.Params.FromBookingDate, req.Params.ToBookingDate, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if req.Params.CreditDebitIndicator != nil </span><span class="cov0" title="0">{
                filter = filter.WithMovementType(account.MovementType(*req.Params.CreditDebitIndicator))
        }</span>

        <span class="cov0" title="0">txs, err := s.service.ConsentedTransactions(ctx, req.AccountID, consentID, orgID, pag, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseAccountTransactions{
                Data:  []AccountTransactionsData{},
                Meta:  *api.NewMeta(),
                Links: *api.NewPaginatedLinks(s.baseURL+"/accounts/"+req.AccountID+"/transactions-current", txs),
        }
        for _, tx := range txs.Records </span><span class="cov0" title="0">{
                data := AccountTransactionsData{
                        CompletedAuthorisedPaymentType: EnumCompletedAuthorisedPaymentIndicator(tx.Status),
                        CreditDebitType:                EnumCreditDebitIndicator(tx.MovementType),
                        PartieBranchCode:               tx.PartieBranchCode,
                        PartieCheckDigit:               tx.PartieCheckDigit,
                        PartieCnpjCpf:                  tx.PartieCNPJCPF,
                        PartieCompeCode:                tx.PartieCompeCode,
                        PartieNumber:                   tx.PartieNumber,
                        TransactionAmount: AccountTransactionsDataAmount{
                                Amount:   tx.Amount,
                                Currency: s.config.Currency(),
                        },
                        TransactionDateTime: tx.CreatedAt.Format(timeutil.DateTimeMillisFormat),
                        TransactionID:       tx.ID,
                        TransactionName:     tx.Name,
                        Type:                EnumTransactionTypes(tx.Type),
                }
                if tx.PartiePersonType != nil </span><span class="cov0" title="0">{
                        partiePersonType := EnumPartiePersonType(*tx.PartiePersonType)
                        data.PartiePersonType = &amp;partiePersonType
                }</span>
                <span class="cov0" title="0">resp.Data = append(resp.Data, data)</span>
        }

        <span class="cov0" title="0">return AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse{OKResponseAccountTransactionsJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error, pagination bool) <span class="cov0" title="0">{
        if errors.Is(err, account.ErrNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("FORBIDDEN", http.StatusForbidden, account.ErrNotAllowed.Error()).Pagination(pagination))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, account.ErrJointAccountPendingAuthorization) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("STATUS_RESOURCE_PENDING_AUTHORISATION", http.StatusForbidden, account.ErrJointAccountPendingAuthorization.Error()).Pagination(pagination))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">//go:build go1.22

// Package accountv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package accountv2

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        OAuth2SecurityScopes = "OAuth2Security.Scopes"
        OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for EnumAccountSubType.
const (
        CONJUNTASIMPLES   EnumAccountSubType = "CONJUNTA_SIMPLES"
        CONJUNTASOLIDARIA EnumAccountSubType = "CONJUNTA_SOLIDARIA"
        INDIVIDUAL        EnumAccountSubType = "INDIVIDUAL"
)

// Defines values for EnumAccountType.
const (
        CONTADEPOSITOAVISTA   EnumAccountType = "CONTA_DEPOSITO_A_VISTA"
        CONTAPAGAMENTOPREPAGA EnumAccountType = "CONTA_PAGAMENTO_PRE_PAGA"
        CONTAPOUPANCA         EnumAccountType = "CONTA_POUPANCA"
)

// Defines values for EnumCompletedAuthorisedPaymentIndicator.
const (
        LANCAMENTOFUTURO     EnumCompletedAuthorisedPaymentIndicator = "LANCAMENTO_FUTURO"
        TRANSACAOEFETIVADA   EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_EFETIVADA"
        TRANSACAOPROCESSANDO EnumCompletedAuthorisedPaymentIndicator = "TRANSACAO_PROCESSANDO"
)

// Defines values for EnumCreditDebitIndicator.
const (
        CREDITO EnumCreditDebitIndicator = "CREDITO"
        DEBITO  EnumCreditDebitIndicator = "DEBITO"
)

// Defines values for EnumPartiePersonType.
const (
        PESSOAJURIDICA EnumPartiePersonType = "PESSOA_JURIDICA"
        PESSOANATURAL  EnumPartiePersonType = "PESSOA_NATURAL"
)

// Defines values for EnumTransactionTypes.
const (
        BOLETO                        EnumTransactionTypes = "BOLETO"
        CARTAO                        EnumTransactionTypes = "CARTAO"
        CONVENIOARRECADACAO           EnumTransactionTypes = "CONVENIO_ARRECADACAO"
        DEPOSITO                      EnumTransactionTypes = "DEPOSITO"
        DOC                           EnumTransactionTypes = "DOC"
        ENCARGOSJUROSCHEQUEESPECIAL   EnumTransactionTypes = "ENCARGOS_JUROS_CHEQUE_ESPECIAL"
        FOLHAPAGAMENTO                EnumTransactionTypes = "FOLHA_PAGAMENTO"
        OPERACAOCREDITO               EnumTransactionTypes = "OPERACAO_CREDITO"
        OUTROS                        EnumTransactionTypes = "OUTROS"
        PACOTETARIFASERVICOS          EnumTransactionTypes = "PACOTE_TARIFA_SERVICOS"
        PIX                           EnumTransactionTypes = "PIX"
        PORTABILIDADESALARIO          EnumTransactionTypes = "PORTABILIDADE_SALARIO"
        RENDIMENTOAPLICFINANCEIRA     EnumTransactionTypes = "RENDIMENTO_APLIC_FINANCEIRA"
        RESGATEAPLICFINANCEIRA        EnumTransactionTypes = "RESGATE_APLIC_FINANCEIRA"
        SAQUE                         EnumTransactionTypes = "SAQUE"
        TARIFASERVICOSAVULSOS         EnumTransactionTypes = "TARIFA_SERVICOS_AVULSOS"
        TED                           EnumTransactionTypes = "TED"
        TRANSFERENCIAMESMAINSTITUICAO EnumTransactionTypes = "TRANSFERENCIA_MESMA_INSTITUICAO"
)

// AccountBalancesData Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountBalancesData struct {
        // AutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
        AutomaticallyInvestedAmount AccountBalancesDataAutomaticallyInvestedAmount `json:"automaticallyInvestedAmount"`

        // AvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
        AvailableAmount AccountBalancesDataAvailableAmount `json:"availableAmount"`

        // BlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
        BlockedAmount AccountBalancesDataBlockedAmount `json:"blockedAmount"`

        // UpdateDateTime Data e hora da última atualização do saldo. É esperado que a instituição informe a última vez que capturou o saldo para compartilhamento no Open Finance. Dessa forma, é possível que:
        // - Caso a instituição capture dados de forma síncrona essa informação seja de poucos momentos;
        // - Caso a instituição capture dados de forma assíncrona essa informação seja de horas ou dias no passado;
        // - Quando não existente uma data vinculada especificamente ao bloco, se assume a data e hora de atualização do cadastro como um todo.
        //
        // De toda forma, é preciso continuar respeitando o prazo máximo de tempestividade da API de Contas.
        UpdateDateTime timeutil.DateTime `json:"updateDateTime"`
}

// AccountBalancesDataAutomaticallyInvestedAmount Saldo disponível com aplicação automática - corresponde a soma do saldo disponível acrescido do valor obtido a partir da aplicação automática. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAutomaticallyInvestedAmount struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountBalancesDataAvailableAmount Saldo disponível para utilização imediata. No caso de conta de depósito a vista, sem considerar cheque especial e investimentos atrelados a conta. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataAvailableAmount struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountBalancesDataBlockedAmount Saldo bloqueado, não disponível para utilização imediata, por motivo de bloqueio apresentado para o cliente nos canais eletrônicos. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountBalancesDataBlockedAmount struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountData defines model for AccountData.
type AccountData struct {
        // AccountID Identifica de forma única  a conta do cliente, mantendo as regras de imutabilidade dentro da instituição transmissora.
        AccountID string `json:"accountId"`

        // BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
        //
        // [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de CONTA_PAGAMENTO_PRE_PAGA.
        BranchCode *string `json:"branchCode,omitempty"`

        // BrandName Nome da Marca reportada pelo participante no Open Finance. Recomenda-se utilizar, sempre que possível, o mesmo nome de marca atribuído no campo do diretório Customer Friendly Server Name (Authorisation Server).
        BrandName string `json:"brandName"`

        // CheckDigit Dígito da conta
        CheckDigit string `json:"checkDigit"`

        // CompanyCnpj Número completo do CNPJ da instituição responsável pelo Cadastro - o CNPJ corresponde ao número de inscrição no Cadastro de Pessoa Jurídica. Deve-se ter apenas os números do CNPJ, sem máscara
        CompanyCnpj string `json:"companyCnpj"`

        // CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas).O Compe (Sistema de Compensação de Cheques e Outros Papéis) é um sistema que identifica e processa as compensações bancárias. Ele é representado por um código de três dígitos que serve como identificador de bancos, sendo assim, cada instituição bancária possui um número exclusivo
        CompeCode string `json:"compeCode"`

        // Number Número da conta
        Number string `json:"number"`

        // Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
        // Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
        // Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
        // Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
        Type EnumAccountType `json:"type"`
}

// AccountIdentificationData Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
type AccountIdentificationData struct {
        // BranchCode Código da Agência detentora da conta. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
        //
        // [Restrição] Obrigatoriamente deve ser preenchido quando o campo "type" for diferente de conta pré-paga.
        BranchCode *string `json:"branchCode,omitempty"`

        // CheckDigit Dígito da conta
        CheckDigit string `json:"checkDigit"`

        // CompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas). O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
        CompeCode string `json:"compeCode"`

        // Currency Moeda referente ao valor da transação, segundo modelo ISO-4217. p.ex. 'BRL'
        // Todos os saldos informados estão representados com a moeda vigente do Brasil
        Currency string `json:"currency"`

        // Number Número da conta
        Number string `json:"number"`

        // Subtype Subtipo de conta (vide Enum):
        // Conta individual - possui um único titular
        // Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
        // Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
        Subtype EnumAccountSubType `json:"subtype"`

        // Type Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
        // Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
        // Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
        // Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
        Type EnumAccountType `json:"type"`
}

// AccountOverdraftLimitsData Conjunto de informações da Conta de: depósito à vista
type AccountOverdraftLimitsData struct {
        // OverdraftContractedLimit Valor do limite contratado do cheque especial.
        OverdraftContractedLimit *AccountOverdraftLimitsDataOverdraftContractedLimit `json:"overdraftContractedLimit,omitempty"`

        // OverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
        OverdraftUsedLimit *AccountOverdraftLimitsDataOverdraftUsedLimit `json:"overdraftUsedLimit,omitempty"`

        // UnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
        UnarrangedOverdraftAmount *AccountOverdraftLimitsDataUnarrangedOverdraftAmount `json:"unarrangedOverdraftAmount,omitempty"`
}

// AccountOverdraftLimitsDataOverdraftContractedLimit Valor do limite contratado do cheque especial.
type AccountOverdraftLimitsDataOverdraftContractedLimit struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataOverdraftUsedLimit Valor utilizado total do limite do cheque especial e o adiantamento a depositante.
type AccountOverdraftLimitsDataOverdraftUsedLimit struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountOverdraftLimitsDataUnarrangedOverdraftAmount Valor de operação contratada em caráter emergencial para cobertura de saldo devedor em conta de depósitos à vista e de excesso sobre o limite pactuado de cheque especial.
type AccountOverdraftLimitsDataUnarrangedOverdraftAmount struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// AccountTransactionsData defines model for AccountTransactionsData.
type AccountTransactionsData struct {
        // CompletedAuthorisedPaymentType Indicador da transação:
        //   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
        //   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
        //   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
        CompletedAuthorisedPaymentType EnumCompletedAuthorisedPaymentIndicator `json:"completedAuthorisedPaymentType"`

        // CreditDebitType Indicador do tipo de lançamento:
        // Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
        // Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
        CreditDebitType EnumCreditDebitIndicator `json:"creditDebitType"`

        // PartieBranchCode Código da Agência detentora da conta da pessoa envolvida na transação. (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito, no exercício de atividades da instituição, não podendo ser móvel ou transitória)
        PartieBranchCode *string `json:"partieBranchCode,omitempty"`

        // PartieCheckDigit Dígito da conta da pessoa envolvida na transação
        PartieCheckDigit *string `json:"partieCheckDigit,omitempty"`

        // PartieCnpjCpf Identificação da pessoa envolvida na transação: pagador ou recebedor (Preencher com o CPF ou CNPJ, sem formatação). Com a IN BCB nº 371, a partir de 02/05/23, o envio das informações de identificação de contraparte tornou-se obrigatória para transações de pagamento. Para maiores detalhes, favor consultar a página `Orientações - Contas`.
        //
        // [Restrição] Quando o "type“ for preenchido com valor FOLHA_PAGAMENTO e a transmissora for a responsável pelo pagamento de salário (banco-folha), o partieCnpjCpf informado deve ser do empregador relacionado.
        PartieCnpjCpf *string `json:"partieCnpjCpf,omitempty"`

        // PartieCompeCode Código identificador atribuído pelo Banco Central do Brasil às instituições participantes do STR (Sistema de Transferência de reservas) referente à pessoa envolvida na transação. O número-código substituiu o antigo código COMPE. Todos os participantes do STR, exceto as Infraestruturas do Mercado Financeiro (IMF) e a Secretaria do Tesouro Nacional, possuem um número-código independentemente de participarem da Centralizadora da Compensação de Cheques (Compe).
        PartieCompeCode *string `json:"partieCompeCode,omitempty"`

        // PartieNumber Número da conta da pessoa envolvida na transação
        PartieNumber *string `json:"partieNumber,omitempty"`

        // PartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
        // Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
        // Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
        PartiePersonType *EnumPartiePersonType `json:"partiePersonType,omitempty"`

        // TransactionAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
        TransactionAmount AccountTransactionsDataAmount `json:"transactionAmount"`

        // TransactionDateTime Data e hora original da transação.
        TransactionDateTime string `json:"transactionDateTime"`

        // TransactionID Código ou identificador único prestado pela instituição que mantém a conta para representar a transação individual.
        // O ideal é que o `transactionId` seja imutável.
        // No entanto, o `transactionId` deve obedecer, no mínimo, as regras de imutabilidade propostas conforme tabela “Data de imutabilidade por tipo de transação” presente nas orientações desta API.
        TransactionID string `json:"transactionId"`

        // TransactionName Literal usada na instituição financeira para identificar a transação. A informação apresentada precisa ser a mesma utilizada nos canais eletrônicos da instituição (extrato). Em casos onde a descrição da transação é apresentada com múltiplas linhas, todas as linhas devem ser enviadas (concatenadas) neste atributo, não sendo obrigatória a concatenação das informações já enviadas em outros atributos (ex: valor, data) do mesmo endpoint.
        TransactionName string `json:"transactionName"`

        // Type O campo deve classificar a transação em um dos tipos descritos.
        // O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
        // A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
        // Por exemplo no caso de recebimento de pensão alimentícia.
        Type EnumTransactionTypes `json:"type"`
}

// AccountTransactionsDataAmount Valor da transação. Expresso em valor monetário com no mínimo 2 casas e no máximo 4 casas decimais.
type AccountTransactionsDataAmount struct {
        // Amount Valor relacionado ao objeto.
        Amount string `json:"amount"`

        // Currency Moeda referente ao valor monetário, seguindo o modelo ISO-4217.
        Currency string `json:"currency"`
}

// EnumAccountSubType Subtipo de conta (vide Enum):
// Conta individual - possui um único titular
// Conta conjunta simples - onde as movimentações financeiras só podem serem realizadas mediante autorização de TODOS os correntistas da conta.
// Conta conjunta solidária - é a modalidade cujos titulares podem realizar movimentações de forma isolada, isto é, sem que seja necessária a autorização dos demais titulares
type EnumAccountSubType string

// EnumAccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type EnumAccountType string

// EnumCompletedAuthorisedPaymentIndicator Indicador da transação:
//   - Transação efetivada: a transação atinge esse status quando o `transactionId` torna-se imutável;
//   - Lançamento futuro: a transação será efetivada em momento futuro, ou seja, o `transactionId` pode mudar;
//   - Transação processando: a transação está em processamento, ou seja, o `transactionId` pode mudar.
type EnumCompletedAuthorisedPaymentIndicator string

// EnumCreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type EnumCreditDebitIndicator string

// EnumPartiePersonType Identificação do Tipo de Pessoa da pessoa envolvida na transação.
// Pessoa Natural - Informar CPF no campo “partieCnpjCpf”.
// Pessoa Jurídica - Informar CNPJ no campo “partieCnpjCpf”.
type EnumPartiePersonType string

// EnumTransactionTypes O campo deve classificar a transação em um dos tipos descritos.
// O transmissor deve classificar as transações disponíveis associando-a a um dos itens do Enum listado neste campo.
// A opção OUTROS só deve ser utilizada para os casos em que de fato a transação compartilhada não possa ser classificada como um dos itens deste Enum.
// Por exemplo no caso de recebimento de pensão alimentícia.
type EnumTransactionTypes string

// ResponseAccountBalances defines model for ResponseAccountBalances.
type ResponseAccountBalances struct {
        // Data Conjunto de informações das Contas de: depósito à vista, poupança e de pagamento pré-paga
        Data  AccountBalancesData `json:"data"`
        Links api.Links           `json:"links"`
        Meta  api.Meta            `json:"meta"`
}

// ResponseAccountIdentification defines model for ResponseAccountIdentification.
type ResponseAccountIdentification struct {
        // Data Conjunto dos atributos que caracterizam as Contas de: depósito à vista, poupança e de pagamento pré-paga
        Data  AccountIdentificationData `json:"data"`
        Links api.Links                 `json:"links"`
        Meta  api.Meta                  `json:"meta"`
}

// ResponseAccountList defines model for ResponseAccountList.
type ResponseAccountList struct {
        // Data Lista de contas depósito à vista, poupança e pagamento pré-pagas mantidas pelo cliente na instituição transmissora e para as quais ele tenha fornecido consentimento
        Data  []AccountData `json:"data"`
        Links api.Links     `json:"links"`
        Meta  api.Meta      `json:"meta"`
}

// ResponseAccountOverdraftLimits defines model for ResponseAccountOverdraftLimits.
type ResponseAccountOverdraftLimits struct {
        // Data Conjunto de informações da Conta de: depósito à vista
        Data  AccountOverdraftLimitsData `json:"data"`
        Links api.Links                  `json:"links"`
        Meta  api.Meta                   `json:"meta"`
}

// ResponseAccountTransactions defines model for ResponseAccountTransactions.
type ResponseAccountTransactions struct {
        // Data Lista dos lançamentos referentes às transações realizadas e de lançamentos futuros para as contas de: depósito à vista, poupança e de pagamento pré-paga
        Data  []AccountTransactionsData `json:"data"`
        Links api.Links                 `json:"links"`
        Meta  api.Meta                  `json:"meta"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorMetaSingle defines model for ResponseErrorMetaSingle.
type ResponseErrorMetaSingle struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// Authorization defines model for Authorization.
type Authorization = string

// AccountID defines model for accountId.
type AccountID = string

// AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum
// Conta de depósito à vista ou Conta corrente - é o tipo mais comum. Nela, o dinheiro fica à sua disposição para ser sacado a qualquer momento. Essa conta não gera rendimentos para o depositante
// Conta poupança - foi criada para estimular as pessoas a pouparem. O dinheiro que ficar na conta por trinta dias passa a gerar rendimentos, com isenção de imposto de renda para quem declara. Ou seja, o dinheiro “cresce” (rende) enquanto ficar guardado na conta. Cada depósito terá rendimentos de mês em mês, sempre no dia do mês em que o dinheiro tiver sido depositado
// Conta de pagamento pré-paga: segundo CIRCULAR Nº 3.680, BCB de  2013, é a 'destinada à execução de transações de pagamento em moeda eletrônica realizadas com base em fundos denominados em reais previamente aportados'
type AccountType = EnumAccountType

// CreditDebitIndicator Indicador do tipo de lançamento:
// Débito (no extrato) Em um extrato bancário, os débitos, marcados com a letra “D” ao lado do valor registrado, informam as saídas de dinheiro na conta-corrente.
// Crédito (no extrato) Em um extrato bancário, os créditos, marcados com a letra “C” ao lado do valor registrado, informam as entradas de dinheiro na conta-corrente.
type CreditDebitIndicator = EnumCreditDebitIndicator

// FromBookingDate defines model for fromBookingDate.
type FromBookingDate = timeutil.BrazilDate

// FromBookingDateMaxLimited defines model for fromBookingDateMaxLimited.
type FromBookingDateMaxLimited = timeutil.BrazilDate

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// PaginationKey defines model for pagination-key.
type PaginationKey = string

// ToBookingDate defines model for toBookingDate.
type ToBookingDate = timeutil.BrazilDate

// ToBookingDateMaxLimited defines model for toBookingDateMaxLimited.
type ToBookingDateMaxLimited = timeutil.BrazilDate

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorMetaSingle

// BadRequestWithAdditionalProperties defines model for BadRequestWithAdditionalProperties.
type BadRequestWithAdditionalProperties = ResponseError

// Default defines model for Default.
type Default = ResponseErrorMetaSingle

// DefaultWithAdditionalProperties defines model for DefaultWithAdditionalProperties.
type DefaultWithAdditionalProperties = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorMetaSingle

// ForbiddenWithAdditionalProperties defines model for ForbiddenWithAdditionalProperties.
type ForbiddenWithAdditionalProperties = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorMetaSingle

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorMetaSingle

// InternalServerErrorWithAdditionalProperties defines model for InternalServerErrorWithAdditionalProperties.
type InternalServerErrorWithAdditionalProperties = ResponseError

// Locked defines model for Locked.
type Locked = ResponseErrorMetaSingle

// LockedWithAdditionalProperties defines model for LockedWithAdditionalProperties.
type LockedWithAdditionalProperties = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorMetaSingle

// MethodNotAllowedWithAdditionalProperties defines model for MethodNotAllowedWithAdditionalProperties.
type MethodNotAllowedWithAdditionalProperties = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorMetaSingle

// NotAcceptableWithAdditionalProperties defines model for NotAcceptableWithAdditionalProperties.
type NotAcceptableWithAdditionalProperties = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseErrorMetaSingle

// NotFoundWithAdditionalProperties defines model for NotFoundWithAdditionalProperties.
type NotFoundWithAdditionalProperties = ResponseError

// OKResponseAccountBalances defines model for OKResponseAccountBalances.
type OKResponseAccountBalances = ResponseAccountBalances

// OKResponseAccountIdentification defines model for OKResponseAccountIdentification.
type OKResponseAccountIdentification = ResponseAccountIdentification

// OKResponseAccountList defines model for OKResponseAccountList.
type OKResponseAccountList = ResponseAccountList

// OKResponseAccountOverdraftLimits defines model for OKResponseAccountOverdraftLimits.
type OKResponseAccountOverdraftLimits = ResponseAccountOverdraftLimits

// OKResponseAccountTransactions defines model for OKResponseAccountTransactions.
type OKResponseAccountTransactions = ResponseAccountTransactions

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorMetaSingle

// SiteIsOverloadedWithAdditionalProperties defines model for SiteIsOverloadedWithAdditionalProperties.
type SiteIsOverloadedWithAdditionalProperties = ResponseError

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorMetaSingle

// TooManyRequestsWithAdditionalProperties defines model for TooManyRequestsWithAdditionalProperties.
type TooManyRequestsWithAdditionalProperties = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorMetaSingle

// UnauthorizedWithAdditionalProperties defines model for UnauthorizedWithAdditionalProperties.
type UnauthorizedWithAdditionalProperties = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorMetaSingle

// UnprocessableEntityWithAdditionalProperties defines model for UnprocessableEntityWithAdditionalProperties.
type UnprocessableEntityWithAdditionalProperties = ResponseError

// AccountsGetAccountsParams defines parameters for AccountsGetAccounts.
type AccountsGetAccountsParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

        // AccountType Tipos de contas. Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas, conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica. Vide Enum.
        AccountType *AccountType `form:"accountType,omitempty" json:"accountType,omitempty"`

        // PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
        PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDParams defines parameters for AccountsGetAccountsAccountID.
type AccountsGetAccountsAccountIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDBalancesParams defines parameters for AccountsGetAccountsAccountIDBalances.
type AccountsGetAccountsAccountIDBalancesParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDOverdraftLimitsParams defines parameters for AccountsGetAccountsAccountIDOverdraftLimits.
type AccountsGetAccountsAccountIDOverdraftLimitsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsParams defines parameters for AccountsGetAccountsAccountIDTransactions.
type AccountsGetAccountsAccountIDTransactionsParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

        // FromBookingDate Data inicial de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
        FromBookingDate *FromBookingDate `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

        // ToBookingDate Data final de filtragem. [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado. Caso não seja informado, deve ser assumido o dia atual.
        ToBookingDate *ToBookingDate `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

        // CreditDebitIndicator Indicador do tipo de lançamento
        CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

        // PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
        PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// AccountsGetAccountsAccountIDTransactionsCurrentParams defines parameters for AccountsGetAccountsAccountIDTransactionsCurrent.
type AccountsGetAccountsAccountIDTransactionsCurrentParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

        // FromBookingDate Data inicial de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
        // [Restrição] Deve obrigatoriamente ser enviado caso o campo toBookingDate seja informado.
        // Caso não seja informado, deve ser assumido o dia atual.
        FromBookingDate *FromBookingDateMaxLimited `form:"fromBookingDate,omitempty" json:"fromBookingDate,omitempty"`

        // ToBookingDate Data final de filtragem. O período máximo utilizado no filtro é de 7 dias inclusive (D-6).
        // [Restrição] Deve obrigatoriamente ser enviado caso o campo fromBookingDate seja informado.
        // Caso não seja informado, deve ser assumido o dia atual.
        ToBookingDate *ToBookingDateMaxLimited `form:"toBookingDate,omitempty" json:"toBookingDate,omitempty"`

        // CreditDebitIndicator Indicador do tipo de lançamento
        CreditDebitIndicator *CreditDebitIndicator `form:"creditDebitIndicator,omitempty" json:"creditDebitIndicator,omitempty"`

        // PaginationKey Identificador de rechamada, utilizado para evitar a contagem de chamadas ao endpoint durante a paginação.
        PaginationKey *PaginationKey `form:"pagination-key,omitempty" json:"pagination-key,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Obtém a lista de contas consentidas pelo cliente.
        // (GET /accounts)
        AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams)
        // Obtém os dados de identificação da conta identificada por accountId.
        // (GET /accounts/{accountId})
        AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams)
        // Obtém os saldos da conta identificada por accountId.
        // (GET /accounts/{accountId}/balances)
        AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams)
        // Obtém os limites da conta identificada por accountId.
        // (GET /accounts/{accountId}/overdraft-limits)
        AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams)
        // Obtém a lista de transações da conta identificada por accountId.
        // (GET /accounts/{accountId}/transactions)
        AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams)
        // Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
        // (GET /accounts/{accountId}/transactions-current)
        AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AccountsGetAccounts operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccounts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "accountType" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "accountType", r.URL.Query(), &amp;params.AccountType)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountType", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "pagination-key" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &amp;params.PaginationKey)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "pagination-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccounts(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AccountsGetAccountsAccountID operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "accountId" -------------
        var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsAccountIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccountsAccountID(w, r, accountID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "accountId" -------------
        var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsAccountIDBalancesParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccountsAccountIDBalances(w, r, accountID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "accountId" -------------
        var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsAccountIDOverdraftLimitsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccountsAccountIDOverdraftLimits(w, r, accountID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "accountId" -------------
        var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsAccountIDTransactionsParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "fromBookingDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &amp;params.FromBookingDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "toBookingDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &amp;params.ToBookingDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "creditDebitIndicator" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &amp;params.CreditDebitIndicator)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "pagination-key" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &amp;params.PaginationKey)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "pagination-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccountsAccountIDTransactions(w, r, accountID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (siw *ServerInterfaceWrapper) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "accountId" -------------
        var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "accounts"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AccountsGetAccountsAccountIDTransactionsCurrentParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "fromBookingDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "fromBookingDate", r.URL.Query(), &amp;params.FromBookingDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "fromBookingDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "toBookingDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "toBookingDate", r.URL.Query(), &amp;params.ToBookingDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "toBookingDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "creditDebitIndicator" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "creditDebitIndicator", r.URL.Query(), &amp;params.CreditDebitIndicator)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "creditDebitIndicator", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "pagination-key" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "pagination-key", r.URL.Query(), &amp;params.PaginationKey)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "pagination-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AccountsGetAccountsAccountIDTransactionsCurrent(w, r, accountID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("GET "+options.BaseURL+"/accounts", wrapper.AccountsGetAccounts)
        m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}", wrapper.AccountsGetAccountsAccountID)
        m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/balances", wrapper.AccountsGetAccountsAccountIDBalances)
        m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/overdraft-limits", wrapper.AccountsGetAccountsAccountIDOverdraftLimits)
        m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions", wrapper.AccountsGetAccountsAccountIDTransactions)
        m.HandleFunc("GET "+options.BaseURL+"/accounts/{accountId}/transactions-current", wrapper.AccountsGetAccountsAccountIDTransactionsCurrent)

        return m</span>
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type DefaultWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type LockedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type OKResponseAccountBalancesJSONResponse ResponseAccountBalances

type OKResponseAccountIdentificationJSONResponse ResponseAccountIdentification

type OKResponseAccountListJSONResponse ResponseAccountList

type OKResponseAccountOverdraftLimitsJSONResponse ResponseAccountOverdraftLimits

type OKResponseAccountTransactionsJSONResponse ResponseAccountTransactions

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorMetaSingle

type UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type AccountsGetAccountsRequestObject struct {
        Params AccountsGetAccountsParams
}

type AccountsGetAccountsResponseObject interface {
        VisitAccountsGetAccountsResponse(w http.ResponseWriter) error
}

type AccountsGetAccounts200JSONResponse struct {
        OKResponseAccountListJSONResponse
}

func (response AccountsGetAccounts200JSONResponse) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts400ApplicationJSONCharsetUTF8Response struct {
        BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts404ApplicationJSONCharsetUTF8Response struct {
        NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts423ApplicationJSONCharsetUTF8Response struct {
        LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccounts529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccounts529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseError
        StatusCode int
}

func (response AccountsGetAccountsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AccountsGetAccountsAccountIDRequestObject struct {
        AccountID AccountID `json:"accountId"`
        Params    AccountsGetAccountsAccountIDParams
}

type AccountsGetAccountsAccountIDResponseObject interface {
        VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountID200JSONResponse struct {
        OKResponseAccountIdentificationJSONResponse
}

func (response AccountsGetAccountsAccountID200JSONResponse) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response struct {
        LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountID529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseError
        StatusCode int
}

func (response AccountsGetAccountsAccountIDdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AccountsGetAccountsAccountIDBalancesRequestObject struct {
        AccountID AccountID `json:"accountId"`
        Params    AccountsGetAccountsAccountIDBalancesParams
}

type AccountsGetAccountsAccountIDBalancesResponseObject interface {
        VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDBalances200JSONResponse struct {
        OKResponseAccountBalancesJSONResponse
}

func (response AccountsGetAccountsAccountIDBalances200JSONResponse) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response struct {
        BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response struct {
        NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response struct {
        LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDBalances529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseError
        StatusCode int
}

func (response AccountsGetAccountsAccountIDBalancesdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDBalancesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimitsRequestObject struct {
        AccountID AccountID `json:"accountId"`
        Params    AccountsGetAccountsAccountIDOverdraftLimitsParams
}

type AccountsGetAccountsAccountIDOverdraftLimitsResponseObject interface {
        VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse struct {
        OKResponseAccountOverdraftLimitsJSONResponse
}

func (response AccountsGetAccountsAccountIDOverdraftLimits200JSONResponse) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response struct {
        BadRequestWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response struct {
        NotFoundWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response struct {
        LockedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDOverdraftLimits529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseError
        StatusCode int
}

func (response AccountsGetAccountsAccountIDOverdraftLimitsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AccountsGetAccountsAccountIDTransactionsRequestObject struct {
        AccountID AccountID `json:"accountId"`
        Params    AccountsGetAccountsAccountIDTransactionsParams
}

type AccountsGetAccountsAccountIDTransactionsResponseObject interface {
        VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactions200JSONResponse struct {
        OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactions200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response struct {
        LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactions529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseErrorMetaSingle
        StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrentRequestObject struct {
        AccountID AccountID `json:"accountId"`
        Params    AccountsGetAccountsAccountIDTransactionsCurrentParams
}

type AccountsGetAccountsAccountIDTransactionsCurrentResponseObject interface {
        VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error
}

type AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse struct {
        OKResponseAccountTransactionsJSONResponse
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent200JSONResponse) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent400ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent401ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent403ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent404ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent405ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent406ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent422ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response struct {
        LockedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent423ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(423)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent429ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent500ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent504ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AccountsGetAccountsAccountIDTransactionsCurrent529ApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseErrorMetaSingle
        StatusCode int
}

func (response AccountsGetAccountsAccountIDTransactionsCurrentdefaultApplicationJSONCharsetUTF8Response) VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Obtém a lista de contas consentidas pelo cliente.
        // (GET /accounts)
        AccountsGetAccounts(ctx context.Context, request AccountsGetAccountsRequestObject) (AccountsGetAccountsResponseObject, error)
        // Obtém os dados de identificação da conta identificada por accountId.
        // (GET /accounts/{accountId})
        AccountsGetAccountsAccountID(ctx context.Context, request AccountsGetAccountsAccountIDRequestObject) (AccountsGetAccountsAccountIDResponseObject, error)
        // Obtém os saldos da conta identificada por accountId.
        // (GET /accounts/{accountId}/balances)
        AccountsGetAccountsAccountIDBalances(ctx context.Context, request AccountsGetAccountsAccountIDBalancesRequestObject) (AccountsGetAccountsAccountIDBalancesResponseObject, error)
        // Obtém os limites da conta identificada por accountId.
        // (GET /accounts/{accountId}/overdraft-limits)
        AccountsGetAccountsAccountIDOverdraftLimits(ctx context.Context, request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject) (AccountsGetAccountsAccountIDOverdraftLimitsResponseObject, error)
        // Obtém a lista de transações da conta identificada por accountId.
        // (GET /accounts/{accountId}/transactions)
        AccountsGetAccountsAccountIDTransactions(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsRequestObject) (AccountsGetAccountsAccountIDTransactionsResponseObject, error)
        // Obtém a lista de transações recentes (últimos 7 dias) da conta identificada por accountId.
        // (GET /accounts/{accountId}/transactions-current)
        AccountsGetAccountsAccountIDTransactionsCurrent(ctx context.Context, request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject) (AccountsGetAccountsAccountIDTransactionsCurrentResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// AccountsGetAccounts operation middleware
func (sh *strictHandler) AccountsGetAccounts(w http.ResponseWriter, r *http.Request, params AccountsGetAccountsParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsRequestObject

        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccounts(ctx, request.(AccountsGetAccountsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccounts")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AccountsGetAccountsAccountID operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountID(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsAccountIDRequestObject

        request.AccountID = accountID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccountsAccountID(ctx, request.(AccountsGetAccountsAccountIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccountsAccountID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsAccountIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsAccountIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AccountsGetAccountsAccountIDBalances operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDBalances(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDBalancesParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsAccountIDBalancesRequestObject

        request.AccountID = accountID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccountsAccountIDBalances(ctx, request.(AccountsGetAccountsAccountIDBalancesRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccountsAccountIDBalances")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsAccountIDBalancesResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsAccountIDBalancesResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AccountsGetAccountsAccountIDOverdraftLimits operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDOverdraftLimits(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDOverdraftLimitsParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsAccountIDOverdraftLimitsRequestObject

        request.AccountID = accountID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccountsAccountIDOverdraftLimits(ctx, request.(AccountsGetAccountsAccountIDOverdraftLimitsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccountsAccountIDOverdraftLimits")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsAccountIDOverdraftLimitsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsAccountIDOverdraftLimitsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AccountsGetAccountsAccountIDTransactions operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactions(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsAccountIDTransactionsRequestObject

        request.AccountID = accountID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccountsAccountIDTransactions(ctx, request.(AccountsGetAccountsAccountIDTransactionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccountsAccountIDTransactions")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AccountsGetAccountsAccountIDTransactionsCurrent operation middleware
func (sh *strictHandler) AccountsGetAccountsAccountIDTransactionsCurrent(w http.ResponseWriter, r *http.Request, accountID AccountID, params AccountsGetAccountsAccountIDTransactionsCurrentParams) <span class="cov0" title="0">{
        var request AccountsGetAccountsAccountIDTransactionsCurrentRequestObject

        request.AccountID = accountID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AccountsGetAccountsAccountIDTransactionsCurrent(ctx, request.(AccountsGetAccountsAccountIDTransactionsCurrentRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AccountsGetAccountsAccountIDTransactionsCurrent")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AccountsGetAccountsAccountIDTransactionsCurrentResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAccountsGetAccountsAccountIDTransactionsCurrentResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
        "8erJ1f8PAAD//5jksAKH1QAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=app -o=./api_gen.go ./swagger.yml
package app

import (
        "context"
        "errors"
        "net/http"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/resource"
        "github.com/luikyv/mock-bank/internal/session"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "github.com/rs/cors"
        "github.com/unrolled/secure"
)

const (
        cookieSessionId = "sessionId"
        sessionValidity = 3 * time.Hour
)

var _ StrictServerInterface = Server{}

type BankConfig interface {
        AccountBranch() string
        AccountCheckDigit() string
        AccountCompeCode() string
}

type Server struct {
        config          BankConfig
        host            string
        sessionService  session.Service
        userService     user.Service
        consentService  consent.Service
        resourceService resource.Service
        accountService  account.Service
}

func NewServer(
        config BankConfig,
        host string,
        service session.Service,
        userService user.Service,
        consentService consent.Service,
        resourceService resource.Service,
        accountService account.Service,
) Server <span class="cov0" title="0">{
        return Server{
                config:          config,
                host:            host,
                sessionService:  service,
                userService:     userService,
                consentService:  consentService,
                resourceService: resourceService,
                accountService:  accountService,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{

        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{ return "PARAMETRO_INVALIDO" }</span>)
        <span class="cov0" title="0">secureMiddleware := secure.New(secure.Options{
                STSSeconds:            31536000,
                STSIncludeSubdomains:  true,
                STSPreload:            true,
                FrameDeny:             true,
                ContentTypeNosniff:    true,
                BrowserXssFilter:      true,
                ContentSecurityPolicy: "default-src 'self'; script-src 'self'",
        })
        c := cors.New(cors.Options{
                AllowedOrigins:   []string{s.host},
                AllowCredentials: true,
                AllowedMethods: []string{
                        http.MethodHead,
                        http.MethodGet,
                        http.MethodPost,
                        http.MethodDelete,
                        http.MethodPut,
                        http.MethodPatch,
                },
        })

        handler := HandlerWithOptions(NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        writeResponseError(w, r, err)
                }</span>,
        }), StdHTTPServerOptions{
                Middlewares: []MiddlewareFunc{
                        swaggerMiddleware,
                        fapiIDMiddleware,
                        authSessionMiddleware(s.sessionService),
                        func(next http.Handler) http.Handler <span class="cov0" title="0">{
                                return c.Handler(next)
                        }</span>,
                        func(next http.Handler) http.Handler <span class="cov0" title="0">{
                                return secureMiddleware.Handler(next)
                        }</span>,
                },
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        })
        <span class="cov0" title="0">mux.Handle("/api/", handler)</span>
}

func (s Server) GetDirectoryAuthURL(ctx context.Context, request GetDirectoryAuthURLRequestObject) (GetDirectoryAuthURLResponseObject, error) <span class="cov0" title="0">{
        session, authURL, err := s.sessionService.Create(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">headers := GetDirectoryAuthURL200ResponseHeaders{
                SetCookie: (&amp;http.Cookie{
                        Name:     cookieSessionId,
                        Value:    session.ID.String(),
                        Path:     "/api",
                        Expires:  timeutil.DateTimeNow().Add(sessionValidity).Time,
                        HttpOnly: true,
                        Secure:   true,
                        Domain:   strings.TrimPrefix(s.host, "https://"),
                        SameSite: http.SameSiteStrictMode,
                }).String(),
        }

        resp := AuthURLResponse{
                Data: struct {
                        URL string `json:"url"`
                }{
                        URL: authURL,
                },
        }
        return GetDirectoryAuthURL200JSONResponse{Headers: headers, Body: resp}, nil</span>
}

func (s Server) HandleDirectoryCallback(ctx context.Context, req HandleDirectoryCallbackRequestObject) (HandleDirectoryCallbackResponseObject, error) <span class="cov0" title="0">{
        sessionID := ctx.Value(api.CtxKeySessionID).(string)
        if err := s.sessionService.Authorize(ctx, sessionID, req.Params.Code); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">headers := HandleDirectoryCallback303ResponseHeaders{
                Location: s.host + "/",
        }
        return HandleDirectoryCallback303Response{Headers: headers}, nil</span>
}

func (s Server) LogoutUser(ctx context.Context, req LogoutUserRequestObject) (LogoutUserResponseObject, error) <span class="cov0" title="0">{
        sessionID := ctx.Value(api.CtxKeySessionID).(string)
        _ = s.sessionService.Delete(ctx, sessionID)

        headers := LogoutUser303ResponseHeaders{
                SetCookie: (&amp;http.Cookie{
                        Name:     cookieSessionId,
                        Path:     "/api",
                        Expires:  time.Unix(0, 0),
                        MaxAge:   -1,
                        HttpOnly: true,
                        Secure:   true,
                        Domain:   strings.TrimPrefix(s.host, "https://"),
                        SameSite: http.SameSiteStrictMode,
                }).String(),
                Location: s.host + "/",
        }
        return LogoutUser303Response{Headers: headers}, nil
}</span>

func (s Server) GetCurrentUser(ctx context.Context, req GetCurrentUserRequestObject) (GetCurrentUserResponseObject, error) <span class="cov0" title="0">{
        sessionID := ctx.Value(api.CtxKeySessionID).(string)
        session, err := s.sessionService.Session(ctx, sessionID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := UserResponse{
                Data: struct {
                        Organizations []struct {
                                ID   string `json:"id"`
                                Name string `json:"name"`
                        } `json:"organizations"`
                        Username string `json:"username"`
                }{
                        Organizations: []struct {
                                ID   string `json:"id"`
                                Name string `json:"name"`
                        }{},
                        Username: session.Username,
                },
        }
        for orgID, org := range session.Organizations </span><span class="cov0" title="0">{
                resp.Data.Organizations = append(resp.Data.Organizations, struct {
                        ID   string `json:"id"`
                        Name string `json:"name"`
                }{
                        ID:   orgID,
                        Name: org.Name,
                })
        }</span>
        <span class="cov0" title="0">return GetCurrentUser200JSONResponse(resp), nil</span>
}

func (s Server) GetMockUsers(ctx context.Context, req GetMockUsersRequestObject) (GetMockUsersResponseObject, error) <span class="cov0" title="0">{
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)

        us, err := s.userService.Users(ctx, req.OrgID, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := MockUsersResponse{
                Data: []struct {
                        Cpf         string  `json:"cpf"`
                        Description *string `json:"description,omitempty"`
                        ID          string  `json:"id"`
                        Name        string  `json:"name"`
                        Username    string  `json:"username"`
                }{},
                Meta:  api.NewPaginatedMeta(us),
                Links: api.NewPaginatedLinks(s.host+"/api/orgs/"+req.OrgID+"/users", us),
        }
        for _, u := range us.Records </span><span class="cov0" title="0">{
                data := struct {
                        Cpf         string  `json:"cpf"`
                        Description *string `json:"description,omitempty"`
                        ID          string  `json:"id"`
                        Name        string  `json:"name"`
                        Username    string  `json:"username"`
                }{
                        ID:          u.ID.String(),
                        Username:    u.Username,
                        Cpf:         u.CPF,
                        Name:        u.Name,
                        Description: u.Description,
                }
                resp.Data = append(resp.Data, data)
        }</span>
        <span class="cov0" title="0">return GetMockUsers200JSONResponse(resp), nil</span>
}

func (s Server) CreateMockUser(ctx context.Context, req CreateMockUserRequestObject) (CreateMockUserResponseObject, error) <span class="cov0" title="0">{
        u := &amp;user.User{
                Username:    req.Body.Data.Username,
                Name:        req.Body.Data.Name,
                CPF:         req.Body.Data.Cpf,
                Description: req.Body.Data.Description,
                OrgID:       req.OrgID,
        }

        if err := s.userService.Create(ctx, u); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := MockUserResponse{
                Data: struct {
                        Cpf         string  `json:"cpf"`
                        Description *string `json:"description,omitempty"`
                        ID          string  `json:"id"`
                        Name        string  `json:"name"`
                        Password    *string `json:"password,omitempty"`
                        Username    string  `json:"username"`
                }{
                        Cpf:         u.CPF,
                        ID:          u.ID.String(),
                        Name:        u.Name,
                        Username:    u.Name,
                        Description: u.Description,
                },
        }
        return CreateMockUser201JSONResponse(resp), nil</span>
}

func (s Server) UpdateMockUser(ctx context.Context, req UpdateMockUserRequestObject) (UpdateMockUserResponseObject, error) <span class="cov0" title="0">{
        u := &amp;user.User{
                ID:          req.UserID,
                Username:    req.Body.Data.Username,
                Name:        req.Body.Data.Name,
                CPF:         req.Body.Data.Cpf,
                Description: req.Body.Data.Description,
                OrgID:       req.OrgID,
        }
        if err := s.userService.Update(ctx, u); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := MockUserResponse{
                Data: struct {
                        Cpf         string  `json:"cpf"`
                        Description *string `json:"description,omitempty"`
                        ID          string  `json:"id"`
                        Name        string  `json:"name"`
                        Password    *string `json:"password,omitempty"`
                        Username    string  `json:"username"`
                }{
                        Cpf:         u.CPF,
                        ID:          u.ID.String(),
                        Name:        u.Name,
                        Username:    u.Name,
                        Description: u.Description,
                },
        }
        return UpdateMockUser200JSONResponse(resp), nil</span>
}

func (s Server) DeleteMockUser(ctx context.Context, req DeleteMockUserRequestObject) (DeleteMockUserResponseObject, error) <span class="cov0" title="0">{
        if err := s.userService.Delete(ctx, req.UserID, req.OrgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return DeleteMockUser204Response{}, nil</span>
}

func (s Server) BindUserToBusiness(ctx context.Context, req BindUserToBusinessRequestObject) (BindUserToBusinessResponseObject, error) <span class="cov0" title="0">{
        if err := s.userService.BindUserToBusiness(ctx, req.UserID, req.BusinessID, req.OrgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return BindUserToBusiness201Response{}, nil</span>
}

func (s Server) CreateAccount(ctx context.Context, req CreateAccountRequestObject) (CreateAccountResponseObject, error) <span class="cov0" title="0">{
        acc := &amp;account.Account{
                Number:                      req.Body.Data.Number,
                Type:                        account.Type(req.Body.Data.Type),
                SubType:                     account.SubType(req.Body.Data.Subtype),
                AvailableAmount:             req.Body.Data.AvailableAmount,
                BlockedAmount:               req.Body.Data.BlockedAmount,
                AutomaticallyInvestedAmount: req.Body.Data.AutomaticallyInvestedAmount,
                OrgID:                       req.OrgID,
                OwnerID:                     req.UserID,
        }
        if err := s.accountService.Create(ctx, acc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := AccountResponse{
                Data: AccountData{
                        AccountID:                   acc.ID.String(),
                        AutomaticallyInvestedAmount: acc.AutomaticallyInvestedAmount,
                        AvailableAmount:             acc.AvailableAmount,
                        BlockedAmount:               acc.BlockedAmount,
                        BranchCode:                  s.config.AccountBranch(),
                        CheckDigit:                  s.config.AccountCheckDigit(),
                        CompeCode:                   s.config.AccountCompeCode(),
                        Number:                      acc.Number,
                        Subtype:                     string(acc.SubType),
                        Type:                        string(acc.Type),
                },
        }

        return CreateAccount201JSONResponse(resp), nil</span>
}

func (s Server) DeleteAccount(ctx context.Context, req DeleteAccountRequestObject) (DeleteAccountResponseObject, error) <span class="cov0" title="0">{
        if err := s.accountService.Delete(ctx, req.AccountID, req.OrgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return DeleteAccount204Response{}, nil</span>
}

func (s Server) UpdateAccount(ctx context.Context, req UpdateAccountRequestObject) (UpdateAccountResponseObject, error) <span class="cov0" title="0">{
        acc := &amp;account.Account{
                ID:                          req.AccountID,
                Number:                      req.Body.Data.Number,
                Type:                        account.Type(req.Body.Data.Type),
                SubType:                     account.SubType(req.Body.Data.Subtype),
                AvailableAmount:             req.Body.Data.AvailableAmount,
                BlockedAmount:               req.Body.Data.BlockedAmount,
                AutomaticallyInvestedAmount: req.Body.Data.AutomaticallyInvestedAmount,
                OrgID:                       req.OrgID,
                OwnerID:                     req.UserID,
        }
        if err := s.accountService.Update(ctx, acc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := AccountResponse{
                Data: AccountData{
                        AccountID:                   acc.ID.String(),
                        AutomaticallyInvestedAmount: acc.AutomaticallyInvestedAmount,
                        AvailableAmount:             acc.AvailableAmount,
                        BlockedAmount:               acc.BlockedAmount,
                        BranchCode:                  s.config.AccountBranch(),
                        CheckDigit:                  s.config.AccountCheckDigit(),
                        CompeCode:                   s.config.AccountCompeCode(),
                        Number:                      acc.Number,
                        Subtype:                     string(acc.SubType),
                        Type:                        string(acc.Type),
                },
        }

        return UpdateAccount201JSONResponse(resp), nil</span>
}

func (s Server) GetAccounts(ctx context.Context, req GetAccountsRequestObject) (GetAccountsResponseObject, error) <span class="cov0" title="0">{
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        accs, err := s.accountService.Accounts(ctx, req.UserID.String(), req.OrgID, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := AccountsResponse{
                Data:  []AccountData{},
                Meta:  api.NewPaginatedMeta(accs),
                Links: api.NewPaginatedLinks(s.host+"/api/orgs/"+req.OrgID+"/users/"+req.UserID.String()+"/accounts", accs),
        }
        for _, acc := range accs.Records </span><span class="cov0" title="0">{
                resp.Data = append(resp.Data, AccountData{
                        AccountID:                   acc.ID.String(),
                        AutomaticallyInvestedAmount: acc.AutomaticallyInvestedAmount,
                        AvailableAmount:             acc.AvailableAmount,
                        BlockedAmount:               acc.BlockedAmount,
                        BranchCode:                  s.config.AccountBranch(),
                        CheckDigit:                  s.config.AccountCheckDigit(),
                        CompeCode:                   s.config.AccountCompeCode(),
                        Number:                      acc.Number,
                        Subtype:                     string(acc.SubType),
                        Type:                        string(acc.Type),
                })
        }</span>

        <span class="cov0" title="0">return GetAccounts200JSONResponse(resp), nil</span>
}

func (s Server) GetConsents(ctx context.Context, req GetConsentsRequestObject) (GetConsentsResponseObject, error) <span class="cov0" title="0">{
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        cs, err := s.consentService.Consents(ctx, req.UserID, req.OrgID, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ConsentsResponse{
                Data: []struct {
                        ClientID             string             `json:"clientId"`
                        ConsentID            string             `json:"consentId"`
                        CreationDateTime     timeutil.DateTime  `json:"creationDateTime"`
                        ExpirationDateTime   *timeutil.DateTime `json:"expirationDateTime,omitempty"`
                        Permissions          []string           `json:"permissions"`
                        RejectedBy           *string            `json:"rejectedBy,omitempty"`
                        RejectionReason      *string            `json:"rejectionReason,omitempty"`
                        Status               string             `json:"status"`
                        StatusUpdateDateTime timeutil.DateTime  `json:"statusUpdateDateTime"`
                        UserID               string             `json:"userId"`
                }{},
                Meta:  api.NewPaginatedMeta(cs),
                Links: api.NewPaginatedLinks(s.host+"/api/orgs/"+req.OrgID+"/users/"+req.UserID.String()+"/consents", cs),
        }
        for _, c := range cs.Records </span><span class="cov0" title="0">{
                data := struct {
                        ClientID             string             `json:"clientId"`
                        ConsentID            string             `json:"consentId"`
                        CreationDateTime     timeutil.DateTime  `json:"creationDateTime"`
                        ExpirationDateTime   *timeutil.DateTime `json:"expirationDateTime,omitempty"`
                        Permissions          []string           `json:"permissions"`
                        RejectedBy           *string            `json:"rejectedBy,omitempty"`
                        RejectionReason      *string            `json:"rejectionReason,omitempty"`
                        Status               string             `json:"status"`
                        StatusUpdateDateTime timeutil.DateTime  `json:"statusUpdateDateTime"`
                        UserID               string             `json:"userId"`
                }{
                        ClientID:             c.ClientID,
                        ConsentID:            c.URN(),
                        CreationDateTime:     c.CreatedAt,
                        Status:               string(c.Status),
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        ExpirationDateTime:   c.ExpiresAt,
                        UserID:               c.OwnerID.String(),
                }
                perms := make([]string, len(c.Permissions))
                for i, p := range c.Permissions </span><span class="cov0" title="0">{
                        perms[i] = string(p)
                }</span>
                <span class="cov0" title="0">data.Permissions = perms

                // TODO: Make the rejection an object.
                if c.Rejection != nil </span><span class="cov0" title="0">{
                        rejectedBy := string(c.Rejection.By)
                        data.RejectedBy = &amp;rejectedBy
                        rejectionReason := string(c.Rejection.Reason)
                        data.RejectionReason = &amp;rejectionReason
                }</span>

                <span class="cov0" title="0">resp.Data = append(resp.Data, data)</span>
        }
        <span class="cov0" title="0">return GetConsents200JSONResponse(resp), nil</span>
}

func (s Server) GetResources(ctx context.Context, req GetResourcesRequestObject) (GetResourcesResponseObject, error) <span class="cov0" title="0">{
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)

        rs, err := s.resourceService.Resources(ctx, req.OrgID, resource.Filter{OwnerID: req.UserID.String()}, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResourcesResponse{
                Data: []struct {
                        ConsentID        string            `json:"consentId"`
                        CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                        ResourceID       string            `json:"resourceId"`
                        Status           ResourceStatus    `json:"status"`
                        Type             ResourceType      `json:"type"`
                }{},
                Meta:  *api.NewPaginatedMeta(rs),
                Links: *api.NewPaginatedLinks(s.host+"/api/orgs/"+req.OrgID+"/users/"+req.UserID.String()+"/resources", rs),
        }

        for _, r := range rs.Records </span><span class="cov0" title="0">{
                resp.Data = append(resp.Data, struct {
                        ConsentID        string            `json:"consentId"`
                        CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                        ResourceID       string            `json:"resourceId"`
                        Status           ResourceStatus    `json:"status"`
                        Type             ResourceType      `json:"type"`
                }{
                        ConsentID:        r.ConsentID,
                        ResourceID:       r.ResourceID,
                        Status:           ResourceStatus(r.Status),
                        Type:             ResourceType(r.Type),
                        CreationDateTime: r.CreatedAt,
                })
        }</span>

        <span class="cov0" title="0">return GetResources200JSONResponse(resp), nil</span>
}

func (s Server) PatchResourceStatus(ctx context.Context, req PatchResourceStatusRequestObject) (PatchResourceStatusResponseObject, error) <span class="cov0" title="0">{
        switch resource.Type(req.Params.Type) </span>{
        case resource.TypeAccount:<span class="cov0" title="0">
                if err := s.accountService.UpdateConsent(ctx, req.ConsentID, uuid.MustParse(req.ResourceID), req.OrgID, resource.Status(req.Body.Data.Status)); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("invalid resource type")</span>
        }

        <span class="cov0" title="0">return PatchResourceStatus204Response{}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        if errors.Is(err, session.ErrNotFound) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("UNAUTHORIZED", http.StatusUnauthorized, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, user.ErrAlreadyExists) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("USER_ALREADY_EXISTS", http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, user.ErrInvalidOrgID) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("INVALID_ORG_ID", http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, account.ErrAlreadyExists) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("ACCOUNT_ALREADY_EXISTS", http.StatusBadRequest, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">//go:build go1.22

// Package app provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package app

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        SessionCookieScopes = "SessionCookie.Scopes"
)

// Defines values for ResourceStatus.
const (
        AVAILABLE              ResourceStatus = "AVAILABLE"
        PENDINGAUTHORISATION   ResourceStatus = "PENDING_AUTHORISATION"
        TEMPORARILYUNAVAILABLE ResourceStatus = "TEMPORARILY_UNAVAILABLE"
        UNAVAILABLE            ResourceStatus = "UNAVAILABLE"
)

// Defines values for ResourceType.
const (
        ACCOUNT                    ResourceType = "ACCOUNT"
        BANKFIXEDINCOME            ResourceType = "BANK_FIXED_INCOME"
        CREDITCARDACCOUNT          ResourceType = "CREDIT_CARD_ACCOUNT"
        CREDITFIXEDINCOME          ResourceType = "CREDIT_FIXED_INCOME"
        EXCHANGE                   ResourceType = "EXCHANGE"
        FINANCING                  ResourceType = "FINANCING"
        FUND                       ResourceType = "FUND"
        INVOICEFINANCING           ResourceType = "INVOICE_FINANCING"
        LOAN                       ResourceType = "LOAN"
        TREASURETITLE              ResourceType = "TREASURE_TITLE"
        UNARRANGEDACCOUNTOVERDRAFT ResourceType = "UNARRANGED_ACCOUNT_OVERDRAFT"
        VARIABLEINCOME             ResourceType = "VARIABLE_INCOME"
)

// AccountData defines model for AccountData.
type AccountData struct {
        AccountID                   string `json:"accountId"`
        AutomaticallyInvestedAmount string `json:"automaticallyInvestedAmount"`
        AvailableAmount             string `json:"availableAmount"`
        BlockedAmount               string `json:"blockedAmount"`
        BranchCode                  string `json:"branchCode"`
        CheckDigit                  string `json:"checkDigit"`
        CompeCode                   string `json:"compeCode"`
        Number                      string `json:"number"`
        Subtype                     string `json:"subtype"`
        Type                        string `json:"type"`
}

// AccountRequest defines model for AccountRequest.
type AccountRequest struct {
        Data struct {
                AutomaticallyInvestedAmount string  `json:"automaticallyInvestedAmount"`
                AvailableAmount             string  `json:"availableAmount"`
                BlockedAmount               string  `json:"blockedAmount"`
                Number                      string  `json:"number"`
                OverdraftLimitContracted    *string `json:"overdraftLimitContracted,omitempty"`
                OverdraftLimitUnarraged     *string `json:"overdraftLimitUnarraged,omitempty"`
                OverdraftLimitUsed          *string `json:"overdraftLimitUsed,omitempty"`
                Subtype                     string  `json:"subtype"`
                Type                        string  `json:"type"`
        } `json:"data"`
}

// AccountResponse defines model for AccountResponse.
type AccountResponse struct {
        Data AccountData `json:"data"`
}

// AccountsResponse defines model for AccountsResponse.
type AccountsResponse struct {
        Data  []AccountData `json:"data"`
        Links *api.Links    `json:"links,omitempty"`
        Meta  *api.Meta     `json:"meta,omitempty"`
}

// AuthURLResponse defines model for AuthUrlResponse.
type AuthURLResponse struct {
        Data struct {
                URL string `json:"url"`
        } `json:"data"`
}

// ConsentsResponse defines model for ConsentsResponse.
type ConsentsResponse struct {
        Data []struct {
                ClientID             string             `json:"clientId"`
                ConsentID            string             `json:"consentId"`
                CreationDateTime     timeutil.DateTime  `json:"creationDateTime"`
                ExpirationDateTime   *timeutil.DateTime `json:"expirationDateTime,omitempty"`
                Permissions          []string           `json:"permissions"`
                RejectedBy           *string            `json:"rejectedBy,omitempty"`
                RejectionReason      *string            `json:"rejectionReason,omitempty"`
                Status               string             `json:"status"`
                StatusUpdateDateTime timeutil.DateTime  `json:"statusUpdateDateTime"`
                UserID               string             `json:"userId"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// MockUserRequest defines model for MockUserRequest.
type MockUserRequest struct {
        Data struct {
                Cpf         string  `json:"cpf"`
                Description *string `json:"description,omitempty"`
                Name        string  `json:"name"`
                Password    *string `json:"password,omitempty"`
                Username    string  `json:"username"`
        } `json:"data"`
}

// MockUserResponse defines model for MockUserResponse.
type MockUserResponse struct {
        Data struct {
                Cpf         string  `json:"cpf"`
                Description *string `json:"description,omitempty"`
                ID          string  `json:"id"`
                Name        string  `json:"name"`
                Password    *string `json:"password,omitempty"`
                Username    string  `json:"username"`
        } `json:"data"`
}

// MockUsersResponse defines model for MockUsersResponse.
type MockUsersResponse struct {
        Data []struct {
                Cpf         string  `json:"cpf"`
                Description *string `json:"description,omitempty"`
                ID          string  `json:"id"`
                Name        string  `json:"name"`
                Username    string  `json:"username"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// ResourceStatus defines model for ResourceStatus.
type ResourceStatus string

// ResourceType defines model for ResourceType.
type ResourceType string

// ResourcesResponse defines model for ResourcesResponse.
type ResourcesResponse struct {
        Data []struct {
                ConsentID        string            `json:"consentId"`
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                ResourceID       string            `json:"resourceId"`
                Status           ResourceStatus    `json:"status"`
                Type             ResourceType      `json:"type"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
        Data struct {
                Organizations []struct {
                        ID   string `json:"id"`
                        Name string `json:"name"`
                } `json:"organizations"`
                Username string `json:"username"`
        } `json:"data"`
}

// AccountID defines model for accountId.
type AccountID = openapi_types.UUID

// BusinessID defines model for businessId.
type BusinessID = openapi_types.UUID

// MockUserID defines model for mockUserId.
type MockUserID = openapi_types.UUID

// OrganizationID defines model for organizationId.
type OrganizationID = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// HandleDirectoryCallbackParams defines parameters for HandleDirectoryCallback.
type HandleDirectoryCallbackParams struct {
        Code string `form:"code" json:"code"`
}

// GetMockUsersParams defines parameters for GetMockUsers.
type GetMockUsersParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`
}

// GetConsentsParams defines parameters for GetConsents.
type GetConsentsParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`
}

// PatchResourceStatusJSONBody defines parameters for PatchResourceStatus.
type PatchResourceStatusJSONBody struct {
        Data struct {
                Status ResourceStatus `json:"status"`
        } `json:"data"`
}

// PatchResourceStatusParams defines parameters for PatchResourceStatus.
type PatchResourceStatusParams struct {
        Type ResourceType `form:"type" json:"type"`
}

// CreateMockUserJSONRequestBody defines body for CreateMockUser for application/json ContentType.
type CreateMockUserJSONRequestBody = MockUserRequest

// UpdateMockUserJSONRequestBody defines body for UpdateMockUser for application/json ContentType.
type UpdateMockUserJSONRequestBody = MockUserRequest

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody = AccountRequest

// UpdateAccountJSONRequestBody defines body for UpdateAccount for application/json ContentType.
type UpdateAccountJSONRequestBody = AccountRequest

// PatchResourceStatusJSONRequestBody defines body for PatchResourceStatus for application/json ContentType.
type PatchResourceStatusJSONRequestBody PatchResourceStatusJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Get the authentication URL for the directory service
        // (GET /api/directory/auth-url)
        GetDirectoryAuthURL(w http.ResponseWriter, r *http.Request)

        // (GET /api/directory/callback)
        HandleDirectoryCallback(w http.ResponseWriter, r *http.Request, params HandleDirectoryCallbackParams)
        // Logout the current user
        // (POST /api/logout)
        LogoutUser(w http.ResponseWriter, r *http.Request)
        // Get current user information
        // (GET /api/me)
        GetCurrentUser(w http.ResponseWriter, r *http.Request)
        // List mock users in an organization
        // (GET /api/orgs/{orgId}/users)
        GetMockUsers(w http.ResponseWriter, r *http.Request, orgID OrganizationID, params GetMockUsersParams)
        // Create a new user in an organization
        // (POST /api/orgs/{orgId}/users)
        CreateMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID)
        // Delete a mock user in an organization
        // (DELETE /api/orgs/{orgId}/users/{userId})
        DeleteMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID)
        // Update a user in an organization
        // (PUT /api/orgs/{orgId}/users/{userId})
        UpdateMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID)
        // Get accounts of a user
        // (GET /api/orgs/{orgId}/users/{userId}/accounts)
        GetAccounts(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetAccountsParams)
        // Create a new account
        // (POST /api/orgs/{orgId}/users/{userId}/accounts)
        CreateAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID)
        // Delete an account
        // (DELETE /api/orgs/{orgId}/users/{userId}/accounts/{accountId})
        DeleteAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, accountID AccountID)
        // Update an account
        // (PUT /api/orgs/{orgId}/users/{userId}/accounts/{accountId})
        UpdateAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, accountID AccountID)
        // Bind a user to a business
        // (POST /api/orgs/{orgId}/users/{userId}/businesses/{businessId}/bind)
        BindUserToBusiness(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, businessID BusinessID)
        // Get consents of a user
        // (GET /api/orgs/{orgId}/users/{userId}/consents)
        GetConsents(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetConsentsParams)
        // Get shared resources of a user
        // (GET /api/orgs/{orgId}/users/{userId}/resources)
        GetResources(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetResourcesParams)
        // Update status of a shared resource
        // (PATCH /api/orgs/{orgId}/users/{userId}/resources/{resourceId}/consents/{consentId})
        PatchResourceStatus(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, resourceID string, consentID openapi_types.UUID, params PatchResourceStatusParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetDirectoryAuthURL operation middleware
func (siw *ServerInterfaceWrapper) GetDirectoryAuthURL(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetDirectoryAuthURL(w, r)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// HandleDirectoryCallback operation middleware
func (siw *ServerInterfaceWrapper) HandleDirectoryCallback(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params HandleDirectoryCallbackParams

        // ------------- Required query parameter "code" -------------

        if paramValue := r.URL.Query().Get("code"); paramValue != "" </span>{<span class="cov0" title="0">

        }</span> else<span class="cov0" title="0"> {
                siw.ErrorHandlerFunc(w, r, &amp;RequiredParamError{ParamName: "code"})
                return
        }</span>

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, true, "code", r.URL.Query(), &amp;params.Code)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "code", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.HandleDirectoryCallback(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// LogoutUser operation middleware
func (siw *ServerInterfaceWrapper) LogoutUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.LogoutUser(w, r)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetCurrentUser operation middleware
func (siw *ServerInterfaceWrapper) GetCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetCurrentUser(w, r)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetMockUsers operation middleware
func (siw *ServerInterfaceWrapper) GetMockUsers(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params GetMockUsersParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetMockUsers(w, r, orgID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// CreateMockUser operation middleware
func (siw *ServerInterfaceWrapper) CreateMockUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.CreateMockUser(w, r, orgID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// DeleteMockUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteMockUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.DeleteMockUser(w, r, orgID, userID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// UpdateMockUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateMockUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.UpdateMockUser(w, r, orgID, userID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetAccounts operation middleware
func (siw *ServerInterfaceWrapper) GetAccounts(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params GetAccountsParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetAccounts(w, r, orgID, userID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// CreateAccount operation middleware
func (siw *ServerInterfaceWrapper) CreateAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.CreateAccount(w, r, orgID, userID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// DeleteAccount operation middleware
func (siw *ServerInterfaceWrapper) DeleteAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        // ------------- Path parameter "accountId" -------------
        <span class="cov0" title="0">var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.DeleteAccount(w, r, orgID, userID, accountID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// UpdateAccount operation middleware
func (siw *ServerInterfaceWrapper) UpdateAccount(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        // ------------- Path parameter "accountId" -------------
        <span class="cov0" title="0">var accountID AccountID

        err = runtime.BindStyledParameterWithOptions("simple", "accountId", r.PathValue("accountId"), &amp;accountID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "accountId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.UpdateAccount(w, r, orgID, userID, accountID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// BindUserToBusiness operation middleware
func (siw *ServerInterfaceWrapper) BindUserToBusiness(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        // ------------- Path parameter "businessId" -------------
        <span class="cov0" title="0">var businessID BusinessID

        err = runtime.BindStyledParameterWithOptions("simple", "businessId", r.PathValue("businessId"), &amp;businessID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "businessId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.BindUserToBusiness(w, r, orgID, userID, businessID)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetConsents operation middleware
func (siw *ServerInterfaceWrapper) GetConsents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params GetConsentsParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetConsents(w, r, orgID, userID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetResources operation middleware
func (siw *ServerInterfaceWrapper) GetResources(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params GetResourcesParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetResources(w, r, orgID, userID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PatchResourceStatus operation middleware
func (siw *ServerInterfaceWrapper) PatchResourceStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "orgId" -------------
        var orgID OrganizationID

        err = runtime.BindStyledParameterWithOptions("simple", "orgId", r.PathValue("orgId"), &amp;orgID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "orgId", Err: err})
                return
        }</span>

        // ------------- Path parameter "userId" -------------
        <span class="cov0" title="0">var userID MockUserID

        err = runtime.BindStyledParameterWithOptions("simple", "userId", r.PathValue("userId"), &amp;userID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "userId", Err: err})
                return
        }</span>

        // ------------- Path parameter "resourceId" -------------
        <span class="cov0" title="0">var resourceID string

        err = runtime.BindStyledParameterWithOptions("simple", "resourceId", r.PathValue("resourceId"), &amp;resourceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "resourceId", Err: err})
                return
        }</span>

        // ------------- Path parameter "consentId" -------------
        <span class="cov0" title="0">var consentID openapi_types.UUID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, SessionCookieScopes, []string{})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PatchResourceStatusParams

        // ------------- Required query parameter "type" -------------

        if paramValue := r.URL.Query().Get("type"); paramValue != "" </span>{<span class="cov0" title="0">

        }</span> else<span class="cov0" title="0"> {
                siw.ErrorHandlerFunc(w, r, &amp;RequiredParamError{ParamName: "type"})
                return
        }</span>

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, true, "type", r.URL.Query(), &amp;params.Type)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "type", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PatchResourceStatus(w, r, orgID, userID, resourceID, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("GET "+options.BaseURL+"/api/directory/auth-url", wrapper.GetDirectoryAuthURL)
        m.HandleFunc("GET "+options.BaseURL+"/api/directory/callback", wrapper.HandleDirectoryCallback)
        m.HandleFunc("POST "+options.BaseURL+"/api/logout", wrapper.LogoutUser)
        m.HandleFunc("GET "+options.BaseURL+"/api/me", wrapper.GetCurrentUser)
        m.HandleFunc("GET "+options.BaseURL+"/api/orgs/{orgId}/users", wrapper.GetMockUsers)
        m.HandleFunc("POST "+options.BaseURL+"/api/orgs/{orgId}/users", wrapper.CreateMockUser)
        m.HandleFunc("DELETE "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}", wrapper.DeleteMockUser)
        m.HandleFunc("PUT "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}", wrapper.UpdateMockUser)
        m.HandleFunc("GET "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/accounts", wrapper.GetAccounts)
        m.HandleFunc("POST "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/accounts", wrapper.CreateAccount)
        m.HandleFunc("DELETE "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/accounts/{accountId}", wrapper.DeleteAccount)
        m.HandleFunc("PUT "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/accounts/{accountId}", wrapper.UpdateAccount)
        m.HandleFunc("POST "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/businesses/{businessId}/bind", wrapper.BindUserToBusiness)
        m.HandleFunc("GET "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/consents", wrapper.GetConsents)
        m.HandleFunc("GET "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/resources", wrapper.GetResources)
        m.HandleFunc("PATCH "+options.BaseURL+"/api/orgs/{orgId}/users/{userId}/resources/{resourceId}/consents/{consentId}", wrapper.PatchResourceStatus)

        return m</span>
}

type GetDirectoryAuthURLRequestObject struct {
}

type GetDirectoryAuthURLResponseObject interface {
        VisitGetDirectoryAuthURLResponse(w http.ResponseWriter) error
}

type GetDirectoryAuthURL200ResponseHeaders struct {
        SetCookie string
}

type GetDirectoryAuthURL200JSONResponse struct {
        Body    AuthURLResponse
        Headers GetDirectoryAuthURL200ResponseHeaders
}

func (response GetDirectoryAuthURL200JSONResponse) VisitGetDirectoryAuthURLResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type HandleDirectoryCallbackRequestObject struct {
        Params HandleDirectoryCallbackParams
}

type HandleDirectoryCallbackResponseObject interface {
        VisitHandleDirectoryCallbackResponse(w http.ResponseWriter) error
}

type HandleDirectoryCallback303ResponseHeaders struct {
        Location  string
        SetCookie string
}

type HandleDirectoryCallback303Response struct {
        Headers HandleDirectoryCallback303ResponseHeaders
}

func (response HandleDirectoryCallback303Response) VisitHandleDirectoryCallbackResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
        w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
        w.WriteHeader(303)
        return nil
}</span>

type LogoutUserRequestObject struct {
}

type LogoutUserResponseObject interface {
        VisitLogoutUserResponse(w http.ResponseWriter) error
}

type LogoutUser303ResponseHeaders struct {
        Location  string
        SetCookie string
}

type LogoutUser303Response struct {
        Headers LogoutUser303ResponseHeaders
}

func (response LogoutUser303Response) VisitLogoutUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Location", fmt.Sprint(response.Headers.Location))
        w.Header().Set("Set-Cookie", fmt.Sprint(response.Headers.SetCookie))
        w.WriteHeader(303)
        return nil
}</span>

type GetCurrentUserRequestObject struct {
}

type GetCurrentUserResponseObject interface {
        VisitGetCurrentUserResponse(w http.ResponseWriter) error
}

type GetCurrentUser200JSONResponse UserResponse

func (response GetCurrentUser200JSONResponse) VisitGetCurrentUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetMockUsersRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        Params GetMockUsersParams
}

type GetMockUsersResponseObject interface {
        VisitGetMockUsersResponse(w http.ResponseWriter) error
}

type GetMockUsers200JSONResponse MockUsersResponse

func (response GetMockUsers200JSONResponse) VisitGetMockUsersResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateMockUserRequestObject struct {
        OrgID OrganizationID `json:"orgId"`
        Body  *CreateMockUserJSONRequestBody
}

type CreateMockUserResponseObject interface {
        VisitCreateMockUserResponse(w http.ResponseWriter) error
}

type CreateMockUser201JSONResponse MockUserResponse

func (response CreateMockUser201JSONResponse) VisitCreateMockUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteMockUserRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
}

type DeleteMockUserResponseObject interface {
        VisitDeleteMockUserResponse(w http.ResponseWriter) error
}

type DeleteMockUser204Response struct {
}

func (response DeleteMockUser204Response) VisitDeleteMockUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type UpdateMockUserRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
        Body   *UpdateMockUserJSONRequestBody
}

type UpdateMockUserResponseObject interface {
        VisitUpdateMockUserResponse(w http.ResponseWriter) error
}

type UpdateMockUser200JSONResponse MockUserResponse

func (response UpdateMockUser200JSONResponse) VisitUpdateMockUserResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetAccountsRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
        Params GetAccountsParams
}

type GetAccountsResponseObject interface {
        VisitGetAccountsResponse(w http.ResponseWriter) error
}

type GetAccounts200JSONResponse AccountsResponse

func (response GetAccounts200JSONResponse) VisitGetAccountsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type CreateAccountRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
        Body   *CreateAccountJSONRequestBody
}

type CreateAccountResponseObject interface {
        VisitCreateAccountResponse(w http.ResponseWriter) error
}

type CreateAccount201JSONResponse AccountResponse

func (response CreateAccount201JSONResponse) VisitCreateAccountResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteAccountRequestObject struct {
        OrgID     OrganizationID `json:"orgId"`
        UserID    MockUserID     `json:"userId"`
        AccountID AccountID      `json:"accountId"`
}

type DeleteAccountResponseObject interface {
        VisitDeleteAccountResponse(w http.ResponseWriter) error
}

type DeleteAccount204Response struct {
}

func (response DeleteAccount204Response) VisitDeleteAccountResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type UpdateAccountRequestObject struct {
        OrgID     OrganizationID `json:"orgId"`
        UserID    MockUserID     `json:"userId"`
        AccountID AccountID      `json:"accountId"`
        Body      *UpdateAccountJSONRequestBody
}

type UpdateAccountResponseObject interface {
        VisitUpdateAccountResponse(w http.ResponseWriter) error
}

type UpdateAccount201JSONResponse AccountResponse

func (response UpdateAccount201JSONResponse) VisitUpdateAccountResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type BindUserToBusinessRequestObject struct {
        OrgID      OrganizationID `json:"orgId"`
        UserID     MockUserID     `json:"userId"`
        BusinessID BusinessID     `json:"businessId"`
}

type BindUserToBusinessResponseObject interface {
        VisitBindUserToBusinessResponse(w http.ResponseWriter) error
}

type BindUserToBusiness201Response struct {
}

func (response BindUserToBusiness201Response) VisitBindUserToBusinessResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(201)
        return nil
}</span>

type GetConsentsRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
        Params GetConsentsParams
}

type GetConsentsResponseObject interface {
        VisitGetConsentsResponse(w http.ResponseWriter) error
}

type GetConsents200JSONResponse ConsentsResponse

func (response GetConsents200JSONResponse) VisitGetConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetResourcesRequestObject struct {
        OrgID  OrganizationID `json:"orgId"`
        UserID MockUserID     `json:"userId"`
        Params GetResourcesParams
}

type GetResourcesResponseObject interface {
        VisitGetResourcesResponse(w http.ResponseWriter) error
}

type GetResources200JSONResponse ResourcesResponse

func (response GetResources200JSONResponse) VisitGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PatchResourceStatusRequestObject struct {
        OrgID      OrganizationID     `json:"orgId"`
        UserID     MockUserID         `json:"userId"`
        ResourceID string             `json:"resourceId"`
        ConsentID  openapi_types.UUID `json:"consentId"`
        Params     PatchResourceStatusParams
        Body       *PatchResourceStatusJSONRequestBody
}

type PatchResourceStatusResponseObject interface {
        VisitPatchResourceStatusResponse(w http.ResponseWriter) error
}

type PatchResourceStatus204Response struct {
}

func (response PatchResourceStatus204Response) VisitPatchResourceStatusResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Get the authentication URL for the directory service
        // (GET /api/directory/auth-url)
        GetDirectoryAuthURL(ctx context.Context, request GetDirectoryAuthURLRequestObject) (GetDirectoryAuthURLResponseObject, error)

        // (GET /api/directory/callback)
        HandleDirectoryCallback(ctx context.Context, request HandleDirectoryCallbackRequestObject) (HandleDirectoryCallbackResponseObject, error)
        // Logout the current user
        // (POST /api/logout)
        LogoutUser(ctx context.Context, request LogoutUserRequestObject) (LogoutUserResponseObject, error)
        // Get current user information
        // (GET /api/me)
        GetCurrentUser(ctx context.Context, request GetCurrentUserRequestObject) (GetCurrentUserResponseObject, error)
        // List mock users in an organization
        // (GET /api/orgs/{orgId}/users)
        GetMockUsers(ctx context.Context, request GetMockUsersRequestObject) (GetMockUsersResponseObject, error)
        // Create a new user in an organization
        // (POST /api/orgs/{orgId}/users)
        CreateMockUser(ctx context.Context, request CreateMockUserRequestObject) (CreateMockUserResponseObject, error)
        // Delete a mock user in an organization
        // (DELETE /api/orgs/{orgId}/users/{userId})
        DeleteMockUser(ctx context.Context, request DeleteMockUserRequestObject) (DeleteMockUserResponseObject, error)
        // Update a user in an organization
        // (PUT /api/orgs/{orgId}/users/{userId})
        UpdateMockUser(ctx context.Context, request UpdateMockUserRequestObject) (UpdateMockUserResponseObject, error)
        // Get accounts of a user
        // (GET /api/orgs/{orgId}/users/{userId}/accounts)
        GetAccounts(ctx context.Context, request GetAccountsRequestObject) (GetAccountsResponseObject, error)
        // Create a new account
        // (POST /api/orgs/{orgId}/users/{userId}/accounts)
        CreateAccount(ctx context.Context, request CreateAccountRequestObject) (CreateAccountResponseObject, error)
        // Delete an account
        // (DELETE /api/orgs/{orgId}/users/{userId}/accounts/{accountId})
        DeleteAccount(ctx context.Context, request DeleteAccountRequestObject) (DeleteAccountResponseObject, error)
        // Update an account
        // (PUT /api/orgs/{orgId}/users/{userId}/accounts/{accountId})
        UpdateAccount(ctx context.Context, request UpdateAccountRequestObject) (UpdateAccountResponseObject, error)
        // Bind a user to a business
        // (POST /api/orgs/{orgId}/users/{userId}/businesses/{businessId}/bind)
        BindUserToBusiness(ctx context.Context, request BindUserToBusinessRequestObject) (BindUserToBusinessResponseObject, error)
        // Get consents of a user
        // (GET /api/orgs/{orgId}/users/{userId}/consents)
        GetConsents(ctx context.Context, request GetConsentsRequestObject) (GetConsentsResponseObject, error)
        // Get shared resources of a user
        // (GET /api/orgs/{orgId}/users/{userId}/resources)
        GetResources(ctx context.Context, request GetResourcesRequestObject) (GetResourcesResponseObject, error)
        // Update status of a shared resource
        // (PATCH /api/orgs/{orgId}/users/{userId}/resources/{resourceId}/consents/{consentId})
        PatchResourceStatus(ctx context.Context, request PatchResourceStatusRequestObject) (PatchResourceStatusResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// GetDirectoryAuthURL operation middleware
func (sh *strictHandler) GetDirectoryAuthURL(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request GetDirectoryAuthURLRequestObject

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetDirectoryAuthURL(ctx, request.(GetDirectoryAuthURLRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetDirectoryAuthURL")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetDirectoryAuthURLResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetDirectoryAuthURLResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// HandleDirectoryCallback operation middleware
func (sh *strictHandler) HandleDirectoryCallback(w http.ResponseWriter, r *http.Request, params HandleDirectoryCallbackParams) <span class="cov0" title="0">{
        var request HandleDirectoryCallbackRequestObject

        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.HandleDirectoryCallback(ctx, request.(HandleDirectoryCallbackRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "HandleDirectoryCallback")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(HandleDirectoryCallbackResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitHandleDirectoryCallbackResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// LogoutUser operation middleware
func (sh *strictHandler) LogoutUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request LogoutUserRequestObject

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.LogoutUser(ctx, request.(LogoutUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "LogoutUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(LogoutUserResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitLogoutUserResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetCurrentUser operation middleware
func (sh *strictHandler) GetCurrentUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var request GetCurrentUserRequestObject

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetCurrentUser(ctx, request.(GetCurrentUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetCurrentUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetCurrentUserResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetCurrentUserResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetMockUsers operation middleware
func (sh *strictHandler) GetMockUsers(w http.ResponseWriter, r *http.Request, orgID OrganizationID, params GetMockUsersParams) <span class="cov0" title="0">{
        var request GetMockUsersRequestObject

        request.OrgID = orgID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetMockUsers(ctx, request.(GetMockUsersRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetMockUsers")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetMockUsersResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetMockUsersResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// CreateMockUser operation middleware
func (sh *strictHandler) CreateMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID) <span class="cov0" title="0">{
        var request CreateMockUserRequestObject

        request.OrgID = orgID

        var body CreateMockUserJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateMockUser(ctx, request.(CreateMockUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateMockUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateMockUserResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitCreateMockUserResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// DeleteMockUser operation middleware
func (sh *strictHandler) DeleteMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID) <span class="cov0" title="0">{
        var request DeleteMockUserRequestObject

        request.OrgID = orgID
        request.UserID = userID

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteMockUser(ctx, request.(DeleteMockUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteMockUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteMockUserResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitDeleteMockUserResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// UpdateMockUser operation middleware
func (sh *strictHandler) UpdateMockUser(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID) <span class="cov0" title="0">{
        var request UpdateMockUserRequestObject

        request.OrgID = orgID
        request.UserID = userID

        var body UpdateMockUserJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateMockUser(ctx, request.(UpdateMockUserRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateMockUser")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateMockUserResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitUpdateMockUserResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetAccounts operation middleware
func (sh *strictHandler) GetAccounts(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetAccountsParams) <span class="cov0" title="0">{
        var request GetAccountsRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetAccounts(ctx, request.(GetAccountsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetAccounts")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetAccountsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetAccountsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// CreateAccount operation middleware
func (sh *strictHandler) CreateAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID) <span class="cov0" title="0">{
        var request CreateAccountRequestObject

        request.OrgID = orgID
        request.UserID = userID

        var body CreateAccountJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.CreateAccount(ctx, request.(CreateAccountRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "CreateAccount")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(CreateAccountResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitCreateAccountResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// DeleteAccount operation middleware
func (sh *strictHandler) DeleteAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, accountID AccountID) <span class="cov0" title="0">{
        var request DeleteAccountRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.AccountID = accountID

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteAccount(ctx, request.(DeleteAccountRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteAccount")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteAccountResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitDeleteAccountResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// UpdateAccount operation middleware
func (sh *strictHandler) UpdateAccount(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, accountID AccountID) <span class="cov0" title="0">{
        var request UpdateAccountRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.AccountID = accountID

        var body UpdateAccountJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.UpdateAccount(ctx, request.(UpdateAccountRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "UpdateAccount")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(UpdateAccountResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitUpdateAccountResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// BindUserToBusiness operation middleware
func (sh *strictHandler) BindUserToBusiness(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, businessID BusinessID) <span class="cov0" title="0">{
        var request BindUserToBusinessRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.BusinessID = businessID

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.BindUserToBusiness(ctx, request.(BindUserToBusinessRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "BindUserToBusiness")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(BindUserToBusinessResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitBindUserToBusinessResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetConsents operation middleware
func (sh *strictHandler) GetConsents(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetConsentsParams) <span class="cov0" title="0">{
        var request GetConsentsRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetConsents(ctx, request.(GetConsentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetConsents")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetConsentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetConsentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetResources operation middleware
func (sh *strictHandler) GetResources(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, params GetResourcesParams) <span class="cov0" title="0">{
        var request GetResourcesRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetResources(ctx, request.(GetResourcesRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetResources")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetResourcesResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetResourcesResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PatchResourceStatus operation middleware
func (sh *strictHandler) PatchResourceStatus(w http.ResponseWriter, r *http.Request, orgID OrganizationID, userID MockUserID, resourceID string, consentID openapi_types.UUID, params PatchResourceStatusParams) <span class="cov0" title="0">{
        var request PatchResourceStatusRequestObject

        request.OrgID = orgID
        request.UserID = userID
        request.ResourceID = resourceID
        request.ConsentID = consentID
        request.Params = params

        var body PatchResourceStatusJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PatchResourceStatus(ctx, request.(PatchResourceStatusRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PatchResourceStatus")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PatchResourceStatusResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPatchResourceStatusResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file6" style="display: none">package app

import (
        "context"
        "net/http"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/session"
)

func authSessionMiddleware(service session.Service) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return authSessionMiddlewareHandler(next, service)
        }</span>
}

func authSessionMiddlewareHandler(next http.Handler, service session.Service) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/api/directory/auth-url" </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()

                cookie, err := r.Cookie(cookieSessionId)
                if err != nil </span><span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "session not found"))
                        return
                }</span>

                <span class="cov0" title="0">session, err := service.Session(r.Context(), cookie.Value)
                if err != nil </span><span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "session not found"))
                        return
                }</span>
                <span class="cov0" title="0">ctx = context.WithValue(ctx, api.CtxKeySessionID, session.ID.String())

                orgID := r.PathValue("orgId")
                if orgID != "" </span><span class="cov0" title="0">{
                        if _, ok := session.Organizations[orgID]; !ok </span><span class="cov0" title="0">{
                                api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid org id"))
                                return
                        }</span>
                        <span class="cov0" title="0">ctx = context.WithValue(ctx, api.CtxKeyOrgID, orgID)</span>
                }

                <span class="cov0" title="0">r = r.WithContext(ctx)
                next.ServeHTTP(w, r)</span>
        })
}

func fapiIDMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                interactionID := r.Header.Get(middleware.HeaderXFAPIInteractionID)
                // Verify if the interaction ID is valid, return a new value if not.
                if _, err := uuid.Parse(interactionID); err != nil </span><span class="cov0" title="0">{
                        interactionID = uuid.NewString()
                }</span>

                // Return the same interaction ID in the response.
                <span class="cov0" title="0">w.Header().Set(middleware.HeaderXFAPIInteractionID, interactionID)
                next.ServeHTTP(w, r)</span>
        })
}
</pre>

		<pre class="file" id="file7" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=autopaymentv2 -o=./api_gen.go ./swagger.yml
package autopaymentv2

import (
        "context"
        "crypto"
        "errors"
        "net/http"
        "strings"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/enrollment"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/idempotency"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var _ StrictServerInterface = Server{}

type BankConfig interface {
        Host() string
        ISPB() string
        IBGETownCode() string
        AccountBranch() string
}

type Server struct {
        config             BankConfig
        baseURL            string
        service            autopayment.Service
        idempotencyService idempotency.Service
        op                 *provider.Provider
        keystoreHost       string
        orgID              string
        signer             crypto.Signer
}

func NewServer(
        config BankConfig,
        service autopayment.Service,
        idempotencyService idempotency.Service,
        op *provider.Provider,
        keystoreHost string,
        orgID string,
        signer crypto.Signer,
) Server <span class="cov0" title="0">{
        service = service.WithVersion("v2")
        return Server{
                config:             config,
                baseURL:            config.Host() + "/open-banking/automatic-payments/v2",
                service:            service,
                idempotencyService: idempotencyService,
                op:                 op,
                keystoreHost:       keystoreHost,
                orgID:              orgID,
                signer:             signer,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        autoPaymentMux := http.NewServeMux()

        jwtMiddleware := middleware.JWT(s.baseURL, s.orgID, s.keystoreHost, s.signer)
        idempotencyMiddleware := middleware.Idempotency(s.idempotencyService)
        clientCredentialsAuthMiddleware := middleware.Auth(s.op, goidc.GrantClientCredentials, autopayment.Scope)
        authCodeAuthMiddleware := middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID)
        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "is missing") </span><span class="cov0" title="0">{
                        return "PARAMETRO_NAO_INFORMADO"
                }</span>
                <span class="cov0" title="0">return "PARAMETRO_INVALIDO"</span>
        })
        // TODO. Use the swagger version.
        <span class="cov0" title="0">xvMiddleware := middleware.Version("2.0.0")

        wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err)
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{
                        xvMiddleware,
                        swaggerMiddleware,
                },
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsPostRecurringConsents)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("POST /recurring-consents", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("GET /recurring-consents/{recurringConsentId}", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("PATCH /recurring-consents/{recurringConsentId}", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsPostPixRecurringPayments)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = authCodeAuthMiddleware(handler)
        autoPaymentMux.Handle("POST /pix/recurring-payments", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("GET /pix/recurring-payments/{recurringPaymentId}", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsGetPixRecurringPayments)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("GET /pix/recurring-payments", handler)

        handler = http.HandlerFunc(wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)

        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        autoPaymentMux.Handle("PATCH /pix/recurring-payments/{recurringPaymentId}", handler)

        handler = middleware.FAPIID(nil)(autoPaymentMux)
        mux.Handle("/open-banking/automatic-payments/v2/", http.StripPrefix("/open-banking/automatic-payments/v2", handler))</span>
}

func (s Server) AutomaticPaymentsPostRecurringConsents(ctx context.Context, req AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error) <span class="cov0" title="0">{
        clientID := ctx.Value(api.CtxKeyClientID).(string)
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        c := &amp;autopayment.Consent{
                UserIdentification: req.Body.Data.LoggedUser.Document.Identification,
                UserRel:            consent.Relation(req.Body.Data.LoggedUser.Document.Rel),
                ExpiresAt:          req.Body.Data.ExpirationDateTime,
                AdditionalInfo:     req.Body.Data.AdditionalInformation,
                Configuration:      req.Body.Data.RecurringConfiguration,
                ClientID:           clientID,
                OrgID:              orgID,
        }
        if business := req.Body.Data.BusinessEntity; business != nil </span><span class="cov0" title="0">{
                c.BusinessIdentification = &amp;business.Document.Identification
                c.BusinessIdentification = &amp;business.Document.Rel
        }</span>

        <span class="cov0" title="0">for _, creditor := range req.Body.Data.Creditors </span><span class="cov0" title="0">{
                c.Creditors = append(c.Creditors, autopayment.Creditor{
                        Type:    payment.CreditorType(creditor.PersonType),
                        CPFCNPJ: creditor.CpfCnpj,
                        Name:    creditor.Name,
                })
        }</span>

        <span class="cov0" title="0">var debtorAccount *payment.Account
        if req.Body.Data.DebtorAccount != nil </span><span class="cov0" title="0">{
                debtorAccount = &amp;payment.Account{
                        ISPB:   req.Body.Data.DebtorAccount.Ispb,
                        Issuer: req.Body.Data.DebtorAccount.Issuer,
                        Number: req.Body.Data.DebtorAccount.Number,
                        Type:   payment.AccountType(req.Body.Data.DebtorAccount.AccountType),
                }
        }</span>
        <span class="cov0" title="0">if err := s.service.CreateConsent(ctx, c, debtorAccount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponsePostRecurringConsent{
                Data: struct {
                        AdditionalInformation *string            "json:\"additionalInformation,omitempty\""
                        AuthorisedAtDateTime  *timeutil.DateTime "json:\"authorisedAtDateTime,omitempty\""
                        BusinessEntity        *BusinessEntity    "json:\"businessEntity,omitempty\""
                        CreationDateTime      timeutil.DateTime  "json:\"creationDateTime\""
                        Creditors             Creditors          "json:\"creditors\""
                        DebtorAccount         *struct {
                                AccountType EnumAccountTypeConsents "json:\"accountType\""
                                Ispb        string                  "json:\"ispb\""
                                Issuer      *string                 "json:\"issuer,omitempty\""
                                Number      string                  "json:\"number\""
                        } "json:\"debtorAccount,omitempty\""
                        ExpirationDateTime     *timeutil.DateTime     "json:\"expirationDateTime,omitempty\""
                        LoggedUser             LoggedUser             "json:\"loggedUser\""
                        RecurringConfiguration RecurringConfiguration "json:\"recurringConfiguration\""
                        RecurringConsentID     string                 "json:\"recurringConsentId\""
                        Rejection              *Rejection             "json:\"rejection,omitempty\""
                        Revocation             *struct {
                                Reason *struct {
                                        Code   ResponsePostRecurringConsentDataRevocationReasonCode "json:\"code\""
                                        Detail string                                               "json:\"detail\""
                                } "json:\"reason,omitempty\""
                                RevokedAt   timeutil.DateTime                                     "json:\"revokedAt\""
                                RevokedBy   ResponsePostRecurringConsentDataRevocationRevokedBy   "json:\"revokedBy\""
                                RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom "json:\"revokedFrom\""
                        } "json:\"revocation,omitempty\""
                        Status               EnumAuthorisationStatusType "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime           "json:\"statusUpdateDateTime\""
                        UpdatedAtDateTime    *timeutil.DateTime          "json:\"updatedAtDateTime,omitempty\""
                }{
                        AdditionalInformation: c.AdditionalInfo,
                        CreationDateTime:      c.CreatedAt,
                        ExpirationDateTime:    c.ExpiresAt,
                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: c.UserIdentification,
                                        Rel:            string(c.UserRel),
                                },
                        },
                        RecurringConfiguration: c.Configuration,
                        RecurringConsentID:     c.URN(),
                        Status:                 EnumAuthorisationStatusType(c.Status),
                        StatusUpdateDateTime:   c.StatusUpdatedAt,
                        UpdatedAtDateTime:      &amp;c.UpdatedAt,
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/recurring-consents/" + c.URN()),
        }

        for _, creditor := range c.Creditors </span><span class="cov0" title="0">{
                resp.Data.Creditors = append(resp.Data.Creditors, struct {
                        CpfCnpj    string                "json:\"cpfCnpj\""
                        Name       string                "json:\"name\""
                        PersonType EnumPaymentPersonType "json:\"personType\""
                }{
                        CpfCnpj:    creditor.CPFCNPJ,
                        Name:       creditor.Name,
                        PersonType: EnumPaymentPersonType(creditor.Type),
                })
        }</span>

        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *c.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *c.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;struct {
                        AccountType EnumAccountTypeConsents "json:\"accountType\""
                        Ispb        string                  "json:\"ispb\""
                        Issuer      *string                 "json:\"issuer,omitempty\""
                        Number      string                  "json:\"number\""
                }{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      c.DebtorAccount.Number,
                        AccountType: EnumAccountTypeConsents(payment.ConvertAccountType(c.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsPostRecurringConsents201JSONResponse{RecurringConsentsPostJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, req AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        c, err := s.service.Consent(ctx, req.RecurringConsentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseRecurringConsent{
                Data: struct {
                        AdditionalInformation *string              "json:\"additionalInformation,omitempty\""
                        ApprovalDueDate       *timeutil.BrazilDate "json:\"approvalDueDate,omitempty\""
                        AuthorisedAtDateTime  *timeutil.DateTime   "json:\"authorisedAtDateTime,omitempty\""
                        BusinessEntity        *BusinessEntity      "json:\"businessEntity,omitempty\""
                        CreationDateTime      timeutil.DateTime    "json:\"creationDateTime\""
                        Creditors             Creditors            "json:\"creditors\""
                        DebtorAccount         *struct {
                                AccountType  EnumAccountTypeConsents "json:\"accountType\""
                                IbgeTownCode *string                 "json:\"ibgeTownCode,omitempty\""
                                Ispb         string                  "json:\"ispb\""
                                Issuer       *string                 "json:\"issuer,omitempty\""
                                Number       string                  "json:\"number\""
                        } "json:\"debtorAccount,omitempty\""
                        ExpirationDateTime     *timeutil.DateTime     "json:\"expirationDateTime,omitempty\""
                        LoggedUser             LoggedUser             "json:\"loggedUser\""
                        RecurringConfiguration RecurringConfiguration "json:\"recurringConfiguration\""
                        RecurringConsentID     string                 "json:\"recurringConsentId\""
                        Rejection              *Rejection             "json:\"rejection,omitempty\""
                        Revocation             *struct {
                                Reason *struct {
                                        Code   ResponseRecurringConsentDataRevocationReasonCode "json:\"code\""
                                        Detail string                                           "json:\"detail\""
                                } "json:\"reason,omitempty\""
                                RevokedAt   timeutil.DateTime                                 "json:\"revokedAt\""
                                RevokedBy   ResponseRecurringConsentDataRevocationRevokedBy   "json:\"revokedBy\""
                                RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom "json:\"revokedFrom\""
                        } "json:\"revocation,omitempty\""
                        RiskSignals          *RiskSignalsConsents        "json:\"riskSignals,omitempty\""
                        Status               EnumAuthorisationStatusType "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime           "json:\"statusUpdateDateTime\""
                        UpdatedAtDateTime    *timeutil.DateTime          "json:\"updatedAtDateTime,omitempty\""
                }{
                        RecurringConsentID:     c.URN(),
                        AdditionalInformation:  c.AdditionalInfo,
                        ApprovalDueDate:        c.ApprovalDueAt,
                        AuthorisedAtDateTime:   c.AuthorizedAt,
                        CreationDateTime:       c.CreatedAt,
                        ExpirationDateTime:     c.ExpiresAt,
                        RiskSignals:            c.RiskSignals,
                        Status:                 EnumAuthorisationStatusType(c.Status),
                        StatusUpdateDateTime:   c.StatusUpdatedAt,
                        UpdatedAtDateTime:      &amp;c.UpdatedAt,
                        RecurringConfiguration: c.Configuration,
                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: c.UserIdentification,
                                        Rel:            string(c.UserRel),
                                },
                        },
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/recurring-consents/" + c.URN()),
        }

        for _, creditor := range c.Creditors </span><span class="cov0" title="0">{
                resp.Data.Creditors = append(resp.Data.Creditors, struct {
                        CpfCnpj    string                "json:\"cpfCnpj\""
                        Name       string                "json:\"name\""
                        PersonType EnumPaymentPersonType "json:\"personType\""
                }{
                        CpfCnpj:    creditor.CPFCNPJ,
                        Name:       creditor.Name,
                        PersonType: EnumPaymentPersonType(creditor.Type),
                })
        }</span>

        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *c.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *c.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                ibgeTownCode := s.config.IBGETownCode()
                resp.Data.DebtorAccount = &amp;struct {
                        AccountType  EnumAccountTypeConsents "json:\"accountType\""
                        IbgeTownCode *string                 "json:\"ibgeTownCode,omitempty\""
                        Ispb         string                  "json:\"ispb\""
                        Issuer       *string                 "json:\"issuer,omitempty\""
                        Number       string                  "json:\"number\""
                }{
                        Ispb:         s.config.ISPB(),
                        IbgeTownCode: &amp;ibgeTownCode,
                        Issuer:       &amp;branch,
                        Number:       c.DebtorAccount.Number,
                        AccountType:  EnumAccountTypeConsents(payment.ConvertAccountType(c.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">if c.Rejection != nil </span><span class="cov0" title="0">{
                resp.Data.Rejection = &amp;Rejection{
                        Reason: &amp;ConsentRejectionReason{
                                Code:   ConsentRejectionReasonCode(c.Rejection.Code),
                                Detail: c.Rejection.Detail,
                        },
                        RejectedAt:   c.StatusUpdatedAt,
                        RejectedBy:   RejectionRejectedBy(c.Rejection.By),
                        RejectedFrom: RejectionRejectedFrom(c.Rejection.From),
                }
        }</span>

        <span class="cov0" title="0">if c.Revocation != nil </span><span class="cov0" title="0">{
                resp.Data.Revocation = &amp;struct {
                        Reason *struct {
                                Code   ResponseRecurringConsentDataRevocationReasonCode "json:\"code\""
                                Detail string                                           "json:\"detail\""
                        } "json:\"reason,omitempty\""
                        RevokedAt   timeutil.DateTime                                 "json:\"revokedAt\""
                        RevokedBy   ResponseRecurringConsentDataRevocationRevokedBy   "json:\"revokedBy\""
                        RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom "json:\"revokedFrom\""
                }{
                        Reason: &amp;struct {
                                Code   ResponseRecurringConsentDataRevocationReasonCode "json:\"code\""
                                Detail string                                           "json:\"detail\""
                        }{
                                Code:   ResponseRecurringConsentDataRevocationReasonCode(c.Revocation.Code),
                                Detail: c.Revocation.Detail,
                        },
                        RevokedAt:   c.StatusUpdatedAt,
                        RevokedBy:   ResponseRecurringConsentDataRevocationRevokedBy(c.Revocation.By),
                        RevokedFrom: ResponseRecurringConsentDataRevocationRevokedFrom(c.Revocation.From),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse{RecurringConsentsConsentIDJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, req AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)

        var c *autopayment.Consent
        var err error
        if action, _ := req.Body.Data.AsConsentRejection(); action.Status != nil &amp;&amp; *action.Status == ConsentRejectionStatusREJECTED </span><span class="cov0" title="0">{
                c, err = s.service.RejectConsentByID(ctx, req.RecurringConsentID, orgID, autopayment.ConsentRejection{
                        By:     autopayment.TerminatedBy(action.Rejection.RejectedBy),
                        From:   autopayment.TerminatedFrom(action.Rejection.RejectedFrom),
                        Code:   autopayment.ConsentRejectionCode(action.Rejection.Reason.Code),
                        Detail: action.Rejection.Reason.Detail,
                })
        }</span> else<span class="cov0" title="0"> if action, _ := req.Body.Data.AsConsentRevocation(); action.Status != nil &amp;&amp; *action.Status == REVOKED </span><span class="cov0" title="0">{
                c, err = s.service.RevokeConsent(ctx, req.RecurringConsentID, orgID, autopayment.ConsentRevocation{
                        By:     autopayment.TerminatedBy(action.Revocation.RevokedBy),
                        From:   autopayment.TerminatedFrom(action.Revocation.RevokedFrom),
                        Code:   autopayment.ConsentRevocationCode(action.Revocation.Reason.Code),
                        Detail: action.Revocation.Reason.Detail,
                })
        }</span> else<span class="cov0" title="0"> {
                action, _ := req.Body.Data.AsConsentEdition()
                c, err = s.service.EditConsent(ctx, req.RecurringConsentID, orgID, action)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseRecurringConsentPatch{
                Data: struct {
                        AdditionalInformation *string              "json:\"additionalInformation,omitempty\""
                        ApprovalDueDate       *timeutil.BrazilDate "json:\"approvalDueDate,omitempty\""
                        AuthorisedAtDateTime  *timeutil.DateTime   "json:\"authorisedAtDateTime,omitempty\""
                        BusinessEntity        *BusinessEntity      "json:\"businessEntity,omitempty\""
                        CreationDateTime      timeutil.DateTime    "json:\"creationDateTime\""
                        Creditors             Creditors            "json:\"creditors\""
                        DebtorAccount         *struct {
                                AccountType EnumAccountTypeConsents "json:\"accountType\""
                                Ispb        string                  "json:\"ispb\""
                                Issuer      *string                 "json:\"issuer,omitempty\""
                                Number      string                  "json:\"number\""
                        } "json:\"debtorAccount,omitempty\""
                        ExpirationDateTime     *timeutil.DateTime     "json:\"expirationDateTime,omitempty\""
                        LoggedUser             *LoggedUser            "json:\"loggedUser,omitempty\""
                        RecurringConfiguration RecurringConfiguration "json:\"recurringConfiguration\""
                        RecurringConsentID     string                 "json:\"recurringConsentId\""
                        Rejection              *struct {
                                Reason       *ConsentRejectionReason                                "json:\"reason,omitempty\""
                                RejectedAt   timeutil.DateTime                                      "json:\"rejectedAt\""
                                RejectedBy   ResponseRecurringConsentPatchDataRejectionRejectedBy   "json:\"rejectedBy\""
                                RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom "json:\"rejectedFrom\""
                        } "json:\"rejection,omitempty\""
                        Revocation *struct {
                                Reason *struct {
                                        Code   ResponseRecurringConsentPatchDataRevocationReasonCode "json:\"code\""
                                        Detail string                                                "json:\"detail\""
                                } "json:\"reason,omitempty\""
                                RevokedAt   timeutil.DateTime                                      "json:\"revokedAt\""
                                RevokedBy   ResponseRecurringConsentPatchDataRevocationRevokedBy   "json:\"revokedBy\""
                                RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom "json:\"revokedFrom\""
                        } "json:\"revocation,omitempty\""
                        RiskSignals          *RiskSignalsConsents        "json:\"riskSignals,omitempty\""
                        Status               EnumAuthorisationStatusType "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime           "json:\"statusUpdateDateTime\""
                        UpdatedAtDateTime    *timeutil.DateTime          "json:\"updatedAtDateTime,omitempty\""
                }{
                        AdditionalInformation: c.AdditionalInfo,
                        ApprovalDueDate:       c.ApprovalDueAt,
                        AuthorisedAtDateTime:  c.AuthorizedAt,
                        CreationDateTime:      c.CreatedAt,
                        ExpirationDateTime:    c.ExpiresAt,
                        LoggedUser: &amp;LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: c.UserIdentification,
                                        Rel:            string(c.UserRel),
                                },
                        },
                        RecurringConfiguration: c.Configuration,
                        RecurringConsentID:     c.URN(),
                        Status:                 EnumAuthorisationStatusType(c.Status),
                        StatusUpdateDateTime:   c.StatusUpdatedAt,
                        UpdatedAtDateTime:      &amp;c.UpdatedAt,
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/recurring-consents/" + c.URN()),
        }

        for _, creditor := range c.Creditors </span><span class="cov0" title="0">{
                resp.Data.Creditors = append(resp.Data.Creditors, struct {
                        CpfCnpj    string                "json:\"cpfCnpj\""
                        Name       string                "json:\"name\""
                        PersonType EnumPaymentPersonType "json:\"personType\""
                }{
                        CpfCnpj:    creditor.CPFCNPJ,
                        Name:       creditor.Name,
                        PersonType: EnumPaymentPersonType(creditor.Type),
                })
        }</span>

        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *c.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *c.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;struct {
                        AccountType EnumAccountTypeConsents "json:\"accountType\""
                        Ispb        string                  "json:\"ispb\""
                        Issuer      *string                 "json:\"issuer,omitempty\""
                        Number      string                  "json:\"number\""
                }{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      c.DebtorAccount.Number,
                        AccountType: EnumAccountTypeConsents(payment.ConvertAccountType(c.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">if c.Rejection != nil </span><span class="cov0" title="0">{
                resp.Data.Rejection = &amp;struct {
                        Reason       *ConsentRejectionReason                                "json:\"reason,omitempty\""
                        RejectedAt   timeutil.DateTime                                      "json:\"rejectedAt\""
                        RejectedBy   ResponseRecurringConsentPatchDataRejectionRejectedBy   "json:\"rejectedBy\""
                        RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom "json:\"rejectedFrom\""
                }{
                        Reason: &amp;ConsentRejectionReason{
                                Code:   ConsentRejectionReasonCode(c.Rejection.Code),
                                Detail: c.Rejection.Detail,
                        },
                        RejectedAt:   c.StatusUpdatedAt,
                        RejectedBy:   ResponseRecurringConsentPatchDataRejectionRejectedBy(c.Rejection.By),
                        RejectedFrom: ResponseRecurringConsentPatchDataRejectionRejectedFrom(c.Rejection.From),
                }
        }</span>

        <span class="cov0" title="0">if c.Revocation != nil </span><span class="cov0" title="0">{
                resp.Data.Revocation = &amp;struct {
                        Reason *struct {
                                Code   ResponseRecurringConsentPatchDataRevocationReasonCode "json:\"code\""
                                Detail string                                                "json:\"detail\""
                        } "json:\"reason,omitempty\""
                        RevokedAt   timeutil.DateTime                                      "json:\"revokedAt\""
                        RevokedBy   ResponseRecurringConsentPatchDataRevocationRevokedBy   "json:\"revokedBy\""
                        RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom "json:\"revokedFrom\""
                }{
                        Reason: &amp;struct {
                                Code   ResponseRecurringConsentPatchDataRevocationReasonCode "json:\"code\""
                                Detail string                                                "json:\"detail\""
                        }{
                                Code:   ResponseRecurringConsentPatchDataRevocationReasonCode(c.Revocation.Code),
                                Detail: c.Revocation.Detail,
                        },
                        RevokedAt:   c.StatusUpdatedAt,
                        RevokedBy:   ResponseRecurringConsentPatchDataRevocationRevokedBy(c.Revocation.By),
                        RevokedFrom: ResponseRecurringConsentPatchDataRevocationRevokedFrom(c.Revocation.From),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse{RecurringConsentsConsentIDPatchJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, req AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error) <span class="cov0" title="0">{
        clientID := ctx.Value(api.CtxKeyClientID).(string)
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        scopes := ctx.Value(api.CtxKeyScopes).(string)
        p := &amp;autopayment.Payment{
                EndToEndID:                req.Body.Data.EndToEndID,
                Date:                      req.Body.Data.Date,
                Amount:                    req.Body.Data.Payment.Amount,
                Currency:                  req.Body.Data.Payment.Currency,
                CreditorAccountISBP:       req.Body.Data.CreditorAccount.Ispb,
                CreditorAccountIssuer:     req.Body.Data.CreditorAccount.Issuer,
                CreditorAccountNumber:     req.Body.Data.CreditorAccount.Number,
                CreditorAccountType:       payment.AccountType(req.Body.Data.CreditorAccount.AccountType),
                RemittanceInformation:     req.Body.Data.RemittanceInformation,
                CNPJInitiator:             req.Body.Data.CnpjInitiator,
                IBGETownCode:              req.Body.Data.IbgeTownCode,
                LocalInstrument:           payment.LocalInstrument(req.Body.Data.LocalInstrument),
                Proxy:                     req.Body.Data.Proxy,
                TransactionIdentification: req.Body.Data.TransactionIdentification,
                DocumentIdentification:    req.Body.Data.Document.Identification,
                DocumentRel:               consent.Relation(req.Body.Data.Document.Rel),
                Reference:                 req.Body.Data.PaymentReference,
                RiskSignals:               req.Body.Data.RiskSignals,
                ClientID:                  clientID,
                OrgID:                     orgID,
        }

        if req.Body.Data.RecurringConsentID != nil </span><span class="cov0" title="0">{
                consentID := strings.TrimPrefix(*req.Body.Data.RecurringConsentID, autopayment.ConsentURNPrefix)
                p.ConsentID = uuid.MustParse(consentID)
        }</span>

        <span class="cov0" title="0">if consentID, _ := autopayment.ConsentIDFromScopes(scopes); consentID != "" </span><span class="cov0" title="0">{
                p.ConsentID = uuid.MustParse(consentID)
        }</span>
        <span class="cov0" title="0">if enrollmentID, _ := enrollment.IDFromScopes(scopes); enrollmentID != "" </span><span class="cov0" title="0">{
                id := uuid.MustParse(enrollmentID)
                p.EnrollmentID = &amp;id
        }</span>

        <span class="cov0" title="0">if req.Body.Data.AuthorisationFlow != nil </span><span class="cov0" title="0">{
                authFlow := payment.AuthorisationFlow(*req.Body.Data.AuthorisationFlow)
                p.AuthorisationFlow = &amp;authFlow
        }</span>

        <span class="cov0" title="0">if req.Body.Data.OriginalRecurringPaymentID != nil </span><span class="cov0" title="0">{
                originalID, err := uuid.Parse(*req.Body.Data.OriginalRecurringPaymentID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errorutil.New("invalid original recurring payment id")
                }</span>
                <span class="cov0" title="0">p.OriginalID = &amp;originalID</span>
        }

        <span class="cov0" title="0">if err := s.service.Create(ctx, p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">consentID := autopayment.ConsentURN(p.ConsentID)
        resp := ResponseRecurringPaymentsIDPost{
                Data: ResponseRecurringPaymentsPostData{
                        CnpjInitiator:    p.CNPJInitiator,
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: CreditorAccountPostPixPaymentsResponse{
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                                AccountType: EnumAccountTypePayments(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        },
                        Date: p.Date,
                        Document: struct {
                                Identification string                                       `json:"identification"`
                                Rel            ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
                        }{
                                Identification: p.DocumentIdentification,
                                Rel:            ResponseRecurringPaymentsPostDataDocumentRel(p.DocumentRel),
                        },
                        EndToEndID:      p.EndToEndID,
                        LocalInstrument: ResponseRecurringPaymentsPostDataLocalInstrument(p.LocalInstrument),
                        Payment: PaymentPix{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        PaymentReference:          p.Reference,
                        Proxy:                     p.Proxy,
                        RecurringConsentID:        &amp;consentID,
                        RecurringPaymentID:        p.ID.String(),
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/pix/recurring-payments/" + p.ID.String()),
        }

        if p.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;DebtorAccount{
                        AccountType: EnumAccountTypeConsents(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        Issuer:      &amp;branch,
                        Ispb:        s.config.ISPB(),
                        Number:      p.DebtorAccount.Number,
                }
        }</span>

        <span class="cov0" title="0">if p.AuthorisationFlow != nil </span><span class="cov0" title="0">{
                authFlow := ResponseRecurringPaymentsPostDataAuthorisationFlow(*p.AuthorisationFlow)
                resp.Data.AuthorisationFlow = &amp;authFlow
        }</span>

        <span class="cov0" title="0">if p.OriginalID != nil </span><span class="cov0" title="0">{
                originalID := p.OriginalID.String()
                resp.Data.OriginalRecurringPaymentID = &amp;originalID
        }</span>

        <span class="cov0" title="0">if rejection := p.Rejection; rejection != nil </span><span class="cov0" title="0">{
                resp.Data.RejectionReason = &amp;RejectionReason{
                        Code:   EnumRejectionReasonCode(rejection.Code),
                        Detail: rejection.Detail,
                }
        }</span>

        <span class="cov0" title="0">if cancellation := p.Cancellation; cancellation != nil </span><span class="cov0" title="0">{
                resp.Data.Cancellation = &amp;PixPaymentCancellation{
                        CancelledAt: p.StatusUpdatedAt,
                        CancelledBy: struct {
                                Document struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                } "json:\"document\""
                        }{
                                Document: struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                }{
                                        Identification: cancellation.By,
                                        Rel:            "CPF",
                                },
                        },
                        CancelledFrom: EnumPaymentCancellationFromType(cancellation.From),
                        Reason:        EnumPaymentCancellationReasonType(cancellation.Reason),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsPostPixRecurringPayments201JSONResponse{N201RecurringPaymentsIDPostJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, req AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        p, err := s.service.Payment(ctx, req.RecurringPaymentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">consentID := autopayment.ConsentURN(p.ConsentID)
        resp := ResponseRecurringPaymentsIDRead{
                Data: ResponseRecurringPaymentsDataRead{
                        CnpjInitiator:    p.CNPJInitiator,
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: &amp;CreditorAccount{
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                                AccountType: EnumAccountTypePayments(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        },
                        Date: p.Date,
                        Document: struct {
                                Identification string                                       `json:"identification"`
                                Rel            ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
                        }{
                                Identification: p.DocumentIdentification,
                                Rel:            ResponseRecurringPaymentsDataReadDocumentRel(p.DocumentRel),
                        },
                        EndToEndID:      p.EndToEndID,
                        LocalInstrument: ResponseRecurringPaymentsDataReadLocalInstrument(p.LocalInstrument),
                        Payment: PaymentPix{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        PaymentReference:          p.Reference,
                        Proxy:                     p.Proxy,
                        RecurringConsentID:        &amp;consentID,
                        RecurringPaymentID:        p.ID.String(),
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/pix/recurring-payments/" + p.ID.String()),
        }

        if p.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;DebtorAccount{
                        AccountType: EnumAccountTypeConsents(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        Issuer:      &amp;branch,
                        Ispb:        s.config.ISPB(),
                        Number:      p.DebtorAccount.Number,
                }
        }</span>

        <span class="cov0" title="0">if p.AuthorisationFlow != nil </span><span class="cov0" title="0">{
                authFlow := ResponseRecurringPaymentsDataReadAuthorisationFlow(*p.AuthorisationFlow)
                resp.Data.AuthorisationFlow = &amp;authFlow
        }</span>

        <span class="cov0" title="0">if p.OriginalID != nil </span><span class="cov0" title="0">{
                originalID := p.OriginalID.String()
                resp.Data.OriginalRecurringPaymentID = &amp;originalID
        }</span>

        <span class="cov0" title="0">if rejection := p.Rejection; rejection != nil </span><span class="cov0" title="0">{
                resp.Data.RejectionReason = &amp;RejectionReason{
                        Code:   EnumRejectionReasonCode(rejection.Code),
                        Detail: rejection.Detail,
                }
        }</span>

        <span class="cov0" title="0">if cancellation := p.Cancellation; cancellation != nil </span><span class="cov0" title="0">{
                resp.Data.Cancellation = &amp;PixPaymentCancellation{
                        CancelledAt: p.StatusUpdatedAt,
                        CancelledBy: struct {
                                Document struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                } "json:\"document\""
                        }{
                                Document: struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                }{
                                        Identification: cancellation.By,
                                        Rel:            "CPF",
                                },
                        },
                        CancelledFrom: EnumPaymentCancellationFromType(cancellation.From),
                        Reason:        EnumPaymentCancellationReasonType(cancellation.Reason),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse{N200RecurringPaymentsIDReadJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, req AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        filter := autopayment.Filter{ConsentID: req.Params.RecurringConsentID}
        payments, err := s.service.Payments(ctx, orgID, &amp;filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseRecurringPixPayment{
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/pix/recurring-payments" + filter.URLQuery()),
        }
        for _, p := range payments </span><span class="cov0" title="0">{
                consentID := autopayment.ConsentURN(p.ConsentID)
                data := struct {
                        CreationDateTime timeutil.DateTime   "json:\"creationDateTime\""
                        Date             timeutil.BrazilDate "json:\"date\""
                        Document         struct {
                                Identification string                              "json:\"identification\""
                                Rel            ResponseRecurringPixDataDocumentRel "json:\"rel\""
                        } "json:\"document\""
                        EndToEndID                 EndToEndID                  "json:\"endToEndId\""
                        OriginalRecurringPaymentID *OriginalRecurringPaymentID "json:\"originalRecurringPaymentId,omitempty\""
                        Payment                    PaymentPix                  "json:\"payment\""
                        PaymentReference           *string                     "json:\"paymentReference,omitempty\""
                        RecurringConsentID         *string                     "json:\"recurringConsentId,omitempty\""
                        RecurringPaymentID         string                      "json:\"recurringPaymentId\""
                        RejectionReason            *RejectionReasonGet         "json:\"rejectionReason,omitempty\""
                        RemittanceInformation      *string                     "json:\"remittanceInformation,omitempty\""
                        Status                     EnumPaymentStatusType       "json:\"status\""
                        StatusUpdateDateTime       timeutil.DateTime           "json:\"statusUpdateDateTime\""
                        TransactionIdentification  *string                     "json:\"transactionIdentification,omitempty\""
                }{
                        CreationDateTime: p.CreatedAt,
                        Date:             p.Date,
                        Document: struct {
                                Identification string                              "json:\"identification\""
                                Rel            ResponseRecurringPixDataDocumentRel "json:\"rel\""
                        }{
                                Identification: p.DocumentIdentification,
                                Rel:            ResponseRecurringPixDataDocumentRel(p.DocumentRel),
                        },
                        EndToEndID: p.EndToEndID,
                        Payment: PaymentPix{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        PaymentReference:          p.Reference,
                        RecurringConsentID:        &amp;consentID,
                        RecurringPaymentID:        p.ID.String(),
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                }

                if p.OriginalID != nil </span><span class="cov0" title="0">{
                        originalID := p.OriginalID.String()
                        data.OriginalRecurringPaymentID = &amp;originalID
                }</span>

                <span class="cov0" title="0">if rejection := p.Rejection; rejection != nil </span><span class="cov0" title="0">{
                        data.RejectionReason = &amp;RejectionReasonGet{
                                Code:   EnumRejectionReasonCodeGet(rejection.Code),
                                Detail: rejection.Detail,
                        }
                }</span>

                <span class="cov0" title="0">resp.Data = append(resp.Data, data)</span>
        }

        <span class="cov0" title="0">return AutomaticPaymentsGetPixRecurringPayments200JSONResponse{N200RecurringPixPaymentReadJSONResponse(resp)}, nil</span>
}

func (s Server) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, req AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        p, err := s.service.Cancel(ctx, req.RecurringPaymentID, orgID, consent.Document{
                Identification: req.Body.Data.Cancellation.CancelledBy.Document.Identification,
                Rel:            consent.Relation(req.Body.Data.Cancellation.CancelledBy.Document.Rel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">consentID := autopayment.ConsentURN(p.ConsentID)
        resp := ResponseRecurringPaymentsIDPatch{
                Data: ResponseRecurringPaymentsDataPatch{
                        CnpjInitiator:    p.CNPJInitiator,
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: &amp;CreditorAccount{
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                                AccountType: EnumAccountTypePayments(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        },
                        Date: p.Date,
                        Document: struct {
                                Identification string                                        "json:\"identification\""
                                Rel            ResponseRecurringPaymentsDataPatchDocumentRel "json:\"rel\""
                        }{
                                Identification: p.DocumentIdentification,
                                Rel:            ResponseRecurringPaymentsDataPatchDocumentRel(p.DocumentRel),
                        },
                        EndToEndID:      p.EndToEndID,
                        LocalInstrument: ResponseRecurringPaymentsDataPatchLocalInstrument(p.LocalInstrument),
                        Payment: PaymentPix{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        PaymentReference:          p.Reference,
                        Proxy:                     p.Proxy,
                        RecurringConsentID:        &amp;consentID,
                        RecurringPaymentID:        p.ID.String(),
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/pix/recurring-payments/" + p.ID.String()),
        }

        if p.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;DebtorAccount{
                        AccountType: EnumAccountTypeConsents(payment.ConvertAccountType(p.DebtorAccount.Type)),
                        Issuer:      &amp;branch,
                        Ispb:        s.config.ISPB(),
                        Number:      p.DebtorAccount.Number,
                }
        }</span>

        <span class="cov0" title="0">if p.AuthorisationFlow != nil </span><span class="cov0" title="0">{
                authFlow := ResponseRecurringPaymentsDataPatchAuthorisationFlow(*p.AuthorisationFlow)
                resp.Data.AuthorisationFlow = &amp;authFlow
        }</span>

        <span class="cov0" title="0">if p.OriginalID != nil </span><span class="cov0" title="0">{
                originalID := p.OriginalID.String()
                resp.Data.OriginalRecurringPaymentID = &amp;originalID
        }</span>

        <span class="cov0" title="0">if rejection := p.Rejection; rejection != nil </span><span class="cov0" title="0">{
                resp.Data.RejectionReason = &amp;RejectionReason{
                        Code:   EnumRejectionReasonCode(rejection.Code),
                        Detail: rejection.Detail,
                }
        }</span>

        <span class="cov0" title="0">if cancellation := p.Cancellation; cancellation != nil </span><span class="cov0" title="0">{
                resp.Data.Cancellation = &amp;PixPaymentCancellation{
                        CancelledAt: p.StatusUpdatedAt,
                        CancelledBy: struct {
                                Document struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                } "json:\"document\""
                        }{
                                Document: struct {
                                        Identification string                                       "json:\"identification\""
                                        Rel            PixPaymentCancellationCancelledByDocumentRel "json:\"rel\""
                                }{
                                        Identification: cancellation.By,
                                        Rel:            "CPF",
                                },
                        },
                        CancelledFrom: EnumPaymentCancellationFromType(cancellation.From),
                        Reason:        EnumPaymentCancellationReasonType(cancellation.Reason),
                }
        }</span>

        <span class="cov0" title="0">return AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse{N200RecurringPaymentsIDPatchJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        if errors.Is(err, autopayment.ErrInvalidEndToEndID) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidPayment) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DETALHE_PAGAMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrPaymentDoesNotMatchConsent) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PAGAMENTO_DIVERGENTE_CONSENTIMENTO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidDate) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DATA_PAGAMENTO_INVALIDA", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrMissingValue) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_NAO_INFORMADO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrCancelNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PAGAMENTO_NAO_PERMITE_CANCELAMENTO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidConsentStatus) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CONSENTIMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidData) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidEdition) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DETALHE_EDICAO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrFieldNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CAMPO_NAO_PERMITIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrConsentPartiallyAccepted) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CONSENTIMENTO_PENDENTE_AUTORIZACAO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;errorutil.Error{}) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">//go:build go1.22

// Package autopaymentv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package autopaymentv2

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
        OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
        OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreatePixRecurringPaymentErrorsCode.
const (
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOINVALIDO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_INVALIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeCONSENTIMENTOPENDENTEAUTORIZACAO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHEPAGAMENTOINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeDETALHETENTATIVAINVALIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "DETALHE_TENTATIVA_INVALIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeERROIDEMPOTENCIA                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeFORAPRAZOPERMITIDO                        N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "FORA_PRAZO_PERMITIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEPERIODOVALOREXCEDIDO                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITETENTATIVASEXCEDIDO                  N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_TENTATIVAS_EXCEDIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeNAOINFORMADO                              N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "NAO_INFORMADO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTODIVERGENTECONSENTIMENTO          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADODETENTORA                N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_DETENTORA"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodePAGAMENTORECUSADOSPI                      N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PAGAMENTO_RECUSADO_SPI"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETROINVALIDO                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodePARAMETRONAOINFORMADO                     N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeSALDOINSUFICIENTE                         N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "SALDO_INSUFICIENTE"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORACIMALIMITE                          N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_ACIMA_LIMITE"
        N422ResponseErrorCreatePixRecurringPaymentErrorsCodeVALORINVALIDO                             N422ResponseErrorCreatePixRecurringPaymentErrorsCode = "VALOR_INVALIDO"
)

// Defines values for N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode.
const (
        N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodeCANCELAMENTOFORAPERIODOPERMITIDO N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "CANCELAMENTO_FORA_PERIODO_PERMITIDO"
        N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePAGAMENTONAOPERMITECANCELAMENTO  N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
        N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETROINVALIDO                N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCodePARAMETRONAOINFORMADO            N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for N422ResponseErrorRecurringConsentsErrorsCode.
const (
        N422ResponseErrorRecurringConsentsErrorsCodeCAMPONAOPERMITIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "CAMPO_NAO_PERMITIDO"
        N422ResponseErrorRecurringConsentsErrorsCodeCONSENTIMENTONAOPERMITECANCELAMENTO N422ResponseErrorRecurringConsentsErrorsCode = "CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO"
        N422ResponseErrorRecurringConsentsErrorsCodeDETALHEEDICAOINVALIDO               N422ResponseErrorRecurringConsentsErrorsCode = "DETALHE_EDICAO_INVALIDO"
        N422ResponseErrorRecurringConsentsErrorsCodeFALTAMSINAISOBRIGATORIOSPLATAFORMA  N422ResponseErrorRecurringConsentsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA"
        N422ResponseErrorRecurringConsentsErrorsCodePARAMETROINVALIDO                   N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorRecurringConsentsErrorsCodePARAMETRONAOINFORMADO               N422ResponseErrorRecurringConsentsErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorRecurringConsentsErrorsCodePERMISSAOINSUFICIENTE               N422ResponseErrorRecurringConsentsErrorsCode = "PERMISSAO_INSUFICIENTE"
)

// Defines values for AutomaticAutomaticInterval.
const (
        AutomaticAutomaticIntervalANUAL      AutomaticAutomaticInterval = "ANUAL"
        AutomaticAutomaticIntervalMENSAL     AutomaticAutomaticInterval = "MENSAL"
        AutomaticAutomaticIntervalSEMANAL    AutomaticAutomaticInterval = "SEMANAL"
        AutomaticAutomaticIntervalSEMESTRAL  AutomaticAutomaticInterval = "SEMESTRAL"
        AutomaticAutomaticIntervalTRIMESTRAL AutomaticAutomaticInterval = "TRIMESTRAL"
)

// Defines values for AutomaticRequestAutomaticInterval.
const (
        AutomaticRequestAutomaticIntervalANUAL      AutomaticRequestAutomaticInterval = "ANUAL"
        AutomaticRequestAutomaticIntervalMENSAL     AutomaticRequestAutomaticInterval = "MENSAL"
        AutomaticRequestAutomaticIntervalSEMANAL    AutomaticRequestAutomaticInterval = "SEMANAL"
        AutomaticRequestAutomaticIntervalSEMESTRAL  AutomaticRequestAutomaticInterval = "SEMESTRAL"
        AutomaticRequestAutomaticIntervalTRIMESTRAL AutomaticRequestAutomaticInterval = "TRIMESTRAL"
)

// Defines values for ConsentRejectionRejectionRejectedBy.
const (
        ConsentRejectionRejectionRejectedByDETENTORA  ConsentRejectionRejectionRejectedBy = "DETENTORA"
        ConsentRejectionRejectionRejectedByINICIADORA ConsentRejectionRejectionRejectedBy = "INICIADORA"
        ConsentRejectionRejectionRejectedByUSUARIO    ConsentRejectionRejectionRejectedBy = "USUARIO"
)

// Defines values for ConsentRejectionRejectionRejectedFrom.
const (
        ConsentRejectionRejectionRejectedFromDETENTORA  ConsentRejectionRejectionRejectedFrom = "DETENTORA"
        ConsentRejectionRejectionRejectedFromINICIADORA ConsentRejectionRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ConsentRejectionStatus.
const (
        ConsentRejectionStatusREJECTED ConsentRejectionStatus = "REJECTED"
)

// Defines values for ConsentRejectionReasonCode.
const (
        ConsentRejectionReasonCodeAUTENTICACAODIVERGENTE    ConsentRejectionReasonCode = "AUTENTICACAO_DIVERGENTE"
        ConsentRejectionReasonCodeCONTANAOPERMITEPAGAMENTO  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
        ConsentRejectionReasonCodeCONTASORIGEMDESTINOIGUAIS ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        ConsentRejectionReasonCodeFALHAINFRAESTRUTURA       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
        ConsentRejectionReasonCodeNAOINFORMADO              ConsentRejectionReasonCode = "NAO_INFORMADO"
        ConsentRejectionReasonCodeREJEITADOUSUARIO          ConsentRejectionReasonCode = "REJEITADO_USUARIO"
        ConsentRejectionReasonCodeSALDOINSUFICIENTE         ConsentRejectionReasonCode = "SALDO_INSUFICIENTE"
        ConsentRejectionReasonCodeTEMPOEXPIRADOAUTORIZACAO  ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
        ConsentRejectionReasonCodeVALORACIMALIMITE          ConsentRejectionReasonCode = "VALOR_ACIMA_LIMITE"
)

// Defines values for ConsentRevocationRevocationRevokedBy.
const (
        ConsentRevocationRevocationRevokedByDETENTORA  ConsentRevocationRevocationRevokedBy = "DETENTORA"
        ConsentRevocationRevocationRevokedByINICIADORA ConsentRevocationRevocationRevokedBy = "INICIADORA"
        ConsentRevocationRevocationRevokedByUSUARIO    ConsentRevocationRevocationRevokedBy = "USUARIO"
)

// Defines values for ConsentRevocationRevocationRevokedFrom.
const (
        ConsentRevocationRevocationRevokedFromDETENTORA  ConsentRevocationRevocationRevokedFrom = "DETENTORA"
        ConsentRevocationRevocationRevokedFromINICIADORA ConsentRevocationRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ConsentRevocationStatus.
const (
        REVOKED ConsentRevocationStatus = "REVOKED"
)

// Defines values for ConsentRevokedReasonCode.
const (
        ConsentRevokedReasonCodeNAOINFORMADO      ConsentRevokedReasonCode = "NAO_INFORMADO"
        ConsentRevokedReasonCodeREVOGADORECEBEDOR ConsentRevokedReasonCode = "REVOGADO_RECEBEDOR"
        ConsentRevokedReasonCodeREVOGADOUSUARIO   ConsentRevokedReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ContractDebtorDocumentRel.
const (
        ContractDebtorDocumentRelCNPJ ContractDebtorDocumentRel = "CNPJ"
        ContractDebtorDocumentRelCPF  ContractDebtorDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataAuthorisationFlow.
const (
        CreateRecurringPixPaymentDataAuthorisationFlowCIBAFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
        CreateRecurringPixPaymentDataAuthorisationFlowFIDOFLOW   CreateRecurringPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
        CreateRecurringPixPaymentDataAuthorisationFlowHYBRIDFLOW CreateRecurringPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for CreateRecurringPixPaymentDataDocumentRel.
const (
        CreateRecurringPixPaymentDataDocumentRelCNPJ CreateRecurringPixPaymentDataDocumentRel = "CNPJ"
        CreateRecurringPixPaymentDataDocumentRelCPF  CreateRecurringPixPaymentDataDocumentRel = "CPF"
)

// Defines values for CreateRecurringPixPaymentDataLocalInstrument.
const (
        CreateRecurringPixPaymentDataLocalInstrumentDICT CreateRecurringPixPaymentDataLocalInstrument = "DICT"
        CreateRecurringPixPaymentDataLocalInstrumentINIC CreateRecurringPixPaymentDataLocalInstrument = "INIC"
        CreateRecurringPixPaymentDataLocalInstrumentMANU CreateRecurringPixPaymentDataLocalInstrument = "MANU"
)

// Defines values for EnumAccountTypeConsents.
const (
        EnumAccountTypeConsentsCACC EnumAccountTypeConsents = "CACC"
        EnumAccountTypeConsentsSVGS EnumAccountTypeConsents = "SVGS"
        EnumAccountTypeConsentsTRAN EnumAccountTypeConsents = "TRAN"
)

// Defines values for EnumAccountTypePayments.
const (
        EnumAccountTypePaymentsCACC EnumAccountTypePayments = "CACC"
        EnumAccountTypePaymentsSVGS EnumAccountTypePayments = "SVGS"
        EnumAccountTypePaymentsTRAN EnumAccountTypePayments = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
        EnumAuthorisationStatusTypeAUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
        EnumAuthorisationStatusTypeAWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
        EnumAuthorisationStatusTypeCONSUMED              EnumAuthorisationStatusType = "CONSUMED"
        EnumAuthorisationStatusTypePARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
        EnumAuthorisationStatusTypeREJECTED              EnumAuthorisationStatusType = "REJECTED"
        EnumAuthorisationStatusTypeREVOKED               EnumAuthorisationStatusType = "REVOKED"
)

// Defines values for EnumPaymentCancellationFromType.
const (
        EnumPaymentCancellationFromTypeDETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
        EnumPaymentCancellationFromTypeINICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
        CANCELADOAGENDAMENTO EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
        CANCELADOPENDENCIA   EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
        EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
        PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
        PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
        EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
        EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
        EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
        EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
        EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
        EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
        EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
        EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
        PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonCode.
const (
        EnumRejectionReasonCodeCONSENTIMENTOINVALIDO                     EnumRejectionReasonCode = "CONSENTIMENTO_INVALIDO"
        EnumRejectionReasonCodeCONSENTIMENTOREVOGADO                     EnumRejectionReasonCode = "CONSENTIMENTO_REVOGADO"
        EnumRejectionReasonCodeDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
        EnumRejectionReasonCodeDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
        EnumRejectionReasonCodeFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
        EnumRejectionReasonCodeFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
        EnumRejectionReasonCodeFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        EnumRejectionReasonCodeFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
        EnumRejectionReasonCodeFORAPRAZOPERMITIDO                        EnumRejectionReasonCode = "FORA_PRAZO_PERMITIDO"
        EnumRejectionReasonCodeLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
        EnumRejectionReasonCodeLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
        EnumRejectionReasonCodeLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
        EnumRejectionReasonCodeLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
        EnumRejectionReasonCodeLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
        EnumRejectionReasonCodeNAOINFORMADO                              EnumRejectionReasonCode = "NAO_INFORMADO"
        EnumRejectionReasonCodePAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        EnumRejectionReasonCodePAGAMENTORECUSADODETENTORA                EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
        EnumRejectionReasonCodePAGAMENTORECUSADOSPI                      EnumRejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
        EnumRejectionReasonCodeSALDOINSUFICIENTE                         EnumRejectionReasonCode = "SALDO_INSUFICIENTE"
        EnumRejectionReasonCodeTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
        EnumRejectionReasonCodeVALORACIMALIMITE                          EnumRejectionReasonCode = "VALOR_ACIMA_LIMITE"
        EnumRejectionReasonCodeVALORINVALIDO                             EnumRejectionReasonCode = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonCodeGet.
const (
        EnumRejectionReasonCodeGetCONSENTIMENTOINVALIDO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_INVALIDO"
        EnumRejectionReasonCodeGetCONSENTIMENTOREVOGADO                     EnumRejectionReasonCodeGet = "CONSENTIMENTO_REVOGADO"
        EnumRejectionReasonCodeGetDETALHEPAGAMENTOINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_PAGAMENTO_INVALIDO"
        EnumRejectionReasonCodeGetDETALHETENTATIVAINVALIDO                  EnumRejectionReasonCodeGet = "DETALHE_TENTATIVA_INVALIDO"
        EnumRejectionReasonCodeGetFALHAINFRAESTRUTURADETENTORA              EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_DETENTORA"
        EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAICP                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_ICP"
        EnumRejectionReasonCodeGetFALHAINFRAESTRUTURAPSPRECEBEDOR           EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        EnumRejectionReasonCodeGetFALHAINFRAESTRUTURASPI                    EnumRejectionReasonCodeGet = "FALHA_INFRAESTRUTURA_SPI"
        EnumRejectionReasonCodeGetFORAPRAZOPERMITIDO                        EnumRejectionReasonCodeGet = "FORA_PRAZO_PERMITIDO"
        EnumRejectionReasonCodeGetLIMITEPERIODOQUANTIDADEEXCEDIDO           EnumRejectionReasonCodeGet = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
        EnumRejectionReasonCodeGetLIMITEPERIODOVALOREXCEDIDO                EnumRejectionReasonCodeGet = "LIMITE_PERIODO_VALOR_EXCEDIDO"
        EnumRejectionReasonCodeGetLIMITETENTATIVASEXCEDIDO                  EnumRejectionReasonCodeGet = "LIMITE_TENTATIVAS_EXCEDIDO"
        EnumRejectionReasonCodeGetLIMITEVALORTOTALCONSENTIMENTOEXCEDIDO     EnumRejectionReasonCodeGet = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
        EnumRejectionReasonCodeGetLIMITEVALORTRANSACAOCONSENTIMENTOEXCEDIDO EnumRejectionReasonCodeGet = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO"
        EnumRejectionReasonCodeGetNAOINFORMADO                              EnumRejectionReasonCodeGet = "NAO_INFORMADO"
        EnumRejectionReasonCodeGetPAGAMENTODIVERGENTECONSENTIMENTO          EnumRejectionReasonCodeGet = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        EnumRejectionReasonCodeGetPAGAMENTORECUSADODETENTORA                EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_DETENTORA"
        EnumRejectionReasonCodeGetPAGAMENTORECUSADOSPI                      EnumRejectionReasonCodeGet = "PAGAMENTO_RECUSADO_SPI"
        EnumRejectionReasonCodeGetSALDOINSUFICIENTE                         EnumRejectionReasonCodeGet = "SALDO_INSUFICIENTE"
        EnumRejectionReasonCodeGetTITULARIDADEINCONSISTENTE                 EnumRejectionReasonCodeGet = "TITULARIDADE_INCONSISTENTE"
        EnumRejectionReasonCodeGetVALORACIMALIMITE                          EnumRejectionReasonCodeGet = "VALOR_ACIMA_LIMITE"
        EnumRejectionReasonCodeGetVALORINVALIDO                             EnumRejectionReasonCodeGet = "VALOR_INVALIDO"
)

// Defines values for PatchPixPaymentDataCancellationCancelledByDocumentRel.
const (
        PatchPixPaymentDataCancellationCancelledByDocumentRelCNPJ PatchPixPaymentDataCancellationCancelledByDocumentRel = "CNPJ"
        PatchPixPaymentDataCancellationCancelledByDocumentRelCPF  PatchPixPaymentDataCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for PixPaymentCancellationCancelledByDocumentRel.
const (
        PixPaymentCancellationCancelledByDocumentRelCNPJ PixPaymentCancellationCancelledByDocumentRel = "CNPJ"
        PixPaymentCancellationCancelledByDocumentRelCPF  PixPaymentCancellationCancelledByDocumentRel = "CPF"
)

// Defines values for RejectionRejectedBy.
const (
        RejectionRejectedByDETENTORA  RejectionRejectedBy = "DETENTORA"
        RejectionRejectedByINICIADORA RejectionRejectedBy = "INICIADORA"
        RejectionRejectedByUSUARIO    RejectionRejectedBy = "USUARIO"
)

// Defines values for RejectionRejectedFrom.
const (
        RejectionRejectedFromDETENTORA  RejectionRejectedFrom = "DETENTORA"
        RejectionRejectedFromINICIADORA RejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseErrorCreateConsentErrorsCode.
const (
        ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA       ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
        ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO    ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
        ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA            ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
        ResponseErrorCreateConsentErrorsCodeFUNCIONALIDADENAOHABILITADA ResponseErrorCreateConsentErrorsCode = "FUNCIONALIDADE_NAO_HABILITADA"
        ResponseErrorCreateConsentErrorsCodeNAOINFORMADO                ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
        ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO           ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
        ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO       ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationReasonCode.
const (
        ResponsePostRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponsePostRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
        ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
        ResponsePostRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponsePostRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedBy.
const (
        ResponsePostRecurringConsentDataRevocationRevokedByDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedBy = "DETENTORA"
        ResponsePostRecurringConsentDataRevocationRevokedByINICIADORA ResponsePostRecurringConsentDataRevocationRevokedBy = "INICIADORA"
        ResponsePostRecurringConsentDataRevocationRevokedByUSUARIO    ResponsePostRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponsePostRecurringConsentDataRevocationRevokedFrom.
const (
        ResponsePostRecurringConsentDataRevocationRevokedFromDETENTORA  ResponsePostRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
        ResponsePostRecurringConsentDataRevocationRevokedFromINICIADORA ResponsePostRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentDataRevocationReasonCode.
const (
        ResponseRecurringConsentDataRevocationReasonCodeNAOINFORMADO      ResponseRecurringConsentDataRevocationReasonCode = "NAO_INFORMADO"
        ResponseRecurringConsentDataRevocationReasonCodeREVOGADORECEBEDOR ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
        ResponseRecurringConsentDataRevocationReasonCodeREVOGADOUSUARIO   ResponseRecurringConsentDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedBy.
const (
        ResponseRecurringConsentDataRevocationRevokedByDETENTORA  ResponseRecurringConsentDataRevocationRevokedBy = "DETENTORA"
        ResponseRecurringConsentDataRevocationRevokedByINICIADORA ResponseRecurringConsentDataRevocationRevokedBy = "INICIADORA"
        ResponseRecurringConsentDataRevocationRevokedByUSUARIO    ResponseRecurringConsentDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentDataRevocationRevokedFrom.
const (
        ResponseRecurringConsentDataRevocationRevokedFromDETENTORA  ResponseRecurringConsentDataRevocationRevokedFrom = "DETENTORA"
        ResponseRecurringConsentDataRevocationRevokedFromINICIADORA ResponseRecurringConsentDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedBy.
const (
        ResponseRecurringConsentPatchDataRejectionRejectedByDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedBy = "DETENTORA"
        ResponseRecurringConsentPatchDataRejectionRejectedByINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedBy = "INICIADORA"
        ResponseRecurringConsentPatchDataRejectionRejectedByUSUARIO    ResponseRecurringConsentPatchDataRejectionRejectedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRejectionRejectedFrom.
const (
        ResponseRecurringConsentPatchDataRejectionRejectedFromDETENTORA  ResponseRecurringConsentPatchDataRejectionRejectedFrom = "DETENTORA"
        ResponseRecurringConsentPatchDataRejectionRejectedFromINICIADORA ResponseRecurringConsentPatchDataRejectionRejectedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationReasonCode.
const (
        NAOINFORMADO      ResponseRecurringConsentPatchDataRevocationReasonCode = "NAO_INFORMADO"
        REVOGADORECEBEDOR ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_RECEBEDOR"
        REVOGADOUSUARIO   ResponseRecurringConsentPatchDataRevocationReasonCode = "REVOGADO_USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedBy.
const (
        ResponseRecurringConsentPatchDataRevocationRevokedByDETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedBy = "DETENTORA"
        ResponseRecurringConsentPatchDataRevocationRevokedByINICIADORA ResponseRecurringConsentPatchDataRevocationRevokedBy = "INICIADORA"
        ResponseRecurringConsentPatchDataRevocationRevokedByUSUARIO    ResponseRecurringConsentPatchDataRevocationRevokedBy = "USUARIO"
)

// Defines values for ResponseRecurringConsentPatchDataRevocationRevokedFrom.
const (
        DETENTORA  ResponseRecurringConsentPatchDataRevocationRevokedFrom = "DETENTORA"
        INICIADORA ResponseRecurringConsentPatchDataRevocationRevokedFrom = "INICIADORA"
)

// Defines values for ResponseRecurringPaymentsDataPatchAuthorisationFlow.
const (
        ResponseRecurringPaymentsDataPatchAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "CIBA_FLOW"
        ResponseRecurringPaymentsDataPatchAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataPatchAuthorisationFlow = "FIDO_FLOW"
        ResponseRecurringPaymentsDataPatchAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataPatchAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataPatchDocumentRel.
const (
        ResponseRecurringPaymentsDataPatchDocumentRelCNPJ ResponseRecurringPaymentsDataPatchDocumentRel = "CNPJ"
        ResponseRecurringPaymentsDataPatchDocumentRelCPF  ResponseRecurringPaymentsDataPatchDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataPatchLocalInstrument.
const (
        ResponseRecurringPaymentsDataPatchLocalInstrumentDICT ResponseRecurringPaymentsDataPatchLocalInstrument = "DICT"
        ResponseRecurringPaymentsDataPatchLocalInstrumentINIC ResponseRecurringPaymentsDataPatchLocalInstrument = "INIC"
        ResponseRecurringPaymentsDataPatchLocalInstrumentMANU ResponseRecurringPaymentsDataPatchLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsDataReadAuthorisationFlow.
const (
        ResponseRecurringPaymentsDataReadAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "CIBA_FLOW"
        ResponseRecurringPaymentsDataReadAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsDataReadAuthorisationFlow = "FIDO_FLOW"
        ResponseRecurringPaymentsDataReadAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsDataReadAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsDataReadDocumentRel.
const (
        ResponseRecurringPaymentsDataReadDocumentRelCNPJ ResponseRecurringPaymentsDataReadDocumentRel = "CNPJ"
        ResponseRecurringPaymentsDataReadDocumentRelCPF  ResponseRecurringPaymentsDataReadDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsDataReadLocalInstrument.
const (
        ResponseRecurringPaymentsDataReadLocalInstrumentDICT ResponseRecurringPaymentsDataReadLocalInstrument = "DICT"
        ResponseRecurringPaymentsDataReadLocalInstrumentINIC ResponseRecurringPaymentsDataReadLocalInstrument = "INIC"
        ResponseRecurringPaymentsDataReadLocalInstrumentMANU ResponseRecurringPaymentsDataReadLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPaymentsPostDataAuthorisationFlow.
const (
        ResponseRecurringPaymentsPostDataAuthorisationFlowCIBAFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "CIBA_FLOW"
        ResponseRecurringPaymentsPostDataAuthorisationFlowFIDOFLOW   ResponseRecurringPaymentsPostDataAuthorisationFlow = "FIDO_FLOW"
        ResponseRecurringPaymentsPostDataAuthorisationFlowHYBRIDFLOW ResponseRecurringPaymentsPostDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponseRecurringPaymentsPostDataDocumentRel.
const (
        ResponseRecurringPaymentsPostDataDocumentRelCNPJ ResponseRecurringPaymentsPostDataDocumentRel = "CNPJ"
        ResponseRecurringPaymentsPostDataDocumentRelCPF  ResponseRecurringPaymentsPostDataDocumentRel = "CPF"
)

// Defines values for ResponseRecurringPaymentsPostDataLocalInstrument.
const (
        ResponseRecurringPaymentsPostDataLocalInstrumentDICT ResponseRecurringPaymentsPostDataLocalInstrument = "DICT"
        ResponseRecurringPaymentsPostDataLocalInstrumentINIC ResponseRecurringPaymentsPostDataLocalInstrument = "INIC"
        ResponseRecurringPaymentsPostDataLocalInstrumentMANU ResponseRecurringPaymentsPostDataLocalInstrument = "MANU"
)

// Defines values for ResponseRecurringPixDataDocumentRel.
const (
        ResponseRecurringPixDataDocumentRelCNPJ ResponseRecurringPixDataDocumentRel = "CNPJ"
        ResponseRecurringPixDataDocumentRelCPF  ResponseRecurringPixDataDocumentRel = "CPF"
)

// N422ResponseErrorCreatePixRecurringPayment defines model for 422ResponseErrorCreatePixRecurringPayment.
type N422ResponseErrorCreatePixRecurringPayment struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação da iniciação de pagamento:
                // - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
                // - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
                // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
                // - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
                // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
                // - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - NAO_INFORMADO: Não informada pela detentora de conta.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
                // - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
                // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
                // - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
                // - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
                // - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
                Code N422ResponseErrorCreatePixRecurringPaymentErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
                // - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
                // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
                // - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
                // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
                // - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - NAO_INFORMADO: Não informada pela detentora de conta.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
                // - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
                // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
                // - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
                // - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
                // - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
                // - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
                // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
                // - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
                // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
                // - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - NAO_INFORMADO: Não informada pela detentora de conta.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
                // - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
                // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: Limite de transação excedido.
                // - LIMITE_TENTATIVAS_EXCEDIDO: Limite de tentativas excedido.
                // - FORA_PRAZO_PERMITIDO: Tentativa fora do prazo.
                // - DETALHE_TENTATIVA_INVALIDO: Nova tentativa inválida
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixRecurringPaymentErrorsCode Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
// - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final).
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: Limite total excedido
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O limite de tentativas para liquidação do pagamento permitidas pelo arranjo foi excedido.
// - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
// - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
type N422ResponseErrorCreatePixRecurringPaymentErrorsCode string

// N422ResponseErrorCreateRecurringPaymentsPaymentID defines model for 422ResponseErrorCreateRecurringPaymentsPaymentId.
type N422ResponseErrorCreateRecurringPaymentsPaymentID struct {
        Errors []struct {
                // Code - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
                // - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
                // - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
                // - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
                Code N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode `json:"code"`

                // Detail - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
                // - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
                // - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
                // - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
                Detail string `json:"detail"`

                // Title - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
                // - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
                // - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
                // - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode - PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento está com um status que não permite cancelamento.
// - CANCELAMENTO_FORA_PERIODO_PERMITIDO: O usuário solicitou o cancelamento fora da janela de tempo permitido.
// - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
// - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
type N422ResponseErrorCreateRecurringPaymentsPaymentIDErrorsCode string

// N422ResponseErrorRecurringConsents defines model for 422ResponseErrorRecurringConsents.
type N422ResponseErrorRecurringConsents struct {
        Errors []struct {
                Code N422ResponseErrorRecurringConsentsErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED")
                // - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
                // - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
                // - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
                // - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
                // - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - CONSENTIMENTO_NAO_PERMITE_CANCELAMENTO: O status do consentimento não permite a realização do cancelamento (em status "CONSUMED" ou "REJECTED").
                // - CAMPO_NAO_PERMITIDO: O(s) campo(s) solicitado(s) para edição não podem ser editados.
                // - PERMISSAO_INSUFICIENTE: Consentimento possui múltiplas alçadas aprovadoras e não permite a edição pelo usuário atual.
                // - DETALHE_EDICAO_INVALIDO: A tentativa de edição do consentimento não respeitou as regras de negócio descritas nos campos.
                // - FALTAM_SINAIS_OBRIGATORIOS_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - PARAMETRO_INVALIDO: Os parâmetros informados não obedecem a formatação especificada.
                // - PARAMETRO_NAO_INFORMADO: Algum ou todos os campos obrigatórios não foram informados.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorRecurringConsentsErrorsCode defines model for 422ResponseErrorRecurringConsents.Errors.Code.
type N422ResponseErrorRecurringConsentsErrorsCode string

// Automatic defines model for Automatic.
type Automatic struct {
        // Automatic Definição da configuração de recorrência para pagamentos automáticos
        Automatic struct {
                // ContractDebtor Informações sobre o cliente devedor do contrato.
                ContractDebtor ContractDebtor `json:"contractDebtor"`

                // ContractID Identificador do contrato de transação
                ContractID string `json:"contractId"`

                // FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
                //
                // [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
                FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

                // FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
                //
                // [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
                FixedAmount *string `json:"fixedAmount,omitempty"`

                // Interval Define a periodicidade permitida para realização de transações
                // - SEMANAL
                // - MENSAL
                // - ANUAL
                // - SEMESTRAL
                // - TRIMESTRAL
                Interval AutomaticAutomaticInterval `json:"interval"`

                // IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
                IsRetryAccepted bool `json:"isRetryAccepted"`

                // MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
                //
                // [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
                MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

                // MinimumVariableAmount Valor definido pelo usuário recebedor.
                // Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
                // Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
                // Não representa um valor mínimo de cobrança para o pagamento.
                MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

                // ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
                // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`

                // UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
                UseOverdraftLimit bool `json:"useOverdraftLimit"`
        } `json:"automatic"`
}

// AutomaticAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticAutomaticInterval string

// AutomaticRequest defines model for AutomaticRequest.
type AutomaticRequest struct {
        // Automatic Definição da configuração de recorrência para pagamentos automáticos
        Automatic struct {
                // ContractDebtor Informações sobre o cliente devedor do contrato.
                ContractDebtor ContractDebtor `json:"contractDebtor"`

                // ContractID Identificador do contrato de transação
                ContractID string `json:"contractId"`

                // FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
                //
                // [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
                FirstPayment *FirstPayment `json:"firstPayment,omitempty"`

                // FixedAmount Valor fixo de cobrança, caso preenchido, representa um consentimento para pagamentos de valores fixos, ou não sujeitos a alteração durante a vigência do consentimento.
                //
                // [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/maximumVariableAmount”
                FixedAmount *string `json:"fixedAmount,omitempty"`

                // Interval Define a periodicidade permitida para realização de transações
                // - SEMANAL
                // - MENSAL
                // - ANUAL
                // - SEMESTRAL
                // - TRIMESTRAL
                Interval AutomaticRequestAutomaticInterval `json:"interval"`

                // IsRetryAccepted Indica se é permitido pelo cliente recebedor fazer tentativas de pagamento (extradia), conforme as regras estabelecidas no arranjo Pix.
                IsRetryAccepted bool `json:"isRetryAccepted"`

                // MaximumVariableAmount Valor máximo permitido por cobrança, caso preenchido, representa um consentimento para pagamentos de valores variáveis.
                //
                // [Restrição] Excludente com o campo “/data/recurringConfiguration/automatic/fixedAmount”
                MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`

                // MinimumVariableAmount Valor definido pelo usuário recebedor.
                // Se o usuário pagador atribuir um valor máximo para os pagamentos daquela autorização (campo “maximumVariableAmount”), ele não poderá ser inferior ao piso definido pelo usuário recebedor.
                // Não pode ser preenchido nas autorizações de valor fixo, ou seja, com campo “/data/recurringConfiguration/automatic/fixedAmount”.
                // Não representa um valor mínimo de cobrança para o pagamento.
                MinimumVariableAmount *string `json:"minimumVariableAmount,omitempty"`

                // ReferenceStartDate Representa a data prevista para a primeira ocorrência de um pagamento associado a recorrência.
                // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                ReferenceStartDate timeutil.BrazilDate `json:"referenceStartDate"`
        } `json:"automatic"`
}

// AutomaticRequestAutomaticInterval Define a periodicidade permitida para realização de transações
// - SEMANAL
// - MENSAL
// - ANUAL
// - SEMESTRAL
// - TRIMESTRAL
type AutomaticRequestAutomaticInterval string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
//
// [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
        Document struct {
                // Identification Número do documento de identificação oficial do titular pessoa jurídica.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
                Rel string `json:"rel"`
        } `json:"document"`
}

// ConsentEdition defines model for ConsentEdition.
type ConsentEdition = autopayment.ConsentEdition

// ConsentRejection defines model for ConsentRejection.
type ConsentRejection struct {
        // Rejection Objeto contendo as informações de rejeição dos consentimentos.
        Rejection struct {
                // Reason Informações sobre o motivo da rejeição
                Reason ConsentRejectionReason `json:"reason"`

                // RejectedBy Ator responsável pela solicitação rejeição
                RejectedBy ConsentRejectionRejectionRejectedBy `json:"rejectedBy"`

                // RejectedFrom Canal onde iniciou-se o processo de rejeição
                // - INICIADORA
                // - DETENTORA
                RejectedFrom ConsentRejectionRejectionRejectedFrom `json:"rejectedFrom"`
        } `json:"rejection"`

        // Status Estado atual do consentimento de longa duração
        Status *ConsentRejectionStatus `json:"status,omitempty"`
}

// ConsentRejectionRejectionRejectedBy Ator responsável pela solicitação rejeição
type ConsentRejectionRejectionRejectedBy string

// ConsentRejectionRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ConsentRejectionRejectionRejectedFrom string

// ConsentRejectionStatus Estado atual do consentimento de longa duração
type ConsentRejectionStatus string

// ConsentRejectionReason Informações sobre o motivo da rejeição
type ConsentRejectionReason struct {
        // Code Código indicador do motivo de rejeição.
        // - NAO_INFORMADO
        // - FALHA_INFRAESTRUTURA
        // - TEMPO_EXPIRADO_AUTORIZACAO
        // - REJEITADO_USUARIO
        // - CONTAS_ORIGEM_DESTINO_IGUAIS
        // - CONTA_NAO_PERMITE_PAGAMENTO
        // - SALDO_INSUFICIENTE
        // - VALOR_ACIMA_LIMITE
        // - AUTENTICACAO_DIVERGENTE
        Code ConsentRejectionReasonCode `json:"code"`

        // Detail Detalhe sobre o motivo de rejeição indicado no campo `/data/rejection/reason/code`
        // - NAO_INFORMADO: Não informada pela detentora de conta;
        // - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento];
        // - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo;
        // - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento;
        // - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento;
        // - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento;
        // - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
        // - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido para permitir a realização de transações pelo cliente;
        // - AUTENTICACAO_DIVERGENTE : Usuário autenticado no detentor diverge do usuário autenticado no iniciador;
        Detail string `json:"detail"`
}

// ConsentRejectionReasonCode Código indicador do motivo de rejeição.
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - AUTENTICACAO_DIVERGENTE
type ConsentRejectionReasonCode string

// ConsentRevocation defines model for ConsentRevocation.
type ConsentRevocation struct {
        // Revocation Objeto contendo as informações de revogação dos consentimentos de longa duração.
        Revocation struct {
                // Reason Informações sobre o motivo da revogação
                Reason ConsentRevokedReason `json:"reason"`

                // RevokedBy Quem iniciou a solicitação de revogação
                // - INICIADORA
                // - USUARIO
                // - DETENTORA
                RevokedBy ConsentRevocationRevocationRevokedBy `json:"revokedBy"`

                // RevokedFrom Canal onde iniciou-se o processo de revogação
                // - INICIADORA
                // - DETENTORA
                RevokedFrom ConsentRevocationRevocationRevokedFrom `json:"revokedFrom"`
        } `json:"revocation"`

        // Status Estado atual do consentimento de longa duração
        Status *ConsentRevocationStatus `json:"status,omitempty"`
}

// ConsentRevocationRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ConsentRevocationRevocationRevokedBy string

// ConsentRevocationRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ConsentRevocationRevocationRevokedFrom string

// ConsentRevocationStatus Estado atual do consentimento de longa duração
type ConsentRevocationStatus string

// ConsentRevokedReason Informações sobre o motivo da revogação
type ConsentRevokedReason struct {
        // Code Código indicador do motivo de revogação.
        // - REVOGADO_RECEBEDOR
        // - REVOGADO_USUARIO
        // - NAO_INFORMADO
        Code ConsentRevokedReasonCode `json:"code"`

        // Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
        // - NAO_INFORMADO: Não informada pela detentora de conta;
        // - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
        // - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
        Detail string `json:"detail"`
}

// ConsentRevokedReasonCode Código indicador do motivo de revogação.
// - REVOGADO_RECEBEDOR
// - REVOGADO_USUARIO
// - NAO_INFORMADO
type ConsentRevokedReasonCode string

// ContractDebtor Informações sobre o cliente devedor do contrato.
type ContractDebtor struct {
        Document struct {
                // Identification Número do documento de identificação oficial do cliente devedor do contrato.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do cliente devedor do contrato.
                Rel ContractDebtorDocumentRel `json:"rel"`
        } `json:"document"`

        // Name Em caso de pessoa natural deve ser informado o nome completo do titular devedor do contrato.
        Name string `json:"name"`
}

// ContractDebtorDocumentRel Tipo do documento de identificação oficial do cliente devedor do contrato.
type ContractDebtorDocumentRel string

// CreateRecurringConsent defines model for CreateRecurringConsent.
type CreateRecurringConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
        Data struct {
                // AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
                AdditionalInformation *string `json:"additionalInformation,omitempty"`

                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
                //
                // [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
                Creditors      Creditors       `json:"creditors"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
                // - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
                // - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
                DebtorAccount *struct {
                        // AccountType Tipos de contas usadas para pagamento.
                        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                        // Segue descrição de cada valor do ENUM.
                        //
                        // - CACC - Current - Conta Corrente.
                        // - SVGS - Savings - Conta de Poupança.
                        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                        AccountType EnumAccountTypeConsents `json:"accountType"`

                        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                        Ispb string `json:"ispb"`

                        // Issuer Código da Agência emissora da conta sem dígito.
                        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                        //
                        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                        Issuer *string `json:"issuer,omitempty"`

                        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
                        // se houver valor alfanumérico, este deve ser convertido para 0.
                        Number string `json:"number"`
                } `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
                RecurringConfiguration autopayment.Configuration `json:"recurringConfiguration"`
        } `json:"data"`
}

// CreateRecurringPixPayment defines model for CreateRecurringPixPayment.
type CreateRecurringPixPayment struct {
        // Data Objeto contendo dados do pagamento e do recebedor (creditor).
        Data CreateRecurringPixPaymentData `json:"data"`
}

// CreateRecurringPixPaymentData Objeto contendo dados do pagamento e do recebedor (creditor).
type CreateRecurringPixPaymentData struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *CreateRecurringPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        //
        // [Restrição] - Se /data/paymentReference = "zero", as informações da conta de crédito enviadas (/data/creditorAccount) devem ser iguais as presentes na conta de crédito informada na criação do consentimento(`/data/recurringConfiguration/automatic/firstPayment/creditorAccount`)
        CreditorAccount struct {
                // AccountType Tipos de contas usadas para pagamento via Pix.
                // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                // Segue descrição de cada valor do ENUM para o escopo do Pix.
                //
                // - CACC - Current - Conta Corrente.
                // - SVGS - Savings - Conta de Poupança.
                // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                AccountType EnumAccountTypePayments `json:"accountType"`

                // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                Ispb string `json:"ispb"`

                // Issuer Código da Agência emissora da conta sem dígito.
                // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                //
                // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                Issuer *string `json:"issuer,omitempty"`

                // Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
                // se houver valor alfanumérico, este deve ser convertido para 0.
                Number string `json:"number"`
        } `json:"creditorAccount"`

        // Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
        Date timeutil.BrazilDate `json:"date"`

        // Document Informações do documento identificador do recebedor da transação.
        Document struct {
                // Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
                // O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
                // Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
                Rel CreateRecurringPixPaymentDataDocumentRel `json:"rel"`
        } `json:"document"`

        // EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
        //
        // - "E" - fixo (1 caractere);
        // - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
        // - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
        // - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
        //
        // Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
        //
        // Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
        EndToEndID EndToEndIDPost `json:"endToEndId"`

        // IbgeTownCode O campo ibgeTownCode no arranjo Pix tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do Pix.
        //
        // Caso a informação referente ao município não seja enviada, o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

        // LocalInstrument Especifica a forma de iniciação do pagamento
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
        //
        // [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
        LocalInstrument CreateRecurringPixPaymentDataLocalInstrument `json:"localInstrument"`

        // OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
        // Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
        // O recurringPaymentId deve ser diferente do endToEndId.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        //
        // [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
        OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

        // Payment Objeto contendo as informações do pagamento.
        Payment PaymentPix `json:"payment"`

        // PaymentReference [Restrição]
        // Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
        //
        // - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
        // - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
        // - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
        // - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
        //   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
        //   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
        //   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
        //   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
        // - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
        //   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
        //   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
        // - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
        //   - Exemplo de Formatos:
        //     - Primeiro pagamento: "zero"
        //     - Semanal: "W50-2024"
        //     - Mensal: "M09-2024"
        //     - Trimestral: "Q3-2024"
        //     - Semestral: "S2-2024"
        //     - Anual: "Y2024"
        PaymentReference *string `json:"paymentReference,omitempty"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
        //
        // [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
        //
        // [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
        //
        // [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
        Proxy *string `json:"proxy,omitempty"`

        // RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        //
        // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
        RecurringConsentID *string `json:"recurringConsentId,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // RiskSignals Sinais de risco para iniciação de pagamentos automáticos
        //
        // [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
        RiskSignals *RiskSignalsPayments `json:"riskSignals,omitempty"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        // Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
        // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
        //
        // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
        // - MANU - O campo transactionIdentification não deve ser preenchido;
        // - DICT - O campo transactionIdentification não deve ser preenchido;
        // - INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// CreateRecurringPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreateRecurringPixPaymentDataAuthorisationFlow string

// CreateRecurringPixPaymentDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type CreateRecurringPixPaymentDataDocumentRel string

// CreateRecurringPixPaymentDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type CreateRecurringPixPaymentDataLocalInstrument string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
// [Restrição]
// Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
type CreditorAccount struct {
        // AccountType Tipos de contas usadas para pagamento via Pix.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM para o escopo do Pix.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountTypePayments `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
        // do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// CreditorAccountConsent Recebe os dados de conta do usuário recebedor.
type CreditorAccountConsent struct {
        // AccountType Tipos de contas usadas para pagamento.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountTypeConsents `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// CreditorAccountPostPixPaymentsResponse Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccountPostPixPaymentsResponse struct {
        // AccountType Tipos de contas usadas para pagamento via Pix.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM para o escopo do Pix.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountTypePayments `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros)
        // do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário recebedor, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// Creditors defines model for Creditors.
type Creditors = []struct {
        // CpfCnpj Identificação da pessoa envolvida na transação.
        // Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
        // O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
        // O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
        CpfCnpj string `json:"cpfCnpj"`

        // Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
        // Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
        Name string `json:"name"`

        // PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
        PersonType EnumPaymentPersonType `json:"personType"`
}

// Day Configurar limite transacional diário determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
type Day struct {
        // QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um dia.
        QuantityLimit *int `json:"quantityLimit,omitempty"`

        // TransactionLimit Valor máximo a ser transacionado diariamente.
        TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
        // AccountType Tipos de contas usadas para pagamento.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountTypeConsents `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
//
// No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
type EndToEndID = string

// EndToEndIDPost Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; "case sensitive", isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// - "E" - fixo (1 caractere);
// - xxxxxxxx - identificação do agente que gerou o EndToEndId, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
// - yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o EndToEndId, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
// - kkkkkkkkkkk – sequência criada pelo agente que gerou o EndToEndId (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”;
//
// Admite-se que o EndToEndId seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
type EndToEndIDPost = string

// EnumAccountTypeConsents Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypeConsents string

// EnumAccountTypePayments Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountTypePayments string

// EnumAuthorisationStatusType Status atual do consentimento recorrente de acordo com a máquina de estados
// - AWAITING_AUTHORISATION - Aguardando autorização
// - PARTIALLY_ACCEPTED - Parcialmente aceito
// - AUTHORISED - Autorizado
// - REJECTED - Rejeitado
// - REVOKED - Revogado
// - CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Estado para qual o pagamento deverá transitar
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual do pagamento. O estado evolui na seguinte ordem:
// - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
// - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
// - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
// - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
// - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
// - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
// - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
// - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
// Em caso insucesso:
// - RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonCode Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
// - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
// - CONSENTIMENTO_REVOGADO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCode string

// EnumRejectionReasonCodeGet Código identificador do motivo de rejeição.
// Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
// - PAGAMENTO_RECUSADO_DETENTORA
// - PAGAMENTO_RECUSADO_SPI
// - CONSENTIMENTO_INVALIDO
// - FALHA_INFRAESTRUTURA_SPI
// - FALHA_INFRAESTRUTURA_ICP
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
// - FALHA_INFRAESTRUTURA_DETENTORA
// - LIMITE_PERIODO_VALOR_EXCEDIDO
// - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
// - TITULARIDADE_INCONSISTENTE
// - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
// - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
// - CONSENTIMENTO_REVOGADO
// - LIMITE_TENTATIVAS_EXCEDIDO
// - FORA_PRAZO_PERMITIDO
// - DETALHE_TENTATIVA_INVALIDO
// - DETALHE_PAGAMENTO_INVALIDO
//
// [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
type EnumRejectionReasonCodeGet string

// FirstPayment Definições para o primeiro pagamento. É considerado como o pagamento da adesão ao serviço pelo usuário pagador.
//
// [Restrição] Para casos em que conta recebedora e conta pagadora pertencem ao mesmo detentor (/data/debtorAccount/ispb = /data/recurringConfiguration/automatic/firstPayment/creditorAccount/ispb), o detentor deve garantir que a conta de crédito informada pertence ao titular do CNPJ enviado no campo “/data/creditors/cpfCnpj”.
type FirstPayment struct {
        // Amount Valor da transação com 2 casas decimais.
        Amount string `json:"amount"`

        // CreditorAccount Recebe os dados de conta do usuário recebedor.
        CreditorAccount CreditorAccountConsent `json:"creditorAccount"`

        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
        Currency string `json:"currency"`

        // Date Define a data alvo da liquidação do pagamento.
        // O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
        Date timeutil.BrazilDate `json:"date"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
        Type EnumPaymentType `json:"type"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
        Document struct {
                // Identification Número do documento de identificação oficial do usuário.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do usuário.
                Rel string `json:"rel"`
        } `json:"document"`
}

// Month Configurar limite transacional mensal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Month struct {
        // QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um mês.
        QuantityLimit *int `json:"quantityLimit,omitempty"`

        // TransactionLimit Valor máximo a ser transacionado mensalmente.
        TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
        Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
        // Cancellation Informações gerais sobre o cancelamento.
        Cancellation struct {
                // CancelledBy Informações gerais sobre o usuário que solicitou o cancelamento.
                CancelledBy struct {
                        // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                        Document struct {
                                // Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica
                                Identification string `json:"identification"`

                                // Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
                                Rel PatchPixPaymentDataCancellationCancelledByDocumentRel `json:"rel"`
                        } `json:"document"`
                } `json:"cancelledBy"`
        } `json:"cancellation"`

        // Status Estado para qual o pagamento deverá transitar
        Status EnumPaymentCancellationStatusType `json:"status"`
}

// PatchPixPaymentDataCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PatchPixPaymentDataCancellationCancelledByDocumentRel string

// PatchRecurringConsent defines model for PatchRecurringConsent.
type PatchRecurringConsent struct {
        // Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
        Data PatchRecurringConsent_Data `json:"data"`
}

// PatchRecurringConsent_Data Objeto contendo as informações de rejeição, revogação e edição dos consentimentos
type PatchRecurringConsent_Data struct {
        union json.RawMessage
}

// PaymentPix Objeto contendo as informações do pagamento.
type PaymentPix struct {
        // Amount Valor da transação com 2 casas decimais.
        Amount string `json:"amount"`

        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'. Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
        Currency string `json:"currency"`
}

// PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
type PeriodicLimits struct {
        // Day Configurar limite transacional diário determinado pelo usuário pagador.
        //
        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
        Day *Day `json:"day,omitempty"`

        // Month Configurar limite transacional mensal determinado pelo usuário pagador.
        //
        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
        Month *Month `json:"month,omitempty"`

        // Week Configurar limite transacional semanal determinado pelo usuário pagador.
        //
        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
        Week *Week `json:"week,omitempty"`

        // Year Configurar limite transacional anual determinado pelo usuário pagador.
        //
        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
        Year *Year `json:"year,omitempty"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
        // CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), formato UTC.
        CancelledAt timeutil.DateTime `json:"cancelledAt"`

        // CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
        CancelledBy struct {
                // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                Document struct {
                        // Identification Número do documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
                        Identification string `json:"identification"`

                        // Rel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
                        Rel PixPaymentCancellationCancelledByDocumentRel `json:"rel"`
                } `json:"document"`
        } `json:"cancelledBy"`

        // CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
        //
        // Valores possíveis:
        //
        // INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
        //
        // DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
        CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

        // Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
        //
        // Valores possíveis:
        //
        // CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
        //
        // CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
        Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PixPaymentCancellationCancelledByDocumentRel Tipo de documento de identificação oficial do pagador ou recebedor, pessoa natural ou jurídica.
type PixPaymentCancellationCancelledByDocumentRel string

// RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
type RecurringConfiguration = autopayment.Configuration

// Rejection Objeto contendo as informações de rejeição dos consentimentos.
//
// [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
type Rejection struct {
        // Reason Informações sobre o motivo da rejeição
        Reason *ConsentRejectionReason `json:"reason,omitempty"`

        // RejectedAt Data e hora em que o consentimento foi rejeitado
        RejectedAt timeutil.DateTime `json:"rejectedAt"`

        // RejectedBy Quem iniciou a solicitação de rejeição
        // - INICIADORA
        // - USUARIO
        // - DETENTORA
        RejectedBy RejectionRejectedBy `json:"rejectedBy"`

        // RejectedFrom Canal onde iniciou-se o processo de rejeição
        // - INICIADORA
        // - DETENTORA
        RejectedFrom RejectionRejectedFrom `json:"rejectedFrom"`
}

// RejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type RejectionRejectedBy string

// RejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type RejectionRejectedFrom string

// RejectionReason Objeto contendo o motivo de rejeição assíncrono
type RejectionReason struct {
        // Code Código identificador do motivo de rejeição.
        // Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
        // - SALDO_INSUFICIENTE
        // - VALOR_ACIMA_LIMITE
        // - VALOR_INVALIDO
        // - NAO_INFORMADO
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
        // - PAGAMENTO_RECUSADO_DETENTORA
        // - PAGAMENTO_RECUSADO_SPI
        // - CONSENTIMENTO_INVALIDO
        // - FALHA_INFRAESTRUTURA_SPI
        // - FALHA_INFRAESTRUTURA_ICP
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
        // - FALHA_INFRAESTRUTURA_DETENTORA
        // - TITULARIDADE_INCONSISTENTE
        // - LIMITE_PERIODO_VALOR_EXCEDIDO
        // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
        // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
        // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
        // - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
        // - CONSENTIMENTO_REVOGADO
        // - FORA_PRAZO_PERMITIDO
        // - DETALHE_TENTATIVA_INVALIDO
        // - DETALHE_PAGAMENTO_INVALIDO
        //
        // [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
        Code EnumRejectionReasonCode `json:"code"`

        // Detail Detalhe sobre o código identificador do motivo de rejeição.
        //
        // - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
        // - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
        // - VALOR_INVALIDO: O valor enviado não é válido;
        // - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
        // - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
        // - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
        // - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
        // - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
        // - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
        // - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
        // - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração
        // - LIMITE_PERIODO_VALOR_EXCEDIDO: A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
        // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO: A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
        // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
        // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
        // - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido.
        // - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
        // - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
        // - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
        // - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio.
        Detail string `json:"detail"`
}

// RejectionReasonGet Objeto contendo o motivo de rejeição assíncrono
type RejectionReasonGet struct {
        // Code Código identificador do motivo de rejeição.
        // Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status.
        // - SALDO_INSUFICIENTE
        // - VALOR_ACIMA_LIMITE
        // - VALOR_INVALIDO
        // - NAO_INFORMADO
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
        // - PAGAMENTO_RECUSADO_DETENTORA
        // - PAGAMENTO_RECUSADO_SPI
        // - CONSENTIMENTO_INVALIDO
        // - FALHA_INFRAESTRUTURA_SPI
        // - FALHA_INFRAESTRUTURA_ICP
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR
        // - FALHA_INFRAESTRUTURA_DETENTORA
        // - LIMITE_PERIODO_VALOR_EXCEDIDO
        // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO
        // - TITULARIDADE_INCONSISTENTE
        // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO
        // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação
        // - CONSENTIMENTO_REVOGADO
        // - LIMITE_TENTATIVAS_EXCEDIDO
        // - FORA_PRAZO_PERMITIDO
        // - DETALHE_TENTATIVA_INVALIDO
        // - DETALHE_PAGAMENTO_INVALIDO
        //
        // [Restrição] Esse motivo deverá ser enviado quando o campo `/data/status` for igual a RJCT (REJECTED).
        Code EnumRejectionReasonCodeGet `json:"code"`

        // Detail Detalhe sobre o código identificador do motivo de rejeição.
        //
        // - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento;
        // - VALOR_ACIMA_LIMITE: Valida se o valor ultrapassa o limite estabelecido [na instituição (conta ou canal)/no arranjo] para permitir a realização de transações pelo cliente;
        // - VALOR_INVALIDO: O valor enviado não é válido;
        // - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta;
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento;
        // - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa];
        // - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002];
        // - CONSENTIMENTO_INVALIDO: Consentimento inválido (em status final);
        // - FALHA_INFRAESTRUTURA_SPI: Indica uma falha no Sistema de Pagamentos Instantâneos (SPI);
        // - FALHA_INFRAESTRUTURA_ICP: Indica uma falha na Infraestrutura de Chaves Públicas (ICP);
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR: Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento;
        // - FALHA_INFRAESTRUTURA_DETENTORA: indica uma falha na infraestrutura da instituição detentora das informações ou recursos;
        // - LIMITE_PERIODO_VALOR_EXCEDIDO – A transação não pode ser realizada pois o valor parametrizado no consentimento foi excedido.
        // - LIMITE_PERIODO_QUANTIDADE_EXCEDIDO – A transação não pode ser realizada pois a quantidade parametrizada no consentimento foi excedida.
        // - TITULARIDADE_INCONSISTENTE: Conta atualmente não associada ao CPF/CNPJ do consentimento de longa duração.
        // - LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO: O valor da transação excede o limite global do consentimento.
        // - LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO: O valor da transação ultrapassar o limite de valor por transação.
        // - CONSENTIMENTO_REVOGADO: O pagamento estava associado a um consentimento que foi revogado.
        // - LIMITE_TENTATIVAS_EXCEDIDO: O máximo de tentativas de liquidação permitidas pelo arranjo foi atingido
        // - FORA_PRAZO_PERMITIDO: O horário ou período da requisição não permite o agendamento pelo detentor.
        // - DETALHE_TENTATIVA_INVALIDO: O parâmetro [nome_do(s)_campo(s)] inseridos para a nova tentativa de pagamento não condizem com o pagamento original que falhou e não são permitidos na nova tentativa de pagamento.
        // - DETALHE_PAGAMENTO_INVALIDO: Valida se determinado parâmetro informado obedece as regras de negócio
        Detail string `json:"detail"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`

        // Meta Meta informações referente à API requisitada.
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsent defines model for ResponseErrorCreateConsent.
type ResponseErrorCreateConsent struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
                // - DATA_PAGAMENTO_INVALIDA
                // - DETALHE_PAGAMENTO_INVALIDO
                // - PARAMETRO_NAO_INFORMADO
                // - PARAMETRO_INVALIDO
                // - ERRO_IDEMPOTENCIA
                // - NAO_INFORMADO
                // - FUNCIONALIDADE_NAO_HABILITADA
                Code ResponseErrorCreateConsentErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
                // - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                // - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
                // - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - NAO_INFORMADO: Não informado.
                // - FUNCIONALIDADE_NAO_HABILITADA: A detentora de conta não oferece o serviço nessa modalidade.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// - DATA_PAGAMENTO_INVALIDA
// - DETALHE_PAGAMENTO_INVALIDO
// - PARAMETRO_NAO_INFORMADO
// - PARAMETRO_INVALIDO
// - ERRO_IDEMPOTENCIA
// - NAO_INFORMADO
// - FUNCIONALIDADE_NAO_HABILITADA
type ResponseErrorCreateConsentErrorsCode string

// ResponsePostRecurringConsent defines model for ResponsePostRecurringConsent.
type ResponsePostRecurringConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
        Data struct {
                // AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
                AdditionalInformation *string `json:"additionalInformation,omitempty"`

                // AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
                //
                // [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
                AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
                //
                // [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                Creditors        Creditors         `json:"creditors"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
                // - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
                // - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
                //
                // [Restrições]
                // - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
                DebtorAccount *struct {
                        // AccountType Tipos de contas usadas para pagamento.
                        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                        // Segue descrição de cada valor do ENUM.
                        //
                        // - CACC - Current - Conta Corrente.
                        // - SVGS - Savings - Conta de Poupança.
                        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                        AccountType EnumAccountTypeConsents `json:"accountType"`

                        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                        Ispb string `json:"ispb"`

                        // Issuer Código da Agência emissora da conta sem dígito.
                        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                        //
                        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                        Issuer *string `json:"issuer,omitempty"`

                        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
                        Number string `json:"number"`
                } `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
                RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

                // RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
                RecurringConsentID string `json:"recurringConsentId"`

                // Rejection Objeto contendo as informações de rejeição dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
                Rejection *Rejection `json:"rejection,omitempty"`

                // Revocation Objeto contendo as informações de revogação dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
                Revocation *struct {
                        // Reason Informações sobre o motivo da revogação
                        Reason *struct {
                                // Code Código indicador do motivo da revogação
                                Code ResponsePostRecurringConsentDataRevocationReasonCode `json:"code"`

                                // Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
                                // - NAO_INFORMADO: Não informada pela detentora de conta;
                                // - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
                                // - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
                                Detail string `json:"detail"`
                        } `json:"reason,omitempty"`

                        // RevokedAt Data e hora em que o consentimento foi revogado
                        RevokedAt timeutil.DateTime `json:"revokedAt"`

                        // RevokedBy Quem iniciou a solicitação de revogação
                        // - INICIADORA
                        // - USUARIO
                        // - DETENTORA
                        RevokedBy ResponsePostRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

                        // RevokedFrom Canal onde iniciou-se o processo de revogação
                        // - INICIADORA
                        // - DETENTORA
                        RevokedFrom ResponsePostRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
                } `json:"revocation,omitempty"`

                // Status Status atual do consentimento recorrente de acordo com a máquina de estados
                // - AWAITING_AUTHORISATION - Aguardando autorização
                // - PARTIALLY_ACCEPTED - Parcialmente aceito
                // - AUTHORISED - Autorizado
                // - REJECTED - Rejeitado
                // - REVOKED - Revogado
                // - CONSUMED - Consumido
                Status EnumAuthorisationStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

                // UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
                // O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
                // Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
                // A edição só é permitida para o produto Pix automático.
                UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponsePostRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponsePostRecurringConsentDataRevocationReasonCode string

// ResponsePostRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedBy string

// ResponsePostRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponsePostRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsent defines model for ResponseRecurringConsent.
type ResponseRecurringConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
        Data struct {
                // AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
                AdditionalInformation *string `json:"additionalInformation,omitempty"`

                // ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
                //
                // [Restrição]
                // Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
                ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

                // AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
                //
                // [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
                AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
                //
                // [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                Creditors        Creditors         `json:"creditors"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
                // - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
                // - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
                //
                // [Restrições]
                // - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
                DebtorAccount *struct {
                        // AccountType Tipos de contas usadas para pagamento.
                        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                        // Segue descrição de cada valor do ENUM.
                        //
                        // - CACC - Current - Conta Corrente.
                        // - SVGS - Savings - Conta de Poupança.
                        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                        AccountType EnumAccountTypeConsents `json:"accountType"`

                        // IbgeTownCode Campo utilizado pela iniciadora para cálculo do dia útil de liquidação do pagamento (vide especificação do endToEndId) baseado no município de cadastro do usuário pagador no detentor.
                        //
                        // [Restrições]
                        // Campo de preenchimento obrigatório quando o oneOf utilizado do recurringConfiguration for “automatic”, e o consentimento passar pelo estado AUTHORISED.
                        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

                        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                        Ispb string `json:"ispb"`

                        // Issuer Código da Agência emissora da conta sem dígito.
                        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                        //
                        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                        Issuer *string `json:"issuer,omitempty"`

                        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir), se houver valor alfanumérico, este deve ser convertido para 0.
                        Number string `json:"number"`
                } `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
                RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

                // RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
                RecurringConsentID string `json:"recurringConsentId"`

                // Rejection Objeto contendo as informações de rejeição dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
                Rejection *Rejection `json:"rejection,omitempty"`

                // Revocation Objeto contendo as informações de revogação dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
                Revocation *struct {
                        // Reason Informações sobre o motivo da revogação
                        Reason *struct {
                                // Code Código indicador do motivo da revogação
                                Code ResponseRecurringConsentDataRevocationReasonCode `json:"code"`

                                // Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
                                // - NAO_INFORMADO: Não informada pela detentora de conta;
                                // - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
                                // - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
                                Detail string `json:"detail"`
                        } `json:"reason,omitempty"`

                        // RevokedAt Data e hora em que o consentimento foi revogado
                        RevokedAt timeutil.DateTime `json:"revokedAt"`

                        // RevokedBy Quem iniciou a solicitação de revogação
                        // - INICIADORA
                        // - USUARIO
                        // - DETENTORA
                        RevokedBy ResponseRecurringConsentDataRevocationRevokedBy `json:"revokedBy"`

                        // RevokedFrom Canal onde iniciou-se o processo de revogação
                        // - INICIADORA
                        // - DETENTORA
                        RevokedFrom ResponseRecurringConsentDataRevocationRevokedFrom `json:"revokedFrom"`
                } `json:"revocation,omitempty"`

                // RiskSignals Sinais de risco para iniciação de pagamentos automáticos
                //
                // [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
                RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

                // Status Status atual do consentimento recorrente de acordo com a máquina de estados
                // - AWAITING_AUTHORISATION - Aguardando autorização
                // - PARTIALLY_ACCEPTED - Parcialmente aceito
                // - AUTHORISED - Autorizado
                // - REJECTED - Rejeitado
                // - REVOKED - Revogado
                // - CONSUMED - Consumido
                Status EnumAuthorisationStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

                // UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
                // O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
                // Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
                // A edição só é permitida para o produto Pix automático.
                UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentDataRevocationReasonCode string

// ResponseRecurringConsentDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedBy string

// ResponseRecurringConsentDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentDataRevocationRevokedFrom string

// ResponseRecurringConsentPatch defines model for ResponseRecurringConsentPatch.
type ResponseRecurringConsentPatch struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento individual.
        Data struct {
                // AdditionalInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional no consentimento
                AdditionalInformation *string `json:"additionalInformation,omitempty"`

                // ApprovalDueDate Representa a data máxima para aprovação de um consentimento que encontra-se (ou passou) pelo estado PARTIALLY_ACCEPTED. A aprovação deve ocorrer até as 23:59h do dia informado, caso contrário, consentimento deve ser rejeitado.
                //
                // [Restrição]
                // Deve ser preenchido pela instituição detentora sempre que um consentimento estiver (ou passado) no estado PARTIALLY_ACCEPTED
                ApprovalDueDate *timeutil.BrazilDate `json:"approvalDueDate,omitempty"`

                // AuthorisedAtDateTime Data e hora em que o consentimento foi autorizado.
                //
                // [Restrição] Campo de envio obrigatório quando consentimento transitar para AUTHORISED.
                AuthorisedAtDateTime *timeutil.DateTime `json:"authorisedAtDateTime,omitempty"`

                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento.
                //
                // [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`
                Creditors        Creditors         `json:"creditors"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // - Caso a ITP tenha coletado as informações de conta do usuário pagador, essas poderão ser enviadas no consentimento para a detentora neste objeto, ou;
                // - Se não coletado pelo ITP, o usuário pagador precisará definir durante a autorização do consentimento.
                // - Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.
                //
                // [Restrições]
                // - Objeto obrigatório que deverá ser retornado quando o consentimento estiver ou passar pelo status AUTHORISED;
                DebtorAccount *struct {
                        // AccountType Tipos de contas usadas para pagamento.
                        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                        // Segue descrição de cada valor do ENUM.
                        //
                        // - CACC - Current - Conta Corrente.
                        // - SVGS - Savings - Conta de Poupança.
                        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                        AccountType EnumAccountTypeConsents `json:"accountType"`

                        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                        Ispb string `json:"ispb"`

                        // Issuer Código da Agência emissora da conta sem dígito.
                        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                        //
                        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                        Issuer *string `json:"issuer,omitempty"`

                        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
                        // se houver valor alfanumérico, este deve ser convertido para 0.
                        Number string `json:"number"`
                } `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento deve deixar de ser válido. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] Caso o consentimento seja para Pix Automático ("automatic" selecionado no oneOf "/data/recurringConfiguration/") o horário de expiração do consentimento precisa ser às 23:59:59 (UTC).
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser *LoggedUser `json:"loggedUser,omitempty"`

                // RecurringConfiguration Campo destinado a configuração dos diferentes produtos de pagamentos recorrentes.
                RecurringConfiguration RecurringConfiguration `json:"recurringConfiguration"`

                // RecurringConsentID Identificador único do consentimento de longa duração criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name. Um URN, conforme definido na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141) é um Uniform Resource Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123). Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://datatracker.ietf.org/doc/html/rfc8141).
                RecurringConsentID string `json:"recurringConsentId"`

                // Rejection Objeto contendo as informações de rejeição dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REJECTED".
                Rejection *struct {
                        // Reason Informações sobre o motivo da rejeição
                        Reason *ConsentRejectionReason `json:"reason,omitempty"`

                        // RejectedAt Data e hora em que o consentimento foi rejeitado
                        RejectedAt timeutil.DateTime `json:"rejectedAt"`

                        // RejectedBy Quem iniciou a solicitação de rejeição
                        // - INICIADORA
                        // - USUARIO
                        // - DETENTORA
                        RejectedBy ResponseRecurringConsentPatchDataRejectionRejectedBy `json:"rejectedBy"`

                        // RejectedFrom Canal onde iniciou-se o processo de rejeição
                        // - INICIADORA
                        // - DETENTORA
                        RejectedFrom ResponseRecurringConsentPatchDataRejectionRejectedFrom `json:"rejectedFrom"`
                } `json:"rejection,omitempty"`

                // Revocation Objeto contendo as informações de revogação dos consentimentos.
                //
                // [Restrição] Campo de preenchimento obrigatório caso status do consentimento igual a "REVOKED".
                Revocation *struct {
                        // Reason Informações sobre o motivo da revogação
                        Reason *struct {
                                // Code Código indicador do motivo da revogação
                                Code ResponseRecurringConsentPatchDataRevocationReasonCode `json:"code"`

                                // Detail Detalhe sobre o motivo de revogação indicado no campo `/data/revocation/reason/code`.
                                // - NAO_INFORMADO: Não informada pela detentora de conta;
                                // - REVOGADO_USUARIO: O usuário pagador revogou a recorrência do consentimento;
                                // - REVOGADO_RECEBEDOR: O usuário recebedor revogou a recorrência do consentimento.
                                Detail string `json:"detail"`
                        } `json:"reason,omitempty"`

                        // RevokedAt Data e hora em que o consentimento foi revogado
                        RevokedAt timeutil.DateTime `json:"revokedAt"`

                        // RevokedBy Quem iniciou a solicitação de revogação
                        // - INICIADORA
                        // - USUARIO
                        // - DETENTORA
                        RevokedBy ResponseRecurringConsentPatchDataRevocationRevokedBy `json:"revokedBy"`

                        // RevokedFrom Canal onde iniciou-se o processo de revogação
                        // - INICIADORA
                        // - DETENTORA
                        RevokedFrom ResponseRecurringConsentPatchDataRevocationRevokedFrom `json:"revokedFrom"`
                } `json:"revocation,omitempty"`

                // RiskSignals Sinais de risco para iniciação de pagamentos automáticos
                //
                // [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
                RiskSignals *RiskSignalsConsents `json:"riskSignals,omitempty"`

                // Status Status atual do consentimento recorrente de acordo com a máquina de estados
                // - AWAITING_AUTHORISATION - Aguardando autorização
                // - PARTIALLY_ACCEPTED - Parcialmente aceito
                // - AUTHORISED - Autorizado
                // - REJECTED - Rejeitado
                // - REVOKED - Revogado
                // - CONSUMED - Consumido
                Status EnumAuthorisationStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora em que o consentimento teve o status atualizado. Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

                // UpdatedAtDateTime Data e hora em que o consentimento foi atualizado pelo usuário pagador.
                // O campo deve ser atualizado pelo detentor sempre que o consentimento for editado.
                // Caso a edição seja realizada a partir do iniciador, o detentor deve preencher com a data e hora (UTC) em que recebeu a solicitação de edição.
                // A edição só é permitida para o produto Pix automático.
                UpdatedAtDateTime *timeutil.DateTime `json:"updatedAtDateTime,omitempty"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseRecurringConsentPatchDataRejectionRejectedBy Quem iniciou a solicitação de rejeição
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedBy string

// ResponseRecurringConsentPatchDataRejectionRejectedFrom Canal onde iniciou-se o processo de rejeição
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRejectionRejectedFrom string

// ResponseRecurringConsentPatchDataRevocationReasonCode Código indicador do motivo da revogação
type ResponseRecurringConsentPatchDataRevocationReasonCode string

// ResponseRecurringConsentPatchDataRevocationRevokedBy Quem iniciou a solicitação de revogação
// - INICIADORA
// - USUARIO
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedBy string

// ResponseRecurringConsentPatchDataRevocationRevokedFrom Canal onde iniciou-se o processo de revogação
// - INICIADORA
// - DETENTORA
type ResponseRecurringConsentPatchDataRevocationRevokedFrom string

// ResponseRecurringPaymentsDataPatch defines model for ResponseRecurringPaymentsDataPatch.
type ResponseRecurringPaymentsDataPatch struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *ResponseRecurringPaymentsDataPatchAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
        //
        // [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
        Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // CreationDateTime Data e hora em que o pagamento foi criado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        // [Restrição]
        // Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
        CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

        // Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
        Date timeutil.BrazilDate `json:"date"`

        // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
        // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
        DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

        // Document Informações do documento identificador do recebedor da transação.
        Document struct {
                // Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
                // O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
                // Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
                Rel ResponseRecurringPaymentsDataPatchDocumentRel `json:"rel"`
        } `json:"document"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
        //
        // No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
        EndToEndID EndToEndID `json:"endToEndId"`

        // LocalInstrument Especifica a forma de iniciação do pagamento
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
        //
        // [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
        LocalInstrument ResponseRecurringPaymentsDataPatchLocalInstrument `json:"localInstrument"`

        // OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
        // Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
        // O recurringPaymentId deve ser diferente do endToEndId.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        //
        // [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
        OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

        // Payment Objeto contendo as informações do pagamento.
        Payment PaymentPix `json:"payment"`

        // PaymentReference [Restrição]
        // Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
        //
        // - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
        // - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
        // - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
        // - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
        //   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
        //   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
        //   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
        //   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
        // - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
        //   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
        //   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
        // - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
        //   - Exemplo de Formatos:
        //     - Primeiro pagamento: "zero"
        //     - Semanal: "W50-2024"
        //     - Mensal: "M09-2024"
        //     - Trimestral: "Q3-2024"
        //     - Semestral: "S2-2024"
        //     - Anual: "Y2024"
        PaymentReference *string `json:"paymentReference,omitempty"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
        // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
        // Esta validação é opcional caso o localInstrument for igual a INIC.
        //
        // [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
        //
        // [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
        Proxy *string `json:"proxy,omitempty"`

        // RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        //
        // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
        RecurringConsentID *string `json:"recurringConsentId,omitempty"`

        // RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        RecurringPaymentID string `json:"recurringPaymentId"`

        // RejectionReason Objeto contendo o motivo de rejeição assíncrono
        RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual do pagamento. O estado evolui na seguinte ordem:
        // - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        // - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        // - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        // - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        // - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        // - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        // - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
        // - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        // Em caso insucesso:
        // - RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        // Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
        // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
        //
        // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
        //
        // MANU - O campo transactionIdentification não deve ser preenchido;
        // DICT - O campo transactionIdentification não deve ser preenchido;
        // INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataPatchAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataPatchAuthorisationFlow string

// ResponseRecurringPaymentsDataPatchDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataPatchDocumentRel string

// ResponseRecurringPaymentsDataPatchLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataPatchLocalInstrument string

// ResponseRecurringPaymentsDataRead defines model for ResponseRecurringPaymentsDataRead.
type ResponseRecurringPaymentsDataRead struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *ResponseRecurringPaymentsDataReadAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
        //
        // [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
        Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // CreationDateTime Data e hora em que o pagamento foi criado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        // [Restrição]
        // Caso o pagamento tenha sido criado utilizando versão 2.0.0 ou superior, o retorno desse objeto é obrigatório pela instituição detentora
        CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

        // Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
        Date timeutil.BrazilDate `json:"date"`

        // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
        // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
        DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

        // Document Informações do documento identificador do recebedor da transação.
        Document struct {
                // Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
                // O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
                // Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
                Rel ResponseRecurringPaymentsDataReadDocumentRel `json:"rel"`
        } `json:"document"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
        //
        // No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
        EndToEndID EndToEndID `json:"endToEndId"`

        // LocalInstrument Especifica a forma de iniciação do pagamento
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
        //
        // [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
        LocalInstrument ResponseRecurringPaymentsDataReadLocalInstrument `json:"localInstrument"`

        // OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
        // Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
        // O recurringPaymentId deve ser diferente do endToEndId.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        //
        // [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
        OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

        // Payment Objeto contendo as informações do pagamento.
        Payment PaymentPix `json:"payment"`

        // PaymentReference [Restrição]
        // Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
        //
        // - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
        // - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
        // - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
        // - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
        //   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
        //   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
        //   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
        //   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
        // - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
        //   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
        //   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
        // - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
        //   - Exemplo de Formatos:
        //     - Primeiro pagamento: "zero"
        //     - Semanal: "W50-2024"
        //     - Mensal: "M09-2024"
        //     - Trimestral: "Q3-2024"
        //     - Semestral: "S2-2024"
        //     - Anual: "Y2024"
        PaymentReference *string `json:"paymentReference,omitempty"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
        // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT e validar o campo creditorAccount.
        // Esta validação é opcional caso o localInstrument for igual a INIC.
        //
        // [Restrição] Se localInstrument for igual a DICT, o campo proxy deve ser preenchido.
        //
        // [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
        Proxy *string `json:"proxy,omitempty"`

        // RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        //
        // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
        RecurringConsentID *string `json:"recurringConsentId,omitempty"`

        // RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        RecurringPaymentID string `json:"recurringPaymentId"`

        // RejectionReason Objeto contendo o motivo de rejeição assíncrono
        RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual do pagamento. O estado evolui na seguinte ordem:
        // - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        // - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        // - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        // - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        // - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        // - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        // - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
        // - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        // Em caso insucesso:
        // - RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        // Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
        // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
        //
        // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
        //
        // MANU - O campo transactionIdentification não deve ser preenchido;
        // DICT - O campo transactionIdentification não deve ser preenchido;
        // INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsDataReadAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsDataReadAuthorisationFlow string

// ResponseRecurringPaymentsDataReadDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsDataReadDocumentRel string

// ResponseRecurringPaymentsDataReadLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsDataReadLocalInstrument string

// ResponseRecurringPaymentsIDPatch defines model for ResponseRecurringPaymentsIdPatch.
type ResponseRecurringPaymentsIDPatch struct {
        Data  ResponseRecurringPaymentsDataPatch `json:"data"`
        Links api.Links                          `json:"links"`
        Meta  api.Meta                           `json:"meta"`
}

// ResponseRecurringPaymentsIDPost defines model for ResponseRecurringPaymentsIdPost.
type ResponseRecurringPaymentsIDPost struct {
        Data  ResponseRecurringPaymentsPostData `json:"data"`
        Links api.Links                         `json:"links"`
        Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsIDRead defines model for ResponseRecurringPaymentsIdRead.
type ResponseRecurringPaymentsIDRead struct {
        Data  ResponseRecurringPaymentsDataRead `json:"data"`
        Links api.Links                         `json:"links"`
        Meta  api.Meta                          `json:"meta"`
}

// ResponseRecurringPaymentsPostData defines model for ResponseRecurringPaymentsPostData.
type ResponseRecurringPaymentsPostData struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *ResponseRecurringPaymentsPostDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
        //
        // [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
        Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // CreationDateTime Data e hora em que o pagamento foi criado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        CreditorAccount CreditorAccountPostPixPaymentsResponse `json:"creditorAccount"`

        // Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
        Date timeutil.BrazilDate `json:"date"`

        // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
        // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
        DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

        // Document Informações do documento identificador do recebedor da transação.
        Document struct {
                // Identification Número do documento de identificação oficial do recebedor pessoa natural ou jurídica.
                // O valor informado deve ser igual a um dos valores enviados na etapa de criação do consentimento (dentro do array “/data/creditors”).
                // Quando não respeitada essa regra, deve ser retornado pelo detentor, de maneira síncrona, erro HTTP 422 - PAGAMENTO_DIVERGENTE_CONSENTIMENTO
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
                Rel ResponseRecurringPaymentsPostDataDocumentRel `json:"rel"`
        } `json:"document"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
        //
        // No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
        EndToEndID EndToEndID `json:"endToEndId"`

        // LocalInstrument Especifica a forma de iniciação do pagamento
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
        //
        // [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
        LocalInstrument ResponseRecurringPaymentsPostDataLocalInstrument `json:"localInstrument"`

        // OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
        // Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
        // O recurringPaymentId deve ser diferente do endToEndId.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        //
        // [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
        OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

        // Payment Objeto contendo as informações do pagamento.
        Payment PaymentPix `json:"payment"`

        // PaymentReference [Restrição]
        // Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
        //
        // - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
        // - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
        // - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
        // - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
        //   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
        //   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
        //   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
        //   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
        // - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
        //   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
        //   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
        // - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
        //   - Exemplo de Formatos:
        //     - Primeiro pagamento: "zero"
        //     - Semanal: "W50-2024"
        //     - Mensal: "M09-2024"
        //     - Trimestral: "Q3-2024"
        //     - Semestral: "S2-2024"
        //     - Anual: "Y2024"
        PaymentReference *string `json:"paymentReference,omitempty"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641. Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços. Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na [RFC4122](https://tools.ietf.org/html/rfc4122).
        //
        // [Restrição] Se localInstrument for igual a DICT ou INIC, o campo proxy deve ser preenchido.
        //
        // [Restrição] Se informado, a detentora da conta deve validar o proxy no DICT (quando localInstrument for igual a DICT) e validar o objeto creditorAccount. Ação opcional caso o localInstrument for igual a INIC
        //
        // [Restrição] Caso o campo “/data/localInstrument” seja enviado como “MANU”, o campo “/data/proxy” não deve ser informado
        Proxy *string `json:"proxy,omitempty"`

        // RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        //
        // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
        RecurringConsentID *string `json:"recurringConsentId,omitempty"`

        // RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        RecurringPaymentID string `json:"recurringPaymentId"`

        // RejectionReason Objeto contendo o motivo de rejeição assíncrono
        RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual do pagamento. O estado evolui na seguinte ordem:
        // - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        // - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        // - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        // - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        // - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        // - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        // - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
        // - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        // Em caso insucesso:
        // - RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        // Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
        // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
        //
        // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
        //
        // MANU - O campo transactionIdentification não deve ser preenchido;
        // DICT - O campo transactionIdentification não deve ser preenchido;
        // INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPaymentsPostDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseRecurringPaymentsPostDataAuthorisationFlow string

// ResponseRecurringPaymentsPostDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPaymentsPostDataDocumentRel string

// ResponseRecurringPaymentsPostDataLocalInstrument Especifica a forma de iniciação do pagamento
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido
//
// [Restrição] Caso consentimento associado a tentativa de pagamento seja para Pix automático (objeto “automatic” selecionado no oneOf do campo "/data/recurringConfiguration"), apenas o método MANU é permitido.
type ResponseRecurringPaymentsPostDataLocalInstrument string

// ResponseRecurringPixData defines model for ResponseRecurringPixData.
type ResponseRecurringPixData = []struct {
        // CreationDateTime Data e hora em que o pagamento foi criado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // Date Data em que o pagamento será realizado. Uma string com a utilização de timezone UTC-3 (UTC time format).
        Date timeutil.BrazilDate `json:"date"`

        // Document Informações do documento.
        Document struct {
                // Identification Número do documento de identificação oficial do titular pessoa natural ou jurídica.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
                Rel ResponseRecurringPixDataDocumentRel `json:"rel"`
        } `json:"document"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora.
        //
        // No caso de Pix Automático, a iniciadora deverá, no que tange á composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília, mesmo a janela sendo, para o detentor, até as 21h.
        EndToEndID EndToEndID `json:"endToEndId"`

        // OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
        // Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
        // O recurringPaymentId deve ser diferente do endToEndId.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        //
        // [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
        OriginalRecurringPaymentID *OriginalRecurringPaymentID `json:"originalRecurringPaymentId,omitempty"`

        // Payment Objeto contendo as informações do pagamento.
        Payment PaymentPix `json:"payment"`

        // PaymentReference [Restrição]
        // Campo de preenchimento obrigatório caso seja um pagamento de Pix automático, caso não respeitado, a instituição detentora deve retornar erro HTTP 422 com o código DETALHE_PAGAMENTO_INVALIDO.
        //
        // - Primeiro pagamento: Se for o pagamento inicial especificado em “/data/firstPayment”, preencha o campo com a string fixa “zero”.
        // - Semanal: Preencha com W$numSemana-$ano, onde $numSemana representa o número da semana no ano. Exemplo: "W50-2024".
        // - Mensal: Use M$mês-$ano, onde $mês representa o mês com dois dígitos. Exemplo: "M09-2024".
        // - Trimestral: Utilize Q$trimestre-$ano, onde $trimestre indica o trimestre do ano (1 a 4).
        //   - Janeiro a Março: Q1-$ano (ex.: "Q1-2024").
        //   - Abril a Junho: Q2-$ano (ex.: "Q2-2024").
        //   - Julho a Setembro: Q3-$ano (ex.: "Q3-2024").
        //   - Outubro a Dezembro: Q4-$ano (ex.: "Q4-2024").
        // - Semestral: Utilize $semestre-$ano, onde $semestre indica o semestre do ano (1 para janeiro a junho e 2 para julho a dezembro).
        //   - Janeiro a Junho: S1-$ano (ex.: "S1-2024").
        //   - Julho a Dezembro: S2-$ano (ex.: "S2-2024").
        // - Anual: Use Y$ano, apenas com o ano. Exemplo: "Y2024".
        //   - Exemplo de Formatos:
        //     - Primeiro pagamento: "zero"
        //     - Semanal: "W50-2024"
        //     - Mensal: "M09-2024"
        //     - Trimestral: "Q3-2024"
        //     - Semestral: "S2-2024"
        //     - Anual: "Y2024"
        PaymentReference *string `json:"paymentReference,omitempty"`

        // RecurringConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        //
        // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
        RecurringConsentID *string `json:"recurringConsentId,omitempty"`

        // RecurringPaymentID Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento. O `recurringPaymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        RecurringPaymentID string `json:"recurringPaymentId"`

        // RejectionReason Objeto contendo o motivo de rejeição assíncrono
        RejectionReason *RejectionReasonGet `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual do pagamento. O estado evolui na seguinte ordem:
        // - RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        // - CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        // - ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        // - ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        // - RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        // - ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        // - PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise. Não se aplica para Transferências inteligentes.
        // - SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        // Em caso insucesso:
        // - RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora em que o pagamento teve o status atualizado.
        // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339),
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        // Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
        // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:Letras minúsculas, de 'a' a 'z' Letras maiúsculas, de 'A' a 'z' Dígitos decimais, de '0' a '9'.
        //
        // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo “localInstrument”:
        //
        // MANU - O campo transactionIdentification não deve ser preenchido;
        // DICT - O campo transactionIdentification não deve ser preenchido;
        // INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponseRecurringPixDataDocumentRel Tipo do documento de identificação oficial do titular pessoa natural ou jurídica.
type ResponseRecurringPixDataDocumentRel string

// ResponseRecurringPixPayment defines model for ResponseRecurringPixPayment.
type ResponseRecurringPixPayment struct {
        Data  ResponseRecurringPixData `json:"data"`
        Links api.Links                `json:"links"`
        Meta  api.Meta                 `json:"meta"`
}

// RiskSignalsConsentEdition Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf).
// Só estará presente após a primeira edição do consentimento de longa duração.
// Objeto de envio obrigatório para a edição dos parâmetros do consentimento, exceto para o caso de edição exclusiva do campo “/data/creditors/name”.
type RiskSignalsConsentEdition = map[string]any

// RiskSignalsConsents Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Pix Automático (O objeto "/data/recurringConfiguration/automatic" usado no oneOf). Só estará presente após a primeira edição do consentimento de longa duração.
type RiskSignalsConsents = map[string]any

// RiskSignalsPayments Sinais de risco para iniciação de pagamentos automáticos
//
// [Restrição] Deve ser enviado quando o consentimento for para o produto Sweeping Accounts (O objeto "/data/recurringConfiguration/sweeping" usado no oneOf)
type RiskSignalsPayments = map[string]any

// Sweeping defines model for Sweeping.
type Sweeping struct {
        // Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
        Sweeping struct {
                // PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
                PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

                // StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
                // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                //
                // [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
                StartDateTime timeutil.DateTime `json:"startDateTime"`

                // TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
                TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

                // TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
                TransactionLimit *string `json:"transactionLimit,omitempty"`

                // UseOverdraftLimit Indica se o usuário pagador autorizou a utilização de limite pré-aprovado (cheque especial) na sua conta para realização de pagamentos, caso o cliente possua o produto.
                UseOverdraftLimit bool `json:"useOverdraftLimit"`
        } `json:"sweeping"`
}

// SweepingRequest defines model for SweepingRequest.
type SweepingRequest struct {
        // Sweeping Definição da configuração de recorrência para transferências automáticas de fundos.
        Sweeping struct {
                // PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
                PeriodicLimits *PeriodicLimits `json:"periodicLimits,omitempty"`

                // StartDateTime Description: Data e hora em que o consentimento deve passar a ser válido.
                // Uma string com data e hora conforme especificação [RFC-3339](https://datatracker.ietf.org/doc/html/rfc3339), sempre com a utilização de timezone UTC(UTC time format).
                //
                // [Restrição] Caso esse campo não seja enviado pelo iniciador na requisição, o detentor deve preencher esse campo com o mesmo valor atribuído ao campo /data/creationDateTime.
                StartDateTime *timeutil.DateTime `json:"startDateTime,omitempty"`

                // TotalAllowedAmount Valor máximo a ser atingido pelo somatório de todas as transações que utilizam o consentimento autorizado pelo cliente. Caso o valor seja superado, a detentora de conta deve negar a transação solicitada pela iniciadora.
                TotalAllowedAmount *string `json:"totalAllowedAmount,omitempty"`

                // TransactionLimit Valor máximo para cada transação de pagamento associada a esse consentimento. Caso valor do pagamento seja maior que esse limite, a detentora de contas deve rejeitar a transação de pagamento.
                TransactionLimit *string `json:"transactionLimit,omitempty"`
        } `json:"sweeping"`
}

// Vrp defines model for Vrp.
type Vrp struct {
        // Vrp Definição da configuração de recorrência para realização de transações de valores variáveis
        Vrp struct {
                // GlobalLimits Limite transacional máximo para pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
                GlobalLimits *struct {
                        // QuantityLimit Quantidade máxima de ocorrência  de pagamentos, após atingir este valor, o consentimento deve ir para o status "CONSUMED"
                        QuantityLimit *int `json:"quantityLimit,omitempty"`

                        // TransactionLimit Valor transacional máximo para pagamentos sob este consentimento, após atingir este valor, o consentimento deve ir para o status "CONSUMED".
                        TransactionLimit *string `json:"transactionLimit,omitempty"`
                } `json:"globalLimits,omitempty"`

                // PeriodicLimits Limites transacionais por período determinado pelo usuário pagador.
                PeriodicLimits *struct {
                        // Day Configurar limite transacional diário determinado pelo usuário pagador.
                        //
                        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos.
                        Day *Day `json:"day,omitempty"`

                        // Month Configurar limite transacional mensal determinado pelo usuário pagador.
                        //
                        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
                        Month *Month `json:"month,omitempty"`

                        // Week Configurar limite transacional semanal determinado pelo usuário pagador.
                        //
                        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
                        Week *Week `json:"week,omitempty"`

                        // Year Configurar limite transacional anual determinado pelo usuário pagador.
                        //
                        // [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
                        Year *Year `json:"year,omitempty"`
                } `json:"periodicLimits,omitempty"`

                // TransactionLimit Limite máximo de valor permitido para cada transação de pagamento.
                TransactionLimit *string `json:"transactionLimit,omitempty"`
        } `json:"vrp"`
}

// Week Configurar limite transacional semanal determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Week struct {
        // QuantityLimit Quantidade limite de transações permitidas para ocorrer durante uma semana.
        QuantityLimit *int `json:"quantityLimit,omitempty"`

        // TransactionLimit Valor máximo a ser transacionado semanalmente.
        TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// Year Configurar limite transacional anual determinado pelo usuário pagador.
//
// [Restrição] Caso enviado o objeto, ao menos um dos campos (`quantityLimit` ou `transactionLimit`) devem ser preenchidos
type Year struct {
        // QuantityLimit Quantidade limite de transações permitidas para ocorrer durante um ano.
        QuantityLimit *int `json:"quantityLimit,omitempty"`

        // TransactionLimit Valor máximo a ser transacionado por um ano, a partir da data definida no campo `/data/startDateTime`.
        TransactionLimit *string `json:"transactionLimit,omitempty"`
}

// OriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
// A tentativa de pagamento original é a primeira tentativa (Intradia – Primeira Tentativa, vide documentação) realizada para o pagamento de uma determinada recorrência.
// Código ou identificador único informado pela instituição detentora da conta para representar a iniciação de pagamento.
// O recurringPaymentId deve ser diferente do endToEndId.
// Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
//
// [Restrição] Este campo é de envio obrigatório pela Iniciadora quando for uma nova tentativa de liquidação de pagamento que falhou anteriormente.
type OriginalRecurringPaymentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// EndDate defines model for endDate.
type EndDate = string

// ParameterOriginalRecurringPaymentId defines model for originalRecurringPaymentId.
type ParameterOriginalRecurringPaymentId = string

// PathRecurringConsentID defines model for pathRecurringConsentId.
type PathRecurringConsentID = string

// PathRecurringPaymentID defines model for pathRecurringPaymentId.
type PathRecurringPaymentID = string

// RecurringConsentID defines model for recurringConsentId.
type RecurringConsentID = string

// StartDate defines model for startDate.
type StartDate = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200RecurringPaymentsIDPatch defines model for 200RecurringPaymentsIdPatch.
type N200RecurringPaymentsIDPatch = ResponseRecurringPaymentsIDPatch

// N200RecurringPaymentsIDRead defines model for 200RecurringPaymentsIdRead.
type N200RecurringPaymentsIDRead = ResponseRecurringPaymentsIDRead

// N200RecurringPixPaymentRead defines model for 200RecurringPixPaymentRead.
type N200RecurringPixPaymentRead = ResponseRecurringPixPayment

// N201RecurringPaymentsIDPost defines model for 201RecurringPaymentsIdPost.
type N201RecurringPaymentsIDPost = ResponseRecurringPaymentsIDPost

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPaymentsConsents defines model for BadRequestPaymentsConsents.
type BadRequestPaymentsConsents = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeoutWithAdditionalProperties defines model for GatewayTimeoutWithAdditionalProperties.
type GatewayTimeoutWithAdditionalProperties = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// RecurringConsentsConsentID defines model for RecurringConsentsConsentId.
type RecurringConsentsConsentID = ResponseRecurringConsent

// RecurringConsentsConsentIDPatch defines model for RecurringConsentsConsentIdPatch.
type RecurringConsentsConsentIDPatch = ResponseRecurringConsentPatch

// RecurringConsentsPost defines model for RecurringConsentsPost.
type RecurringConsentsPost = ResponsePostRecurringConsent

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// AutomaticPaymentsGetPixRecurringPaymentsParams defines parameters for AutomaticPaymentsGetPixRecurringPayments.
type AutomaticPaymentsGetPixRecurringPaymentsParams struct {
        // RecurringConsentID O `recurringConsentId` é o identificador único do consentimento de longa duração e deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independe da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para `recurringConsentId` temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição detentora (bancoex).
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        RecurringConsentID RecurringConsentID `form:"recurringConsentId" json:"recurringConsentId"`

        // StartDate Data inicial de corte da ocorrência do pagamento ligada ao consentimento de longa duração.
        StartDate *StartDate `form:"startDate,omitempty" json:"startDate,omitempty"`

        // EndDate Data final de corte para recuperação da ocorrência do pagamento ligada ao consentimento de longa duração.
        EndDate *EndDate `form:"endDate,omitempty" json:"endDate,omitempty"`

        // ParameterOriginalRecurringPaymentID Campo que contém o código ou o identificador da tentativa original de pagamento que falhou.
        // Código ou identificador único criado pela instituição detentora da conta para representar a iniciação de pagamento.
        // Caso informado, devem ser retornados todos os pagamentos associados ao identificador informado, sendo eles o pagamento original (dono do identificador) e as novas tentativas que enviaram o identificador na sua requisição, indicando que representam nova tentativa.
        ParameterOriginalRecurringPaymentID *ParameterOriginalRecurringPaymentId `form:"originalRecurringPaymentId,omitempty" json:"originalRecurringPaymentId,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPostPixRecurringPaymentsParams defines parameters for AutomaticPaymentsPostPixRecurringPayments.
type AutomaticPaymentsPostPixRecurringPaymentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsGetPixRecurringPaymentsPaymentID.
type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams defines parameters for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostRecurringConsentsParams defines parameters for AutomaticPaymentsPostRecurringConsents.
type AutomaticPaymentsPostRecurringConsentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsGetRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsGetRecurringConsentsConsentID.
type AutomaticPaymentsGetRecurringConsentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`
}

// AutomaticPaymentsPatchRecurringConsentsConsentIDParams defines parameters for AutomaticPaymentsPatchRecurringConsentsConsentID.
type AutomaticPaymentsPatchRecurringConsentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o iniciador. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o iniciador.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora..
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody defines body for AutomaticPaymentsPostPixRecurringPayments for application/json ContentType.
type AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody = CreateRecurringPixPayment

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody defines body for AutomaticPaymentsPatchPixRecurringPaymentsPaymentID for application/json ContentType.
type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// AutomaticPaymentsPostRecurringConsentsJSONRequestBody defines body for AutomaticPaymentsPostRecurringConsents for application/json ContentType.
type AutomaticPaymentsPostRecurringConsentsJSONRequestBody = CreateRecurringConsent

// AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody defines body for AutomaticPaymentsPatchRecurringConsentsConsentID for application/json ContentType.
type AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody = PatchRecurringConsent

// AsConsentEdition returns the union data inside the PatchRecurringConsent_Data as a ConsentEdition
func (t PatchRecurringConsent_Data) AsConsentEdition() (ConsentEdition, error) <span class="cov0" title="0">{
        var body ConsentEdition
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromConsentEdition overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentEdition
func (t *PatchRecurringConsent_Data) FromConsentEdition(v ConsentEdition) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeConsentEdition performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentEdition
func (t *PatchRecurringConsent_Data) MergeConsentEdition(v ConsentEdition) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsConsentRevocation returns the union data inside the PatchRecurringConsent_Data as a ConsentRevocation
func (t PatchRecurringConsent_Data) AsConsentRevocation() (ConsentRevocation, error) <span class="cov0" title="0">{
        var body ConsentRevocation
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromConsentRevocation overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) FromConsentRevocation(v ConsentRevocation) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeConsentRevocation performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRevocation
func (t *PatchRecurringConsent_Data) MergeConsentRevocation(v ConsentRevocation) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsConsentRejection returns the union data inside the PatchRecurringConsent_Data as a ConsentRejection
func (t PatchRecurringConsent_Data) AsConsentRejection() (ConsentRejection, error) <span class="cov0" title="0">{
        var body ConsentRejection
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromConsentRejection overwrites any union data inside the PatchRecurringConsent_Data as the provided ConsentRejection
func (t *PatchRecurringConsent_Data) FromConsentRejection(v ConsentRejection) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeConsentRejection performs a merge with any union data inside the PatchRecurringConsent_Data, using the provided ConsentRejection
func (t *PatchRecurringConsent_Data) MergeConsentRejection(v ConsentRejection) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t PatchRecurringConsent_Data) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *PatchRecurringConsent_Data) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Busca informações de transações de pagamentos associadas a um consentimento.
        // (GET /pix/recurring-payments)
        AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams)
        // Cria uma transação de pagamento.
        // (POST /pix/recurring-payments)
        AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams)
        // Busca informações de uma transação de pagamento.
        // (GET /pix/recurring-payments/{recurringPaymentId})
        AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams)
        // Cancelamento de solicitação de pagamento automático.
        // (PATCH /pix/recurring-payments/{recurringPaymentId})
        AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams)
        // Cria um consentimento para transações de pagamentos.
        // (POST /recurring-consents)
        AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams)
        // Busca informações de um consentimento.
        // (GET /recurring-consents/{recurringConsentId})
        AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams)
        // Rejeita, revoga ou edita um consentimento.
        // (PATCH /recurring-consents/{recurringConsentId})
        AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsGetPixRecurringPaymentsParams

        // ------------- Required query parameter "recurringConsentId" -------------

        if paramValue := r.URL.Query().Get("recurringConsentId"); paramValue != "" </span>{<span class="cov0" title="0">

        }</span> else<span class="cov0" title="0"> {
                siw.ErrorHandlerFunc(w, r, &amp;RequiredParamError{ParamName: "recurringConsentId"})
                return
        }</span>

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, true, "recurringConsentId", r.URL.Query(), &amp;params.RecurringConsentID)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "startDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &amp;params.StartDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "startDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "endDate" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &amp;params.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "endDate", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "originalRecurringPaymentId" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "originalRecurringPaymentId", r.URL.Query(), &amp;params.ParameterOriginalRecurringPaymentID)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "originalRecurringPaymentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsGetPixRecurringPayments(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "recurring-consent:recurringConsentId", "recurring-payments"})

        ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "recurring-payments", "enrollment:enrollmentId", "nrp-consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsPostPixRecurringPaymentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsPostPixRecurringPayments(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "recurringPaymentId" -------------
        var recurringPaymentID PathRecurringPaymentID

        err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &amp;recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "recurringPaymentId" -------------
        var recurringPaymentID PathRecurringPaymentID

        err = runtime.BindStyledParameterWithOptions("simple", "recurringPaymentId", r.PathValue("recurringPaymentId"), &amp;recurringPaymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "recurringPaymentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w, r, recurringPaymentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsPostRecurringConsentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsPostRecurringConsents(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "recurringConsentId" -------------
        var recurringConsentID PathRecurringConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &amp;recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsGetRecurringConsentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsGetRecurringConsentsConsentID(w, r, recurringConsentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "recurringConsentId" -------------
        var recurringConsentID PathRecurringConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "recurringConsentId", r.PathValue("recurringConsentId"), &amp;recurringConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "recurringConsentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"recurring-payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AutomaticPaymentsPatchRecurringConsentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AutomaticPaymentsPatchRecurringConsentsConsentID(w, r, recurringConsentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsGetPixRecurringPayments)
        m.HandleFunc("POST "+options.BaseURL+"/pix/recurring-payments", wrapper.AutomaticPaymentsPostPixRecurringPayments)
        m.HandleFunc("GET "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsGetPixRecurringPaymentsPaymentID)
        m.HandleFunc("PATCH "+options.BaseURL+"/pix/recurring-payments/{recurringPaymentId}", wrapper.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID)
        m.HandleFunc("POST "+options.BaseURL+"/recurring-consents", wrapper.AutomaticPaymentsPostRecurringConsents)
        m.HandleFunc("GET "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsGetRecurringConsentsConsentID)
        m.HandleFunc("PATCH "+options.BaseURL+"/recurring-consents/{recurringConsentId}", wrapper.AutomaticPaymentsPatchRecurringConsentsConsentID)

        return m</span>
}

type N200RecurringPaymentsIDPatchJSONResponse ResponseRecurringPaymentsIDPatch

type N200RecurringPaymentsIDReadJSONResponse ResponseRecurringPaymentsIDRead

type N200RecurringPixPaymentReadJSONResponse ResponseRecurringPixPayment

type N201RecurringPaymentsIDPostJSONResponse ResponseRecurringPaymentsIDPost

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type RecurringConsentsConsentIDJSONResponse ResponseRecurringConsent

type RecurringConsentsConsentIDPatchJSONResponse ResponseRecurringConsentPatch

type RecurringConsentsPostJSONResponse ResponsePostRecurringConsent

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableConsentsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityPatchApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityPixPatchApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityPixRecurringPaymentApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type AutomaticPaymentsGetPixRecurringPaymentsRequestObject struct {
        Params AutomaticPaymentsGetPixRecurringPaymentsParams
}

type AutomaticPaymentsGetPixRecurringPaymentsResponseObject interface {
        VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPayments200JSONResponse struct {
        N200RecurringPixPaymentReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPayments200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsPostPixRecurringPaymentsRequestObject struct {
        Params AutomaticPaymentsPostPixRecurringPaymentsParams
        Body   *AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
}

type AutomaticPaymentsPostPixRecurringPaymentsResponseObject interface {
        VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostPixRecurringPayments201JSONResponse struct {
        N201RecurringPaymentsIDPostJSONResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments201JSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse struct {
        UnprocessableEntityPixRecurringPaymentApplicationJwtResponse
}

func (response AutomaticPaymentsPostPixRecurringPayments422ApplicationJwtResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostPixRecurringPayments529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsPostPixRecurringPaymentsdefaultJSONResponse) VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject struct {
        RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
        Params             AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject interface {
        VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse struct {
        N200RecurringPaymentsIDReadJSONResponse
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsGetPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject struct {
        RecurringPaymentID PathRecurringPaymentID `json:"recurringPaymentId"`
        Params             AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams
        Body               *AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject interface {
        VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse struct {
        N200RecurringPaymentsIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID200JSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse struct {
        UnprocessableEntityPixPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsPostRecurringConsentsRequestObject struct {
        Params AutomaticPaymentsPostRecurringConsentsParams
        Body   *AutomaticPaymentsPostRecurringConsentsJSONRequestBody
}

type AutomaticPaymentsPostRecurringConsentsResponseObject interface {
        VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPostRecurringConsents201JSONResponse struct {
        RecurringConsentsPostJSONResponse
}

func (response AutomaticPaymentsPostRecurringConsents201JSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response struct {
        BadRequestPaymentsConsentsApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse struct {
        UnprocessableConsentsApplicationJwtResponse
}

func (response AutomaticPaymentsPostRecurringConsents422ApplicationJwtResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPostRecurringConsents529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsPostRecurringConsentsdefaultJSONResponse) VisitAutomaticPaymentsPostRecurringConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject struct {
        RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
        Params             AutomaticPaymentsGetRecurringConsentsConsentIDParams
}

type AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject interface {
        VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse struct {
        RecurringConsentsConsentIDJSONResponse
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsGetRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsGetRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject struct {
        RecurringConsentID PathRecurringConsentID `json:"recurringConsentId"`
        Params             AutomaticPaymentsPatchRecurringConsentsConsentIDParams
        Body               *AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
}

type AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject interface {
        VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error
}

type AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse struct {
        RecurringConsentsConsentIDPatchJSONResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID200JSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse struct {
        UnprocessableEntityPatchApplicationJwtResponse
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID422ApplicationJwtResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutWithAdditionalPropertiesApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AutomaticPaymentsPatchRecurringConsentsConsentIDdefaultJSONResponse) VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Busca informações de transações de pagamentos associadas a um consentimento.
        // (GET /pix/recurring-payments)
        AutomaticPaymentsGetPixRecurringPayments(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsResponseObject, error)
        // Cria uma transação de pagamento.
        // (POST /pix/recurring-payments)
        AutomaticPaymentsPostPixRecurringPayments(ctx context.Context, request AutomaticPaymentsPostPixRecurringPaymentsRequestObject) (AutomaticPaymentsPostPixRecurringPaymentsResponseObject, error)
        // Busca informações de uma transação de pagamento.
        // (GET /pix/recurring-payments/{recurringPaymentId})
        AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject, error)
        // Cancelamento de solicitação de pagamento automático.
        // (PATCH /pix/recurring-payments/{recurringPaymentId})
        AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx context.Context, request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject) (AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject, error)
        // Cria um consentimento para transações de pagamentos.
        // (POST /recurring-consents)
        AutomaticPaymentsPostRecurringConsents(ctx context.Context, request AutomaticPaymentsPostRecurringConsentsRequestObject) (AutomaticPaymentsPostRecurringConsentsResponseObject, error)
        // Busca informações de um consentimento.
        // (GET /recurring-consents/{recurringConsentId})
        AutomaticPaymentsGetRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject, error)
        // Rejeita, revoga ou edita um consentimento.
        // (PATCH /recurring-consents/{recurringConsentId})
        AutomaticPaymentsPatchRecurringConsentsConsentID(ctx context.Context, request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject) (AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// AutomaticPaymentsGetPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsGetPixRecurringPaymentsParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsGetPixRecurringPaymentsRequestObject

        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsGetPixRecurringPayments(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPayments")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsPostPixRecurringPayments operation middleware
func (sh *strictHandler) AutomaticPaymentsPostPixRecurringPayments(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostPixRecurringPaymentsParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsPostPixRecurringPaymentsRequestObject

        request.Params = params

        var body AutomaticPaymentsPostPixRecurringPaymentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsPostPixRecurringPayments(ctx, request.(AutomaticPaymentsPostPixRecurringPaymentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsPostPixRecurringPayments")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsPostPixRecurringPaymentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsPostPixRecurringPaymentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsGetPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsGetPixRecurringPaymentsPaymentIDParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject

        request.RecurringPaymentID = recurringPaymentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsGetPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsGetPixRecurringPaymentsPaymentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsGetPixRecurringPaymentsPaymentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsPatchPixRecurringPaymentsPaymentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(w http.ResponseWriter, r *http.Request, recurringPaymentID PathRecurringPaymentID, params AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject

        request.RecurringPaymentID = recurringPaymentID
        request.Params = params

        var body AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsPatchPixRecurringPaymentsPaymentID(ctx, request.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsPatchPixRecurringPaymentsPaymentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsPatchPixRecurringPaymentsPaymentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsPostRecurringConsents operation middleware
func (sh *strictHandler) AutomaticPaymentsPostRecurringConsents(w http.ResponseWriter, r *http.Request, params AutomaticPaymentsPostRecurringConsentsParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsPostRecurringConsentsRequestObject

        request.Params = params

        var body AutomaticPaymentsPostRecurringConsentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsPostRecurringConsents(ctx, request.(AutomaticPaymentsPostRecurringConsentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsPostRecurringConsents")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsPostRecurringConsentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsPostRecurringConsentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsGetRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsGetRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsGetRecurringConsentsConsentIDParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject

        request.RecurringConsentID = recurringConsentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsGetRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsGetRecurringConsentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsGetRecurringConsentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsGetRecurringConsentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsGetRecurringConsentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// AutomaticPaymentsPatchRecurringConsentsConsentID operation middleware
func (sh *strictHandler) AutomaticPaymentsPatchRecurringConsentsConsentID(w http.ResponseWriter, r *http.Request, recurringConsentID PathRecurringConsentID, params AutomaticPaymentsPatchRecurringConsentsConsentIDParams) <span class="cov0" title="0">{
        var request AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject

        request.RecurringConsentID = recurringConsentID
        request.Params = params

        var body AutomaticPaymentsPatchRecurringConsentsConsentIDJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AutomaticPaymentsPatchRecurringConsentsConsentID(ctx, request.(AutomaticPaymentsPatchRecurringConsentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AutomaticPaymentsPatchRecurringConsentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AutomaticPaymentsPatchRecurringConsentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAutomaticPaymentsPatchRecurringConsentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
        "np7lL9++ePv/AwAA//8XQ4dXO4MDAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file9" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=consentv3 -o=./api_gen.go ./swagger.yml
package consentv3

import (
        "context"
        "errors"
        "net/http"

        "github.com/google/uuid"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type Server struct {
        baseURL string
        service consent.Service
        op      *provider.Provider
}

func NewServer(host string, service consent.Service, op *provider.Provider) Server <span class="cov0" title="0">{
        return Server{
                baseURL: host + "/open-banking/consents/v3",
                service: service,
                op:      op,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        consentMux := http.NewServeMux()

        clientCredentialsAuthMiddleware := middleware.Auth(s.op, goidc.GrantClientCredentials, consent.Scope)
        authCodeAuthMiddleware := middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID, consent.ScopeID)
        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{ return "PARAMETRO_INVALIDO" }</span>)

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err)
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{
                        swaggerMiddleware,
                        middleware.FAPIID(nil),
                },
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.ConsentsPostConsents)
        handler = clientCredentialsAuthMiddleware(handler)
        consentMux.Handle("POST /consents", handler)

        handler = http.HandlerFunc(wrapper.ConsentsDeleteConsentsConsentID)
        handler = clientCredentialsAuthMiddleware(handler)
        consentMux.Handle("DELETE /consents/{consentId}", handler)

        handler = http.HandlerFunc(wrapper.ConsentsGetConsentsConsentID)
        handler = clientCredentialsAuthMiddleware(handler)
        consentMux.Handle("GET /consents/{consentId}", handler)

        handler = http.HandlerFunc(wrapper.ConsentsPostConsentsConsentIDExtends)
        handler = authCodeAuthMiddleware(handler)
        consentMux.Handle("POST /consents/{consentId}/extends", handler)

        handler = http.HandlerFunc(wrapper.ConsentsGetConsentsConsentIDExtensions)
        handler = clientCredentialsAuthMiddleware(handler)
        consentMux.Handle("GET /consents/{consentId}/extensions", handler)

        mux.Handle("/open-banking/consents/v3/", http.StripPrefix("/open-banking/consents/v3", consentMux))</span>
}

func (s Server) ConsentsPostConsents(ctx context.Context, req ConsentsPostConsentsRequestObject) (ConsentsPostConsentsResponseObject, error) <span class="cov0" title="0">{
        var perms []consent.Permission
        for _, p := range req.Body.Data.Permissions </span><span class="cov0" title="0">{
                perms = append(perms, consent.Permission(p))
        }</span>
        <span class="cov0" title="0">c := &amp;consent.Consent{
                Status:             consent.StatusAwaitingAuthorization,
                UserIdentification: req.Body.Data.LoggedUser.Document.Identification,
                UserRel:            consent.Relation(req.Body.Data.LoggedUser.Document.Rel),
                Permissions:        perms,
                ExpiresAt:          req.Body.Data.ExpirationDateTime,
                ClientID:           ctx.Value(api.CtxKeyClientID).(string),
                OrgID:              ctx.Value(api.CtxKeyOrgID).(string),
        }

        if business := req.Body.Data.BusinessEntity; business != nil </span><span class="cov0" title="0">{
                rel := consent.Relation(business.Document.Rel)
                c.BusinessIdentification = &amp;business.Document.Identification
                c.BusinessRel = &amp;rel
        }</span>

        <span class="cov0" title="0">if err := s.service.Create(ctx, c); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var respPerms []ResponseConsentDataPermissions
        for _, p := range c.Permissions </span><span class="cov0" title="0">{
                respPerms = append(respPerms, ResponseConsentDataPermissions(p))
        }</span>
        <span class="cov0" title="0">resp := ResponseConsent{
                Data: struct {
                        ConsentID            string                           `json:"consentId"`
                        CreationDateTime     timeutil.DateTime                `json:"creationDateTime"`
                        ExpirationDateTime   *timeutil.DateTime               `json:"expirationDateTime,omitempty"`
                        Permissions          []ResponseConsentDataPermissions `json:"permissions"`
                        Status               ResponseConsentDataStatus        `json:"status"`
                        StatusUpdateDateTime timeutil.DateTime                `json:"statusUpdateDateTime"`
                }{
                        ConsentID:            c.URN(),
                        Status:               ResponseConsentDataStatus(c.Status),
                        Permissions:          respPerms,
                        CreationDateTime:     c.CreatedAt,
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        ExpirationDateTime:   c.ExpiresAt,
                },
                Links: api.NewLinks(s.baseURL + "/consents/" + c.URN()),
                Meta:  api.NewMeta(),
        }

        return ConsentsPostConsents201JSONResponse{N201ConsentsCreatedJSONResponse(resp)}, nil</span>
}

func (s Server) ConsentsGetConsentsConsentID(ctx context.Context, req ConsentsGetConsentsConsentIDRequestObject) (ConsentsGetConsentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        c, err := s.service.Consent(ctx, req.ConsentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var respPerms []ResponseConsentReadDataPermissions
        for _, p := range c.Permissions </span><span class="cov0" title="0">{
                respPerms = append(respPerms, ResponseConsentReadDataPermissions(p))
        }</span>
        <span class="cov0" title="0">resp := ResponseConsentRead{
                Data: struct {
                        ConsentID          string                               `json:"consentId"`
                        CreationDateTime   timeutil.DateTime                    `json:"creationDateTime"`
                        ExpirationDateTime *timeutil.DateTime                   `json:"expirationDateTime,omitempty"`
                        Permissions        []ResponseConsentReadDataPermissions `json:"permissions"`
                        Rejection          *struct {
                                Reason struct {
                                        AdditionalInformation *string                                    `json:"additionalInformation,omitempty"`
                                        Code                  ResponseConsentReadDataRejectionReasonCode `json:"code"`
                                } `json:"reason"`
                                RejectedBy EnumRejectedBy `json:"rejectedBy"`
                        } `json:"rejection,omitempty"`
                        Status               ResponseConsentReadDataStatus `json:"status"`
                        StatusUpdateDateTime timeutil.DateTime             `json:"statusUpdateDateTime"`
                }{
                        ConsentID:            c.URN(),
                        CreationDateTime:     c.CreatedAt,
                        Permissions:          respPerms,
                        Status:               ResponseConsentReadDataStatus(c.Status),
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        ExpirationDateTime:   c.ExpiresAt,
                },
                Links: api.NewLinks(s.baseURL + "/consents/" + c.URN()),
                Meta:  api.NewMeta(),
        }

        if c.Rejection != nil </span><span class="cov0" title="0">{
                resp.Data.Rejection = &amp;struct {
                        Reason struct {
                                AdditionalInformation *string                                    `json:"additionalInformation,omitempty"`
                                Code                  ResponseConsentReadDataRejectionReasonCode `json:"code"`
                        } `json:"reason"`
                        RejectedBy EnumRejectedBy `json:"rejectedBy"`
                }{}
                resp.Data.Rejection.RejectedBy = EnumRejectedBy(c.Rejection.By)
                resp.Data.Rejection.Reason.Code = ResponseConsentReadDataRejectionReasonCode(c.Rejection.Reason)
        }</span>
        <span class="cov0" title="0">return ConsentsGetConsentsConsentID200JSONResponse{N200ConsentsConsentIDReadJSONResponse(resp)}, nil</span>
}

func (s Server) ConsentsDeleteConsentsConsentID(ctx context.Context, req ConsentsDeleteConsentsConsentIDRequestObject) (ConsentsDeleteConsentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        if err := s.service.Delete(ctx, req.ConsentID, orgID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return ConsentsDeleteConsentsConsentID204Response{}, nil</span>
}

func (s Server) ConsentsPostConsentsConsentIDExtends(ctx context.Context, req ConsentsPostConsentsConsentIDExtendsRequestObject) (ConsentsPostConsentsConsentIDExtendsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        consentID := ctx.Value(api.CtxKeyConsentID).(string)
        ext := &amp;consent.Extension{
                ConsentID:     uuid.MustParse(consentID),
                UserAgent:     req.Params.XCustomerUserAgent,
                UserIPAddress: req.Params.XFapiCustomerIPAddress,
        }

        c, err := s.service.Extend(ctx, consentID, orgID, ext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var respPerms []ResponseConsentExtensionsDataPermissions
        for _, p := range c.Permissions </span><span class="cov0" title="0">{
                respPerms = append(respPerms, ResponseConsentExtensionsDataPermissions(p))
        }</span>
        <span class="cov0" title="0">resp := ResponseConsentExtensions{
                Data: struct {
                        ConsentID            string                                     `json:"consentId"`
                        CreationDateTime     timeutil.DateTime                          `json:"creationDateTime"`
                        ExpirationDateTime   *timeutil.DateTime                         `json:"expirationDateTime,omitempty"`
                        Permissions          []ResponseConsentExtensionsDataPermissions `json:"permissions"`
                        Status               ResponseConsentExtensionsDataStatus        `json:"status"`
                        StatusUpdateDateTime timeutil.DateTime                          `json:"statusUpdateDateTime"`
                }{
                        ConsentID:            c.URN(),
                        CreationDateTime:     c.CreatedAt,
                        Permissions:          respPerms,
                        Status:               ResponseConsentExtensionsDataStatus(c.Status),
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        ExpirationDateTime:   c.ExpiresAt,
                },
        }
        return ConsentsPostConsentsConsentIDExtends201JSONResponse{N201ConsentsCreatedExtensionsJSONResponse(resp)}, nil</span>
}

func (s Server) ConsentsGetConsentsConsentIDExtensions(ctx context.Context, req ConsentsGetConsentsConsentIDExtensionsRequestObject) (ConsentsGetConsentsConsentIDExtensionsResponseObject, error) <span class="cov0" title="0">{

        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        exts, err := s.service.Extensions(ctx, req.ConsentID, orgID, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseConsentReadExtensions{
                Links: api.NewPaginatedLinks(s.baseURL+"/consents/"+req.ConsentID+"/extensions", exts),
                Meta:  api.NewPaginatedMeta(exts),
        }
        for _, ext := range exts.Records </span><span class="cov0" title="0">{
                extResp := struct {
                        ExpirationDateTime         *timeutil.DateTime   `json:"expirationDateTime,omitempty"`
                        LoggedUser                 LoggedUserExtensions `json:"loggedUser"`
                        PreviousExpirationDateTime *timeutil.DateTime   `json:"previousExpirationDateTime,omitempty"`
                        RequestDateTime            timeutil.DateTime    `json:"requestDateTime"`
                        XCustomerUserAgent         *string              `json:"xCustomerUserAgent,omitempty"`
                        XFapiCustomerIPAddress     *string              `json:"xFapiCustomerIpAddress,omitempty"`
                }{
                        LoggedUser: LoggedUserExtensions{
                                Document: LoggedUserDocumentExtensions{
                                        Identification: ext.UserCPF,
                                        Rel:            consent.DefaultUserDocumentRelation,
                                },
                        },
                        RequestDateTime:            ext.RequestedAt,
                        ExpirationDateTime:         ext.ExpiresAt,
                        PreviousExpirationDateTime: ext.PreviousExpiresAt,
                        XCustomerUserAgent:         &amp;ext.UserAgent,
                        XFapiCustomerIPAddress:     &amp;ext.UserIPAddress,
                }

                resp.Data = append(resp.Data, extResp)
        }</span>

        <span class="cov0" title="0">return ConsentsGetConsentsConsentIDExtensions200JSONResponse{N200ConsentsConsentIDReadExtensionsJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        if errors.Is(err, consent.ErrAccessNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("FORBIDDEN", http.StatusForbidden, consent.ErrAccessNotAllowed.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrExtensionNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("FORBIDDEN", http.StatusForbidden, consent.ErrExtensionNotAllowed.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrInvalidPermissionGroup) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("COMBINACAO_PERMISSOES_INCORRETA", http.StatusUnprocessableEntity, consent.ErrInvalidPermissionGroup.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrPersonalAndBusinessPermissionsTogether) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PERMISSAO_PF_PJ_EM_CONJUNTO", http.StatusUnprocessableEntity, consent.ErrPersonalAndBusinessPermissionsTogether.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrInvalidExpiration) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DATA_EXPIRACAO_INVALIDA", http.StatusUnprocessableEntity, consent.ErrInvalidExpiration.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrAlreadyRejected) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CONSENTIMENTO_EM_STATUS_REJEITADO", http.StatusUnprocessableEntity, consent.ErrAlreadyRejected.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrCannotExtendConsentNotAuthorized) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("ESTADO_CONSENTIMENTO_INVALIDO", http.StatusUnprocessableEntity, consent.ErrCannotExtendConsentNotAuthorized.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, consent.ErrCannotExtendConsentForJointAccount) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DEPENDE_MULTIPLA_ALCADA", http.StatusUnprocessableEntity, consent.ErrCannotExtendConsentForJointAccount.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;errorutil.Error{}) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">//go:build go1.22

// Package consentv3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package consentv3

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
        OAuth2SecurityScopes          = "OAuth2Security.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
        N422ResponseErrorCreateConsentErrorsCodeDATAEXPIRACAOINVALIDA       N422ResponseErrorCreateConsentErrorsCode = "DATA_EXPIRACAO_INVALIDA"
        N422ResponseErrorCreateConsentErrorsCodeDEPENDEMULTIPLAALCADA       N422ResponseErrorCreateConsentErrorsCode = "DEPENDE_MULTIPLA_ALCADA"
        N422ResponseErrorCreateConsentErrorsCodeERRONAOMAPEADO              N422ResponseErrorCreateConsentErrorsCode = "ERRO_NAO_MAPEADO"
        N422ResponseErrorCreateConsentErrorsCodeESTADOCONSENTIMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "ESTADO_CONSENTIMENTO_INVALIDO"
)

// Defines values for CreateConsentDataPermissions.
const (
        CreateConsentDataPermissionsACCOUNTSBALANCESREAD                                CreateConsentDataPermissions = "ACCOUNTS_BALANCES_READ"
        CreateConsentDataPermissionsACCOUNTSOVERDRAFTLIMITSREAD                         CreateConsentDataPermissions = "ACCOUNTS_OVERDRAFT_LIMITS_READ"
        CreateConsentDataPermissionsACCOUNTSREAD                                        CreateConsentDataPermissions = "ACCOUNTS_READ"
        CreateConsentDataPermissionsACCOUNTSTRANSACTIONSREAD                            CreateConsentDataPermissions = "ACCOUNTS_TRANSACTIONS_READ"
        CreateConsentDataPermissionsBANKFIXEDINCOMESREAD                                CreateConsentDataPermissions = "BANK_FIXED_INCOMES_READ"
        CreateConsentDataPermissionsCREDITCARDSACCOUNTSBILLSREAD                        CreateConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_READ"
        CreateConsentDataPermissionsCREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD            CreateConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ"
        CreateConsentDataPermissionsCREDITCARDSACCOUNTSLIMITSREAD                       CreateConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ"
        CreateConsentDataPermissionsCREDITCARDSACCOUNTSREAD                             CreateConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_READ"
        CreateConsentDataPermissionsCREDITCARDSACCOUNTSTRANSACTIONSREAD                 CreateConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ"
        CreateConsentDataPermissionsCREDITFIXEDINCOMESREAD                              CreateConsentDataPermissions = "CREDIT_FIXED_INCOMES_READ"
        CreateConsentDataPermissionsCUSTOMERSBUSINESSADITTIONALINFOREAD                 CreateConsentDataPermissions = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ"
        CreateConsentDataPermissionsCUSTOMERSBUSINESSIDENTIFICATIONSREAD                CreateConsentDataPermissions = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ"
        CreateConsentDataPermissionsCUSTOMERSPERSONALADITTIONALINFOREAD                 CreateConsentDataPermissions = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ"
        CreateConsentDataPermissionsCUSTOMERSPERSONALIDENTIFICATIONSREAD                CreateConsentDataPermissions = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ"
        CreateConsentDataPermissionsEXCHANGESREAD                                       CreateConsentDataPermissions = "EXCHANGES_READ"
        CreateConsentDataPermissionsFINANCINGSPAYMENTSREAD                              CreateConsentDataPermissions = "FINANCINGS_PAYMENTS_READ"
        CreateConsentDataPermissionsFINANCINGSREAD                                      CreateConsentDataPermissions = "FINANCINGS_READ"
        CreateConsentDataPermissionsFINANCINGSSCHEDULEDINSTALMENTSREAD                  CreateConsentDataPermissions = "FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        CreateConsentDataPermissionsFINANCINGSWARRANTIESREAD                            CreateConsentDataPermissions = "FINANCINGS_WARRANTIES_READ"
        CreateConsentDataPermissionsFUNDSREAD                                           CreateConsentDataPermissions = "FUNDS_READ"
        CreateConsentDataPermissionsINVOICEFINANCINGSPAYMENTSREAD                       CreateConsentDataPermissions = "INVOICE_FINANCINGS_PAYMENTS_READ"
        CreateConsentDataPermissionsINVOICEFINANCINGSREAD                               CreateConsentDataPermissions = "INVOICE_FINANCINGS_READ"
        CreateConsentDataPermissionsINVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD           CreateConsentDataPermissions = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        CreateConsentDataPermissionsINVOICEFINANCINGSWARRANTIESREAD                     CreateConsentDataPermissions = "INVOICE_FINANCINGS_WARRANTIES_READ"
        CreateConsentDataPermissionsLOANSPAYMENTSREAD                                   CreateConsentDataPermissions = "LOANS_PAYMENTS_READ"
        CreateConsentDataPermissionsLOANSREAD                                           CreateConsentDataPermissions = "LOANS_READ"
        CreateConsentDataPermissionsLOANSSCHEDULEDINSTALMENTSREAD                       CreateConsentDataPermissions = "LOANS_SCHEDULED_INSTALMENTS_READ"
        CreateConsentDataPermissionsLOANSWARRANTIESREAD                                 CreateConsentDataPermissions = "LOANS_WARRANTIES_READ"
        CreateConsentDataPermissionsRESOURCESREAD                                       CreateConsentDataPermissions = "RESOURCES_READ"
        CreateConsentDataPermissionsTREASURETITLESREAD                                  CreateConsentDataPermissions = "TREASURE_TITLES_READ"
        CreateConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD             CreateConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ"
        CreateConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTREAD                     CreateConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ"
        CreateConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD CreateConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ"
        CreateConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD           CreateConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ"
        CreateConsentDataPermissionsVARIABLEINCOMESREAD                                 CreateConsentDataPermissions = "VARIABLE_INCOMES_READ"
)

// Defines values for EnumRejectedBy.
const (
        ASPSP EnumRejectedBy = "ASPSP"
        TPP   EnumRejectedBy = "TPP"
        USER  EnumRejectedBy = "USER"
)

// Defines values for ResponseConsentDataPermissions.
const (
        ResponseConsentDataPermissionsACCOUNTSBALANCESREAD                                ResponseConsentDataPermissions = "ACCOUNTS_BALANCES_READ"
        ResponseConsentDataPermissionsACCOUNTSOVERDRAFTLIMITSREAD                         ResponseConsentDataPermissions = "ACCOUNTS_OVERDRAFT_LIMITS_READ"
        ResponseConsentDataPermissionsACCOUNTSREAD                                        ResponseConsentDataPermissions = "ACCOUNTS_READ"
        ResponseConsentDataPermissionsACCOUNTSTRANSACTIONSREAD                            ResponseConsentDataPermissions = "ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentDataPermissionsBANKFIXEDINCOMESREAD                                ResponseConsentDataPermissions = "BANK_FIXED_INCOMES_READ"
        ResponseConsentDataPermissionsCREDITCARDSACCOUNTSBILLSREAD                        ResponseConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_READ"
        ResponseConsentDataPermissionsCREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD            ResponseConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ"
        ResponseConsentDataPermissionsCREDITCARDSACCOUNTSLIMITSREAD                       ResponseConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ"
        ResponseConsentDataPermissionsCREDITCARDSACCOUNTSREAD                             ResponseConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_READ"
        ResponseConsentDataPermissionsCREDITCARDSACCOUNTSTRANSACTIONSREAD                 ResponseConsentDataPermissions = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentDataPermissionsCREDITFIXEDINCOMESREAD                              ResponseConsentDataPermissions = "CREDIT_FIXED_INCOMES_READ"
        ResponseConsentDataPermissionsCUSTOMERSBUSINESSADITTIONALINFOREAD                 ResponseConsentDataPermissions = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ"
        ResponseConsentDataPermissionsCUSTOMERSBUSINESSIDENTIFICATIONSREAD                ResponseConsentDataPermissions = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ"
        ResponseConsentDataPermissionsCUSTOMERSPERSONALADITTIONALINFOREAD                 ResponseConsentDataPermissions = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ"
        ResponseConsentDataPermissionsCUSTOMERSPERSONALIDENTIFICATIONSREAD                ResponseConsentDataPermissions = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ"
        ResponseConsentDataPermissionsEXCHANGESREAD                                       ResponseConsentDataPermissions = "EXCHANGES_READ"
        ResponseConsentDataPermissionsFINANCINGSPAYMENTSREAD                              ResponseConsentDataPermissions = "FINANCINGS_PAYMENTS_READ"
        ResponseConsentDataPermissionsFINANCINGSREAD                                      ResponseConsentDataPermissions = "FINANCINGS_READ"
        ResponseConsentDataPermissionsFINANCINGSSCHEDULEDINSTALMENTSREAD                  ResponseConsentDataPermissions = "FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentDataPermissionsFINANCINGSWARRANTIESREAD                            ResponseConsentDataPermissions = "FINANCINGS_WARRANTIES_READ"
        ResponseConsentDataPermissionsFUNDSREAD                                           ResponseConsentDataPermissions = "FUNDS_READ"
        ResponseConsentDataPermissionsINVOICEFINANCINGSPAYMENTSREAD                       ResponseConsentDataPermissions = "INVOICE_FINANCINGS_PAYMENTS_READ"
        ResponseConsentDataPermissionsINVOICEFINANCINGSREAD                               ResponseConsentDataPermissions = "INVOICE_FINANCINGS_READ"
        ResponseConsentDataPermissionsINVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD           ResponseConsentDataPermissions = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentDataPermissionsINVOICEFINANCINGSWARRANTIESREAD                     ResponseConsentDataPermissions = "INVOICE_FINANCINGS_WARRANTIES_READ"
        ResponseConsentDataPermissionsLOANSPAYMENTSREAD                                   ResponseConsentDataPermissions = "LOANS_PAYMENTS_READ"
        ResponseConsentDataPermissionsLOANSREAD                                           ResponseConsentDataPermissions = "LOANS_READ"
        ResponseConsentDataPermissionsLOANSSCHEDULEDINSTALMENTSREAD                       ResponseConsentDataPermissions = "LOANS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentDataPermissionsLOANSWARRANTIESREAD                                 ResponseConsentDataPermissions = "LOANS_WARRANTIES_READ"
        ResponseConsentDataPermissionsRESOURCESREAD                                       ResponseConsentDataPermissions = "RESOURCES_READ"
        ResponseConsentDataPermissionsTREASURETITLESREAD                                  ResponseConsentDataPermissions = "TREASURE_TITLES_READ"
        ResponseConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD             ResponseConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ"
        ResponseConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTREAD                     ResponseConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ"
        ResponseConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD ResponseConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD           ResponseConsentDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ"
        ResponseConsentDataPermissionsVARIABLEINCOMESREAD                                 ResponseConsentDataPermissions = "VARIABLE_INCOMES_READ"
)

// Defines values for ResponseConsentDataStatus.
const (
        ResponseConsentDataStatusAUTHORISED            ResponseConsentDataStatus = "AUTHORISED"
        ResponseConsentDataStatusAWAITINGAUTHORISATION ResponseConsentDataStatus = "AWAITING_AUTHORISATION"
        ResponseConsentDataStatusREJECTED              ResponseConsentDataStatus = "REJECTED"
)

// Defines values for ResponseConsentExtensionsDataPermissions.
const (
        ResponseConsentExtensionsDataPermissionsACCOUNTSBALANCESREAD                                ResponseConsentExtensionsDataPermissions = "ACCOUNTS_BALANCES_READ"
        ResponseConsentExtensionsDataPermissionsACCOUNTSOVERDRAFTLIMITSREAD                         ResponseConsentExtensionsDataPermissions = "ACCOUNTS_OVERDRAFT_LIMITS_READ"
        ResponseConsentExtensionsDataPermissionsACCOUNTSREAD                                        ResponseConsentExtensionsDataPermissions = "ACCOUNTS_READ"
        ResponseConsentExtensionsDataPermissionsACCOUNTSTRANSACTIONSREAD                            ResponseConsentExtensionsDataPermissions = "ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentExtensionsDataPermissionsBANKFIXEDINCOMESREAD                                ResponseConsentExtensionsDataPermissions = "BANK_FIXED_INCOMES_READ"
        ResponseConsentExtensionsDataPermissionsCREDITCARDSACCOUNTSBILLSREAD                        ResponseConsentExtensionsDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_READ"
        ResponseConsentExtensionsDataPermissionsCREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD            ResponseConsentExtensionsDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ"
        ResponseConsentExtensionsDataPermissionsCREDITCARDSACCOUNTSLIMITSREAD                       ResponseConsentExtensionsDataPermissions = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ"
        ResponseConsentExtensionsDataPermissionsCREDITCARDSACCOUNTSREAD                             ResponseConsentExtensionsDataPermissions = "CREDIT_CARDS_ACCOUNTS_READ"
        ResponseConsentExtensionsDataPermissionsCREDITCARDSACCOUNTSTRANSACTIONSREAD                 ResponseConsentExtensionsDataPermissions = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentExtensionsDataPermissionsCREDITFIXEDINCOMESREAD                              ResponseConsentExtensionsDataPermissions = "CREDIT_FIXED_INCOMES_READ"
        ResponseConsentExtensionsDataPermissionsCUSTOMERSBUSINESSADITTIONALINFOREAD                 ResponseConsentExtensionsDataPermissions = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ"
        ResponseConsentExtensionsDataPermissionsCUSTOMERSBUSINESSIDENTIFICATIONSREAD                ResponseConsentExtensionsDataPermissions = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ"
        ResponseConsentExtensionsDataPermissionsCUSTOMERSPERSONALADITTIONALINFOREAD                 ResponseConsentExtensionsDataPermissions = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ"
        ResponseConsentExtensionsDataPermissionsCUSTOMERSPERSONALIDENTIFICATIONSREAD                ResponseConsentExtensionsDataPermissions = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ"
        ResponseConsentExtensionsDataPermissionsFINANCINGSPAYMENTSREAD                              ResponseConsentExtensionsDataPermissions = "FINANCINGS_PAYMENTS_READ"
        ResponseConsentExtensionsDataPermissionsFINANCINGSREAD                                      ResponseConsentExtensionsDataPermissions = "FINANCINGS_READ"
        ResponseConsentExtensionsDataPermissionsFINANCINGSSCHEDULEDINSTALMENTSREAD                  ResponseConsentExtensionsDataPermissions = "FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentExtensionsDataPermissionsFINANCINGSWARRANTIESREAD                            ResponseConsentExtensionsDataPermissions = "FINANCINGS_WARRANTIES_READ"
        ResponseConsentExtensionsDataPermissionsFUNDSREAD                                           ResponseConsentExtensionsDataPermissions = "FUNDS_READ"
        ResponseConsentExtensionsDataPermissionsINVOICEFINANCINGSPAYMENTSREAD                       ResponseConsentExtensionsDataPermissions = "INVOICE_FINANCINGS_PAYMENTS_READ"
        ResponseConsentExtensionsDataPermissionsINVOICEFINANCINGSREAD                               ResponseConsentExtensionsDataPermissions = "INVOICE_FINANCINGS_READ"
        ResponseConsentExtensionsDataPermissionsINVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD           ResponseConsentExtensionsDataPermissions = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentExtensionsDataPermissionsINVOICEFINANCINGSWARRANTIESREAD                     ResponseConsentExtensionsDataPermissions = "INVOICE_FINANCINGS_WARRANTIES_READ"
        ResponseConsentExtensionsDataPermissionsLOANSPAYMENTSREAD                                   ResponseConsentExtensionsDataPermissions = "LOANS_PAYMENTS_READ"
        ResponseConsentExtensionsDataPermissionsLOANSREAD                                           ResponseConsentExtensionsDataPermissions = "LOANS_READ"
        ResponseConsentExtensionsDataPermissionsLOANSSCHEDULEDINSTALMENTSREAD                       ResponseConsentExtensionsDataPermissions = "LOANS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentExtensionsDataPermissionsLOANSWARRANTIESREAD                                 ResponseConsentExtensionsDataPermissions = "LOANS_WARRANTIES_READ"
        ResponseConsentExtensionsDataPermissionsRESOURCESREAD                                       ResponseConsentExtensionsDataPermissions = "RESOURCES_READ"
        ResponseConsentExtensionsDataPermissionsTREASURETITLESREAD                                  ResponseConsentExtensionsDataPermissions = "TREASURE_TITLES_READ"
        ResponseConsentExtensionsDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD             ResponseConsentExtensionsDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ"
        ResponseConsentExtensionsDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTREAD                     ResponseConsentExtensionsDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ"
        ResponseConsentExtensionsDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD ResponseConsentExtensionsDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentExtensionsDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD           ResponseConsentExtensionsDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ"
        ResponseConsentExtensionsDataPermissionsVARIABLEINCOMESREAD                                 ResponseConsentExtensionsDataPermissions = "VARIABLE_INCOMES_READ"
)

// Defines values for ResponseConsentExtensionsDataStatus.
const (
        ResponseConsentExtensionsDataStatusAUTHORISED            ResponseConsentExtensionsDataStatus = "AUTHORISED"
        ResponseConsentExtensionsDataStatusAWAITINGAUTHORISATION ResponseConsentExtensionsDataStatus = "AWAITING_AUTHORISATION"
        ResponseConsentExtensionsDataStatusREJECTED              ResponseConsentExtensionsDataStatus = "REJECTED"
)

// Defines values for ResponseConsentReadDataPermissions.
const (
        ResponseConsentReadDataPermissionsACCOUNTSBALANCESREAD                                ResponseConsentReadDataPermissions = "ACCOUNTS_BALANCES_READ"
        ResponseConsentReadDataPermissionsACCOUNTSOVERDRAFTLIMITSREAD                         ResponseConsentReadDataPermissions = "ACCOUNTS_OVERDRAFT_LIMITS_READ"
        ResponseConsentReadDataPermissionsACCOUNTSREAD                                        ResponseConsentReadDataPermissions = "ACCOUNTS_READ"
        ResponseConsentReadDataPermissionsACCOUNTSTRANSACTIONSREAD                            ResponseConsentReadDataPermissions = "ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentReadDataPermissionsBANKFIXEDINCOMESREAD                                ResponseConsentReadDataPermissions = "BANK_FIXED_INCOMES_READ"
        ResponseConsentReadDataPermissionsCREDITCARDSACCOUNTSBILLSREAD                        ResponseConsentReadDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_READ"
        ResponseConsentReadDataPermissionsCREDITCARDSACCOUNTSBILLSTRANSACTIONSREAD            ResponseConsentReadDataPermissions = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ"
        ResponseConsentReadDataPermissionsCREDITCARDSACCOUNTSLIMITSREAD                       ResponseConsentReadDataPermissions = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ"
        ResponseConsentReadDataPermissionsCREDITCARDSACCOUNTSREAD                             ResponseConsentReadDataPermissions = "CREDIT_CARDS_ACCOUNTS_READ"
        ResponseConsentReadDataPermissionsCREDITCARDSACCOUNTSTRANSACTIONSREAD                 ResponseConsentReadDataPermissions = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ"
        ResponseConsentReadDataPermissionsCREDITFIXEDINCOMESREAD                              ResponseConsentReadDataPermissions = "CREDIT_FIXED_INCOMES_READ"
        ResponseConsentReadDataPermissionsCUSTOMERSBUSINESSADITTIONALINFOREAD                 ResponseConsentReadDataPermissions = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ"
        ResponseConsentReadDataPermissionsCUSTOMERSBUSINESSIDENTIFICATIONSREAD                ResponseConsentReadDataPermissions = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ"
        ResponseConsentReadDataPermissionsCUSTOMERSPERSONALADITTIONALINFOREAD                 ResponseConsentReadDataPermissions = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ"
        ResponseConsentReadDataPermissionsCUSTOMERSPERSONALIDENTIFICATIONSREAD                ResponseConsentReadDataPermissions = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ"
        ResponseConsentReadDataPermissionsEXCHANGESREAD                                       ResponseConsentReadDataPermissions = "EXCHANGES_READ"
        ResponseConsentReadDataPermissionsFINANCINGSPAYMENTSREAD                              ResponseConsentReadDataPermissions = "FINANCINGS_PAYMENTS_READ"
        ResponseConsentReadDataPermissionsFINANCINGSREAD                                      ResponseConsentReadDataPermissions = "FINANCINGS_READ"
        ResponseConsentReadDataPermissionsFINANCINGSSCHEDULEDINSTALMENTSREAD                  ResponseConsentReadDataPermissions = "FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentReadDataPermissionsFINANCINGSWARRANTIESREAD                            ResponseConsentReadDataPermissions = "FINANCINGS_WARRANTIES_READ"
        ResponseConsentReadDataPermissionsFUNDSREAD                                           ResponseConsentReadDataPermissions = "FUNDS_READ"
        ResponseConsentReadDataPermissionsINVOICEFINANCINGSPAYMENTSREAD                       ResponseConsentReadDataPermissions = "INVOICE_FINANCINGS_PAYMENTS_READ"
        ResponseConsentReadDataPermissionsINVOICEFINANCINGSREAD                               ResponseConsentReadDataPermissions = "INVOICE_FINANCINGS_READ"
        ResponseConsentReadDataPermissionsINVOICEFINANCINGSSCHEDULEDINSTALMENTSREAD           ResponseConsentReadDataPermissions = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentReadDataPermissionsINVOICEFINANCINGSWARRANTIESREAD                     ResponseConsentReadDataPermissions = "INVOICE_FINANCINGS_WARRANTIES_READ"
        ResponseConsentReadDataPermissionsLOANSPAYMENTSREAD                                   ResponseConsentReadDataPermissions = "LOANS_PAYMENTS_READ"
        ResponseConsentReadDataPermissionsLOANSREAD                                           ResponseConsentReadDataPermissions = "LOANS_READ"
        ResponseConsentReadDataPermissionsLOANSSCHEDULEDINSTALMENTSREAD                       ResponseConsentReadDataPermissions = "LOANS_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentReadDataPermissionsLOANSWARRANTIESREAD                                 ResponseConsentReadDataPermissions = "LOANS_WARRANTIES_READ"
        ResponseConsentReadDataPermissionsRESOURCESREAD                                       ResponseConsentReadDataPermissions = "RESOURCES_READ"
        ResponseConsentReadDataPermissionsTREASURETITLESREAD                                  ResponseConsentReadDataPermissions = "TREASURE_TITLES_READ"
        ResponseConsentReadDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTPAYMENTSREAD             ResponseConsentReadDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ"
        ResponseConsentReadDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTREAD                     ResponseConsentReadDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ"
        ResponseConsentReadDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTSCHEDULEDINSTALMENTSREAD ResponseConsentReadDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ"
        ResponseConsentReadDataPermissionsUNARRANGEDACCOUNTSOVERDRAFTWARRANTIESREAD           ResponseConsentReadDataPermissions = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ"
        ResponseConsentReadDataPermissionsVARIABLEINCOMESREAD                                 ResponseConsentReadDataPermissions = "VARIABLE_INCOMES_READ"
)

// Defines values for ResponseConsentReadDataRejectionReasonCode.
const (
        CONSENTEXPIRED           ResponseConsentReadDataRejectionReasonCode = "CONSENT_EXPIRED"
        CONSENTMAXDATEREACHED    ResponseConsentReadDataRejectionReasonCode = "CONSENT_MAX_DATE_REACHED"
        CONSENTTECHNICALISSUE    ResponseConsentReadDataRejectionReasonCode = "CONSENT_TECHNICAL_ISSUE"
        CUSTOMERMANUALLYREJECTED ResponseConsentReadDataRejectionReasonCode = "CUSTOMER_MANUALLY_REJECTED"
        CUSTOMERMANUALLYREVOKED  ResponseConsentReadDataRejectionReasonCode = "CUSTOMER_MANUALLY_REVOKED"
        INTERNALSECURITYREASON   ResponseConsentReadDataRejectionReasonCode = "INTERNAL_SECURITY_REASON"
)

// Defines values for ResponseConsentReadDataStatus.
const (
        AUTHORISED            ResponseConsentReadDataStatus = "AUTHORISED"
        AWAITINGAUTHORISATION ResponseConsentReadDataStatus = "AWAITING_AUTHORISATION"
        REJECTED              ResponseConsentReadDataStatus = "REJECTED"
)

// Defines values for ResponseErrorUnprocessableEntityErrorsCode.
const (
        ResponseErrorUnprocessableEntityErrorsCodeCOMBINACAOPERMISSOESINCORRETA    ResponseErrorUnprocessableEntityErrorsCode = "COMBINACAO_PERMISSOES_INCORRETA"
        ResponseErrorUnprocessableEntityErrorsCodeDATAEXPIRACAOINVALIDA            ResponseErrorUnprocessableEntityErrorsCode = "DATA_EXPIRACAO_INVALIDA"
        ResponseErrorUnprocessableEntityErrorsCodeERRONAOMAPEADO                   ResponseErrorUnprocessableEntityErrorsCode = "ERRO_NAO_MAPEADO"
        ResponseErrorUnprocessableEntityErrorsCodeINFORMACOESPJNAOINFORMADAS       ResponseErrorUnprocessableEntityErrorsCode = "INFORMACOES_PJ_NAO_INFORMADAS"
        ResponseErrorUnprocessableEntityErrorsCodePERMISSAOPFPJEMCONJUNTO          ResponseErrorUnprocessableEntityErrorsCode = "PERMISSAO_PF_PJ_EM_CONJUNTO"
        ResponseErrorUnprocessableEntityErrorsCodePERMISSOESPJINCORRETAS           ResponseErrorUnprocessableEntityErrorsCode = "PERMISSOES_PJ_INCORRETAS"
        ResponseErrorUnprocessableEntityErrorsCodeSEMPERMISSOESFUNCIONAISRESTANTES ResponseErrorUnprocessableEntityErrorsCode = "SEM_PERMISSOES_FUNCIONAIS_RESTANTES"
)

// Defines values for ResponseErrorUnprocessableEntityDeleteErrorsCode.
const (
        CONSENTIMENTOEMSTATUSREJEITADO ResponseErrorUnprocessableEntityDeleteErrorsCode = "CONSENTIMENTO_EM_STATUS_REJEITADO"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
        Errors []struct {
                // Code Códigos de erros previstos na durante o processo de extensão do consentimento:
                //  - DEPENDE_MULTIPLA_ALCADA: Necessário aprovação de múltipla alçada.
                //  - ESTADO_CONSENTIMENTO_INVALIDO: Estado inválido do consentimento.
                //  - DATA_EXPIRACAO_INVALIDA: Nova data para expiração do consentimento é inválida.
                //  - ERRO_NAO_MAPEADO: Utilizado quando não houver um code de erro definido.
                Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

                // Detail Título específico do erro reportado, de acordo com o código enviado:
                // - DEPENDE_MULTIPLA_ALCADA: O consentimento informado não pode ser renovado sem redirecionamento porque depende de múltipla alçada para aprovação.
                // - ESTADO_CONSENTIMENTO_INVALIDO: O consentimento informado não pode ser renovado sem redirecionamento porque está em um estado que não permite a renovação.
                // - DATA_EXPIRACAO_INVALIDA: O consentimento informado não pode ser renovado pois a nova data de expiração não segue a convenção do ecossistema.
                // - ERRO_NAO_MAPEADO: Utilizado quando não houver um code de erro definido. O texto deve deixar claro o motivo do erro ocorrido.
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - DEPENDE_MULTIPLA_ALCADA: Necessário aprovação de múltipla alçada.
                // - ESTADO_CONSENTIMENTO_INVALIDO: Estado inválido do consentimento.
                // - DATA_EXPIRACAO_INVALIDA: Nova data para expiração do consentimento é inválida.
                // - ERRO_NAO_MAPEADO: Utilizado quando não houver um code de erro definido. O texto deve deixar claro o motivo do erro ocorrido.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na durante o processo de extensão do consentimento:
//   - DEPENDE_MULTIPLA_ALCADA: Necessário aprovação de múltipla alçada.
//   - ESTADO_CONSENTIMENTO_INVALIDO: Estado inválido do consentimento.
//   - DATA_EXPIRACAO_INVALIDA: Nova data para expiração do consentimento é inválida.
//   - ERRO_NAO_MAPEADO: Utilizado quando não houver um code de erro definido.
type N422ResponseErrorCreateConsentErrorsCode string

// BusinessEntity Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
//
// É obrigatório que o número do CNPJ utilizado seja um número válido. A transmissora pode utilizar algoritmos de validação de documento para garantir que se trata de um documento válido, como por exemplo: Cálculo de DV módulo 11 para o CNPJ.
type BusinessEntity struct {
        Document BusinessEntityDocument `json:"document"`
}

// BusinessEntityDocument defines model for BusinessEntityDocument.
type BusinessEntityDocument struct {
        // Identification Número do documento de identificação oficial do titular pessoa jurídica.
        Identification string `json:"identification"`

        // Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
        Rel string `json:"rel"`
}

// BusinessEntityDocumentExtensions defines model for BusinessEntityDocumentExtensions.
type BusinessEntityDocumentExtensions struct {
        // Identification Número do documento de identificação oficial do titular pessoa jurídica.
        Identification string `json:"identification"`

        // Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
        Rel string `json:"rel"`
}

// BusinessEntityExtensions Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
// Deve ser informado apenas para casos de consentimento pessoa jurídica.
// Não precisa ser armazenado separadamente. Para fins de renovação de consentimento, será utilizado apenas para verificação do consentimento vigente, pois é um atributo imutável.
type BusinessEntityExtensions struct {
        Document BusinessEntityDocumentExtensions `json:"document"`
}

// CreateConsent defines model for CreateConsent.
type CreateConsent struct {
        Data struct {
                // BusinessEntity Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
                //
                // É obrigatório que o número do CNPJ utilizado seja um número válido. A transmissora pode utilizar algoritmos de validação de documento para garantir que se trata de um documento válido, como por exemplo: Cálculo de DV módulo 11 para o CNPJ.
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de consentimento com prazo indeterminado o campo não deve ser enviado.
                // Quando preenchido, o valor do campo não pode ultrapassar 12 meses.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
                //
                // É obrigatório que o número do documento utilizado seja um número válido e pertencente ao usuário logado. A transmissora pode utilizar algoritmos de validação de documento para garantir que se trata de um documento válido, como por exemplo: Cálculo de DV módulo 11 para o CPF.
                LoggedUser  LoggedUser                     `json:"loggedUser"`
                Permissions []CreateConsentDataPermissions `json:"permissions"`
        } `json:"data"`
}

// CreateConsentDataPermissions Especifica os tipos de permissões de acesso às APIs no escopo do Open Finance Brasil - Dados cadastrais e transacionais, de acordo com os blocos de consentimento fornecidos pelo usuário e necessários ao acesso a cada endpoint das APIs. Esse array não deve ter duplicidade de itens.
type CreateConsentDataPermissions string

// CreateConsentExtensions defines model for CreateConsentExtensions.
type CreateConsentExtensions struct {
        Data struct {
                // BusinessEntity Titular, pessoa jurídica a quem se referem os dados que são objeto de compartilhamento.
                // Deve ser informado apenas para casos de consentimento pessoa jurídica.
                // Não precisa ser armazenado separadamente. Para fins de renovação de consentimento, será utilizado apenas para verificação do consentimento vigente, pois é um atributo imutável.
                BusinessEntity *BusinessEntityExtensions `json:"businessEntity,omitempty"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de consentimento com prazo indeterminado o campo não deve ser enviado.
                // Quando preenchido, o valor do campo não pode ultrapassar 12 meses.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
                // Deve ser armazenado como novo usuário logado responsável pela renovação do consentimento atual.
                LoggedUser LoggedUserExtensions `json:"loggedUser"`
        } `json:"data"`
}

// EnumRejectedBy Informar usuário responsável pela rejeição.
// 1. USER usuário
// 2. ASPSP instituição transmissora
// 3. TPP instituição receptora
type EnumRejectedBy string

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
//
// É obrigatório que o número do documento utilizado seja um número válido e pertencente ao usuário logado. A transmissora pode utilizar algoritmos de validação de documento para garantir que se trata de um documento válido, como por exemplo: Cálculo de DV módulo 11 para o CPF.
type LoggedUser struct {
        Document LoggedUserDocument `json:"document"`
}

// LoggedUserDocument defines model for LoggedUserDocument.
type LoggedUserDocument struct {
        // Identification Número do documento de identificação oficial do usuário.
        Identification string `json:"identification"`

        // Rel Tipo do documento de identificação oficial do usuário.
        Rel string `json:"rel"`
}

// LoggedUserDocumentExtensions defines model for LoggedUserDocumentExtensions.
type LoggedUserDocumentExtensions struct {
        // Identification Número do documento de identificação oficial do usuário.
        Identification string `json:"identification"`

        // Rel Tipo do documento de identificação oficial do usuário.
        Rel string `json:"rel"`
}

// LoggedUserExtensions Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
// Deve ser armazenado como novo usuário logado responsável pela renovação do consentimento atual.
type LoggedUserExtensions struct {
        Document LoggedUserDocumentExtensions `json:"document"`
}

// ResponseConsent defines model for ResponseConsent.
type ResponseConsent struct {
        Data struct {
                // ConsentID O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentID string `json:"consentId"`

                // CreationDateTime Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de consentimento com prazo indeterminado o campo não deve ser enviado.
                // Quando preenchido, o valor do campo não pode ultrapassar 12 meses.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // Permissions Especifica os tipos de permissões de acesso às APIs no escopo do Open Finance Brasil - Dados cadastrais e transacionais, de acordo com os blocos de consentimento fornecidos pelo usuário e necessários ao acesso a cada endpoint das APIs. Esse array não deve ter duplicidade de itens.
                Permissions []ResponseConsentDataPermissions `json:"permissions"`

                // Status Estado atual do consentimento cadastrado.
                Status ResponseConsentDataStatus `json:"status"`

                // StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// ResponseConsentDataPermissions defines model for ResponseConsent.Data.Permissions.
type ResponseConsentDataPermissions string

// ResponseConsentDataStatus Estado atual do consentimento cadastrado.
type ResponseConsentDataStatus string

// ResponseConsentExtensions defines model for ResponseConsentExtensions.
type ResponseConsentExtensions struct {
        Data struct {
                // ConsentID O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentID string `json:"consentId"`

                // CreationDateTime Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de consentimento com prazo indeterminado o campo não deve ser enviado.
                // Quando preenchido, o valor do campo não pode ultrapassar 12 meses.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // Permissions Especifica os tipos de permissões de acesso às APIs no escopo do Open Finance Brasil - Dados cadastrais e transacionais, de acordo com os blocos de consentimento fornecidos pelo usuário e necessários ao acesso a cada endpoint das APIs. Esse array não deve ter duplicidade de itens.
                Permissions []ResponseConsentExtensionsDataPermissions `json:"permissions"`

                // Status Estado atual do consentimento cadastrado.
                Status ResponseConsentExtensionsDataStatus `json:"status"`

                // StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// ResponseConsentExtensionsDataPermissions defines model for ResponseConsentExtensions.Data.Permissions.
type ResponseConsentExtensionsDataPermissions string

// ResponseConsentExtensionsDataStatus Estado atual do consentimento cadastrado.
type ResponseConsentExtensionsDataStatus string

// ResponseConsentRead defines model for ResponseConsentRead.
type ResponseConsentRead struct {
        Data struct {
                // ConsentID O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentID string `json:"consentId"`

                // CreationDateTime Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada. Em casos de consentimento com prazo indeterminado o campo não deve ser preenchido.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // Permissions Especifica os tipos de permissões de acesso às APIs no escopo do Open Finance Brasil - Dados cadastrais e transacionais, de acordo com os blocos de consentimento fornecidos pelo usuário e necessários ao acesso a cada endpoint das APIs. Esse array não deve ter duplicidade de itens.
                Permissions []ResponseConsentReadDataPermissions `json:"permissions"`

                // Rejection Objeto a ser retornado caso o consentimento seja rejeitado.
                Rejection *struct {
                        // Reason Define a razão pela qual o consentimento foi rejeitado.
                        Reason struct {
                                // AdditionalInformation Contém informações adicionais a critério da transmissora.
                                AdditionalInformation *string `json:"additionalInformation,omitempty"`

                                // Code Define o código da razão pela qual o consentimento foi rejeitado.
                                //
                                // - CONSENT_EXPIRED – consentimento que ultrapassou o tempo limite para autorização.
                                // - CUSTOMER_MANUALLY_REJECTED – cliente efetuou a rejeição do consentimento manualmente através de interação nas instituições participantes.
                                // - CUSTOMER_MANUALLY_REVOKED – cliente efetuou a revogação após a autorização do consentimento.
                                // - CONSENT_MAX_DATE_REACHED – consentimento que ultrapassou o tempo limite de compartilhamento.
                                // - CONSENT_TECHNICAL_ISSUE – consentimento que foi rejeitado devido a um problema técnico que impossibilita seu uso pela instituição receptora, por exemplo: falha associada a troca do AuthCode pelo AccessToken, durante o processo de Hybrid Flow.
                                // - INTERNAL_SECURITY_REASON – consentimento que foi rejeitado devido as políticas de segurança aplicada pela instituição transmissora.
                                Code ResponseConsentReadDataRejectionReasonCode `json:"code"`
                        } `json:"reason"`

                        // RejectedBy Informar usuário responsável pela rejeição.
                        // 1. USER usuário
                        // 2. ASPSP instituição transmissora
                        // 3. TPP instituição receptora
                        RejectedBy EnumRejectedBy `json:"rejectedBy"`
                } `json:"rejection,omitempty"`

                // Status Estado atual do consentimento cadastrado.
                Status ResponseConsentReadDataStatus `json:"status"`

                // StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// ResponseConsentReadDataPermissions defines model for ResponseConsentRead.Data.Permissions.
type ResponseConsentReadDataPermissions string

// ResponseConsentReadDataRejectionReasonCode Define o código da razão pela qual o consentimento foi rejeitado.
//
// - CONSENT_EXPIRED – consentimento que ultrapassou o tempo limite para autorização.
// - CUSTOMER_MANUALLY_REJECTED – cliente efetuou a rejeição do consentimento manualmente através de interação nas instituições participantes.
// - CUSTOMER_MANUALLY_REVOKED – cliente efetuou a revogação após a autorização do consentimento.
// - CONSENT_MAX_DATE_REACHED – consentimento que ultrapassou o tempo limite de compartilhamento.
// - CONSENT_TECHNICAL_ISSUE – consentimento que foi rejeitado devido a um problema técnico que impossibilita seu uso pela instituição receptora, por exemplo: falha associada a troca do AuthCode pelo AccessToken, durante o processo de Hybrid Flow.
// - INTERNAL_SECURITY_REASON – consentimento que foi rejeitado devido as políticas de segurança aplicada pela instituição transmissora.
type ResponseConsentReadDataRejectionReasonCode string

// ResponseConsentReadDataStatus Estado atual do consentimento cadastrado.
type ResponseConsentReadDataStatus string

// ResponseConsentReadExtensions defines model for ResponseConsentReadExtensions.
type ResponseConsentReadExtensions struct {
        Data []struct {
                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do consentimento. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format), utilizado apenas para consulta de alterações históricas de extensão do consentimento.
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                //
                // Em casos de consentimento com prazo indeterminada o campo não deve ser preenchido.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição receptora e que iniciará o processo de consentimento para compartilhamento de dados.
                // Deve ser armazenado como novo usuário logado responsável pela renovação do consentimento atual.
                LoggedUser LoggedUserExtensions `json:"loggedUser"`

                // PreviousExpirationDateTime Data e hora de expiração anteriores a renovação. Reflete a data limite anterior de validade do consentimento. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada. Em casos de consentimento com prazo indeterminado, ou renovações feitas com a v2.2.0 em que não exista persistência dessa informação, o campo não deve ser preenchido.
                PreviousExpirationDateTime *timeutil.DateTime `json:"previousExpirationDateTime,omitempty"`

                // RequestDateTime Data e hora em que o recurso foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                RequestDateTime timeutil.DateTime `json:"requestDateTime"`

                // XCustomerUserAgent Indica o user-agent que o usuário utilizou quando solicitou a renovação sem redirecionamento.
                //
                // [Restrição] De preenchimento obrigatório a partir da v3.0.0. Opcional para renovações feitas com a v2.2.0 quando não existir persistência dessa informação.
                XCustomerUserAgent *string `json:"xCustomerUserAgent,omitempty"`

                // XFapiCustomerIPAddress O endereço IP do usuário logado com o receptor que solicitou a renovação sem redirecionamento.
                //
                // [Restrição] De preenchimento obrigatório a partir da v3.0.0. Opcional para renovações feitas com a v2.2.0 quando não existir persistência dessa informação.
                XFapiCustomerIPAddress *string `json:"xFapiCustomerIpAddress,omitempty"`
        } `json:"data"`
        Links *api.Links `json:"links,omitempty"`
        Meta  *api.Meta  `json:"meta,omitempty"`
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorUnprocessableEntity defines model for ResponseErrorUnprocessableEntity.
type ResponseErrorUnprocessableEntity struct {
        Errors []struct {
                // Code - SEM_PERMISSOES_FUNCIONAIS_RESTANTES
                // - INFORMACOES_PJ_NAO_INFORMADAS
                // - PERMISSOES_PJ_INCORRETAS
                // - PERMISSAO_PF_PJ_EM_CONJUNTO
                // - COMBINACAO_PERMISSOES_INCORRETA
                // - DATA_EXPIRACAO_INVALIDA
                // - ERRO_NAO_MAPEADO
                //
                // A opção “ERRO_NAO_MAPEADO” só deve ser utilizada caso não haja um code especifico mapeado para o erro.
                Code ResponseErrorUnprocessableEntityErrorsCode `json:"code"`

                // Detail Descrição legível por humanos deste erro específico.
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorUnprocessableEntityErrorsCode - SEM_PERMISSOES_FUNCIONAIS_RESTANTES
// - INFORMACOES_PJ_NAO_INFORMADAS
// - PERMISSOES_PJ_INCORRETAS
// - PERMISSAO_PF_PJ_EM_CONJUNTO
// - COMBINACAO_PERMISSOES_INCORRETA
// - DATA_EXPIRACAO_INVALIDA
// - ERRO_NAO_MAPEADO
//
// A opção “ERRO_NAO_MAPEADO” só deve ser utilizada caso não haja um code especifico mapeado para o erro.
type ResponseErrorUnprocessableEntityErrorsCode string

// ResponseErrorUnprocessableEntityDelete defines model for ResponseErrorUnprocessableEntityDelete.
type ResponseErrorUnprocessableEntityDelete struct {
        Errors []struct {
                // Code - CONSENTIMENTO_EM_STATUS_REJEITADO
                Code ResponseErrorUnprocessableEntityDeleteErrorsCode `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseErrorUnprocessableEntityDeleteErrorsCode - CONSENTIMENTO_EM_STATUS_REJEITADO
type ResponseErrorUnprocessableEntityDeleteErrorsCode string

// Authorization defines model for Authorization.
type Authorization = string

// AuthorizationExtensions defines model for AuthorizationExtensions.
type AuthorizationExtensions = string

// ConsentID defines model for ConsentId.
type ConsentID = string

// Page defines model for Page.
type Page = int32

// PageSize defines model for PageSize.
type PageSize = int32

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XCustomerUserAgentExtensions defines model for xCustomerUserAgentExtensions.
type XCustomerUserAgentExtensions = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiCustomerIPAddressExtensions defines model for xFapiCustomerIpAddressExtensions.
type XFapiCustomerIPAddressExtensions = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200ConsentsConsentIDRead defines model for 200ConsentsConsentIdRead.
type N200ConsentsConsentIDRead = ResponseConsentRead

// N200ConsentsConsentIDReadExtensions defines model for 200ConsentsConsentIdReadExtensions.
type N200ConsentsConsentIDReadExtensions = ResponseConsentReadExtensions

// N201ConsentsCreated defines model for 201ConsentsCreated.
type N201ConsentsCreated = ResponseConsent

// N201ConsentsCreatedExtensions defines model for 201ConsentsCreatedExtensions.
type N201ConsentsCreatedExtensions = ResponseConsentExtensions

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`

        // Meta Meta informações referente a API requisitada.
        Meta *struct {
                // RequestDateTime Data e hora da consulta, conforme especificação RFC-3339, formato UTC.
                RequestDateTime timeutil.BrazilDate `json:"requestDateTime"`
        } `json:"meta,omitempty"`
}

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = ResponseErrorUnprocessableEntity

// UnprocessableEntityConsents defines model for UnprocessableEntityConsents.
type UnprocessableEntityConsents = N422ResponseErrorCreateConsent

// UnprocessableEntityDelete defines model for UnprocessableEntityDelete.
type UnprocessableEntityDelete = ResponseErrorUnprocessableEntityDelete

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// ConsentsPostConsentsParams defines parameters for ConsentsPostConsents.
type ConsentsPostConsentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID RFC4122 usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ConsentsDeleteConsentsConsentIDParams defines parameters for ConsentsDeleteConsentsConsentID.
type ConsentsDeleteConsentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID RFC4122 usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ConsentsGetConsentsConsentIDParams defines parameters for ConsentsGetConsentsConsentID.
type ConsentsGetConsentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID RFC4122 usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ConsentsPostConsentsConsentIDExtendsParams defines parameters for ConsentsPostConsentsConsentIDExtends.
type ConsentsPostConsentsConsentIDExtendsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization AuthorizationExtensions `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress XFapiCustomerIPAddressExtensions `json:"x-fapi-customer-ip-address"`

        // XFapiInteractionID Um UUID RFC4122 usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent XCustomerUserAgentExtensions `json:"x-customer-user-agent"`
}

// ConsentsGetConsentsConsentIDExtensionsParams defines parameters for ConsentsGetConsentsConsentIDExtensions.
type ConsentsGetConsentsConsentIDExtensionsParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas. A transmissora deve considerar entrada como 25, caso seja informado algum valor menor pela receptora. Enquanto houver mais que 25 registros a enviar, a transmissora deve considerar o mínimo por página como 25. Somente a última página retornada (ou primeira, no caso de página única) pode conter menos de 25 registros. Mais informações, acesse Especificações de APIs &gt; Padrões &gt; Paginação.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization AuthorizationExtensions `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID RFC4122 usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ConsentsPostConsentsJSONRequestBody defines body for ConsentsPostConsents for application/json ContentType.
type ConsentsPostConsentsJSONRequestBody = CreateConsent

// ConsentsPostConsentsConsentIDExtendsJSONRequestBody defines body for ConsentsPostConsentsConsentIDExtends for application/json ContentType.
type ConsentsPostConsentsConsentIDExtendsJSONRequestBody = CreateConsentExtensions

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Criar novo pedido de consentimento.
        // (POST /consents)
        ConsentsPostConsents(w http.ResponseWriter, r *http.Request, params ConsentsPostConsentsParams)
        // Deletar / Revogar o consentimento identificado por consentId.
        // (DELETE /consents/{consentId})
        ConsentsDeleteConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsDeleteConsentsConsentIDParams)
        // Obter detalhes do consentimento identificado por consentId.
        // (GET /consents/{consentId})
        ConsentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsGetConsentsConsentIDParams)
        // Renovar consentimento identificado por consentId.
        // (POST /consents/{consentId}/extends)
        ConsentsPostConsentsConsentIDExtends(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsPostConsentsConsentIDExtendsParams)
        // Obter detalhes de extensões feitas no consentimento identificado por consentId.
        // (GET /consents/{consentId}/extensions)
        ConsentsGetConsentsConsentIDExtensions(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsGetConsentsConsentIDExtensionsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ConsentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) ConsentsPostConsents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ConsentsPostConsentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ConsentsPostConsents(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// ConsentsDeleteConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) ConsentsDeleteConsentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ConsentsDeleteConsentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ConsentsDeleteConsentsConsentID(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// ConsentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) ConsentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ConsentsGetConsentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ConsentsGetConsentsConsentID(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// ConsentsPostConsentsConsentIDExtends operation middleware
func (siw *ServerInterfaceWrapper) ConsentsPostConsentsConsentIDExtends(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ConsentsPostConsentsConsentIDExtendsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization AuthorizationExtensions
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Required header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddressExtensions
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = XFapiCustomerIPAddress</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-customer-ip-address is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-customer-ip-address", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Required header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgentExtensions
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = XCustomerUserAgent</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-customer-user-agent is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-customer-user-agent", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ConsentsPostConsentsConsentIDExtends(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// ConsentsGetConsentsConsentIDExtensions operation middleware
func (siw *ServerInterfaceWrapper) ConsentsGetConsentsConsentIDExtensions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ConsentsGetConsentsConsentIDExtensionsParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization AuthorizationExtensions
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ConsentsGetConsentsConsentIDExtensions(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.ConsentsPostConsents)
        m.HandleFunc("DELETE "+options.BaseURL+"/consents/{consentId}", wrapper.ConsentsDeleteConsentsConsentID)
        m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.ConsentsGetConsentsConsentID)
        m.HandleFunc("POST "+options.BaseURL+"/consents/{consentId}/extends", wrapper.ConsentsPostConsentsConsentIDExtends)
        m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}/extensions", wrapper.ConsentsGetConsentsConsentIDExtensions)

        return m</span>
}

type N200ConsentsConsentIDReadJSONResponse ResponseConsentRead

type N200ConsentsConsentIDReadExtensionsJSONResponse ResponseConsentReadExtensions

type N201ConsentsCreatedJSONResponse ResponseConsent

type N201ConsentsCreatedExtensionsJSONResponse ResponseConsentExtensions

type N204ConsentsConsentIDDeletedResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`

        // Meta Meta informações referente a API requisitada.
        Meta *struct {
                // RequestDateTime Data e hora da consulta, conforme especificação RFC-3339, formato UTC.
                RequestDateTime timeutil.BrazilDate `json:"requestDateTime"`
        } `json:"meta,omitempty"`
}

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityApplicationJSONCharsetUTF8Response ResponseErrorUnprocessableEntity

type UnprocessableEntityConsentsApplicationJSONCharsetUTF8Response N422ResponseErrorCreateConsent

type UnprocessableEntityDeleteApplicationJSONCharsetUTF8Response ResponseErrorUnprocessableEntityDelete

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type ConsentsPostConsentsRequestObject struct {
        Params ConsentsPostConsentsParams
        Body   *ConsentsPostConsentsJSONRequestBody
}

type ConsentsPostConsentsResponseObject interface {
        VisitConsentsPostConsentsResponse(w http.ResponseWriter) error
}

type ConsentsPostConsents201JSONResponse struct {
        N201ConsentsCreatedJSONResponse
}

func (response ConsentsPostConsents201JSONResponse) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents422ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents429ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents504ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response ConsentsPostConsentsdefaultJSONResponse) VisitConsentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type ConsentsDeleteConsentsConsentIDRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    ConsentsDeleteConsentsConsentIDParams
}

type ConsentsDeleteConsentsConsentIDResponseObject interface {
        VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error
}

type ConsentsDeleteConsentsConsentID204Response = N204ConsentsConsentIDDeletedResponse

func (response ConsentsDeleteConsentsConsentID204Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type ConsentsDeleteConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityDeleteApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID422ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID429ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ConsentsDeleteConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsDeleteConsentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response ConsentsDeleteConsentsConsentIDdefaultJSONResponse) VisitConsentsDeleteConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type ConsentsGetConsentsConsentIDRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    ConsentsGetConsentsConsentIDParams
}

type ConsentsGetConsentsConsentIDResponseObject interface {
        VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type ConsentsGetConsentsConsentID200JSONResponse struct {
        N200ConsentsConsentIDReadJSONResponse
}

func (response ConsentsGetConsentsConsentID200JSONResponse) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID429ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID504ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response ConsentsGetConsentsConsentIDdefaultJSONResponse) VisitConsentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type ConsentsPostConsentsConsentIDExtendsRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    ConsentsPostConsentsConsentIDExtendsParams
        Body      *ConsentsPostConsentsConsentIDExtendsJSONRequestBody
}

type ConsentsPostConsentsConsentIDExtendsResponseObject interface {
        VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error
}

type ConsentsPostConsentsConsentIDExtends201JSONResponse struct {
        N201ConsentsCreatedExtensionsJSONResponse
}

func (response ConsentsPostConsentsConsentIDExtends201JSONResponse) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends400ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends401ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends403ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends404ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends405ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends406ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends415ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends422ApplicationJSONCharsetUTF8Response struct {
        UnprocessableEntityConsentsApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends422ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(422)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends429ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends500ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends504ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtends529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ConsentsPostConsentsConsentIDExtends529ApplicationJSONCharsetUTF8Response) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsPostConsentsConsentIDExtendsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response ConsentsPostConsentsConsentIDExtendsdefaultJSONResponse) VisitConsentsPostConsentsConsentIDExtendsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type ConsentsGetConsentsConsentIDExtensionsRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    ConsentsGetConsentsConsentIDExtensionsParams
}

type ConsentsGetConsentsConsentIDExtensionsResponseObject interface {
        VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error
}

type ConsentsGetConsentsConsentIDExtensions200JSONResponse struct {
        N200ConsentsConsentIDReadExtensionsJSONResponse
}

func (response ConsentsGetConsentsConsentIDExtensions200JSONResponse) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions400ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions401ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions403ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions404ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions405ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions406ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions429ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions500ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions504ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensions529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ConsentsGetConsentsConsentIDExtensions529ApplicationJSONCharsetUTF8Response) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ConsentsGetConsentsConsentIDExtensionsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response ConsentsGetConsentsConsentIDExtensionsdefaultJSONResponse) VisitConsentsGetConsentsConsentIDExtensionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Criar novo pedido de consentimento.
        // (POST /consents)
        ConsentsPostConsents(ctx context.Context, request ConsentsPostConsentsRequestObject) (ConsentsPostConsentsResponseObject, error)
        // Deletar / Revogar o consentimento identificado por consentId.
        // (DELETE /consents/{consentId})
        ConsentsDeleteConsentsConsentID(ctx context.Context, request ConsentsDeleteConsentsConsentIDRequestObject) (ConsentsDeleteConsentsConsentIDResponseObject, error)
        // Obter detalhes do consentimento identificado por consentId.
        // (GET /consents/{consentId})
        ConsentsGetConsentsConsentID(ctx context.Context, request ConsentsGetConsentsConsentIDRequestObject) (ConsentsGetConsentsConsentIDResponseObject, error)
        // Renovar consentimento identificado por consentId.
        // (POST /consents/{consentId}/extends)
        ConsentsPostConsentsConsentIDExtends(ctx context.Context, request ConsentsPostConsentsConsentIDExtendsRequestObject) (ConsentsPostConsentsConsentIDExtendsResponseObject, error)
        // Obter detalhes de extensões feitas no consentimento identificado por consentId.
        // (GET /consents/{consentId}/extensions)
        ConsentsGetConsentsConsentIDExtensions(ctx context.Context, request ConsentsGetConsentsConsentIDExtensionsRequestObject) (ConsentsGetConsentsConsentIDExtensionsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// ConsentsPostConsents operation middleware
func (sh *strictHandler) ConsentsPostConsents(w http.ResponseWriter, r *http.Request, params ConsentsPostConsentsParams) <span class="cov0" title="0">{
        var request ConsentsPostConsentsRequestObject

        request.Params = params

        var body ConsentsPostConsentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConsentsPostConsents(ctx, request.(ConsentsPostConsentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConsentsPostConsents")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConsentsPostConsentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitConsentsPostConsentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// ConsentsDeleteConsentsConsentID operation middleware
func (sh *strictHandler) ConsentsDeleteConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsDeleteConsentsConsentIDParams) <span class="cov0" title="0">{
        var request ConsentsDeleteConsentsConsentIDRequestObject

        request.ConsentID = consentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConsentsDeleteConsentsConsentID(ctx, request.(ConsentsDeleteConsentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConsentsDeleteConsentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConsentsDeleteConsentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitConsentsDeleteConsentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// ConsentsGetConsentsConsentID operation middleware
func (sh *strictHandler) ConsentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsGetConsentsConsentIDParams) <span class="cov0" title="0">{
        var request ConsentsGetConsentsConsentIDRequestObject

        request.ConsentID = consentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConsentsGetConsentsConsentID(ctx, request.(ConsentsGetConsentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConsentsGetConsentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConsentsGetConsentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitConsentsGetConsentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// ConsentsPostConsentsConsentIDExtends operation middleware
func (sh *strictHandler) ConsentsPostConsentsConsentIDExtends(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsPostConsentsConsentIDExtendsParams) <span class="cov0" title="0">{
        var request ConsentsPostConsentsConsentIDExtendsRequestObject

        request.ConsentID = consentID
        request.Params = params

        var body ConsentsPostConsentsConsentIDExtendsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConsentsPostConsentsConsentIDExtends(ctx, request.(ConsentsPostConsentsConsentIDExtendsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConsentsPostConsentsConsentIDExtends")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConsentsPostConsentsConsentIDExtendsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitConsentsPostConsentsConsentIDExtendsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// ConsentsGetConsentsConsentIDExtensions operation middleware
func (sh *strictHandler) ConsentsGetConsentsConsentIDExtensions(w http.ResponseWriter, r *http.Request, consentID ConsentID, params ConsentsGetConsentsConsentIDExtensionsParams) <span class="cov0" title="0">{
        var request ConsentsGetConsentsConsentIDExtensionsRequestObject

        request.ConsentID = consentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ConsentsGetConsentsConsentIDExtensions(ctx, request.(ConsentsGetConsentsConsentIDExtensionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ConsentsGetConsentsConsentIDExtensions")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ConsentsGetConsentsConsentIDExtensionsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitConsentsGetConsentsConsentIDExtensionsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=enrollmentv2 -o=./api_gen.go ./swagger.yml
package enrollmentv2

import (
        "context"
        "crypto"
        "encoding/json"
        "errors"
        "net/http"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/enrollment"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/idempotency"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var _ StrictServerInterface = Server{}

type BankConfig interface {
        Host() string
        ISPB() string
        IBGETownCode() string
        AccountBranch() string
}

type Server struct {
        config             BankConfig
        baseURL            string
        service            enrollment.Service
        idempotencyService idempotency.Service
        op                 *provider.Provider
        keystoreHost       string
        orgID              string
        signer             crypto.Signer
}

func NewServer(
        config BankConfig,
        service enrollment.Service,
        idempotencyService idempotency.Service,
        op *provider.Provider,
        keystoreHost string,
        orgID string,
        signer crypto.Signer,
) Server <span class="cov0" title="0">{
        service = service.WithVersion("v2")
        return Server{
                config:             config,
                baseURL:            config.Host() + "/open-banking/enrollments/v2",
                service:            service,
                idempotencyService: idempotencyService,
                op:                 op,
                keystoreHost:       keystoreHost,
                orgID:              orgID,
                signer:             signer,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        enrollmentMux := http.NewServeMux()

        jwtMiddleware := middleware.JWT(s.baseURL, s.orgID, s.keystoreHost, s.signer)
        idempotencyMiddleware := middleware.Idempotency(s.idempotencyService)
        clientCredentialsAuthMiddleware := middleware.Auth(s.op, goidc.GrantClientCredentials, payment.Scope)
        authCodeAuthMiddleware := middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID, enrollment.ScopeID, enrollment.ScopeConsent, payment.Scope)
        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{
                var schemaErr *openapi3.SchemaError
                if errors.As(err, &amp;schemaErr) &amp;&amp; schemaErr.SchemaField == "required" </span><span class="cov0" title="0">{
                        return "PARAMETRO_NAO_INFORMADO"
                }</span>
                <span class="cov0" title="0">return "PARAMETRO_INVALIDO"</span>
        })

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err)
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{swaggerMiddleware},
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.PostEnrollments)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = middleware.CertCN(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        enrollmentMux.Handle("POST /enrollments", handler)

        handler = http.HandlerFunc(wrapper.GetEnrollment)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        enrollmentMux.Handle("GET /enrollments/{enrollmentId}", handler)

        handler = http.HandlerFunc(wrapper.RiskSignals)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        enrollmentMux.Handle("POST /enrollments/{enrollmentId}/risk-signals", handler)

        handler = http.HandlerFunc(wrapper.EnrollmentCreateFidoRegistrationOptions)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = authCodeAuthMiddleware(handler)
        enrollmentMux.Handle("POST /enrollments/{enrollmentId}/fido-registration-options", handler)

        handler = http.HandlerFunc(wrapper.EnrollmentRegisterFidoCredential)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = authCodeAuthMiddleware(handler)
        enrollmentMux.Handle("POST /enrollments/{enrollmentId}/fido-registration", handler)

        handler = http.HandlerFunc(wrapper.EnrollmentCreateFidoSigningOptions)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        enrollmentMux.Handle("POST /enrollments/{enrollmentId}/fido-sign-options", handler)

        handler = http.HandlerFunc(wrapper.AuthorizeConsent)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = authCodeAuthMiddleware(handler)
        enrollmentMux.Handle("POST /consents/{consentId}/authorise", handler)

        handler = http.HandlerFunc(wrapper.DeleteEnrollment)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        enrollmentMux.Handle("PATCH /enrollments/{enrollmentId}", handler)

        handler = middleware.FAPIID(nil)(enrollmentMux)
        mux.Handle("/open-banking/enrollments/v2/", http.StripPrefix("/open-banking/enrollments/v2", handler))</span>
}

func (s Server) PostEnrollments(ctx context.Context, req PostEnrollmentsRequestObject) (PostEnrollmentsResponseObject, error) <span class="cov0" title="0">{
        clientID := ctx.Value(api.CtxKeyClientID).(string)
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        certCN := ctx.Value(api.CtxKeyCertCN).(string)

        e := &amp;enrollment.Enrollment{
                UserIdentification: req.Body.Data.LoggedUser.Document.Identification,
                UserRel:            consent.Relation(req.Body.Data.LoggedUser.Document.Rel),
                Name:               req.Body.Data.EnrollmentName,
                Permissions:        req.Body.Data.Permissions,
                RelyingParty:       certCN,
                ClientID:           clientID,
                OrgID:              orgID,
        }

        if req.Body.Data.BusinessEntity != nil </span><span class="cov0" title="0">{
                rel := consent.Relation(req.Body.Data.BusinessEntity.Document.Rel)
                e.BusinessIdentification = &amp;req.Body.Data.BusinessEntity.Document.Identification
                e.BusinessRel = &amp;rel
        }</span>

        <span class="cov0" title="0">var debtorAccount *payment.Account
        if req.Body.Data.DebtorAccount != nil </span><span class="cov0" title="0">{
                debtorAccount = &amp;payment.Account{
                        ISPB:   req.Body.Data.DebtorAccount.Ispb,
                        Issuer: req.Body.Data.DebtorAccount.Issuer,
                        Number: req.Body.Data.DebtorAccount.Number,
                        Type:   payment.AccountType(req.Body.Data.DebtorAccount.AccountType),
                }
        }</span>

        <span class="cov0" title="0">if err := s.service.Create(ctx, e, debtorAccount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseCreateEnrollment{
                Data: struct {
                        BusinessEntity       *BusinessEntity            "json:\"businessEntity,omitempty\""
                        CreationDateTime     timeutil.DateTime          "json:\"creationDateTime\""
                        DebtorAccount        *DebtorAccount             "json:\"debtorAccount,omitempty\""
                        EnrollmentID         EnrollmentID               "json:\"enrollmentId\""
                        EnrollmentName       *string                    "json:\"enrollmentName,omitempty\""
                        ExpirationDateTime   *timeutil.DateTime         "json:\"expirationDateTime,omitempty\""
                        LoggedUser           LoggedUser                 "json:\"loggedUser\""
                        Permissions          []EnumEnrollmentPermission "json:\"permissions\""
                        Status               EnumEnrollmentStatus       "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime          "json:\"statusUpdateDateTime\""
                }{
                        CreationDateTime:   e.CreatedAt,
                        EnrollmentID:       EnrollmentID(e.URN()),
                        EnrollmentName:     e.Name,
                        ExpirationDateTime: e.ExpiresAt,
                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: e.UserIdentification,
                                        Rel:            string(e.UserRel),
                                },
                        },
                        Status:               EnumEnrollmentStatus(e.Status),
                        StatusUpdateDateTime: e.StatusUpdatedAt,
                },
                Links: *api.NewLinks(s.baseURL + "/enrollments/" + e.URN()),
                Meta:  *api.NewMeta(),
        }

        for _, p := range e.Permissions </span><span class="cov0" title="0">{
                resp.Data.Permissions = append(resp.Data.Permissions, EnumEnrollmentPermission(p))
        }</span>

        <span class="cov0" title="0">if e.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *e.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *e.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if e.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;DebtorAccount{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      e.DebtorAccount.Number,
                        AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(e.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">return PostEnrollments201JSONResponse{N201EnrollmentsCreatedJSONResponse(resp)}, nil</span>
}

func (s Server) GetEnrollment(ctx context.Context, req GetEnrollmentRequestObject) (GetEnrollmentResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        e, err := s.service.Enrollment(ctx, enrollment.Query{ID: string(req.EnrollmentID), LoadDebtorAccount: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseEnrollment{
                Data: struct {
                        BusinessEntity *BusinessEntity "json:\"businessEntity,omitempty\""
                        Cancellation   *struct {
                                AdditionalInformation *string "json:\"additionalInformation,omitempty\""
                                CancelledBy           *struct {
                                        Document struct {
                                                Identification string "json:\"identification\""
                                                Rel            string "json:\"rel\""
                                        } "json:\"document\""
                                } "json:\"cancelledBy,omitempty\""
                                CancelledFrom EnumEnrollmentCancelledFrom                 "json:\"cancelledFrom\""
                                Reason        ResponseEnrollment_Data_Cancellation_Reason "json:\"reason\""
                                RejectedAt    *timeutil.DateTime                          "json:\"rejectedAt,omitempty\""
                        } "json:\"cancellation,omitempty\""
                        CreationDateTime timeutil.DateTime "json:\"creationDateTime\""
                        DailyLimit       *string           "json:\"dailyLimit,omitempty\""
                        DebtorAccount    *struct {
                                AccountType EnumAccountPaymentsType "json:\"accountType\""
                                Ispb        string                  "json:\"ispb\""
                                Issuer      *string                 "json:\"issuer,omitempty\""
                                Number      string                  "json:\"number\""
                        } "json:\"debtorAccount,omitempty\""
                        EnrollmentID         EnrollmentID               "json:\"enrollmentId\""
                        EnrollmentName       *string                    "json:\"enrollmentName,omitempty\""
                        ExpirationDateTime   *timeutil.DateTime         "json:\"expirationDateTime,omitempty\""
                        LoggedUser           LoggedUser                 "json:\"loggedUser\""
                        Permissions          []EnumEnrollmentPermission "json:\"permissions\""
                        Status               EnumEnrollmentStatus       "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime          "json:\"statusUpdateDateTime\""
                        TransactionLimit     *string                    "json:\"transactionLimit,omitempty\""
                }{
                        CreationDateTime:   e.CreatedAt,
                        EnrollmentID:       EnrollmentID(e.URN()),
                        EnrollmentName:     e.Name,
                        ExpirationDateTime: e.ExpiresAt,
                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: e.UserIdentification,
                                        Rel:            string(e.UserRel),
                                },
                        },
                        Status:               EnumEnrollmentStatus(e.Status),
                        StatusUpdateDateTime: e.StatusUpdatedAt,
                        TransactionLimit:     e.TransactionLimit,
                        DailyLimit:           e.DailyLimit,
                },
                Links: *api.NewLinks(s.baseURL + "/enrollments/" + e.URN()),
                Meta:  *api.NewMeta(),
        }

        for _, p := range e.Permissions </span><span class="cov0" title="0">{
                resp.Data.Permissions = append(resp.Data.Permissions, EnumEnrollmentPermission(p))
        }</span>

        <span class="cov0" title="0">if e.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *e.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *e.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if e.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;struct {
                        AccountType EnumAccountPaymentsType "json:\"accountType\""
                        Ispb        string                  "json:\"ispb\""
                        Issuer      *string                 "json:\"issuer,omitempty\""
                        Number      string                  "json:\"number\""
                }{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      e.DebtorAccount.Number,
                        AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(e.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">if cancellation := e.Cancellation; cancellation != nil </span><span class="cov0" title="0">{
                resp.Data.Cancellation = &amp;struct {
                        AdditionalInformation *string "json:\"additionalInformation,omitempty\""
                        CancelledBy           *struct {
                                Document struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                } "json:\"document\""
                        } "json:\"cancelledBy,omitempty\""
                        CancelledFrom EnumEnrollmentCancelledFrom                 "json:\"cancelledFrom\""
                        Reason        ResponseEnrollment_Data_Cancellation_Reason "json:\"reason\""
                        RejectedAt    *timeutil.DateTime                          "json:\"rejectedAt,omitempty\""
                }{
                        AdditionalInformation: cancellation.AdditionalInfo,
                        CancelledFrom:         EnumEnrollmentCancelledFrom(cancellation.From),
                        RejectedAt:            cancellation.At,
                }

                if cancellation.By != nil </span><span class="cov0" title="0">{
                        resp.Data.Cancellation.CancelledBy = &amp;struct {
                                Document struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                } "json:\"document\""
                        }{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: *cancellation.By,
                                        Rel:            string(consent.RelationCPF),
                                },
                        }
                }</span>

                <span class="cov0" title="0">reason := ResponseEnrollment_Data_Cancellation_Reason{}
                if cancellation.RejectionReason != nil </span><span class="cov0" title="0">{
                        reason.FromResponseEnrollmentDataCancellationReason0(ResponseEnrollmentDataCancellationReason0{
                                RejectionReason: EnrollmentRejectionReason(*cancellation.RejectionReason),
                        })
                }</span>
                <span class="cov0" title="0">if cancellation.RevocationReason != nil </span><span class="cov0" title="0">{
                        reason.FromResponseEnrollmentDataCancellationReason1(ResponseEnrollmentDataCancellationReason1{
                                RevocationReason: EnrollmentRevocationReason(*cancellation.RevocationReason),
                        })
                }</span>

                <span class="cov0" title="0">resp.Data.Cancellation.Reason = reason</span>
        }

        <span class="cov0" title="0">return GetEnrollment200JSONResponse{N200EnrollmentsEnrollmentIDReadJSONResponse(resp)}, nil</span>
}

func (s Server) RiskSignals(ctx context.Context, req RiskSignalsRequestObject) (RiskSignalsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)

        if err := s.service.AddRiskSignals(ctx, req.EnrollmentID, orgID, req.Body.Data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return RiskSignals204Response{}, nil</span>
}

func (s Server) EnrollmentCreateFidoRegistrationOptions(ctx context.Context, req EnrollmentCreateFidoRegistrationOptionsRequestObject) (EnrollmentCreateFidoRegistrationOptionsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)

        e, err := s.service.InitRegistration(ctx, req.EnrollmentID, orgID, enrollment.FIDOOptions{
                RelyingParty: req.Body.Data.Rp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">timeout := int(enrollment.CredentialRegistrationTimeout.Seconds())
        resp := EnrollmentFidoRegistrationOptions{
                Data: struct {
                        Attestation            *string                                  "json:\"attestation,omitempty\""
                        AttestationFormats     *[]string                                "json:\"attestationFormats,omitempty\""
                        AuthenticatorSelection *FidoAuthenticatorSelectionCriteria      "json:\"authenticatorSelection,omitempty\""
                        Challenge              string                                   "json:\"challenge\""
                        EnrollmentID           EnrollmentID                             "json:\"enrollmentId\""
                        ExcludeCredentials     *[]FidoPublicKeyCredentialDescriptor     "json:\"excludeCredentials,omitempty\""
                        Extensions             *map[string]any                          "json:\"extensions,omitempty\""
                        PubKeyCredParams       []FidoPublicKeyCredentialCreationOptions "json:\"pubKeyCredParams\""
                        Rp                     FidoRelyingParty                         "json:\"rp\""
                        Timeout                *int                                     "json:\"timeout,omitempty\""
                        User                   FidoUser                                 "json:\"user\""
                }{
                        EnrollmentID: EnrollmentID(e.URN()),
                        Rp: FidoRelyingParty{
                                ID:   e.RelyingParty,
                                Name: e.Client.Name,
                        },
                        Timeout: &amp;timeout,
                        User: FidoUser{
                                DisplayName: e.Owner.Name,
                                ID:          e.Owner.ID.String(),
                                Name:        e.Owner.Username,
                        },
                },
                Meta: *api.NewMeta(),
        }

        if e.Challenge != nil </span><span class="cov0" title="0">{
                resp.Data.Challenge = *e.Challenge
        }</span>

        <span class="cov0" title="0">for _, p := range enrollment.PublicKeyCredentialParameters </span><span class="cov0" title="0">{
                resp.Data.PubKeyCredParams = append(resp.Data.PubKeyCredParams, FidoPublicKeyCredentialCreationOptions{
                        Type: string(p.Type),
                        Alg:  int(p.Algorithm),
                })
        }</span>

        <span class="cov0" title="0">return EnrollmentCreateFidoRegistrationOptions201JSONResponse{N201EnrollmentFidoRegistrationOptionsJSONResponse(resp)}, nil</span>
}

func (s Server) AuthorizeConsent(ctx context.Context, req AuthorizeConsentRequestObject) (AuthorizeConsentResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        assertion := enrollment.FIDOAssertion{
                ID:    req.Body.Data.FidoAssertion.ID,
                RawID: req.Body.Data.FidoAssertion.RawID,
                Type:  req.Body.Data.FidoAssertion.Type,
                Response: struct {
                        ClientDataJSON    string "json:\"clientDataJSON,omitempty\""
                        AuthenticatorData string "json:\"authenticatorData,omitempty\""
                        Signature         string "json:\"signature,omitempty\""
                        UserHandle        string "json:\"userHandle,omitempty\""
                }{
                        ClientDataJSON:    req.Body.Data.FidoAssertion.Response.ClientDataJSON,
                        AuthenticatorData: req.Body.Data.FidoAssertion.Response.AuthenticatorData,
                        Signature:         req.Body.Data.FidoAssertion.Response.Signature,
                        UserHandle:        req.Body.Data.FidoAssertion.Response.UserHandle,
                },
        }
        if err := s.service.AuthorizeConsent(
                ctx,
                req.ParameterConsentID,
                req.Body.Data.EnrollmentID,
                orgID,
                assertion,
        ); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return AuthorizeConsent204Response{}, nil</span>
}

func (s Server) DeleteEnrollment(ctx context.Context, req DeleteEnrollmentRequestObject) (DeleteEnrollmentResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        cancellation := enrollment.Cancellation{
                From:           payment.CancelledFromInitiator,
                AdditionalInfo: req.Body.Data.Cancellation.AdditionalInformation,
        }
        if by := req.Body.Data.Cancellation.CancelledBy; by != nil </span><span class="cov0" title="0">{
                cancellation.By = &amp;by.Document.Identification
        }</span>
        <span class="cov0" title="0">if rejection, err := req.Body.Data.Cancellation.Reason.AsDeleteEnrollmentJSONBodyDataCancellationReason0(); err == nil &amp;&amp; rejection.RejectionReason != "" </span><span class="cov0" title="0">{
                reason := enrollment.RejectionReason(rejection.RejectionReason)
                cancellation.RejectionReason = &amp;reason
        }</span>
        <span class="cov0" title="0">if revocation, err := req.Body.Data.Cancellation.Reason.AsDeleteEnrollmentJSONBodyDataCancellationReason1(); err == nil &amp;&amp; revocation.RevocationReason != "" </span><span class="cov0" title="0">{
                reason := enrollment.RevocationReason(revocation.RevocationReason)
                cancellation.RevocationReason = &amp;reason
        }</span>

        <span class="cov0" title="0">if err := s.service.CancelByID(ctx, req.EnrollmentID, orgID, cancellation); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return DeleteEnrollment204Response{}, nil</span>
}

func (s Server) EnrollmentRegisterFidoCredential(ctx context.Context, request EnrollmentRegisterFidoCredentialRequestObject) (EnrollmentRegisterFidoCredentialResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        credentialType := "public-key"
        if request.Body.Data.Type != nil </span><span class="cov0" title="0">{
                credentialType = *request.Body.Data.Type
        }</span>
        <span class="cov0" title="0">if err := s.service.RegisterCredential(ctx, request.EnrollmentID, orgID, enrollment.Credential{
                ID:    request.Body.Data.ID,
                RawID: request.Body.Data.RawID,
                Type:  credentialType,
                Response: struct {
                        ClientDataJSON    string "json:\"clientDataJSON,omitempty\""
                        AttestationObject string "json:\"attestationObject,omitempty\""
                }{
                        ClientDataJSON:    request.Body.Data.Response.ClientDataJSON,
                        AttestationObject: request.Body.Data.Response.AttestationObject,
                },
        }); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return EnrollmentRegisterFidoCredential204Response{}, nil</span>
}

func (s Server) EnrollmentCreateFidoSigningOptions(ctx context.Context, req EnrollmentCreateFidoSigningOptionsRequestObject) (EnrollmentCreateFidoSigningOptionsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)

        challenge, err := s.service.InitAuthorization(ctx, req.Body.Data.ConsentIDType, req.EnrollmentID, orgID, enrollment.FIDOOptions{
                RelyingParty: req.Body.Data.Rp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := EnrollmentFidoSignOptions{
                Data: struct {
                        AllowCredentials *[]FidoPublicKeyCredentialDescriptor "json:\"allowCredentials,omitempty\""
                        Challenge        string                               "json:\"challenge\""
                        Extensions       *map[string]any                      "json:\"extensions,omitempty\""
                        RpID             *string                              "json:\"rpId,omitempty\""
                        Timeout          *int32                               "json:\"timeout,omitempty\""
                        UserVerification *string                              "json:\"userVerification,omitempty\""
                }{
                        RpID:      &amp;req.Body.Data.Rp,
                        Challenge: challenge,
                },
                Meta: *api.NewMeta(),
        }

        return EnrollmentCreateFidoSigningOptions201JSONResponse{N201EnrollmentFidoSignOptionsJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        if errors.Is(err, enrollment.ErrMissingValue) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_NAO_INFORMADO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidData) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidPermissions) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PERMISSOES_INVALIDAS", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidPublicKey) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PUBLIC_KEY_INVALIDA", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidStatus) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("STATUS_VINCULO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidOrigin) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("ORIGEM_FIDO_INVALIDA", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidRelyingParty) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("RP_INVALIDA", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, enrollment.ErrInvalidAssertion) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("RISCO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrInvalidConsentStatus) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("STATUS_CONSENTIMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, autopayment.ErrInvalidConsentStatus) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("STATUS_CONSENTIMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;errorutil.Error{}) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}

func (t DeleteEnrollmentJSONBody_Data_Cancellation_Reason) AsDeleteEnrollmentJSONBodyDataCancellationReason0() (DeleteEnrollmentJSONBodyDataCancellationReason0, error) <span class="cov0" title="0">{
        var body DeleteEnrollmentJSONBodyDataCancellationReason0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

func (t DeleteEnrollmentJSONBody_Data_Cancellation_Reason) AsDeleteEnrollmentJSONBodyDataCancellationReason1() (DeleteEnrollmentJSONBodyDataCancellationReason1, error) <span class="cov0" title="0">{
        var body DeleteEnrollmentJSONBodyDataCancellationReason1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

func (t DeleteEnrollmentJSONBody_Data_Cancellation_Reason) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *DeleteEnrollmentJSONBody_Data_Cancellation_Reason) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>
</pre>

		<pre class="file" id="file12" style="display: none">//go:build go1.22

// Package enrollmentv2 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package enrollmentv2

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/enrollment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        OAuth2AuthorizationCodeScopes = "OAuth2AuthorizationCode.Scopes"
        OAuth2ClientCredentialsScopes = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseConsentsAuthorizationErrorsCode.
const (
        N422ResponseConsentsAuthorizationErrorsCodeCONTADEBITODIVERGENTECONSENTIMENTOVINCULO N422ResponseConsentsAuthorizationErrorsCode = "CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO"
        N422ResponseConsentsAuthorizationErrorsCodeERROIDEMPOTENCIA                          N422ResponseConsentsAuthorizationErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseConsentsAuthorizationErrorsCodeFALTAMSINAISOBRIGATORIOSDAPLATAFORMA      N422ResponseConsentsAuthorizationErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
        N422ResponseConsentsAuthorizationErrorsCodePARAMETROINVALIDO                         N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseConsentsAuthorizationErrorsCodePARAMETRONAOINFORMADO                     N422ResponseConsentsAuthorizationErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseConsentsAuthorizationErrorsCodeRISCO                                     N422ResponseConsentsAuthorizationErrorsCode = "RISCO"
        N422ResponseConsentsAuthorizationErrorsCodeSTATUSCONSENTIMENTOINVALIDO               N422ResponseConsentsAuthorizationErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
        N422ResponseConsentsAuthorizationErrorsCodeSTATUSVINCULOINVALIDO                     N422ResponseConsentsAuthorizationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorCancelEnrollmentErrorsCode.
const (
        N422ResponseErrorCancelEnrollmentErrorsCodeERROIDEMPOTENCIA          N422ResponseErrorCancelEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREJEICAO            N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REJEICAO"
        N422ResponseErrorCancelEnrollmentErrorsCodeMOTIVOREVOGACAO           N422ResponseErrorCancelEnrollmentErrorsCode = "MOTIVO_REVOGACAO"
        N422ResponseErrorCancelEnrollmentErrorsCodePARAMETROINVALIDO         N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorCancelEnrollmentErrorsCodePARAMETRONAOINFORMADO     N422ResponseErrorCancelEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorCancelEnrollmentErrorsCodeREJEITADOOUTROSEMDETALHES N422ResponseErrorCancelEnrollmentErrorsCode = "REJEITADO_OUTRO_SEM_DETALHES"
        N422ResponseErrorCancelEnrollmentErrorsCodeREVOGADOOUTROSEMDETALHES  N422ResponseErrorCancelEnrollmentErrorsCode = "REVOGADO_OUTRO_SEM_DETALHES"
        N422ResponseErrorCancelEnrollmentErrorsCodeSTATUSINVALIDO            N422ResponseErrorCancelEnrollmentErrorsCode = "STATUS_INVALIDO"
)

// Defines values for N422ResponseErrorCreateEnrollmentErrorsCode.
const (
        N422ResponseErrorCreateEnrollmentErrorsCodeCONTAINVALIDA         N422ResponseErrorCreateEnrollmentErrorsCode = "CONTA_INVALIDA"
        N422ResponseErrorCreateEnrollmentErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorCreateEnrollmentErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorCreateEnrollmentErrorsCodePARAMETROINVALIDO     N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorCreateEnrollmentErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorCreateEnrollmentErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorCreateEnrollmentErrorsCodePERMISSOESINVALIDAS   N422ResponseErrorCreateEnrollmentErrorsCode = "PERMISSOES_INVALIDAS"
)

// Defines values for N422ResponseErrorFidoRegistrationErrorsCode.
const (
        N422ResponseErrorFidoRegistrationErrorsCodeCHALLENGEINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "CHALLENGE_INVALIDO"
        N422ResponseErrorFidoRegistrationErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorFidoRegistrationErrorsCodeEXTENSIONINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "EXTENSION_INVALIDA"
        N422ResponseErrorFidoRegistrationErrorsCodeORIGEMFIDOINVALIDA    N422ResponseErrorFidoRegistrationErrorsCode = "ORIGEM_FIDO_INVALIDA"
        N422ResponseErrorFidoRegistrationErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorFidoRegistrationErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorFidoRegistrationErrorsCodePUBLICKEYINVALIDA     N422ResponseErrorFidoRegistrationErrorsCode = "PUBLIC_KEY_INVALIDA"
        N422ResponseErrorFidoRegistrationErrorsCodeRPIDHASHINVALIDO      N422ResponseErrorFidoRegistrationErrorsCode = "RP_ID_HASH_INVALIDO"
        N422ResponseErrorFidoRegistrationErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoRegistrationOptionsErrorsCode.
const (
        N422ResponseErrorFidoRegistrationOptionsErrorsCodeERROIDEMPOTENCIA      N422ResponseErrorFidoRegistrationOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETROINVALIDO     N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorFidoRegistrationOptionsErrorsCodePARAMETRONAOINFORMADO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorFidoRegistrationOptionsErrorsCodeRPINVALIDA            N422ResponseErrorFidoRegistrationOptionsErrorsCode = "RP_INVALIDA"
        N422ResponseErrorFidoRegistrationOptionsErrorsCodeSTATUSVINCULOINVALIDO N422ResponseErrorFidoRegistrationOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorFidoSignOptionsErrorsCode.
const (
        N422ResponseErrorFidoSignOptionsErrorsCodeERROIDEMPOTENCIA            N422ResponseErrorFidoSignOptionsErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorFidoSignOptionsErrorsCodePARAMETROINVALIDO           N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorFidoSignOptionsErrorsCodePARAMETRONAOINFORMADO       N422ResponseErrorFidoSignOptionsErrorsCode = "PARAMETRO_NAO_INFORMADO"
        N422ResponseErrorFidoSignOptionsErrorsCodeRPINVALIDA                  N422ResponseErrorFidoSignOptionsErrorsCode = "RP_INVALIDA"
        N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSCONSENTIMENTOINVALIDO N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_CONSENTIMENTO_INVALIDO"
        N422ResponseErrorFidoSignOptionsErrorsCodeSTATUSVINCULOINVALIDO       N422ResponseErrorFidoSignOptionsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for N422ResponseErrorRiskSignalsErrorsCode.
const (
        ERROIDEMPOTENCIA                     N422ResponseErrorRiskSignalsErrorsCode = "ERRO_IDEMPOTENCIA"
        FALTAMSINAISOBRIGATORIOSDAPLATAFORMA N422ResponseErrorRiskSignalsErrorsCode = "FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA"
        PARAMETROINVALIDO                    N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_INVALIDO"
        PARAMETRONAOINFORMADO                N422ResponseErrorRiskSignalsErrorsCode = "PARAMETRO_NAO_INFORMADO"
        STATUSVINCULOINVALIDO                N422ResponseErrorRiskSignalsErrorsCode = "STATUS_VINCULO_INVALIDO"
)

// Defines values for ConsentAuthorizationDataRiskSignalsGeolocationType.
const (
        COARSE   ConsentAuthorizationDataRiskSignalsGeolocationType = "COARSE"
        FINE     ConsentAuthorizationDataRiskSignalsGeolocationType = "FINE"
        INFERRED ConsentAuthorizationDataRiskSignalsGeolocationType = "INFERRED"
)

// Defines values for EnrollmentFidoOptionsInputDataPlatform.
const (
        EnrollmentFidoOptionsInputDataPlatformANDROID       EnrollmentFidoOptionsInputDataPlatform = "ANDROID"
        EnrollmentFidoOptionsInputDataPlatformBROWSER       EnrollmentFidoOptionsInputDataPlatform = "BROWSER"
        EnrollmentFidoOptionsInputDataPlatformCROSSPLATFORM EnrollmentFidoOptionsInputDataPlatform = "CROSS_PLATFORM"
        EnrollmentFidoOptionsInputDataPlatformIOS           EnrollmentFidoOptionsInputDataPlatform = "IOS"
)

// Defines values for EnrollmentRejectionReason.
const (
        REJEITADODISPOSITIVOINCOMPATIVEL              EnrollmentRejectionReason = "REJEITADO_DISPOSITIVO_INCOMPATIVEL"
        REJEITADOFALHAFIDO                            EnrollmentRejectionReason = "REJEITADO_FALHA_FIDO"
        REJEITADOFALHAHYBRIDFLOW                      EnrollmentRejectionReason = "REJEITADO_FALHA_HYBRID_FLOW"
        REJEITADOFALHAINFRAESTRUTURA                  EnrollmentRejectionReason = "REJEITADO_FALHA_INFRAESTRUTURA"
        REJEITADOMANUALMENTE                          EnrollmentRejectionReason = "REJEITADO_MANUALMENTE"
        REJEITADOMAXIMOCHALLENGESATINGIDO             EnrollmentRejectionReason = "REJEITADO_MAXIMO_CHALLENGES_ATINGIDO"
        REJEITADOOUTRO                                EnrollmentRejectionReason = "REJEITADO_OUTRO"
        REJEITADOSEGURANCAINTERNA                     EnrollmentRejectionReason = "REJEITADO_SEGURANCA_INTERNA"
        REJEITADOTEMPOEXPIRADOACCOUNTHOLDERVALIDATION EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION"
        REJEITADOTEMPOEXPIRADOENROLLMENT              EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_ENROLLMENT"
        REJEITADOTEMPOEXPIRADORISKSIGNALS             EnrollmentRejectionReason = "REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS"
)

// Defines values for EnrollmentRevocationReason.
const (
        REVOGADOFALHAINFRAESTRUTURA EnrollmentRevocationReason = "REVOGADO_FALHA_INFRAESTRUTURA"
        REVOGADOMANUALMENTE         EnrollmentRevocationReason = "REVOGADO_MANUALMENTE"
        REVOGADOOUTRO               EnrollmentRevocationReason = "REVOGADO_OUTRO"
        REVOGADOSEGURANCAINTERNA    EnrollmentRevocationReason = "REVOGADO_SEGURANCA_INTERNA"
        REVOGADOVALIDADEEXPIRADA    EnrollmentRevocationReason = "REVOGADO_VALIDADE_EXPIRADA"
)

// Defines values for EnumAccountPaymentsType.
const (
        CACC EnumAccountPaymentsType = "CACC"
        SVGS EnumAccountPaymentsType = "SVGS"
        TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumEnrollmentCancelledFrom.
const (
        DETENTORA  EnumEnrollmentCancelledFrom = "DETENTORA"
        INICIADORA EnumEnrollmentCancelledFrom = "INICIADORA"
)

// Defines values for EnumEnrollmentPermission.
const (
        PAYMENTSINITIATE EnumEnrollmentPermission = "PAYMENTS_INITIATE"
)

// Defines values for EnumEnrollmentStatus.
const (
        AUTHORISED                      EnumEnrollmentStatus = "AUTHORISED"
        AWAITINGACCOUNTHOLDERVALIDATION EnumEnrollmentStatus = "AWAITING_ACCOUNT_HOLDER_VALIDATION"
        AWAITINGENROLLMENT              EnumEnrollmentStatus = "AWAITING_ENROLLMENT"
        AWAITINGRISKSIGNALS             EnumEnrollmentStatus = "AWAITING_RISK_SIGNALS"
        REJECTED                        EnumEnrollmentStatus = "REJECTED"
        REVOKED                         EnumEnrollmentStatus = "REVOKED"
)

// Defines values for EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform.
const (
        EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformANDROID       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "ANDROID"
        EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformBROWSER       EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "BROWSER"
        EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformCROSSPLATFORM EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "CROSS_PLATFORM"
        EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatformIOS           EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform = "IOS"
)

// N422ResponseConsentsAuthorization defines model for 422ResponseConsentsAuthorization.
type N422ResponseConsentsAuthorization struct {
        Errors []struct {
                // Code Códigos de erros previstos:
                //
                // - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
                // - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
                // - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseConsentsAuthorizationErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                //
                // - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
                // - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
                // - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                //
                // - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
                // - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento inválido.
                // - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Falta de sinais obrigatórios para a plataforma do usuário.
                // - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseConsentsAuthorizationErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O vínculo de conta não possui status AUTHORISED.
// - STATUS_CONSENTIMENTO_INVALIDO: O consentimento de pagamentos não possui status AWAITING_AUTHORISATION.
// - RISCO: Validação síncrona dos sinais de risco impediram a ativação do consentimento.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - CONTA_DEBITO_DIVERGENTE_CONSENTIMENTO_VINCULO: A conta de débito informada pelo iniciador não condiz com a conta de débito vinculada ao dispositivo.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseConsentsAuthorizationErrorsCode string

// N422ResponseErrorCancelEnrollment defines model for 422ResponseErrorCancelEnrollment.
type N422ResponseErrorCancelEnrollment struct {
        Errors []struct {
                // Code Códigos de erros previstos no cancelamento do vínculo de conta:
                // - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
                // - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
                // - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
                // - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
                // - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorCancelEnrollmentErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
                // - MOTIVO_REJEICAO: A rejeição do vínculo de conta deve estar associada a um motivo de rejeição.
                // - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
                // - MOTIVO_REVOGACAO: A revogação do vínculo de conta deve estar associada a um motivo de revogação.
                // - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - STATUS_INVALIDO: Status inválido.
                // - MOTIVO_REJEICAO: Motivo de rejeição não especificado.
                // - REJEITADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
                // - MOTIVO_REVOGACAO: Motivo de revogação não especificado.
                // - REVOGADO_OUTRO_SEM_DETALHES: O campo additionalInformation é obrigatório.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCancelEnrollmentErrorsCode Códigos de erros previstos no cancelamento do vínculo de conta:
// - STATUS_INVALIDO: O status do vínculo de conta não permite cancelamento.
// - MOTIVO_REJEICAO: A rejeição do vínculo de conta exige um motivo associado.
// - REJEITADO_OUTRO_SEM_DETALHES: O uso do motivo REJEITADO_OUTRO, deve estar acompanhado de descrição (additionalInformation).
// - MOTIVO_REVOGACAO: A revogação do vínculo de conta exige um motivo associado.
// - REVOGADO_OUTRO_SEM_DETALHES: O uso do motivo REVOGADO_OUTRO deve estar acompanhado de descrição (additionalInformation)
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCancelEnrollmentErrorsCode string

// N422ResponseErrorCreateEnrollment defines model for 422ResponseErrorCreateEnrollment.
type N422ResponseErrorCreateEnrollment struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação do vínculo de conta:
                // - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
                // - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorCreateEnrollmentErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE" ou contêm valores não suportados para esta operação.
                // - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - PERMISSOES_INVALIDAS: Permissões inválidas.
                // - CONTA_INVALIDA: Conta inválida.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorCreateEnrollmentErrorsCode Códigos de erros previstos na criação do vínculo de conta:
// - PERMISSOES_INVALIDAS: As permissões associadas ao vínculo de conta não contêm "PAYMENTS_INITIATE".
// - CONTA_INVALIDA: A conta informada inexiste ou não é compatível com o fluxo de não-redirecionamento.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorCreateEnrollmentErrorsCode string

// N422ResponseErrorFidoRegistration defines model for 422ResponseErrorFidoRegistration.
type N422ResponseErrorFidoRegistration struct {
        Errors []struct {
                // Code Códigos de erros previstos:
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
                // - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
                // - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
                // - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
                // - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
                // - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorFidoRegistrationErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
                // - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
                // - RP_INVALIDA: O valor contido no campo [response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
                // - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
                // - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
                // - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - STATUS_VINCULO_INVALIDO: Status inválido do vínculo de conta.
                // - ORIGEM_FIDO_INVALIDA: "Origin" não pode ser verificada.
                // - RP_INVALIDA: "RpIdHash" não pode ser verificado.
                // - CHALLENGE_INVALIDO: Challenge inválido.
                // - PUBLIC_KEY_INVALIDA: Chave pública inválida.
                // - EXTENSION_INVALIDA: Extensões inválidas.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationErrorsCode Códigos de erros previstos:
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - ORIGEM_FIDO_INVALIDA: O valor contido no campo [response.clientDataJSON.origin](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) não pode ser verificado.
// - RP_INVALIDA: O valor contido no campo [data.response.attestationObject.authData.rpIdHash](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) não pode ser verificado.
// - CHALLENGE_INVALIDO: O campo [response.clientDataJSON.challenge](https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson) possui valor codificado diferente do valor gerado pelo servidor.
// - PUBLIC_KEY_INVALIDA: A chave pública enviada é incompatível com as definições do servidor FIDO2.
// - EXTENSION_INVALIDA: As extensões extraídas são incompatíveis com as diretrizes de segurança do servidor FIDO2.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationErrorsCode string

// N422ResponseErrorFidoRegistrationOptions defines model for 422ResponseErrorFidoRegistrationOptions.
type N422ResponseErrorFidoRegistrationOptions struct {
        Errors []struct {
                // Code Códigos de erros previstos:
                // - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorFidoRegistrationOptionsErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - RP_INVALIDA: Relying party inválida.
                // - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoRegistrationOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite o registro de nova credencial.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoRegistrationOptionsErrorsCode string

// N422ResponseErrorFidoSignOptions defines model for 422ResponseErrorFidoSignOptions.
type N422ResponseErrorFidoSignOptions struct {
        Errors []struct {
                // Code Códigos de erros previstos:
                // - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
                // - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorFidoSignOptionsErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
                // - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - RP_INVALIDA: Relying party inválida.
                // - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
                // - STATUS_CONSENTIMENTO_INVALIDO: Status do consentimento de pagamento inválido.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorFidoSignOptionsErrorsCode Códigos de erros previstos:
// - RP_INVALIDA: O identificador da Relying Party informado não pode ser verificado.
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é tal que não permite assinatura.
// - STATUS_CONSENTIMENTO_INVALIDO: O status do consentimento não permite autorização.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorFidoSignOptionsErrorsCode string

// N422ResponseErrorRiskSignals defines model for 422ResponseErrorRiskSignals.
type N422ResponseErrorRiskSignals struct {
        Errors []struct {
                // Code Códigos de erros previstos:
                //
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Code N422ResponseErrorRiskSignalsErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                //
                // - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                //
                // - STATUS_VINCULO_INVALIDO: Status do vínculo de conta inválido.
                // - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                Title string `json:"title"`
        } `json:"errors"`
        Meta api.Meta `json:"meta"`
}

// N422ResponseErrorRiskSignalsErrorsCode Códigos de erros previstos:
//
// - STATUS_VINCULO_INVALIDO: O status do vínculo de conta é incompatível com a operação.
// - FALTAM_SINAIS_OBRIGATORIOS_DA_PLATAFORMA: Os sinais obrigatórios para a plataforma do usuário não foram enviados em sua totalidade.
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - ERRO_IDEMPOTENCIA: Erro idempotência.
type N422ResponseErrorRiskSignalsErrorsCode string

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
        Document struct {
                // Identification Número do documento de identificação oficial do titular pessoa jurídica.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
                Rel string `json:"rel"`
        } `json:"document"`
}

// ConsentAuthorization defines model for ConsentAuthorization.
type ConsentAuthorization struct {
        // Data Objeto que contém sinais de risco e o id do vínculo de conta para avaliação da autorização de um consentimento de pagamento.
        Data struct {
                // EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição detentora de conta (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                EnrollmentID EnrollmentID `json:"enrollmentId"`

                // FidoAssertion Dados da asserção
                FidoAssertion struct {
                        // ClientExtensionResults Estrutura para extensão de resultados
                        ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

                        // ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública utilizada no processo de autenticação.
                        ID string `json:"id"`

                        // RawID Identificador da credencial. Para envio à detentora de conta, o valor deste atributo deve ser idêntico ao valor do atributo id.
                        RawID string `json:"rawId"`

                        // Response Traz as informações da resposta a asserção.
                        Response struct {
                                // AuthenticatorData Representa a estrutura de dados do autenticador. Deve ser enviado no formato base64url para a detentora de conta.
                                AuthenticatorData string `json:"authenticatorData"`

                                // ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado no formato base64url para a detentora de conta.
                                ClientDataJSON string `json:"clientDataJSON"`

                                // Signature Sequência de bytes contendo a assinatura. Deve ser enviado no formato base64url para a detentora de conta.
                                Signature string `json:"signature"`

                                // UserHandle Nome de usuário que foi enviado durante a criação da credencial. Deve ser enviado no formato base64url para a detentora de conta.
                                // Caso o autenticador FIDO2 não retorne este campo, a iniciadora deve enviar uma string vazia à detentora de conta.
                                UserHandle string `json:"userHandle"`
                        } `json:"response"`

                        // Type Tipo da credencial.
                        Type string `json:"type"`
                } `json:"fidoAssertion"`

                // RiskSignals Conjunto de sinais extraídos do dispositivo do usuário para ativação do consentimento de pagamento.
                // A obrigatoriedade das informações variam de acordo com a plataforma utilizada.
                RiskSignals struct {
                        // AccountTenure Data de cadastro do cliente na iniciadora.
                        AccountTenure timeutil.BrazilDate `json:"accountTenure"`

                        // AntennaInformation Indica em qual antena o dispositivo está conectado.
                        AntennaInformation *string `json:"antennaInformation,omitempty"`

                        // DeviceID ID único do dispositivo gerado pela plataforma.
                        //
                        // Utiliza-se a propriedade do sistema que identifica a combinação de usuário logado, chave de assinatura do aplicativo e dispositivo.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/provider/Settings.Secure#ANDROID_ID).
                        //
                        // [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor/).
                        DeviceID string `json:"deviceId"`

                        // ElapsedTimeSinceBoot Indica por quanto tempo (em milissegundos) o dispositivo está ligado.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/SystemClock#elapsedRealtime%28%29).
                        //
                        // [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/kernel/kern/).
                        //
                        // [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
                        ElapsedTimeSinceBoot *int64 `json:"elapsedTimeSinceBoot,omitempty"`

                        // Geolocation Localização do usuário, obtida com seu consentimento.
                        //
                        // [Android] Informação obtida através do [link](https://developers.google.com/android/reference/com/google/android/gms/location/FusedLocationProviderClient#public-abstract-tasklocation-getlastlocation) considerando as permissões necessárias.
                        //
                        // [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/corelocation/).
                        //
                        // [Restrição] A ITP deve solicitar ao usuário a permissão para compartilhamento de sua localização. Este campo poderá ser omitido caso o GPS esteja indisponível, isto é, sem sinal, ou em dispositivos sem o hardware necessário; ou caso o usuário negue o consentimento.
                        Geolocation *struct {
                                Latitude  *float32                                            `json:"latitude,omitempty"`
                                Longitude *float32                                            `json:"longitude,omitempty"`
                                Type      *ConsentAuthorizationDataRiskSignalsGeolocationType `json:"type,omitempty"`
                        } `json:"geolocation,omitempty"`

                        // Integrity Informa a integridade do dispositivo e app.
                        //
                        // [Android] Conforme documentação Play API Integrity, [link](https://developer.android.com/google/play/integrity/overview?hl=pt-br).
                        //
                        // [iOS] Conforme documentação App Attest, [link](https://developer.apple.com/documentation/devicecheck/establishing-your-app-s-integrity).
                        Integrity *struct {
                                // AppRecognitionVerdict Informa a integridade do app
                                AppRecognitionVerdict *string `json:"appRecognitionVerdict,omitempty"`

                                // DeviceRecognitionVerdict Informa a integridade do dispositivo
                                DeviceRecognitionVerdict *string `json:"deviceRecognitionVerdict,omitempty"`
                        } `json:"integrity,omitempty"`

                        // IsCallInProgress Indica chamada ativa no momento do vínculo.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/media/AudioManager#getMode()).
                        //
                        // [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/callkit/).
                        //
                        // [Restrição] Caso o sinal de risco esteja disponível (cliente permitiu que fosse coletado), o mesmo deverá ser enviado
                        IsCallInProgress *bool `json:"isCallInProgress,omitempty"`

                        // IsCharging Indica se a bateria do dispositivo está sendo carregada.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/BatteryManager).
                        //
                        // [iOS] Informações obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620045-batterymonitoringenabled/).
                        IsCharging *bool `json:"isCharging,omitempty"`

                        // IsDevModeEnabled Indica se o dispositivo está em modo de desenvolvedor.
                        IsDevModeEnabled *bool `json:"isDevModeEnabled,omitempty"`

                        // IsEmulated Indica se o dispositivo é emulado ou real.
                        IsEmulated *bool `json:"isEmulated,omitempty"`

                        // IsMockGPS Indica se o dispositivo está usando um GPS falso. Deve ser enviado sempre que exista o campo geolocation com tipo `COARSE` ou `FINE`.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/location/Location.html#isMock()) ou, para versões anteriores à 12, [link](https://developer.android.com/reference/android/location/Location.html#isFromMockProvider()).
                        //
                        // [iOS] Informação obtida através dos links:
                        // sourceInformation, [link](https://developer.apple.com/documentation/corelocation/cllocation/3861803-sourceinformation).
                        // isSimulatedBySoftware, [link](https://developer.apple.com/documentation/corelocation/cllocationsourceinformation/3861807-issimulatedbysoftware).
                        IsMockGPS *bool `json:"isMockGPS,omitempty"`

                        // IsMonkeyRunner Indica o uso do MonkeyRunner.
                        IsMonkeyRunner *bool `json:"isMonkeyRunner,omitempty"`

                        // IsRootedDevice Indica se o dispositivo atualmente está com permissão de “root”.
                        //
                        // [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
                        IsRootedDevice *bool `json:"isRootedDevice,omitempty"`

                        // IsUsbConnected Indica se o dispositivo está conectado a outro dispositivo via USB.
                        IsUsbConnected *bool `json:"isUsbConnected,omitempty"`

                        // Language Indica o idioma do dispositivo no formato ISO 639-1.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/java/util/Locale#getLanguage()).
                        // [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/foundation/locale/languagecode/).
                        Language string `json:"language"`

                        // OsVersion Versão do sistema operacional.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/os/Build.VERSION#RELEASE).
                        // [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/uikit/uidevice/1620043-systemversion/).
                        OsVersion string `json:"osVersion"`

                        // ScreenBrightness Indica o nível de brilho da tela do dispositivo.
                        //
                        // [Android] O valor é inteiro, tipicamente entre 0 a 255, podendo a faixa de valores variar de acordo com o fabricante do celular. Referência no [link](https://developer.android.com/reference/android/provider/Settings.System#SCREEN_BRIGHTNESS).
                        //
                        // [iOS] O valor é ponto flutuante entre “0.0” e “1.0”. Referência no [link](https://developer.apple.com/documentation/uikit/uiscreen/).
                        //
                        // [Restrição] Campos de envio obrigatório quando o sistema operacional utilizado pelo usuário durante a vinculação de conta ou realização do pagamento for Android ou iOS.
                        ScreenBrightness *float64 `json:"screenBrightness,omitempty"`

                        // ScreenDimensions Dimensões que o aplicativo ocupa na tela do dispositivo.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/android/view/WindowMetrics#getBounds()), ou, para versões anteriores à 11, [link](https://developer.android.com/reference/android/util/DisplayMetrics).
                        //
                        // [iOS] - Informação obtida através do [link](https://developer.apple.com/documentation/metal/mtlrasterizationratemap/3088873-screensize/).
                        ScreenDimensions struct {
                                // Height Altura da tela, em pixels.
                                Height int `json:"height"`

                                // Width Largura da tela, em pixels.
                                Width int `json:"width"`
                        } `json:"screenDimensions"`

                        // UserTimeZoneOffset Indica a configuração de fuso horário do dispositivo do usuário, com o formato UTC offset: ±hh[:mm]. O formato especificado permite a omissão da parte correspondente aos minutos, caso esta última tenha valor zero. Assim, ambos os valores '-03:00' e '-03' são válidos e representam o mesmo fuso horário.
                        //
                        // [Android] Informação obtida através do [link](https://developer.android.com/reference/java/time/ZonedDateTime#getOffset()) ou, para versões anteriores à 8.0, [link](https://developer.android.com/reference/java/util/TimeZone#getOffset(long)).
                        //
                        // [iOS] Informação obtida através do [link](https://developer.apple.com/documentation/foundation/timezone/).
                        UserTimeZoneOffset string `json:"userTimeZoneOffset"`
                } `json:"riskSignals"`
        } `json:"data"`
}

// ConsentAuthorizationDataRiskSignalsGeolocationType defines model for ConsentAuthorization.Data.RiskSignals.Geolocation.Type.
type ConsentAuthorizationDataRiskSignalsGeolocationType string

// CreateEnrollment defines model for CreateEnrollment.
type CreateEnrollment struct {
        // Data Objeto contendo as informações para criação de vínculo de conta.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
                DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

                // EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
                EnrollmentName *string `json:"enrollmentName,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
                LoggedUser  LoggedUser              `json:"loggedUser"`
                Permissions []enrollment.Permission `json:"permissions"`
        } `json:"data"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
type DebtorAccount struct {
        // AccountType Tipos de contas usadas para pagamento via Pix.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM para o escopo do Pix.
        // CACC - Current - Conta Corrente.
        // SVGS - Savings - Conta de Poupança.
        // TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountPaymentsType `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// EnrollmentFidoOptionsInput defines model for EnrollmentFidoOptionsInput.
type EnrollmentFidoOptionsInput struct {
        // Data Objeto que contém as informações sobre a Relying Party e a plataforma sobre a qual o usuário está utilizando o serviço da iniciadora para utilização de FIDO2.
        Data struct {
                // Platform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
                // Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
                Platform EnrollmentFidoOptionsInputDataPlatform `json:"platform"`

                // Rp Identificador único da Relying Party, que corresponde ao valor do CN do certificado de transporte da iniciadora.
                Rp string `json:"rp"`
        } `json:"data"`
}

// EnrollmentFidoOptionsInputDataPlatform Indica a plataforma em que o usuário está utilizando a credencial FIDO2.
// Este campo permite que o servidor FIDO inclua extensões de acordo com a plataforma utilizada.
type EnrollmentFidoOptionsInputDataPlatform string

// EnrollmentFidoRegistration Objeto que contém a resposta da criação de uma nova credencial FIDO2.
type EnrollmentFidoRegistration struct {
        Data struct {
                // AuthenticatorAttachment Indica a forma de comunicação com o autenticador.
                AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

                // ClientExtensionResults Extensões da credencial, específicas por plataforma
                ClientExtensionResults *map[string]interface{} `json:"clientExtensionResults,omitempty"`

                // ID Identificador da credencial. Deve ser o valor em formato base64url do campo rawId da chave pública criada no processo de registro do dispositivo.
                ID string `json:"id"`

                // RawID Identificador da credencial. Para envio ao detentor, o valor deste atributo deve ser idêntico ao valor do atributo id.
                RawID    string `json:"rawId"`
                Response struct {
                        // AttestationObject Agrega as informações da chave pública da credencial. Deve ser enviado em formato base64url para o detentor.
                        AttestationObject string `json:"attestationObject"`

                        // ClientDataJSON Agrega as informações do aplicativo que gerou a credencial. Deve ser enviado em formato base64url para o detentor.
                        ClientDataJSON string `json:"clientDataJSON"`
                } `json:"response"`

                // Type Tipo da credencial
                Type *string `json:"type,omitempty"`
        } `json:"data"`
}

// EnrollmentFidoRegistrationOptions defines model for EnrollmentFidoRegistrationOptions.
type EnrollmentFidoRegistrationOptions struct {
        // Data Objeto que contém as informações necessárias para registro de uma nova credencial FIDO2.
        Data struct {
                // Attestation Indica o tipo de attestation que o autenticador pode utilizar.
                Attestation *string `json:"attestation,omitempty"`

                // AttestationFormats Indica as preferências de formato sobre o campo attestation.
                AttestationFormats *[]string `json:"attestationFormats,omitempty"`

                // AuthenticatorSelection Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
                AuthenticatorSelection *FidoAuthenticatorSelectionCriteria `json:"authenticatorSelection,omitempty"`

                // Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
                Challenge string `json:"challenge"`

                // EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição detentora de conta (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                EnrollmentID       EnrollmentID                         `json:"enrollmentId"`
                ExcludeCredentials *[]FidoPublicKeyCredentialDescriptor `json:"excludeCredentials,omitempty"`

                // Extensions Campo de extensão com opções que variam por plataforma.
                Extensions       *map[string]interface{}                  `json:"extensions,omitempty"`
                PubKeyCredParams []FidoPublicKeyCredentialCreationOptions `json:"pubKeyCredParams"`
                Rp               FidoRelyingParty                         `json:"rp"`

                // Timeout Timeout, em milissegundos, para registro da credencial FIDO2.
                Timeout *int     `json:"timeout,omitempty"`
                User    FidoUser `json:"user"`
        } `json:"data"`
        Meta api.Meta `json:"meta"`
}

// EnrollmentFidoSignOptions defines model for EnrollmentFidoSignOptions.
type EnrollmentFidoSignOptions struct {
        // Data Objeto que contém as informações necessárias para assinatura com uma credencial FIDO2 previamente registrada.
        Data struct {
                AllowCredentials *[]FidoPublicKeyCredentialDescriptor `json:"allowCredentials,omitempty"`

                // Challenge Sequência de bytes aleatórios gerados pelo servidor FIDO2. Deve ser o valor em formato base64url sem padding.
                Challenge string `json:"challenge"`

                // Extensions Campo de extensão com opções que variam por plataforma.
                Extensions *map[string]interface{} `json:"extensions,omitempty"`

                // RpID Identificador da Relying Party.
                RpID *string `json:"rpId,omitempty"`

                // Timeout Expiração, em milissegundos, do challenge.
                Timeout          *int32  `json:"timeout,omitempty"`
                UserVerification *string `json:"userVerification,omitempty"`
        } `json:"data"`
        Meta api.Meta `json:"meta"`
}

// EnrollmentRejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
//
// • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
//
// • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
//
// • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
//
// • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
//
// • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
//
// • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
//
// • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
//
// • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
//
// • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRejectionReason string

// EnrollmentRevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
//
// • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
//
// • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
//
// • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
//
// • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
//
// • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
type EnrollmentRevocationReason string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento via Pix.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM para o escopo do Pix.
// CACC - Current - Conta Corrente.
// SVGS - Savings - Conta de Poupança.
// TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumEnrollmentCancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
//
//        INICIADORA - Vínculo de conta nos canais da iniciadora.
//
//        DETENTORA - Vínculo de conta nos canais da detentora.
type EnumEnrollmentCancelledFrom string

// EnumEnrollmentPermission Permissões atribuídas ao vínculo de conta:
//
// • PAYMENTS_INITIATE: Iniciação de pagamentos sem redirecionamento à detentora.
type EnumEnrollmentPermission string

// EnumEnrollmentStatus Status do vínculo de conta:
//
// • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
//
// • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
//
// • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
//
// • AUTHORISED: Vínculo de conta pronto para uso.
//
// • REVOKED: Vínculo de conta revogado.
//
// • REJECTED: Vínculo de conta rejeitado.
type EnumEnrollmentStatus string

// FidoAuthenticatorSelectionCriteria Restrições adicionais sobre os tipos de autenticadores permitidos para o registro.
type FidoAuthenticatorSelectionCriteria struct {
        // AuthenticatorAttachment Indica os tipos de autenticadores suportados (ex: Sistema Operacional ou Cross-Platform como uma chave USB)
        AuthenticatorAttachment *string `json:"authenticatorAttachment,omitempty"`

        // RequireResidentKey Indica o requisito de verificação do usuário.
        RequireResidentKey *bool `json:"requireResidentKey,omitempty"`

        // ResidentKey Indica o requisito de verificação do usuário.
        ResidentKey *string `json:"residentKey,omitempty"`

        // UserVerification Indica o tipo de "discoverability" da credencial.
        UserVerification *string `json:"userVerification,omitempty"`
}

// FidoPublicKeyCredentialCreationOptions defines model for FidoPublicKeyCredentialCreationOptions.
type FidoPublicKeyCredentialCreationOptions struct {
        // Alg Identificador do algoritmo (COSE)
        Alg int `json:"alg"`

        // Type Identificador do tipo de credencial.
        Type string `json:"type"`
}

// FidoPublicKeyCredentialDescriptor defines model for FidoPublicKeyCredentialDescriptor.
type FidoPublicKeyCredentialDescriptor struct {
        // ID Identificador único da credencial.
        ID string `json:"id"`

        // Type Identificador do tipo de credencial.
        Type string `json:"type"`
}

// FidoRelyingParty defines model for FidoRelyingParty.
type FidoRelyingParty struct {
        // ID Identificador único da Relying Party. Esse campo deve ser preenchido com o valor que é enviado na requisição no campo /data/rp.
        ID string `json:"id"`

        // Name Nome amigável da Relying Party para exibição aos usuários. Deve ser obtido através do Software Statement Assertion, atributo software_client_name.
        Name string `json:"name"`
}

// FidoUser defines model for FidoUser.
type FidoUser struct {
        // DisplayName Identificador do usuário para fins de apresentação. Deve ser formado pelo nome social, se existente, ou nome e sobrenome do cadastro do cliente no detentor de contas.
        DisplayName string `json:"displayName"`

        // ID Identificador único do usuário sob registro em formato base64. A conversão deste valor para o formato original (BufferSource ou ArrayBuffer) não deve ultrapassar 64 bytes.
        // O identificador único deve ser opaco, ou seja, não deve carregar dados pessoais sobre o usuário, por exemplo (não exaustivo) um UUID RFC4122 cumpre com os requisitos desse campo
        ID string `json:"id"`

        // Name Identificador do usuário human-readable.
        Name string `json:"name"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
type LoggedUser struct {
        Document struct {
                // Identification Número do documento de identificação oficial do usuário.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do usuário.
                Rel string `json:"rel"`
        } `json:"document"`
}

// ResponseCreateEnrollment defines model for ResponseCreateEnrollment.
type ResponseCreateEnrollment struct {
        // Data Objeto contendo as informações de resposta da criação de vínculo de conta.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no vínculo para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do vínculo.
                DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

                // EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição detentora de conta (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                EnrollmentID EnrollmentID `json:"enrollmentId"`

                // EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
                EnrollmentName *string `json:"enrollmentName,omitempty"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
                LoggedUser  LoggedUser                 `json:"loggedUser"`
                Permissions []EnumEnrollmentPermission `json:"permissions"`

                // Status Status do vínculo de conta:
                //
                // • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
                //
                // • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
                //
                // • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
                //
                // • AUTHORISED: Vínculo de conta pronto para uso.
                //
                // • REVOKED: Vínculo de conta revogado.
                //
                // • REJECTED: Vínculo de conta rejeitado.
                Status EnumEnrollmentStatus `json:"status"`

                // StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollment defines model for ResponseEnrollment.
type ResponseEnrollment struct {
        // Data Objeto que agrupa as informações de qual foi o usuário logado que solicitou o cancelamento do vínculo de conta.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na iniciadora. [Restrição] Preenchimento obrigatório se usuário logado na iniciadora for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`
                Cancellation   *struct {
                        AdditionalInformation *string `json:"additionalInformation,omitempty"`

                        // CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do vínculo de conta.
                        // Pode estar ausente em cenários de processos automatizados realizarem o cancelamento do vínculo, por exemplo, por data de expiração.
                        CancelledBy *struct {
                                // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                                Document struct {
                                        // Identification Número do documento do usuário responsável pelo cancelamento do vínculo de conta.
                                        Identification string `json:"identification"`

                                        // Rel Tipo do documento do usuário responsável pelo cancelamento do vínculo de conta.
                                        Rel string `json:"rel"`
                                } `json:"document"`
                        } `json:"cancelledBy,omitempty"`

                        // CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento do vínculo de conta. Valores possíveis:
                        //
                        //   INICIADORA - Vínculo de conta nos canais da iniciadora.
                        //
                        //   DETENTORA - Vínculo de conta nos canais da detentora.
                        CancelledFrom EnumEnrollmentCancelledFrom                 `json:"cancelledFrom"`
                        Reason        ResponseEnrollment_Data_Cancellation_Reason `json:"reason"`

                        // RejectedAt Instante de rejeição do vínculo de conta no ambiente da detentora.
                        RejectedAt *timeutil.DateTime `json:"rejectedAt,omitempty"`
                } `json:"cancellation,omitempty"`

                // CreationDateTime O instante em que o vínculo de conta foi criado no ambiente da detentora.
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // DailyLimit Limite diário cumulativo para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
                // servindo como referência para a iniciadora evitar a criação de consentimentos para valores tais que, garantidamente, não serão autorizados.
                // Este campo só estará presente quando o usuário, durante a autorização do vínculo, definir um valor máximo diário diferente do seu limite Pix disponível para o dia.
                DailyLimit    *string `json:"dailyLimit,omitempty"`
                DebtorAccount *struct {
                        // AccountType Tipos de contas usadas para pagamento via Pix.
                        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
                        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
                        // Segue descrição de cada valor do ENUM para o escopo do Pix.
                        // CACC - Current - Conta Corrente.
                        // SVGS - Savings - Conta de Poupança.
                        // TRAN - TransactingAccount - Conta de Pagamento pré-paga.
                        AccountType EnumAccountPaymentsType `json:"accountType"`

                        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
                        Ispb string `json:"ispb"`

                        // Issuer Código da Agência emissora da conta sem dígito.
                        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
                        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
                        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
                        Issuer *string `json:"issuer,omitempty"`

                        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
                        // se houver valor alfanumérico, este deve ser convertido para 0.
                        Number string `json:"number"`
                } `json:"debtorAccount,omitempty"`

                // EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição detentora de conta (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                EnrollmentID EnrollmentID `json:"enrollmentId"`

                // EnrollmentName [Restrição] Deve ser preenchido sempre que o usuário pagador inserir alguma informação no nome do vínculo/dispositivo tanto no iniciador como no detentor de conta
                EnrollmentName *string `json:"enrollmentName,omitempty"`

                // ExpirationDateTime Data e hora de expiração da permissão. Reflete a data limite de validade do vínculo.
                // Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC (UTC time format).
                //
                // [Restrição] De preenchimento obrigatório nos casos em que houver validade determinada.
                // Em casos de vínculo com prazo indeterminado, o campo não deve ser preenchido.
                ExpirationDateTime *timeutil.DateTime `json:"expirationDateTime,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na iniciadora.
                LoggedUser  LoggedUser                 `json:"loggedUser"`
                Permissions []EnumEnrollmentPermission `json:"permissions"`

                // Status Status do vínculo de conta:
                //
                // • AWAITING_RISK_SIGNALS: Vínculo de conta criado e aguardando envio dos sinais de risco para a dentora.
                //
                // • AWAITING_ACCOUNT_HOLDER_VALIDATION: Vínculo de conta aguardando autorização no ambiente da detentora.
                //
                // • AWAITING_ENROLLMENT: Vínculo de conta autorizado no ambiente da detentora e aguardando o vínculo de credenciais (FIDO2).
                //
                // • AUTHORISED: Vínculo de conta pronto para uso.
                //
                // • REVOKED: Vínculo de conta revogado.
                //
                // • REJECTED: Vínculo de conta rejeitado.
                Status EnumEnrollmentStatus `json:"status"`

                // StatusUpdateDateTime O instante em que ocorreu a última alteração de status do vínculo de conta.
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

                // TransactionLimit Valor máximo, por transação, admitido para este vínculo de conta. Este limite não garante a autorização de iniciações de pagamento;
                // servindo como referência para a iniciadora evitar a criação de consentimentos de valores tais que, garantidamente, não serão autorizados.
                //
                // [Restrição] Campo de preenchimento obrigatório pelos participantes quando o campo `status` for preenchido com os valores `AUTHORISED` ou `AWAITING_ENROLLMENT`.
                TransactionLimit *string `json:"transactionLimit,omitempty"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseEnrollmentDataCancellationReason0 Motivo da rejeição do vínculo de conta.
type ResponseEnrollmentDataCancellationReason0 struct {
        // RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
        //
        // • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
        //
        // • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
        //
        // • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
        //
        // • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
        //
        // • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
        //
        // • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
        //
        // • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
        //
        // • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
        //
        // • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
        //
        // • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
        //
        // • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
        RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// ResponseEnrollmentDataCancellationReason1 Motivo da revogação do vínculo de conta.
type ResponseEnrollmentDataCancellationReason1 struct {
        // RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
        //
        // • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
        //
        // • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
        //
        // • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
        //
        // • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
        //
        // • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
        RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// ResponseEnrollment_Data_Cancellation_Reason defines model for ResponseEnrollment.Data.Cancellation.Reason.
type ResponseEnrollment_Data_Cancellation_Reason struct {
        union json.RawMessage
}

// ResponseError defines model for ResponseError.
type ResponseError struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`

        // Meta Meta informações referente à API requisitada.
        Meta *api.Meta `json:"meta,omitempty"`
}

// RiskSignals defines model for RiskSignals.
type RiskSignals struct {
        // Data Informa a integridade do dispositivo e app
        Data map[string]any `json:"data"`
}

// ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type ConsentIDType = string

// EnrollmentID Identificador único do vínculo de conta criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
// Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
// Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
// seja um identificador de recurso persistente e independente da localização.
// Considerando a string urn:bancoex:C1DD33123 como exemplo para enrollmentId temos:
// - o namespace(urn)
// - o identificador associado ao namespace da instituição detentora de conta (bancoex)
// - o identificador específico dentro do namespace (C1DD33123).
// Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
type EnrollmentID = string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ParameterConsentID defines model for consentId.
type ParameterConsentID = string

// XBcbNfc defines model for x-bcb-nfc.
type XBcbNfc = bool

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200EnrollmentsEnrollmentIDRead defines model for 200EnrollmentsEnrollmentIdRead.
type N200EnrollmentsEnrollmentIDRead = ResponseEnrollment

// N201EnrollmentFidoRegistrationOptions defines model for 201EnrollmentFidoRegistrationOptions.
type N201EnrollmentFidoRegistrationOptions = EnrollmentFidoRegistrationOptions

// N201EnrollmentFidoSignOptions defines model for 201EnrollmentFidoSignOptions.
type N201EnrollmentFidoSignOptions = EnrollmentFidoSignOptions

// N201EnrollmentsCreated defines model for 201EnrollmentsCreated.
type N201EnrollmentsCreated = ResponseCreateEnrollment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// ForbiddenEnrollments defines model for ForbiddenEnrollments.
type ForbiddenEnrollments = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// AuthorizeConsentParams defines parameters for AuthorizeConsent.
type AuthorizeConsentParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`

        // XBcbNfc O campo representa uma transação iniciada via NFC. O envio desse campo é obrigatório nesse cenário. As detentoras devem armazenar a informação e correlacioná-la com o consentimento e o pagamento originado.
        XBcbNfc *XBcbNfc `json:"x-bcb-nfc,omitempty"`
}

// PostEnrollmentsParams defines parameters for PostEnrollments.
type PostEnrollmentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// GetEnrollmentParams defines parameters for GetEnrollment.
type GetEnrollmentParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// DeleteEnrollmentJSONBody defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody struct {
        Data struct {
                Cancellation struct {
                        AdditionalInformation *string `json:"additionalInformation,omitempty"`
                        CancelledBy           *struct {
                                Document struct {
                                        Identification string `json:"identification"`
                                        Rel            string `json:"rel"`
                                } `json:"document"`
                        } `json:"cancelledBy,omitempty"`
                        Reason DeleteEnrollmentJSONBody_Data_Cancellation_Reason `json:"reason"`
                } `json:"cancellation"`
        } `json:"data"`
}

// DeleteEnrollmentParams defines parameters for DeleteEnrollment.
type DeleteEnrollmentParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason0 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason0 struct {
        // RejectionReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
        //
        // • REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS: Expiração automática devido a timeout no status "AWAITING_RISK_SIGNALS". O envio de sinais de risco não foi concluído.
        //
        // • REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION: Expiração automática devido a timeout no status "AWAITING_ACCOUNT_HOLDER_VALIDATION". O processo de redirecionamento não foi concluído com sucesso.
        //
        // • REJEITADO_TEMPO_EXPIRADO_ENROLLMENT: Expiração automática devido a timeout no status "AWAITING_ENROLLMENT". O processo de criação e envio de credenciais FIDO2 não foi concluído com sucesso.
        //
        // • REJEITADO_MAXIMO_CHALLENGES_ATINGIDO: Vínculo de conta rejeitado devido várias tentativas vínculo frustradas.
        //
        // • REJEITADO_MANUALMENTE: Cancelamento manual, explicitamente a pedido do usuário.
        //
        // • REJEITADO_DISPOSITIVO_INCOMPATIVEL: Dispositivo não suporta o protocolo FIDO.
        //
        // • REJEITADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
        //
        // • REJEITADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à política de segurança de instituição detentora ou iniciadora considerando a análise dos sinais de risco.
        //
        // • REJEITADO_FALHA_HYBRID_FLOW: Vínculo de conta rejeitado por falha técnica no processo de redirecionamento (por exemplo: troca de authorization code por access token no FAPI Hybrid flow)
        //
        // • REJEITADO_FALHA_FIDO: Vínculo de conta rejeitado por falha técnica no processo de validação ou associação da credencial pública FIDO.
        //
        // • REJEITADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
        RejectionReason EnrollmentRejectionReason `json:"rejectionReason"`
}

// DeleteEnrollmentJSONBodyDataCancellationReason1 defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBodyDataCancellationReason1 struct {
        // RevocationReason Indica o motivo do cancelamento do vínculo de conta. Valores possíveis:
        //
        // • REVOGADO_MANUALMENTE: Cancelamento manual, explicitamente a mando do usuário.
        //
        // • REVOGADO_VALIDADE_EXPIRADA: Expiração automática ao atingir o prazo limite do vínculo de conta.
        //
        // • REVOGADO_FALHA_INFRAESTRUTURA: Falha na infraestrutura na detentora.
        //
        // • REVOGADO_SEGURANCA_INTERNA: Vínculo de conta rejeitado devido à políticas de segurança tanto da iniciadora quanto da detentora.
        //
        // • REVOGADO_OUTRO: Outros motivos não descritos pelas demais. Indicar, neste caso, o motivo em "additionalInformation".
        RevocationReason EnrollmentRevocationReason `json:"revocationReason"`
}

// DeleteEnrollmentJSONBody_Data_Cancellation_Reason defines parameters for DeleteEnrollment.
type DeleteEnrollmentJSONBody_Data_Cancellation_Reason struct {
        union json.RawMessage
}

// EnrollmentRegisterFidoCredentialParams defines parameters for EnrollmentRegisterFidoCredential.
type EnrollmentRegisterFidoCredentialParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoRegistrationOptionsParams defines parameters for EnrollmentCreateFidoRegistrationOptions.
type EnrollmentCreateFidoRegistrationOptionsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBody defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBody struct {
        Data struct {
                // ConsentIDType O consentId é o identificador único do consentimento e deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição detentora de conta (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentIDType ConsentIDType                                          `json:"consentId"`
                Platform      EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform `json:"platform"`
                Rp            string                                                 `json:"rp"`
        } `json:"data"`
}

// EnrollmentCreateFidoSigningOptionsParams defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform defines parameters for EnrollmentCreateFidoSigningOptions.
type EnrollmentCreateFidoSigningOptionsJSONBodyDataPlatform string

// RiskSignalsParams defines parameters for RiskSignals.
type RiskSignalsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com a iniciadora. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com a iniciadora.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser "espelhado" pela detentora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. A iniciadora deve acatar o valor recebido da detentora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// AuthorizeConsentJSONRequestBody defines body for AuthorizeConsent for application/json ContentType.
type AuthorizeConsentJSONRequestBody = ConsentAuthorization

// PostEnrollmentsJSONRequestBody defines body for PostEnrollments for application/json ContentType.
type PostEnrollmentsJSONRequestBody = CreateEnrollment

// DeleteEnrollmentJSONRequestBody defines body for DeleteEnrollment for application/json ContentType.
type DeleteEnrollmentJSONRequestBody DeleteEnrollmentJSONBody

// EnrollmentRegisterFidoCredentialJSONRequestBody defines body for EnrollmentRegisterFidoCredential for application/json ContentType.
type EnrollmentRegisterFidoCredentialJSONRequestBody = EnrollmentFidoRegistration

// EnrollmentCreateFidoRegistrationOptionsJSONRequestBody defines body for EnrollmentCreateFidoRegistrationOptions for application/json ContentType.
type EnrollmentCreateFidoRegistrationOptionsJSONRequestBody = EnrollmentFidoOptionsInput

// EnrollmentCreateFidoSigningOptionsJSONRequestBody defines body for EnrollmentCreateFidoSigningOptions for application/json ContentType.
type EnrollmentCreateFidoSigningOptionsJSONRequestBody EnrollmentCreateFidoSigningOptionsJSONBody

// RiskSignalsJSONRequestBody defines body for RiskSignals for application/json ContentType.
type RiskSignalsJSONRequestBody = RiskSignals

// AsResponseEnrollmentDataCancellationReason0 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason0
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason0() (ResponseEnrollmentDataCancellationReason0, error) <span class="cov0" title="0">{
        var body ResponseEnrollmentDataCancellationReason0
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromResponseEnrollmentDataCancellationReason0 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeResponseEnrollmentDataCancellationReason0 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason0
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason0(v ResponseEnrollmentDataCancellationReason0) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

// AsResponseEnrollmentDataCancellationReason1 returns the union data inside the ResponseEnrollment_Data_Cancellation_Reason as a ResponseEnrollmentDataCancellationReason1
func (t ResponseEnrollment_Data_Cancellation_Reason) AsResponseEnrollmentDataCancellationReason1() (ResponseEnrollmentDataCancellationReason1, error) <span class="cov0" title="0">{
        var body ResponseEnrollmentDataCancellationReason1
        err := json.Unmarshal(t.union, &amp;body)
        return body, err
}</span>

// FromResponseEnrollmentDataCancellationReason1 overwrites any union data inside the ResponseEnrollment_Data_Cancellation_Reason as the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) FromResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        t.union = b
        return err
}</span>

// MergeResponseEnrollmentDataCancellationReason1 performs a merge with any union data inside the ResponseEnrollment_Data_Cancellation_Reason, using the provided ResponseEnrollmentDataCancellationReason1
func (t *ResponseEnrollment_Data_Cancellation_Reason) MergeResponseEnrollmentDataCancellationReason1(v ResponseEnrollmentDataCancellationReason1) error <span class="cov0" title="0">{
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">merged, err := runtime.JSONMerge(t.union, b)
        t.union = merged
        return err</span>
}

func (t ResponseEnrollment_Data_Cancellation_Reason) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := t.union.MarshalJSON()
        return b, err
}</span>

func (t *ResponseEnrollment_Data_Cancellation_Reason) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        err := t.union.UnmarshalJSON(b)
        return err
}</span>

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Autorização de um consentimento de pagamentos na jornada sem redirecionamento
        // (POST /consents/{consentId}/authorise)
        AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams)
        // Criar vínculo de conta.
        // (POST /enrollments)
        PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams)
        // Consultar vínculo de conta.
        // (GET /enrollments/{enrollmentId})
        GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams)
        // Revogar ou rejeitar vínculo de conta.
        // (PATCH /enrollments/{enrollmentId})
        DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams)
        // Associação da credencial FIDO2 ao vínculo de conta.
        // (POST /enrollments/{enrollmentId}/fido-registration)
        EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams)
        // Obter parâmetros para criação de credenciais FIDO2.
        // (POST /enrollments/{enrollmentId}/fido-registration-options)
        EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams)
        // Obter parâmetros para autenticação FIDO2.
        // (POST /enrollments/{enrollmentId}/fido-sign-options)
        EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams)
        // Envio de sinais de risco para iniciação do vínculo de dispositivo
        // (POST /enrollments/{enrollmentId}/risk-signals)
        RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// AuthorizeConsent operation middleware
func (siw *ServerInterfaceWrapper) AuthorizeConsent(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var parameterConsentID ParameterConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;parameterConsentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params AuthorizeConsentParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-bcb-nfc" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-bcb-nfc")]; found </span><span class="cov0" title="0">{
                var XBcbNfc XBcbNfc
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-bcb-nfc", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-bcb-nfc", valueList[0], &amp;XBcbNfc, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-bcb-nfc", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XBcbNfc = &amp;XBcbNfc</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.AuthorizeConsent(w, r, parameterConsentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PostEnrollments operation middleware
func (siw *ServerInterfaceWrapper) PostEnrollments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PostEnrollmentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PostEnrollments(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// GetEnrollment operation middleware
func (siw *ServerInterfaceWrapper) GetEnrollment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params GetEnrollmentParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.GetEnrollment(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// DeleteEnrollment operation middleware
func (siw *ServerInterfaceWrapper) DeleteEnrollment(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params DeleteEnrollmentParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.DeleteEnrollment(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// EnrollmentRegisterFidoCredential operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params EnrollmentRegisterFidoCredentialParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.EnrollmentRegisterFidoCredential(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params EnrollmentCreateFidoRegistrationOptionsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.EnrollmentCreateFidoRegistrationOptions(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (siw *ServerInterfaceWrapper) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params EnrollmentCreateFidoSigningOptionsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.EnrollmentCreateFidoSigningOptions(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// RiskSignals operation middleware
func (siw *ServerInterfaceWrapper) RiskSignals(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "enrollmentId" -------------
        var enrollmentID EnrollmentID

        err = runtime.BindStyledParameterWithOptions("simple", "enrollmentId", r.PathValue("enrollmentId"), &amp;enrollmentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "enrollmentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params RiskSignalsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.RiskSignals(w, r, enrollmentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("POST "+options.BaseURL+"/consents/{consentId}/authorise", wrapper.AuthorizeConsent)
        m.HandleFunc("POST "+options.BaseURL+"/enrollments", wrapper.PostEnrollments)
        m.HandleFunc("GET "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.GetEnrollment)
        m.HandleFunc("PATCH "+options.BaseURL+"/enrollments/{enrollmentId}", wrapper.DeleteEnrollment)
        m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration", wrapper.EnrollmentRegisterFidoCredential)
        m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-registration-options", wrapper.EnrollmentCreateFidoRegistrationOptions)
        m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/fido-sign-options", wrapper.EnrollmentCreateFidoSigningOptions)
        m.HandleFunc("POST "+options.BaseURL+"/enrollments/{enrollmentId}/risk-signals", wrapper.RiskSignals)

        return m</span>
}

type N200EnrollmentsEnrollmentIDReadJSONResponse ResponseEnrollment

type N201EnrollmentFidoRegistrationOptionsJSONResponse EnrollmentFidoRegistrationOptions

type N201EnrollmentFidoSignOptionsJSONResponse EnrollmentFidoSignOptions

type N201EnrollmentsCreatedJSONResponse ResponseCreateEnrollment

type N204EnrollmentsEnrollmentIDDeleteResponse struct {
}

type N204EnrollmentsFidoRegistrationResponse struct {
}

type N204EnrollmentsRiskSignalsResponse struct {
}

type N204PaymentsConsentsAuthorizedResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsAuthorizationApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentCancelApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type AuthorizeConsentRequestObject struct {
        ParameterConsentID ParameterConsentID `json:"consentId"`
        Params             AuthorizeConsentParams
        Body               *AuthorizeConsentJSONRequestBody
}

type AuthorizeConsentResponseObject interface {
        VisitAuthorizeConsentResponse(w http.ResponseWriter) error
}

type AuthorizeConsent204Response = N204PaymentsConsentsAuthorizedResponse

func (response AuthorizeConsent204Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type AuthorizeConsent400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent400ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent401ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent403ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent404ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent405ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent406ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent415ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent422ApplicationJwtResponse struct {
        UnprocessableEntityConsentsAuthorizationApplicationJwtResponse
}

func (response AuthorizeConsent422ApplicationJwtResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type AuthorizeConsent500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent500ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsent529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response AuthorizeConsent529ApplicationJSONCharsetUTF8Response) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type AuthorizeConsentdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response AuthorizeConsentdefaultJSONResponse) VisitAuthorizeConsentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PostEnrollmentsRequestObject struct {
        Params PostEnrollmentsParams
        Body   *PostEnrollmentsJSONRequestBody
}

type PostEnrollmentsResponseObject interface {
        VisitPostEnrollmentsResponse(w http.ResponseWriter) error
}

type PostEnrollments201JSONResponse struct {
        N201EnrollmentsCreatedJSONResponse
}

func (response PostEnrollments201JSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments400ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments401ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenEnrollmentsApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments403ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments404ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments405ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments406ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments415ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentApplicationJwtResponse
}

func (response PostEnrollments422ApplicationJwtResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type PostEnrollments500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments500ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollments529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PostEnrollments529ApplicationJSONCharsetUTF8Response) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PostEnrollmentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PostEnrollmentsdefaultJSONResponse) VisitPostEnrollmentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type GetEnrollmentRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       GetEnrollmentParams
}

type GetEnrollmentResponseObject interface {
        VisitGetEnrollmentResponse(w http.ResponseWriter) error
}

type GetEnrollment200JSONResponse struct {
        N200EnrollmentsEnrollmentIDReadJSONResponse
}

func (response GetEnrollment200JSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment400ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment401ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment403ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment404ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment405ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment406ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment500ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollment529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response GetEnrollment529ApplicationJSONCharsetUTF8Response) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type GetEnrollmentdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response GetEnrollmentdefaultJSONResponse) VisitGetEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type DeleteEnrollmentRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       DeleteEnrollmentParams
        Body         *DeleteEnrollmentJSONRequestBody
}

type DeleteEnrollmentResponseObject interface {
        VisitDeleteEnrollmentResponse(w http.ResponseWriter) error
}

type DeleteEnrollment204Response = N204EnrollmentsEnrollmentIDDeleteResponse

func (response DeleteEnrollment204Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type DeleteEnrollment400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment400ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment401ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment403ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment404ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment405ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment406ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentCancelApplicationJwtResponse
}

func (response DeleteEnrollment422ApplicationJwtResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type DeleteEnrollment500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment500ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollment529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response DeleteEnrollment529ApplicationJSONCharsetUTF8Response) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type DeleteEnrollmentdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response DeleteEnrollmentdefaultJSONResponse) VisitDeleteEnrollmentResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type EnrollmentRegisterFidoCredentialRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       EnrollmentRegisterFidoCredentialParams
        Body         *EnrollmentRegisterFidoCredentialJSONRequestBody
}

type EnrollmentRegisterFidoCredentialResponseObject interface {
        VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error
}

type EnrollmentRegisterFidoCredential204Response = N204EnrollmentsFidoRegistrationResponse

func (response EnrollmentRegisterFidoCredential204Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential400ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential401ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential403ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential404ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential405ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential406ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential415ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentFidoRegistrationApplicationJwtResponse
}

func (response EnrollmentRegisterFidoCredential422ApplicationJwtResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential500ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentRegisterFidoCredential529ApplicationJSONCharsetUTF8Response) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentRegisterFidoCredentialdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response EnrollmentRegisterFidoCredentialdefaultJSONResponse) VisitEnrollmentRegisterFidoCredentialResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type EnrollmentCreateFidoRegistrationOptionsRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       EnrollmentCreateFidoRegistrationOptionsParams
        Body         *EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
}

type EnrollmentCreateFidoRegistrationOptionsResponseObject interface {
        VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoRegistrationOptions201JSONResponse struct {
        N201EnrollmentFidoRegistrationOptionsJSONResponse
}

func (response EnrollmentCreateFidoRegistrationOptions201JSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentFidoRegistrationOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoRegistrationOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoRegistrationOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response EnrollmentCreateFidoRegistrationOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoRegistrationOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type EnrollmentCreateFidoSigningOptionsRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       EnrollmentCreateFidoSigningOptionsParams
        Body         *EnrollmentCreateFidoSigningOptionsJSONRequestBody
}

type EnrollmentCreateFidoSigningOptionsResponseObject interface {
        VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error
}

type EnrollmentCreateFidoSigningOptions201JSONResponse struct {
        N201EnrollmentFidoSignOptionsJSONResponse
}

func (response EnrollmentCreateFidoSigningOptions201JSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions400ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions401ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions403ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions404ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions405ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions406ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions415ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentFidoSignOptionsApplicationJwtResponse
}

func (response EnrollmentCreateFidoSigningOptions422ApplicationJwtResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions500ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response EnrollmentCreateFidoSigningOptions529ApplicationJSONCharsetUTF8Response) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type EnrollmentCreateFidoSigningOptionsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response EnrollmentCreateFidoSigningOptionsdefaultJSONResponse) VisitEnrollmentCreateFidoSigningOptionsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type RiskSignalsRequestObject struct {
        EnrollmentID EnrollmentID `json:"enrollmentId"`
        Params       RiskSignalsParams
        Body         *RiskSignalsJSONRequestBody
}

type RiskSignalsResponseObject interface {
        VisitRiskSignalsResponse(w http.ResponseWriter) error
}

type RiskSignals204Response = N204EnrollmentsRiskSignalsResponse

func (response RiskSignals204Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(204)
        return nil
}</span>

type RiskSignals400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response RiskSignals400ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals401ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response RiskSignals403ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response RiskSignals404ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals405ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response RiskSignals406ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response RiskSignals415ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals422ApplicationJwtResponse struct {
        UnprocessableEntityEnrollmentRiskSignalsApplicationJwtResponse
}

func (response RiskSignals422ApplicationJwtResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type RiskSignals500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response RiskSignals500ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignals529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response RiskSignals529ApplicationJSONCharsetUTF8Response) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type RiskSignalsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response RiskSignalsdefaultJSONResponse) VisitRiskSignalsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Autorização de um consentimento de pagamentos na jornada sem redirecionamento
        // (POST /consents/{consentId}/authorise)
        AuthorizeConsent(ctx context.Context, request AuthorizeConsentRequestObject) (AuthorizeConsentResponseObject, error)
        // Criar vínculo de conta.
        // (POST /enrollments)
        PostEnrollments(ctx context.Context, request PostEnrollmentsRequestObject) (PostEnrollmentsResponseObject, error)
        // Consultar vínculo de conta.
        // (GET /enrollments/{enrollmentId})
        GetEnrollment(ctx context.Context, request GetEnrollmentRequestObject) (GetEnrollmentResponseObject, error)
        // Revogar ou rejeitar vínculo de conta.
        // (PATCH /enrollments/{enrollmentId})
        DeleteEnrollment(ctx context.Context, request DeleteEnrollmentRequestObject) (DeleteEnrollmentResponseObject, error)
        // Associação da credencial FIDO2 ao vínculo de conta.
        // (POST /enrollments/{enrollmentId}/fido-registration)
        EnrollmentRegisterFidoCredential(ctx context.Context, request EnrollmentRegisterFidoCredentialRequestObject) (EnrollmentRegisterFidoCredentialResponseObject, error)
        // Obter parâmetros para criação de credenciais FIDO2.
        // (POST /enrollments/{enrollmentId}/fido-registration-options)
        EnrollmentCreateFidoRegistrationOptions(ctx context.Context, request EnrollmentCreateFidoRegistrationOptionsRequestObject) (EnrollmentCreateFidoRegistrationOptionsResponseObject, error)
        // Obter parâmetros para autenticação FIDO2.
        // (POST /enrollments/{enrollmentId}/fido-sign-options)
        EnrollmentCreateFidoSigningOptions(ctx context.Context, request EnrollmentCreateFidoSigningOptionsRequestObject) (EnrollmentCreateFidoSigningOptionsResponseObject, error)
        // Envio de sinais de risco para iniciação do vínculo de dispositivo
        // (POST /enrollments/{enrollmentId}/risk-signals)
        RiskSignals(ctx context.Context, request RiskSignalsRequestObject) (RiskSignalsResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// AuthorizeConsent operation middleware
func (sh *strictHandler) AuthorizeConsent(w http.ResponseWriter, r *http.Request, parameterConsentID ParameterConsentID, params AuthorizeConsentParams) <span class="cov0" title="0">{
        var request AuthorizeConsentRequestObject

        request.ParameterConsentID = parameterConsentID
        request.Params = params

        var body AuthorizeConsentJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.AuthorizeConsent(ctx, request.(AuthorizeConsentRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "AuthorizeConsent")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(AuthorizeConsentResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitAuthorizeConsentResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PostEnrollments operation middleware
func (sh *strictHandler) PostEnrollments(w http.ResponseWriter, r *http.Request, params PostEnrollmentsParams) <span class="cov0" title="0">{
        var request PostEnrollmentsRequestObject

        request.Params = params

        var body PostEnrollmentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PostEnrollments(ctx, request.(PostEnrollmentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PostEnrollments")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PostEnrollmentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPostEnrollmentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// GetEnrollment operation middleware
func (sh *strictHandler) GetEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params GetEnrollmentParams) <span class="cov0" title="0">{
        var request GetEnrollmentRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.GetEnrollment(ctx, request.(GetEnrollmentRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "GetEnrollment")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(GetEnrollmentResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitGetEnrollmentResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// DeleteEnrollment operation middleware
func (sh *strictHandler) DeleteEnrollment(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params DeleteEnrollmentParams) <span class="cov0" title="0">{
        var request DeleteEnrollmentRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        var body DeleteEnrollmentJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.DeleteEnrollment(ctx, request.(DeleteEnrollmentRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "DeleteEnrollment")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(DeleteEnrollmentResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitDeleteEnrollmentResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// EnrollmentRegisterFidoCredential operation middleware
func (sh *strictHandler) EnrollmentRegisterFidoCredential(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentRegisterFidoCredentialParams) <span class="cov0" title="0">{
        var request EnrollmentRegisterFidoCredentialRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        var body EnrollmentRegisterFidoCredentialJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.EnrollmentRegisterFidoCredential(ctx, request.(EnrollmentRegisterFidoCredentialRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "EnrollmentRegisterFidoCredential")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(EnrollmentRegisterFidoCredentialResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitEnrollmentRegisterFidoCredentialResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// EnrollmentCreateFidoRegistrationOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoRegistrationOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoRegistrationOptionsParams) <span class="cov0" title="0">{
        var request EnrollmentCreateFidoRegistrationOptionsRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        var body EnrollmentCreateFidoRegistrationOptionsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.EnrollmentCreateFidoRegistrationOptions(ctx, request.(EnrollmentCreateFidoRegistrationOptionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "EnrollmentCreateFidoRegistrationOptions")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(EnrollmentCreateFidoRegistrationOptionsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitEnrollmentCreateFidoRegistrationOptionsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// EnrollmentCreateFidoSigningOptions operation middleware
func (sh *strictHandler) EnrollmentCreateFidoSigningOptions(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params EnrollmentCreateFidoSigningOptionsParams) <span class="cov0" title="0">{
        var request EnrollmentCreateFidoSigningOptionsRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        var body EnrollmentCreateFidoSigningOptionsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.EnrollmentCreateFidoSigningOptions(ctx, request.(EnrollmentCreateFidoSigningOptionsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "EnrollmentCreateFidoSigningOptions")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(EnrollmentCreateFidoSigningOptionsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitEnrollmentCreateFidoSigningOptionsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// RiskSignals operation middleware
func (sh *strictHandler) RiskSignals(w http.ResponseWriter, r *http.Request, enrollmentID EnrollmentID, params RiskSignalsParams) <span class="cov0" title="0">{
        var request RiskSignalsRequestObject

        request.EnrollmentID = enrollmentID
        request.Params = params

        var body RiskSignalsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.RiskSignals(ctx, request.(RiskSignalsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "RiskSignals")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(RiskSignalsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitRiskSignalsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package api

import (
        "errors"
        "fmt"
        "log/slog"
        "net/http"
)

type Error struct {
        code        string
        statusCode  int
        description string
        pagination  bool
}

func (err Error) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s", err.code, err.description)
}</span>

func (err Error) WithPagination() Error <span class="cov0" title="0">{
        err.pagination = true
        return err
}</span>

func (err Error) Pagination(b bool) Error <span class="cov0" title="0">{
        err.pagination = b
        return err
}</span>

func NewError(code string, status int, description string) Error <span class="cov0" title="0">{
        err := Error{
                code:        code,
                statusCode:  status,
                description: description,
        }

        return err
}</span>

// WriteError writes an API error response to the provided http.ResponseWriter.
func WriteError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        var apiErr Error
        if !errors.As(err, &amp;apiErr) </span><span class="cov0" title="0">{
                slog.ErrorContext(r.Context(), "unknown error", "error", err)
                WriteError(w, r, Error{"INTERNAL_ERROR", http.StatusInternalServerError, "internal error", false})
                return
        }</span>

        <span class="cov0" title="0">slog.InfoContext(r.Context(), "returning error", "error", err, "status_code", apiErr.statusCode)
        description := apiErr.description
        if len(description) &gt; 2048 </span><span class="cov0" title="0">{
                description = description[:2048]
        }</span>
        <span class="cov0" title="0">errResp := response{
                Errors: []struct {
                        Code   string `json:"code"`
                        Title  string `json:"title"`
                        Detail string `json:"detail"`
                }{
                        {
                                Code:   apiErr.code,
                                Title:  apiErr.code,
                                Detail: description,
                        },
                },
                Meta: NewMeta(),
        }
        if apiErr.pagination </span><span class="cov0" title="0">{
                errResp.Meta = NewSingleRecordMeta()
        }</span>

        <span class="cov0" title="0">WriteJSON(w, errResp, apiErr.statusCode)</span>
}

type response struct {
        Errors []struct {
                Code   string `json:"code"`
                Title  string `json:"title"`
                Detail string `json:"detail"`
        } `json:"errors"`
        Meta *Meta `json:"meta"`
}
</pre>

		<pre class="file" id="file14" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
        "slices"
        "strings"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/oidc"
)

func Auth(op *provider.Provider, grantType goidc.GrantType, scopes ...goidc.Scope) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := r.Context()

                        tokenInfo, err := op.TokenInfoFromRequest(w, r)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.InfoContext(ctx, "the token is not active", "error", err)
                                api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid token").Pagination(true))
                                return
                        }</span>

                        <span class="cov0" title="0">ctx = context.WithValue(ctx, api.CtxKeyClientID, tokenInfo.ClientID)
                        ctx = context.WithValue(ctx, api.CtxKeySubject, tokenInfo.Subject)
                        ctx = context.WithValue(ctx, api.CtxKeyScopes, tokenInfo.Scopes)
                        ctx = context.WithValue(ctx, api.CtxKeyOrgID, tokenInfo.AdditionalTokenClaims[oidc.OrgIDKey])
                        r = r.WithContext(ctx)

                        switch grantType </span>{
                        case goidc.GrantClientCredentials:<span class="cov0" title="0">
                                // Client credentials tokens are issued for the client itself, so the subject must be the client ID.
                                if tokenInfo.Subject != tokenInfo.ClientID </span><span class="cov0" title="0">{
                                        slog.InfoContext(ctx, "invalid token grant type, client credentials is required", "sub", tokenInfo.Subject, "client_id", tokenInfo.ClientID)
                                        api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid token grant type, client credentials is required").Pagination(true))
                                        return
                                }</span>
                        case goidc.GrantAuthorizationCode:<span class="cov0" title="0">
                                // Authorization code tokens are issued for a user, so the subject must not be the client ID.
                                if tokenInfo.Subject == tokenInfo.ClientID </span><span class="cov0" title="0">{
                                        slog.InfoContext(ctx, "invalid token grant type, authorization code is required", "sub", tokenInfo.Subject, "client_id", tokenInfo.ClientID)
                                        api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid token grant type, authorization code is required").Pagination(true))
                                        return
                                }</span>
                        }

                        <span class="cov0" title="0">tokenScopes := strings.Split(tokenInfo.Scopes, " ")
                        if !areScopesValid(scopes, tokenScopes) </span><span class="cov0" title="0">{
                                slog.InfoContext(ctx, "invalid scopes", "token_scopes", tokenInfo.Scopes)
                                api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "token missing scopes").Pagination(true))
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// areScopesValid verifies every scope in requiredScopes has a match among scopes.
// scopes can have more scopes than the defined at requiredScopes, but the contrary results in false.
func areScopesValid(requiredScopes []goidc.Scope, scopes []string) bool <span class="cov0" title="0">{
        for _, requiredScope := range requiredScopes </span><span class="cov0" title="0">{
                if !isScopeValid(requiredScope, scopes) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// isScopeValid verifies if requireScope has a match in scopes.
func isScopeValid(requiredScope goidc.Scope, scopes []string) bool <span class="cov0" title="0">{
        return slices.ContainsFunc(scopes, requiredScope.Matches)
}</span>
</pre>

		<pre class="file" id="file15" style="display: none">package middleware

import (
        "bytes"
        "encoding/base64"
        "errors"
        "io"
        "log/slog"
        "net/http"
        "slices"

        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/idempotency"
)

const headerIdempotencyID = "X-Idempotency-Key"

// Middleware ensures that requests with the same idempotency ID
// are not processed multiple times, returning a cached response if available.
func Idempotency(service idempotency.Service) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        idempotencyID := r.Header.Get(headerIdempotencyID)
                        if idempotencyID == "" </span><span class="cov0" title="0">{
                                api.WriteError(w, r, api.NewError("ERRO_IDEMPOTENCIA", http.StatusUnprocessableEntity, "missing idempotency key header"))
                                return
                        }</span>

                        // Read and cache request body for comparison or forwarding.
                        <span class="cov0" title="0">bodyBytes, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                api.WriteError(w, r, api.NewError("ERRO_IDEMPOTENCIA", http.StatusBadRequest, "unable to read request body"))
                                return
                        }</span>
                        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewReader(bodyBytes))

                        rec, err := service.Response(r.Context(), idempotencyID)
                        if err == nil </span><span class="cov0" title="0">{
                                // Validate if the current request body matches the stored one.
                                if body := base64.RawStdEncoding.EncodeToString(bodyBytes); body != rec.Request </span><span class="cov0" title="0">{
                                        slog.DebugContext(r.Context(), "mismatched idempotent request payload", "id", rec.ID, "got", body, "expected", rec.Request)
                                        api.WriteError(w, r, api.NewError("ERRO_IDEMPOTENCIA", http.StatusUnprocessableEntity, "request payload does not match previous idempotent request"))
                                        return
                                }</span>

                                <span class="cov0" title="0">slog.InfoContext(r.Context(), "return cached idempotency response")
                                writeIdempotencyResp(w, r, rec)
                                return</span>
                        }

                        <span class="cov0" title="0">if !errors.Is(err, idempotency.ErrNotFound) </span><span class="cov0" title="0">{
                                api.WriteError(w, r, api.NewError("ERRO_IDEMPOTENCIA", http.StatusUnprocessableEntity, err.Error()))
                                return
                        }</span>

                        // No previous record, continue and capture response.
                        <span class="cov0" title="0">recorder := &amp;responseRecorder{ResponseWriter: w, Body: &amp;bytes.Buffer{}, StatusCode: http.StatusOK}
                        next.ServeHTTP(recorder, r)

                        // Only successful responses are stored.
                        // TODO: Add 204 to the list.
                        if !slices.Contains([]int{http.StatusOK, http.StatusCreated, http.StatusAccepted}, recorder.StatusCode) </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">err = service.Create(r.Context(), &amp;idempotency.Record{
                                ID:         idempotencyID,
                                Request:    base64.RawStdEncoding.EncodeToString(bodyBytes),
                                Response:   recorder.Body.String(),
                                StatusCode: recorder.StatusCode,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                slog.ErrorContext(r.Context(), "failed to store idempotent response", "error", err)
                        }</span>
                })
        }

}

func writeIdempotencyResp(w http.ResponseWriter, r *http.Request, rec *idempotency.Record) <span class="cov0" title="0">{
        if len(rec.Response) == 0 </span><span class="cov0" title="0">{
                w.WriteHeader(rec.StatusCode)
                slog.DebugContext(r.Context(), "idempotency record has no response body", "id", rec.ID)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(rec.StatusCode)

        resp, _ := base64.RawStdEncoding.DecodeString(rec.Response)
        if _, err := w.Write(resp); err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(r.Context(), "failed to write cached idempotent response body", "error", err)
        }</span>
}

type responseRecorder struct {
        http.ResponseWriter
        Body       *bytes.Buffer
        StatusCode int
}

func (rr *responseRecorder) WriteHeader(statusCode int) <span class="cov0" title="0">{
        rr.StatusCode = statusCode
        rr.ResponseWriter.WriteHeader(statusCode)
}</span>

func (rr *responseRecorder) Write(b []byte) (int, error) <span class="cov0" title="0">{
        rr.Body.Write(b)
        return rr.ResponseWriter.Write(b)
}</span>
</pre>

		<pre class="file" id="file16" style="display: none">package middleware

import (
        "bytes"
        "crypto"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "slices"

        "github.com/go-jose/go-jose/v4"
        "github.com/go-jose/go-jose/v4/jwt"
        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/jwtutil"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

// JWT creates a middleware that handles JWT request/response processing.
// It validates incoming JWT requests and signs outgoing JWT responses.
func JWT(baseURL, bankOrgID, keystoreHost string, signer crypto.Signer) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                next = requestMiddlewareHandler(next, baseURL, keystoreHost)
                next = responseMiddlewareHandler(next, bankOrgID, signer)
                return next
        }</span>
}

// requestMiddlewareHandler processes incoming JWT requests by validating the JWT signature,
// claims, and extracting the payload data for downstream handlers.
func requestMiddlewareHandler(next http.Handler, baseURL, keystoreHost string) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{

                if r.Method == http.MethodGet || r.Method == http.MethodDelete </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">jwsBytes, err := io.ReadAll(r.Body)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "failed to read request jwt body", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "failed to read request body"))
                        return
                }</span>
                <span class="cov0" title="0">defer r.Body.Close()

                jws := string(jwsBytes)
                parsedJWT, err := jwt.ParseSigned(jws, []jose.SignatureAlgorithm{goidc.PS256})
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "invalid jwt", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "invalid jwt"))
                        return
                }</span>

                <span class="cov0" title="0">clientOrgID := r.Context().Value(api.CtxKeyOrgID).(string)
                resp, err := http.Get(keystoreHost + fmt.Sprintf("/%s/application.jwks", clientOrgID))
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "failed to fetch jwks", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "failed to fetch jwks"))
                        return
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "failed to fetch jwks", "status", resp.StatusCode)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "failed to fetch jwks"))
                        return
                }</span>

                <span class="cov0" title="0">var jwks jose.JSONWebKeySet
                if err := json.NewDecoder(resp.Body).Decode(&amp;jwks); err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "failed to decode jwks", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "failed to decode organization jwks"))
                        return
                }</span>

                <span class="cov0" title="0">var jwtClaims jwt.Claims
                var claims map[string]any
                if err := parsedJWT.Claims(jwks, &amp;jwtClaims, &amp;claims); err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "invalid jwt signature", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "invalid jwt signature"))
                        return
                }</span>

                <span class="cov0" title="0">if jwtClaims.IssuedAt == nil </span><span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "iat claim is missing"))
                        return
                }</span>

                <span class="cov0" title="0">if jwtClaims.ID == "" </span><span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "jti claim is missing"))
                        return
                }</span>

                <span class="cov0" title="0">if jwtClaims.Issuer != clientOrgID </span><span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("FORBIDDEN", http.StatusForbidden, "iss claim does not match the client org id"))
                        return
                }</span>

                <span class="cov0" title="0">if err := jwtClaims.Validate(jwt.Expected{
                        AnyAudience: []string{baseURL + r.URL.Path},
                }); err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "invalid jwt claims", slog.String("error", err.Error()))
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "JWT validation failed"))
                        return
                }</span>

                <span class="cov0" title="0">claims = map[string]any{
                        "data": claims["data"],
                }

                jsonBytes, err := json.Marshal(claims)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "failed to convert claims to json", "error", err)
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, "failed to convert claims to json"))
                        return
                }</span>

                <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewReader(jsonBytes))
                r.ContentLength = int64(len(jsonBytes))
                r.Header.Set("Content-Type", "application/json")

                next.ServeHTTP(w, r)</span>
        })
}

// responseMiddlewareHandler processes outgoing responses by wrapping them in a JWT
// with the bank's signature and required claims.
func responseMiddlewareHandler(next http.Handler, bankOrgID string, signer crypto.Signer) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                rec := &amp;responseBuffer{
                        ResponseWriter: w,
                        Body:           &amp;bytes.Buffer{},
                        StatusCode:     http.StatusOK,
                }
                next.ServeHTTP(rec, r)

                if rec.Body.Len() == 0 </span><span class="cov0" title="0">{
                        w.WriteHeader(rec.StatusCode)
                        return
                }</span>

                // Only sign successful responses and 422 responses.
                <span class="cov0" title="0">if !slices.Contains([]int{
                        http.StatusOK,
                        http.StatusCreated,
                        http.StatusAccepted,
                        http.StatusUnprocessableEntity,
                }, rec.StatusCode) </span><span class="cov0" title="0">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(rec.StatusCode)
                        _, _ = w.Write(rec.Body.Bytes())
                        return
                }</span>

                <span class="cov0" title="0">var respPayload map[string]any
                if err := json.Unmarshal(rec.Body.Bytes(), &amp;respPayload); err != nil </span><span class="cov0" title="0">{
                        api.WriteError(w, r, fmt.Errorf("failed to parse response for jwt encoding: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">respPayload["iss"] = bankOrgID
                respPayload["aud"] = r.Context().Value(api.CtxKeyOrgID)
                respPayload["jti"] = uuid.NewString()
                respPayload["iat"] = timeutil.Timestamp()

                jwsResp, err := jwtutil.Sign(respPayload, signer)
                if err != nil </span><span class="cov0" title="0">{
                        api.WriteError(w, r, fmt.Errorf("failed to sign jwt: %w", err))
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/jwt")
                w.WriteHeader(rec.StatusCode)
                _, _ = w.Write([]byte(jwsResp))</span>
        })
}

// responseBuffer captures the response from downstream handlers to allow
// JWT processing before sending to the client.
type responseBuffer struct {
        http.ResponseWriter
        Body       *bytes.Buffer
        StatusCode int
}

func (rr *responseBuffer) WriteHeader(statusCode int) <span class="cov0" title="0">{
        rr.StatusCode = statusCode
}</span>

func (rr *responseBuffer) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return rr.Body.Write(b)
}</span>
</pre>

		<pre class="file" id="file17" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/consent"
)

// Permission creates a middleware that validates phase 2 consent permissions for the request.
// It checks if the consent is active, authorized, and has the required permissions.
// The consent ID is extracted from the scopes and added to the request context.
func Permission(consentService consent.Service, permissions ...consent.Permission) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        ctx := r.Context()
                        scopes := ctx.Value(api.CtxKeyScopes).(string)
                        orgID := ctx.Value(api.CtxKeyOrgID).(string)

                        id, _ := consent.IDFromScopes(scopes)
                        c, err := consentService.Consent(ctx, id, orgID)
                        if err != nil </span><span class="cov0" title="0">{
                                slog.DebugContext(ctx, "could not find consent", "consent_id", id, "error", err)
                                api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid token"))
                                return
                        }</span>

                        <span class="cov0" title="0">if c.Status != consent.StatusAuthorized </span><span class="cov0" title="0">{
                                slog.DebugContext(ctx, "the consent is not authorized", "consent_id", id, "status", c.Status)
                                api.WriteError(w, r, api.NewError("INVALID_STATUS", http.StatusUnauthorized, "the consent is not authorized"))
                                return
                        }</span>

                        <span class="cov0" title="0">if !c.HasPermissions(permissions) </span><span class="cov0" title="0">{
                                slog.DebugContext(ctx, "the consent doesn't have the required permissions", "consent_id", id)
                                api.WriteError(w, r, api.NewError("INVALID_STATUS", http.StatusForbidden, "the consent is missing permissions"))
                        }</span>

                        <span class="cov0" title="0">r = r.WithContext(context.WithValue(ctx, api.CtxKeyConsentID, id))
                        next.ServeHTTP(w, r)</span>
                })
        }
}
</pre>

		<pre class="file" id="file18" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/getkin/kin-openapi/openapi3filter"
        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/oidc"
        netmiddleware "github.com/oapi-codegen/nethttp-middleware"
)

const (
        HeaderCustomerIPAddress  = "X-FAPI-Customer-IP-Address"
        HeaderCustomerUserAgent  = "X-Customer-User-Agent"
        HeaderXFAPIInteractionID = "X-FAPI-Interaction-ID"
)

func CertCN(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                cert, err := oidc.ClientCert(r)
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "could not get client certificate", "error", err)
                        api.WriteError(w, r, api.NewError("UNAUTHORISED", http.StatusUnauthorized, "invalid certificate: could not get client certificate").Pagination(true))
                        return
                }</span>

                <span class="cov0" title="0">ctx := r.Context()
                ctx = context.WithValue(ctx, api.CtxKeyCertCN, cert.Subject.CommonName)
                r = r.WithContext(ctx)
                next.ServeHTTP(w, r)</span>
        })
}

type Options struct {
        ErrorPagination bool
}

func FAPIID(opts *Options) func(http.Handler) http.Handler <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;Options{}
        }</span>
        <span class="cov0" title="0">return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        interactionID := r.Header.Get(HeaderXFAPIInteractionID)
                        if _, err := uuid.Parse(interactionID); err != nil </span><span class="cov0" title="0">{
                                w.Header().Add(HeaderXFAPIInteractionID, uuid.NewString())
                                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusBadRequest, "The fapi interaction id is missing or invalid").Pagination(opts.ErrorPagination))
                                return
                        }</span>

                        // Return the same interaction ID in the response.
                        <span class="cov0" title="0">w.Header().Set(HeaderXFAPIInteractionID, interactionID)
                        next.ServeHTTP(w, r)</span>
                })
        }
}

func Swagger(getSwagger func() (*openapi3.T, error), errCodeFunc func(error) string) (middleware func(http.Handler) http.Handler, version string) <span class="cov0" title="0">{
        spec, err := getSwagger()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return netmiddleware.OapiRequestValidatorWithOptions(spec, &amp;netmiddleware.Options{
                DoNotValidateServers: true,
                Options: openapi3filter.Options{
                        AuthenticationFunc: func(ctx context.Context, ai *openapi3filter.AuthenticationInput) error </span><span class="cov0" title="0">{
                                return nil
                        }</span>,
                },
                ErrorHandlerWithOpts: func(ctx context.Context, err error, w http.ResponseWriter, r *http.Request, opts netmiddleware.ErrorHandlerOpts) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError(errCodeFunc(err), http.StatusUnprocessableEntity, err.Error()))
                }</span>,
        }), spec.Info.Version
}

func Version(v string) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        w.Header().Set("X-V", v)
                        next.ServeHTTP(w, r)
                }</span>)
        }
}
</pre>

		<pre class="file" id="file19" style="display: none">package api

import (
        "net/url"
        "strconv"

        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type ContextKey string

const (
        CtxKeyCorrelationID ContextKey = "correlation_id"
        CtxKeyClientID      ContextKey = "client_id"
        CtxKeyCertCN        ContextKey = "cert_cn"
        CtxKeySubject       ContextKey = "subject"
        CtxKeyScopes        ContextKey = "scopes"
        CtxKeyConsentID     ContextKey = "consent_id"
        CtxKeyInteractionID ContextKey = "interaction_id"
        CtxKeyOrgID         ContextKey = "org_id"
        CtxKeySessionID     ContextKey = "session_id"
)

type Links struct {
        First string `json:"first,omitempty"`
        Last  string `json:"last,omitempty"`
        Next  string `json:"next,omitempty"`
        Prev  string `json:"prev,omitempty"`
        Self  string `json:"self"`
}

func NewLinks(self string) *Links <span class="cov0" title="0">{
        return &amp;Links{
                Self: self,
        }
}</span>

// NewPaginatedLinks generates pagination links (self, first, prev, next, last) based on
// the current page information and the requested URL.
func NewPaginatedLinks[T any](self string, page page.Page[T]) *Links <span class="cov0" title="0">{
        // Helper function to construct a URL with query parameters for pagination.
        buildURL := func(pageNumber int) string </span><span class="cov0" title="0">{
                u, _ := url.Parse(self)
                query := u.Query()
                query.Set("page", strconv.Itoa(pageNumber))
                query.Set("page-size", strconv.Itoa(page.Size))
                u.RawQuery = query.Encode()
                return u.String()
        }</span>

        // Populate the Links struct.
        <span class="cov0" title="0">links := &amp;Links{
                Self: self,
        }

        // If the current page is not the first, generate the "first" and "previous"
        // links.
        if page.Number &gt; 1 </span><span class="cov0" title="0">{
                links.First = buildURL(1)
                links.Prev = buildURL(page.Number - 1)
        }</span>

        // If the current page is not the last, generate the "next" and "last" links.
        <span class="cov0" title="0">if page.Number &lt; page.TotalPages </span><span class="cov0" title="0">{
                links.Next = buildURL(page.Number + 1)
                links.Last = buildURL(page.TotalPages)
        }</span>

        <span class="cov0" title="0">return links</span>
}

type Meta struct {
        RequestDateTime timeutil.DateTime `json:"requestDateTime"`
        TotalRecords    *int              `json:"totalRecords,omitempty"`
        TotalPages      *int              `json:"totalPages,omitempty"`
}

func NewMeta() *Meta <span class="cov0" title="0">{
        return &amp;Meta{
                RequestDateTime: timeutil.DateTimeNow(),
        }
}</span>

func NewPaginatedMeta[T any](p page.Page[T]) *Meta <span class="cov0" title="0">{
        return &amp;Meta{
                RequestDateTime: timeutil.DateTimeNow(),
                TotalRecords:    &amp;p.TotalRecords,
                TotalPages:      &amp;p.TotalPages,
        }
}</span>

func NewSingleRecordMeta() *Meta <span class="cov0" title="0">{
        one := 1
        return &amp;Meta{
                RequestDateTime: timeutil.DateTimeNow(),
                TotalRecords:    &amp;one,
                TotalPages:      &amp;one,
        }
}</span>
</pre>

		<pre class="file" id="file20" style="display: none">package oidc

import (
        "net/http"
        "strings"

        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/rs/cors"
        "github.com/unrolled/secure"
)

type Server struct {
        provider *provider.Provider
        host     string
}

func NewServer(host string, provider *provider.Provider) Server <span class="cov0" title="0">{
        return Server{host: host, provider: provider}
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        corsMiddleware := cors.New(cors.Options{
                AllowedOrigins:   []string{s.host},
                AllowCredentials: true,
                AllowedMethods:   []string{http.MethodHead, http.MethodGet, http.MethodPost},
        })
        secureMiddleware := secure.New(secure.Options{
                STSSeconds:            31536000,
                STSIncludeSubdomains:  true,
                STSPreload:            true,
                FrameDeny:             true,
                ContentTypeNosniff:    true,
                BrowserXssFilter:      true,
                ContentSecurityPolicy: "default-src 'self'; script-src 'self' $NONCE; style-src 'self' $NONCE",
        })
        autorizeMiddleware := func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        if strings.Contains(r.URL.Path, "/authorize") </span><span class="cov0" title="0">{
                                handler := corsMiddleware.Handler(next)
                                handler = secureMiddleware.Handler(handler)
                                handler.ServeHTTP(w, r)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }

        <span class="cov0" title="0">s.provider.RegisterRoutes(mux, autorizeMiddleware)</span>
}
</pre>

		<pre class="file" id="file21" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=paymentv4 -o=./api_gen.go ./swagger.yml
package paymentv4

import (
        "context"
        "crypto"
        "errors"
        "net/http"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/enrollment"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/idempotency"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var _ StrictServerInterface = Server{}

type BankConfig interface {
        Host() string
        ISPB() string
        IBGETownCode() string
        AccountBranch() string
}

type Server struct {
        config             BankConfig
        baseURL            string
        service            payment.Service
        idempotencyService idempotency.Service
        op                 *provider.Provider
        keystoreHost       string
        orgID              string
        signer             crypto.Signer
}

func NewServer(
        config BankConfig,
        service payment.Service,
        idempotencyService idempotency.Service,
        op *provider.Provider,
        keystoreHost string,
        orgID string,
        signer crypto.Signer,
) Server <span class="cov0" title="0">{
        service = service.WithVersion("v4")
        return Server{
                config:             config,
                baseURL:            config.Host() + "/open-banking/payments/v4",
                service:            service,
                idempotencyService: idempotencyService,
                op:                 op,
                keystoreHost:       keystoreHost,
                orgID:              orgID,
                signer:             signer,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        paymentMux := http.NewServeMux()

        jwtMiddleware := middleware.JWT(s.baseURL, s.orgID, s.keystoreHost, s.signer)
        idempotencyMiddleware := middleware.Idempotency(s.idempotencyService)
        clientCredentialsAuthMiddleware := middleware.Auth(s.op, goidc.GrantClientCredentials, payment.Scope)
        authCodeAuthMiddleware := middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID)
        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{
                var schemaErr *openapi3.SchemaError
                if errors.As(err, &amp;schemaErr) &amp;&amp; schemaErr.SchemaField == "required" </span><span class="cov0" title="0">{
                        return "PARAMETRO_NAO_INFORMADO"
                }</span>
                <span class="cov0" title="0">return "PARAMETRO_INVALIDO"</span>
        })

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err)
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{swaggerMiddleware},
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.PaymentsPostConsents)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        paymentMux.Handle("POST /consents", handler)

        handler = http.HandlerFunc(wrapper.PaymentsGetConsentsConsentID)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        paymentMux.Handle("GET /consents/{consentId}", handler)

        handler = http.HandlerFunc(wrapper.PaymentsPostPixPayments)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = authCodeAuthMiddleware(handler)
        paymentMux.Handle("POST /pix/payments", handler)

        handler = http.HandlerFunc(wrapper.PaymentsGetPixPaymentsPaymentID)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        paymentMux.Handle("GET /pix/payments/{paymentId}", handler)

        handler = http.HandlerFunc(wrapper.PaymentsPatchPixPaymentsConsentID)
        handler = idempotencyMiddleware(handler)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        paymentMux.Handle("PATCH /pix/payments/consents/{consentId}", handler)

        handler = http.HandlerFunc(wrapper.PaymentsPatchPixPaymentsPaymentID)
        handler = jwtMiddleware(handler)
        handler = clientCredentialsAuthMiddleware(handler)
        paymentMux.Handle("PATCH /pix/payments/{paymentId}", handler)

        handler = middleware.FAPIID(nil)(paymentMux)
        mux.Handle("/open-banking/payments/v4/", http.StripPrefix("/open-banking/payments/v4", handler))</span>
}

func (s Server) PaymentsPostConsents(ctx context.Context, req PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error) <span class="cov0" title="0">{
        clientID := ctx.Value(api.CtxKeyClientID).(string)
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        c := &amp;payment.Consent{
                UserIdentification:    req.Body.Data.LoggedUser.Document.Identification,
                UserRel:               consent.Relation(req.Body.Data.LoggedUser.Document.Rel),
                ClientID:              clientID,
                CreditorType:          payment.CreditorType(req.Body.Data.Creditor.PersonType),
                CreditorCPFCNPJ:       req.Body.Data.Creditor.CpfCnpj,
                CreditorName:          req.Body.Data.Creditor.Name,
                CreditorAccountISBP:   req.Body.Data.Payment.Details.CreditorAccount.Ispb,
                CreditorAccountNumber: req.Body.Data.Payment.Details.CreditorAccount.Number,
                CreditorAccountType:   payment.AccountType(req.Body.Data.Payment.Details.CreditorAccount.AccountType),
                CreditorAccountIssuer: req.Body.Data.Payment.Details.CreditorAccount.Issuer,
                PaymentType:           payment.Type(req.Body.Data.Payment.Type),
                PaymentCurrency:       req.Body.Data.Payment.Currency,
                PaymentAmount:         req.Body.Data.Payment.Amount,
                PaymentSchedule:       req.Body.Data.Payment.Schedule,
                PaymentDate:           req.Body.Data.Payment.Date,
                LocalInstrument:       payment.LocalInstrument(req.Body.Data.Payment.Details.LocalInstrument),
                IBGETownCode:          req.Body.Data.Payment.IbgeTownCode,
                QRCode:                req.Body.Data.Payment.Details.QrCode,
                Proxy:                 req.Body.Data.Payment.Details.Proxy,
                OrgID:                 orgID,
        }
        if business := req.Body.Data.BusinessEntity; business != nil </span><span class="cov0" title="0">{
                rel := consent.Relation(business.Document.Rel)
                c.BusinessIdentification = &amp;business.Document.Identification
                c.BusinessRel = &amp;rel
        }</span>

        <span class="cov0" title="0">var debtorAccount *payment.Account
        if req.Body.Data.DebtorAccount != nil </span><span class="cov0" title="0">{
                debtorAccount = &amp;payment.Account{
                        ISPB:   req.Body.Data.DebtorAccount.Ispb,
                        Issuer: req.Body.Data.DebtorAccount.Issuer,
                        Number: req.Body.Data.DebtorAccount.Number,
                        Type:   payment.AccountType(req.Body.Data.DebtorAccount.AccountType),
                }
        }</span>
        <span class="cov0" title="0">if err := s.service.CreateConsent(ctx, c, debtorAccount); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseCreatePaymentConsent{
                Data: struct {
                        BusinessEntity     *BusinessEntity        "json:\"businessEntity,omitempty\""
                        ConsentID          string                 "json:\"consentId\""
                        CreationDateTime   timeutil.DateTime      "json:\"creationDateTime\""
                        Creditor           Identification         "json:\"creditor\""
                        DebtorAccount      *ConsentsDebtorAccount "json:\"debtorAccount,omitempty\""
                        ExpirationDateTime timeutil.DateTime      "json:\"expirationDateTime\""
                        LoggedUser         LoggedUser             "json:\"loggedUser\""
                        Payment            struct {
                                Amount       string               "json:\"amount\""
                                Currency     string               "json:\"currency\""
                                Date         *timeutil.BrazilDate "json:\"date,omitempty\""
                                Details      Details              "json:\"details\""
                                IbgeTownCode *string              "json:\"ibgeTownCode,omitempty\""
                                Schedule     *Schedule            "json:\"schedule,omitempty\""
                                Type         EnumPaymentType      "json:\"type\""
                        } "json:\"payment\""
                        Status               EnumAuthorisationStatusType "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime           "json:\"statusUpdateDateTime\""
                }{
                        ConsentID:            c.URN(),
                        Status:               EnumAuthorisationStatusType(c.Status),
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        CreationDateTime:     c.CreatedAt,
                        ExpirationDateTime:   c.ExpiresAt,

                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: c.UserIdentification,
                                        Rel:            string(c.UserRel),
                                },
                        },
                        Creditor: Identification{
                                CpfCnpj:    c.CreditorCPFCNPJ,
                                Name:       c.CreditorName,
                                PersonType: EnumPaymentPersonType(c.CreditorType),
                        },
                        Payment: struct {
                                Amount       string               "json:\"amount\""
                                Currency     string               "json:\"currency\""
                                Date         *timeutil.BrazilDate "json:\"date,omitempty\""
                                Details      Details              "json:\"details\""
                                IbgeTownCode *string              "json:\"ibgeTownCode,omitempty\""
                                Schedule     *Schedule            "json:\"schedule,omitempty\""
                                Type         EnumPaymentType      "json:\"type\""
                        }{
                                Amount:       c.PaymentAmount,
                                Currency:     c.PaymentCurrency,
                                Schedule:     c.PaymentSchedule,
                                Type:         EnumPaymentType(c.PaymentType),
                                IbgeTownCode: c.IBGETownCode,
                                Details: Details{
                                        CreditorAccount: CreditorAccount{
                                                Ispb:        c.CreditorAccountISBP,
                                                Number:      c.CreditorAccountNumber,
                                                AccountType: EnumAccountPaymentsType(c.CreditorAccountType),
                                                Issuer:      c.CreditorAccountIssuer,
                                        },
                                        LocalInstrument: EnumLocalInstrument(c.LocalInstrument),
                                        QrCode:          c.QRCode,
                                        Proxy:           c.Proxy,
                                },
                                Date: c.PaymentDate,
                        },
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/consents/" + c.URN()),
        }

        if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                rel := *c.BusinessRel
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *c.BusinessIdentification,
                                Rel:            string(rel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;ConsentsDebtorAccount{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      c.DebtorAccount.Number,
                        AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(c.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">return PaymentsPostConsents201JSONResponse{N201PaymentsConsentsConsentCreatedJSONResponse(resp)}, nil</span>
}

func (s Server) PaymentsGetConsentsConsentID(ctx context.Context, req PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        c, err := s.service.Consent(ctx, req.ConsentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponsePaymentConsent{
                Data: struct {
                        BusinessEntity       *BusinessEntity             "json:\"businessEntity,omitempty\""
                        ConsentID            string                      "json:\"consentId\""
                        CreationDateTime     timeutil.DateTime           "json:\"creationDateTime\""
                        Creditor             Identification              "json:\"creditor\""
                        DebtorAccount        *ConsentsDebtorAccount      "json:\"debtorAccount,omitempty\""
                        ExpirationDateTime   timeutil.DateTime           "json:\"expirationDateTime\""
                        LoggedUser           LoggedUser                  "json:\"loggedUser\""
                        Payment              PaymentConsent              "json:\"payment\""
                        RejectionReason      *ConsentRejectionReason     "json:\"rejectionReason,omitempty\""
                        Status               EnumAuthorisationStatusType "json:\"status\""
                        StatusUpdateDateTime timeutil.DateTime           "json:\"statusUpdateDateTime\""
                }{
                        ConsentID:            c.URN(),
                        Status:               EnumAuthorisationStatusType(c.Status),
                        StatusUpdateDateTime: c.StatusUpdatedAt,
                        CreationDateTime:     c.CreatedAt,
                        ExpirationDateTime:   c.ExpiresAt,
                        Creditor: Identification{
                                CpfCnpj:    c.CreditorCPFCNPJ,
                                Name:       c.CreditorName,
                                PersonType: EnumPaymentPersonType(c.CreditorType),
                        },
                        LoggedUser: LoggedUser{
                                Document: struct {
                                        Identification string "json:\"identification\""
                                        Rel            string "json:\"rel\""
                                }{
                                        Identification: c.UserIdentification,
                                        Rel:            string(c.UserRel),
                                },
                        },
                        Payment: PaymentConsent{
                                Amount:   c.PaymentAmount,
                                Currency: c.PaymentCurrency,
                                Details: Details{
                                        CreditorAccount: CreditorAccount{
                                                AccountType: EnumAccountPaymentsType(c.CreditorAccountType),
                                                Ispb:        c.CreditorAccountISBP,
                                                Number:      c.CreditorAccountNumber,
                                                Issuer:      c.CreditorAccountIssuer,
                                        },
                                        LocalInstrument: EnumLocalInstrument(c.LocalInstrument),
                                        QrCode:          c.QRCode,
                                        Proxy:           c.Proxy,
                                },
                                Schedule:     c.PaymentSchedule,
                                Date:         c.PaymentDate,
                                Type:         EnumPaymentType(c.PaymentType),
                                IbgeTownCode: c.IBGETownCode,
                        },
                },
                Meta:  *api.NewMeta(),
                Links: *api.NewLinks(s.baseURL + "/consents/" + c.URN()),
        }

        if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                resp.Data.BusinessEntity = &amp;BusinessEntity{
                        Document: struct {
                                Identification string "json:\"identification\""
                                Rel            string "json:\"rel\""
                        }{
                                Identification: *c.BusinessIdentification,
                                Rel:            string(*c.BusinessRel),
                        },
                }
        }</span>

        <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                branch := s.config.AccountBranch()
                resp.Data.DebtorAccount = &amp;ConsentsDebtorAccount{
                        Ispb:        s.config.ISPB(),
                        Issuer:      &amp;branch,
                        Number:      c.DebtorAccount.Number,
                        AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(c.DebtorAccount.Type)),
                }
        }</span>

        <span class="cov0" title="0">if c.Rejection != nil </span><span class="cov0" title="0">{
                resp.Data.RejectionReason = &amp;ConsentRejectionReason{
                        Code:   EnumConsentRejectionReasonType(c.Rejection.Code),
                        Detail: c.Rejection.Detail,
                }
        }</span>

        <span class="cov0" title="0">return PaymentsGetConsentsConsentID200JSONResponse{N200PaymentsConsentsConsentIDReadJSONResponse(resp)}, nil</span>
}

func (s Server) PaymentsPostPixPayments(ctx context.Context, req PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        clientID := ctx.Value(api.CtxKeyClientID).(string)
        scopes := ctx.Value(api.CtxKeyScopes).(string)
        var payments []*payment.Payment
        for _, reqPayment := range req.Body.Data </span><span class="cov0" title="0">{
                p := &amp;payment.Payment{
                        Amount:                    reqPayment.Payment.Amount,
                        Currency:                  reqPayment.Payment.Currency,
                        CreditorAccountISBP:       reqPayment.CreditorAccount.Ispb,
                        CreditorAccountIssuer:     reqPayment.CreditorAccount.Issuer,
                        CreditorAccountNumber:     reqPayment.CreditorAccount.Number,
                        CreditorAccountType:       payment.AccountType(reqPayment.CreditorAccount.AccountType),
                        RemittanceInformation:     reqPayment.RemittanceInformation,
                        QRCode:                    reqPayment.QrCode,
                        Proxy:                     reqPayment.Proxy,
                        TransactionIdentification: reqPayment.TransactionIdentification,
                        IBGETownCode:              reqPayment.IbgeTownCode,
                        ClientID:                  clientID,
                        OrgID:                     orgID,
                }

                if reqPayment.ConsentID != nil </span><span class="cov0" title="0">{
                        p.ConsentID = uuid.MustParse(strings.TrimPrefix(*reqPayment.ConsentID, payment.ConsentURNPrefix))
                }</span>

                <span class="cov0" title="0">if consentID, _ := payment.ConsentIDFromScopes(scopes); consentID != "" </span><span class="cov0" title="0">{
                        p.ConsentID = uuid.MustParse(consentID)
                }</span>

                <span class="cov0" title="0">if enrollmentID, _ := enrollment.IDFromScopes(scopes); enrollmentID != "" </span><span class="cov0" title="0">{
                        id := uuid.MustParse(enrollmentID)
                        p.EnrollmentID = &amp;id
                }</span>

                <span class="cov0" title="0">if reqPayment.EndToEndID != nil </span><span class="cov0" title="0">{
                        p.EndToEndID = *reqPayment.EndToEndID
                }</span>

                <span class="cov0" title="0">if reqPayment.CnpjInitiator != nil </span><span class="cov0" title="0">{
                        p.CNPJInitiator = *reqPayment.CnpjInitiator
                }</span>

                <span class="cov0" title="0">if reqPayment.LocalInstrument != nil </span><span class="cov0" title="0">{
                        p.LocalInstrument = payment.LocalInstrument(*reqPayment.LocalInstrument)
                }</span>

                <span class="cov0" title="0">if reqPayment.AuthorisationFlow != nil </span><span class="cov0" title="0">{
                        authFlow := payment.AuthorisationFlow(*reqPayment.AuthorisationFlow)
                        p.AuthorisationFlow = &amp;authFlow
                }</span>

                <span class="cov0" title="0">payments = append(payments, p)</span>
        }

        <span class="cov0" title="0">if err := s.service.CreatePayments(ctx, payments); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">branch := s.config.AccountBranch()
        resp := ResponseCreatePixPayment{
                Links: *api.NewLinks(s.baseURL + "/pix/payments/" + payments[0].ID.String()),
                Meta:  *api.NewMeta(),
        }
        for _, p := range payments </span><span class="cov0" title="0">{
                consentID := payment.ConsentURN(p.ConsentID)
                respPayment := struct {
                        AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`
                        CnpjInitiator     string                                         `json:"cnpjInitiator"`
                        ConsentID         *string                                        `json:"consentId,omitempty"`
                        CreationDateTime  timeutil.DateTime                              `json:"creationDateTime"`
                        CreditorAccount   CreditorAccount                                `json:"creditorAccount"`
                        DebtorAccount     DebtorAccount                                  `json:"debtorAccount"`
                        EndToEndID        EndToEndID                                     `json:"endToEndId"`
                        IbgeTownCode      *string                                        `json:"ibgeTownCode,omitempty"`
                        LocalInstrument   EnumLocalInstrument                            `json:"localInstrument"`
                        Payment           struct {
                                Amount   string `json:"amount"`
                                Currency string `json:"currency"`
                        } `json:"payment"`
                        PaymentID                 string                `json:"paymentId"`
                        Proxy                     *string               `json:"proxy,omitempty"`
                        RejectionReason           *RejectionReason      `json:"rejectionReason,omitempty"`
                        RemittanceInformation     *string               `json:"remittanceInformation,omitempty"`
                        Status                    EnumPaymentStatusType `json:"status"`
                        StatusUpdateDateTime      timeutil.DateTime     `json:"statusUpdateDateTime"`
                        TransactionIdentification *string               `json:"transactionIdentification,omitempty"`
                }{
                        PaymentID:        p.ID.String(),
                        CnpjInitiator:    p.CNPJInitiator,
                        ConsentID:        &amp;consentID,
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: CreditorAccount{
                                AccountType: EnumAccountPaymentsType(p.CreditorAccountType),
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                        },
                        EndToEndID:      p.EndToEndID,
                        IbgeTownCode:    p.IBGETownCode,
                        LocalInstrument: EnumLocalInstrument(p.LocalInstrument),
                        Payment: struct {
                                Amount   string "json:\"amount\""
                                Currency string "json:\"currency\""
                        }{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        Proxy:                     p.Proxy,
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                        DebtorAccount: DebtorAccount{
                                AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(p.DebtorAccount.Type)),
                                Ispb:        s.config.ISPB(),
                                Issuer:      &amp;branch,
                                Number:      p.DebtorAccount.Number,
                        },
                }

                resp.Data = append(resp.Data, respPayment)
        }</span>

        <span class="cov0" title="0">return PaymentsPostPixPayments201JSONResponse{N201PaymentsInitiationPixPaymentCreatedJSONResponse(resp)}, nil</span>
}

func (s Server) PaymentsPatchPixPaymentsConsentID(ctx context.Context, req PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        payments, err := s.service.CancelAll(ctx, req.ConsentID, orgID, consent.Document{
                Identification: req.Body.Data.Cancellation.CancelledBy.Document.Identification,
                Rel:            consent.Relation(req.Body.Data.Cancellation.CancelledBy.Document.Rel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponsePatchPixConsent{
                Links: *api.NewLinks(s.baseURL + "/pix/payments/consents/" + req.ConsentID),
                Meta:  *api.NewMeta(),
        }
        for _, p := range payments </span><span class="cov0" title="0">{
                resp.Data = append(resp.Data, struct {
                        PaymentID            string            "json:\"paymentId\""
                        StatusUpdateDateTime timeutil.DateTime "json:\"statusUpdateDateTime\""
                }{
                        PaymentID:            p.ID.String(),
                        StatusUpdateDateTime: p.StatusUpdatedAt,
                })
        }</span>

        <span class="cov0" title="0">return PaymentsPatchPixPaymentsConsentID200JSONResponse{N200PatchPixConsentsJSONResponse(resp)}, nil</span>
}

func (s Server) PaymentsGetPixPaymentsPaymentID(ctx context.Context, req PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        p, err := s.service.Payment(ctx, req.PaymentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">branch := s.config.AccountBranch()
        resp := ResponsePixPayment{
                Data: ResponsePixPaymentData{
                        PaymentID:        p.ID.String(),
                        CnpjInitiator:    p.CNPJInitiator,
                        ConsentID:        payment.ConsentURN(p.ConsentID),
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: CreditorAccount{
                                AccountType: EnumAccountPaymentsType(p.CreditorAccountType),
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                        },
                        EndToEndID:      p.EndToEndID,
                        IbgeTownCode:    p.IBGETownCode,
                        LocalInstrument: EnumLocalInstrument(p.LocalInstrument),
                        Payment: struct {
                                Amount   string "json:\"amount\""
                                Currency string "json:\"currency\""
                        }{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        Proxy:                     p.Proxy,
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                        DebtorAccount: DebtorAccount{
                                AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(p.DebtorAccount.Type)),
                                Ispb:        s.config.ISPB(),
                                Issuer:      &amp;branch,
                                Number:      p.DebtorAccount.Number,
                        },
                },
                Links: *api.NewLinks(s.baseURL + "/pix/payments/" + p.ID.String()),
                Meta:  *api.NewMeta(),
        }

        if p.Rejection != nil </span><span class="cov0" title="0">{
                resp.Data.RejectionReason = &amp;RejectionReasonGetPix{
                        Code:   EnumRejectionReasonTypeGetPix(p.Rejection.Code),
                        Detail: p.Rejection.Detail,
                }
        }</span>

        <span class="cov0" title="0">if p.Cancellation != nil </span><span class="cov0" title="0">{
                cancellation := &amp;PixPaymentCancellation{
                        CancelledAt:   p.Cancellation.At,
                        CancelledFrom: EnumPaymentCancellationFromType(p.Cancellation.From),
                        Reason:        EnumPaymentCancellationReasonType(p.Cancellation.Reason),
                }
                cancellation.CancelledBy.Document.Identification = p.Cancellation.By
                cancellation.CancelledBy.Document.Rel = "CPF"
                resp.Data.Cancellation = cancellation
        }</span>

        <span class="cov0" title="0">return PaymentsGetPixPaymentsPaymentID200JSONResponse{N200PaymentsInitiationPixPaymentIDReadJSONResponse(resp)}, nil</span>
}

func (s Server) PaymentsPatchPixPaymentsPaymentID(ctx context.Context, req PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error) <span class="cov0" title="0">{
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        p, err := s.service.Cancel(ctx, string(req.PaymentID), orgID, consent.Document{
                Identification: req.Body.Data.Cancellation.CancelledBy.Document.Identification,
                Rel:            consent.Relation(req.Body.Data.Cancellation.CancelledBy.Document.Rel),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">branch := s.config.AccountBranch()
        resp := ResponsePatchPixPayment{
                Data: ResponsePatchPixPaymentData{
                        PaymentID:        p.ID.String(),
                        CnpjInitiator:    p.CNPJInitiator,
                        ConsentID:        payment.ConsentURN(p.ConsentID),
                        CreationDateTime: p.CreatedAt,
                        CreditorAccount: CreditorAccount{
                                AccountType: EnumAccountPaymentsType(p.CreditorAccountType),
                                Ispb:        p.CreditorAccountISBP,
                                Issuer:      p.CreditorAccountIssuer,
                                Number:      p.CreditorAccountNumber,
                        },
                        EndToEndID:      p.EndToEndID,
                        IbgeTownCode:    p.IBGETownCode,
                        LocalInstrument: EnumLocalInstrument(p.LocalInstrument),
                        Payment: struct {
                                Amount   string "json:\"amount\""
                                Currency string "json:\"currency\""
                        }{
                                Amount:   p.Amount,
                                Currency: p.Currency,
                        },
                        Proxy:                     p.Proxy,
                        RemittanceInformation:     p.RemittanceInformation,
                        Status:                    EnumPaymentStatusType(p.Status),
                        StatusUpdateDateTime:      p.StatusUpdatedAt,
                        TransactionIdentification: p.TransactionIdentification,
                        DebtorAccount: DebtorAccount{
                                AccountType: EnumAccountPaymentsType(payment.ConvertAccountType(p.DebtorAccount.Type)),
                                Ispb:        s.config.ISPB(),
                                Issuer:      &amp;branch,
                                Number:      p.DebtorAccount.Number,
                        },
                },
                Links: *api.NewLinks(s.baseURL + "/pix/payments/" + p.ID.String()),
                Meta:  *api.NewMeta(),
        }

        if p.Cancellation != nil </span><span class="cov0" title="0">{
                cancellation := PatchPixPaymentCancellation{
                        CancelledAt:   p.Cancellation.At,
                        CancelledFrom: EnumPaymentCancellationFromType(p.Cancellation.From),
                        Reason:        EnumPaymentCancellationReasonType(p.Cancellation.Reason),
                }
                cancellation.CancelledBy.Document.Identification = p.Cancellation.By
                cancellation.CancelledBy.Document.Rel = "CPF"
                resp.Data.Cancellation = cancellation
        }</span>

        <span class="cov0" title="0">return PaymentsPatchPixPaymentsPaymentID200JSONResponse{N200PatchPixPaymentsJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        if errors.Is(err, payment.ErrInvalidEndToEndID) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrCreditorAndDebtorAccountsAreEqual) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DETALHE_PAGAMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrInvalidPayment) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DETALHE_PAGAMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrPaymentDoesNotMatchConsent) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PAGAMENTO_DIVERGENTE_CONSENTIMENTO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrInvalidDate) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("DATA_PAGAMENTO_INVALIDA", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrMissingValue) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_NAO_INFORMADO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrCancelNotAllowed) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PAGAMENTO_NAO_PERMITE_CANCELAMENTO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrInvalidConsentStatus) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CONSENTIMENTO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrInvalidData) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.Is(err, payment.ErrConsentPartiallyAccepted) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("CONSENTIMENTO_PENDENTE_AUTORIZACAO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">if errors.As(err, &amp;errorutil.Error{}) </span><span class="cov0" title="0">{
                api.WriteError(w, r, api.NewError("PARAMETRO_INVALIDO", http.StatusUnprocessableEntity, err.Error()))
                return
        }</span>

        <span class="cov0" title="0">api.WriteError(w, r, err)</span>
}
</pre>

		<pre class="file" id="file22" style="display: none">//go:build go1.22

// Package paymentv4 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package paymentv4

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        NonRedirectAuthorizationCodeScopes = "NonRedirectAuthorizationCode.Scopes"
        OAuth2AuthorizationCodeScopes      = "OAuth2AuthorizationCode.Scopes"
        OAuth2ClientCredentialsScopes      = "OAuth2ClientCredentials.Scopes"
)

// Defines values for N422ResponseErrorCreateConsentErrorsCode.
const (
        N422ResponseErrorCreateConsentErrorsCodeDATAPAGAMENTOINVALIDA    N422ResponseErrorCreateConsentErrorsCode = "DATA_PAGAMENTO_INVALIDA"
        N422ResponseErrorCreateConsentErrorsCodeDETALHEPAGAMENTOINVALIDO N422ResponseErrorCreateConsentErrorsCode = "DETALHE_PAGAMENTO_INVALIDO"
        N422ResponseErrorCreateConsentErrorsCodeERROIDEMPOTENCIA         N422ResponseErrorCreateConsentErrorsCode = "ERRO_IDEMPOTENCIA"
        N422ResponseErrorCreateConsentErrorsCodeFORMAPAGAMENTOINVALIDA   N422ResponseErrorCreateConsentErrorsCode = "FORMA_PAGAMENTO_INVALIDA"
        N422ResponseErrorCreateConsentErrorsCodeNAOINFORMADO             N422ResponseErrorCreateConsentErrorsCode = "NAO_INFORMADO"
        N422ResponseErrorCreateConsentErrorsCodePARAMETROINVALIDO        N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_INVALIDO"
        N422ResponseErrorCreateConsentErrorsCodePARAMETRONAOINFORMADO    N422ResponseErrorCreateConsentErrorsCode = "PARAMETRO_NAO_INFORMADO"
)

// Defines values for CreatePixPaymentDataAuthorisationFlow.
const (
        CreatePixPaymentDataAuthorisationFlowCIBAFLOW   CreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
        CreatePixPaymentDataAuthorisationFlowFIDOFLOW   CreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
        CreatePixPaymentDataAuthorisationFlowHYBRIDFLOW CreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for EnumAccountPaymentsType.
const (
        CACC EnumAccountPaymentsType = "CACC"
        SVGS EnumAccountPaymentsType = "SVGS"
        TRAN EnumAccountPaymentsType = "TRAN"
)

// Defines values for EnumAuthorisationStatusType.
const (
        AUTHORISED            EnumAuthorisationStatusType = "AUTHORISED"
        AWAITINGAUTHORISATION EnumAuthorisationStatusType = "AWAITING_AUTHORISATION"
        CONSUMED              EnumAuthorisationStatusType = "CONSUMED"
        PARTIALLYACCEPTED     EnumAuthorisationStatusType = "PARTIALLY_ACCEPTED"
        REJECTED              EnumAuthorisationStatusType = "REJECTED"
)

// Defines values for EnumConsentRejectionReasonType.
const (
        EnumConsentRejectionReasonTypeCONTANAOPERMITEPAGAMENTO  EnumConsentRejectionReasonType = "CONTA_NAO_PERMITE_PAGAMENTO"
        EnumConsentRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS EnumConsentRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        EnumConsentRejectionReasonTypeFALHAINFRAESTRUTURA       EnumConsentRejectionReasonType = "FALHA_INFRAESTRUTURA"
        EnumConsentRejectionReasonTypeNAOINFORMADO              EnumConsentRejectionReasonType = "NAO_INFORMADO"
        EnumConsentRejectionReasonTypeQRCODEINVALIDO            EnumConsentRejectionReasonType = "QRCODE_INVALIDO"
        EnumConsentRejectionReasonTypeREJEITADOUSUARIO          EnumConsentRejectionReasonType = "REJEITADO_USUARIO"
        EnumConsentRejectionReasonTypeSALDOINSUFICIENTE         EnumConsentRejectionReasonType = "SALDO_INSUFICIENTE"
        EnumConsentRejectionReasonTypeTEMPOEXPIRADOAUTORIZACAO  EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_AUTORIZACAO"
        EnumConsentRejectionReasonTypeTEMPOEXPIRADOCONSUMO      EnumConsentRejectionReasonType = "TEMPO_EXPIRADO_CONSUMO"
        EnumConsentRejectionReasonTypeVALORACIMALIMITE          EnumConsentRejectionReasonType = "VALOR_ACIMA_LIMITE"
        EnumConsentRejectionReasonTypeVALORINVALIDO             EnumConsentRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePayment.
const (
        EnumErrorsCreatePaymentCOBRANCAINVALIDA                 EnumErrorsCreatePayment = "COBRANCA_INVALIDA"
        EnumErrorsCreatePaymentCONSENTIMENTOINVALIDO            EnumErrorsCreatePayment = "CONSENTIMENTO_INVALIDO"
        EnumErrorsCreatePaymentCONSENTIMENTOPENDENTEAUTORIZACAO EnumErrorsCreatePayment = "CONSENTIMENTO_PENDENTE_AUTORIZACAO"
        EnumErrorsCreatePaymentDETALHEPAGAMENTOINVALIDO         EnumErrorsCreatePayment = "DETALHE_PAGAMENTO_INVALIDO"
        EnumErrorsCreatePaymentERROIDEMPOTENCIA                 EnumErrorsCreatePayment = "ERRO_IDEMPOTENCIA"
        EnumErrorsCreatePaymentNAOINFORMADO                     EnumErrorsCreatePayment = "NAO_INFORMADO"
        EnumErrorsCreatePaymentPAGAMENTODIVERGENTECONSENTIMENTO EnumErrorsCreatePayment = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        EnumErrorsCreatePaymentPAGAMENTORECUSADODETENTORA       EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_DETENTORA"
        EnumErrorsCreatePaymentPAGAMENTORECUSADOSPI             EnumErrorsCreatePayment = "PAGAMENTO_RECUSADO_SPI"
        EnumErrorsCreatePaymentPARAMETROINVALIDO                EnumErrorsCreatePayment = "PARAMETRO_INVALIDO"
        EnumErrorsCreatePaymentPARAMETRONAOINFORMADO            EnumErrorsCreatePayment = "PARAMETRO_NAO_INFORMADO"
        EnumErrorsCreatePaymentSALDOINSUFICIENTE                EnumErrorsCreatePayment = "SALDO_INSUFICIENTE"
        EnumErrorsCreatePaymentVALORACIMALIMITE                 EnumErrorsCreatePayment = "VALOR_ACIMA_LIMITE"
        EnumErrorsCreatePaymentVALORINVALIDO                    EnumErrorsCreatePayment = "VALOR_INVALIDO"
)

// Defines values for EnumErrorsCreatePixPayment.
const (
        PAGAMENTONAOPERMITECANCELAMENTO EnumErrorsCreatePixPayment = "PAGAMENTO_NAO_PERMITE_CANCELAMENTO"
)

// Defines values for EnumLocalInstrument.
const (
        DICT EnumLocalInstrument = "DICT"
        INIC EnumLocalInstrument = "INIC"
        MANU EnumLocalInstrument = "MANU"
        QRDN EnumLocalInstrument = "QRDN"
        QRES EnumLocalInstrument = "QRES"
)

// Defines values for EnumPaymentCancellationFromType.
const (
        DETENTORA  EnumPaymentCancellationFromType = "DETENTORA"
        INICIADORA EnumPaymentCancellationFromType = "INICIADORA"
)

// Defines values for EnumPaymentCancellationReasonType.
const (
        CANCELADOAGENDAMENTO      EnumPaymentCancellationReasonType = "CANCELADO_AGENDAMENTO"
        CANCELADOMULTIPLASALCADAS EnumPaymentCancellationReasonType = "CANCELADO_MULTIPLAS_ALCADAS"
        CANCELADOPENDENCIA        EnumPaymentCancellationReasonType = "CANCELADO_PENDENCIA"
)

// Defines values for EnumPaymentCancellationStatusType.
const (
        EnumPaymentCancellationStatusTypeCANC EnumPaymentCancellationStatusType = "CANC"
)

// Defines values for EnumPaymentPersonType.
const (
        PESSOAJURIDICA EnumPaymentPersonType = "PESSOA_JURIDICA"
        PESSOANATURAL  EnumPaymentPersonType = "PESSOA_NATURAL"
)

// Defines values for EnumPaymentStatusType.
const (
        EnumPaymentStatusTypeACCP EnumPaymentStatusType = "ACCP"
        EnumPaymentStatusTypeACPD EnumPaymentStatusType = "ACPD"
        EnumPaymentStatusTypeACSC EnumPaymentStatusType = "ACSC"
        EnumPaymentStatusTypeCANC EnumPaymentStatusType = "CANC"
        EnumPaymentStatusTypePDNG EnumPaymentStatusType = "PDNG"
        EnumPaymentStatusTypeRCVD EnumPaymentStatusType = "RCVD"
        EnumPaymentStatusTypeRJCT EnumPaymentStatusType = "RJCT"
        EnumPaymentStatusTypeSCHD EnumPaymentStatusType = "SCHD"
)

// Defines values for EnumPaymentType.
const (
        PIX EnumPaymentType = "PIX"
)

// Defines values for EnumRejectionReasonType.
const (
        EnumRejectionReasonTypeCOBRANCAINVALIDA                 EnumRejectionReasonType = "COBRANCA_INVALIDA"
        EnumRejectionReasonTypeCONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonType = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        EnumRejectionReasonTypeDETALHEPAGAMENTOINVALIDO         EnumRejectionReasonType = "DETALHE_PAGAMENTO_INVALIDO"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURA              EnumRejectionReasonType = "FALHA_INFRAESTRUTURA"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DETENTORA"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURADICT          EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_DICT"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURAICP           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_ICP"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        EnumRejectionReasonTypeFALHAINFRAESTRUTURASPI           EnumRejectionReasonType = "FALHA_INFRAESTRUTURA_SPI"
        EnumRejectionReasonTypeNAOINFORMADO                     EnumRejectionReasonType = "NAO_INFORMADO"
        EnumRejectionReasonTypePAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonType = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        EnumRejectionReasonTypePAGAMENTORECUSADODETENTORA       EnumRejectionReasonType = "PAGAMENTO_RECUSADO_DETENTORA"
        EnumRejectionReasonTypePAGAMENTORECUSADOSPI             EnumRejectionReasonType = "PAGAMENTO_RECUSADO_SPI"
        EnumRejectionReasonTypeSALDOINSUFICIENTE                EnumRejectionReasonType = "SALDO_INSUFICIENTE"
        EnumRejectionReasonTypeVALORACIMALIMITE                 EnumRejectionReasonType = "VALOR_ACIMA_LIMITE"
        EnumRejectionReasonTypeVALORINVALIDO                    EnumRejectionReasonType = "VALOR_INVALIDO"
)

// Defines values for EnumRejectionReasonTypeGetPix.
const (
        COBRANCAINVALIDA                 EnumRejectionReasonTypeGetPix = "COBRANCA_INVALIDA"
        CONTASORIGEMDESTINOIGUAIS        EnumRejectionReasonTypeGetPix = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        DETALHEPAGAMENTOINVALIDO         EnumRejectionReasonTypeGetPix = "DETALHE_PAGAMENTO_INVALIDO"
        FALHAAGENDAMENTOPAGAMENTOS       EnumRejectionReasonTypeGetPix = "FALHA_AGENDAMENTO_PAGAMENTOS"
        FALHAINFRAESTRUTURA              EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA"
        FALHAINFRAESTRUTURADETENTORA     EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DETENTORA"
        FALHAINFRAESTRUTURADICT          EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_DICT"
        FALHAINFRAESTRUTURAICP           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_ICP"
        FALHAINFRAESTRUTURAPSPRECEBEDOR  EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        FALHAINFRAESTRUTURASPI           EnumRejectionReasonTypeGetPix = "FALHA_INFRAESTRUTURA_SPI"
        NAOINFORMADO                     EnumRejectionReasonTypeGetPix = "NAO_INFORMADO"
        PAGAMENTODIVERGENTECONSENTIMENTO EnumRejectionReasonTypeGetPix = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        PAGAMENTORECUSADODETENTORA       EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_DETENTORA"
        PAGAMENTORECUSADOSPI             EnumRejectionReasonTypeGetPix = "PAGAMENTO_RECUSADO_SPI"
        SALDOINSUFICIENTE                EnumRejectionReasonTypeGetPix = "SALDO_INSUFICIENTE"
        VALORACIMALIMITE                 EnumRejectionReasonTypeGetPix = "VALOR_ACIMA_LIMITE"
        VALORINVALIDO                    EnumRejectionReasonTypeGetPix = "VALOR_INVALIDO"
)

// Defines values for ResponseCreatePixPaymentDataAuthorisationFlow.
const (
        ResponseCreatePixPaymentDataAuthorisationFlowCIBAFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
        ResponseCreatePixPaymentDataAuthorisationFlowFIDOFLOW   ResponseCreatePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
        ResponseCreatePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponseCreatePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePatchPixPaymentDataAuthorisationFlow.
const (
        ResponsePatchPixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "CIBA_FLOW"
        ResponsePatchPixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePatchPixPaymentDataAuthorisationFlow = "FIDO_FLOW"
        ResponsePatchPixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePatchPixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ResponsePixPaymentDataAuthorisationFlow.
const (
        ResponsePixPaymentDataAuthorisationFlowCIBAFLOW   ResponsePixPaymentDataAuthorisationFlow = "CIBA_FLOW"
        ResponsePixPaymentDataAuthorisationFlowFIDOFLOW   ResponsePixPaymentDataAuthorisationFlow = "FIDO_FLOW"
        ResponsePixPaymentDataAuthorisationFlowHYBRIDFLOW ResponsePixPaymentDataAuthorisationFlow = "HYBRID_FLOW"
)

// Defines values for ScheduleWeeklyWeeklyDayOfWeek.
const (
        DOMINGO      ScheduleWeeklyWeeklyDayOfWeek = "DOMINGO"
        QUARTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUARTA_FEIRA"
        QUINTAFEIRA  ScheduleWeeklyWeeklyDayOfWeek = "QUINTA_FEIRA"
        SABADO       ScheduleWeeklyWeeklyDayOfWeek = "SABADO"
        SEGUNDAFEIRA ScheduleWeeklyWeeklyDayOfWeek = "SEGUNDA_FEIRA"
        SEXTAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "SEXTA_FEIRA"
        TERCAFEIRA   ScheduleWeeklyWeeklyDayOfWeek = "TERCA_FEIRA"
)

// N422ResponseErrorCreateConsent defines model for 422ResponseErrorCreateConsent.
type N422ResponseErrorCreateConsent struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
                // • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
                // • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
                // • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // • PARAMETRO_INVALIDO: Parâmetro inválido.
                // • ERRO_IDEMPOTENCIA: Erro idempotência.
                // • NAO_INFORMADO: Não informado.
                Code N422ResponseErrorCreateConsentErrorsCode `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento [Modalidade] não suportada.
                // • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida para a forma de pagamento selecionada.
                // • DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
                // • PARAMETRO_NAO_INFORMADO: Parâmetro [nome_campo] obrigatório não informado.
                // • PARAMETRO_INVALIDO: Parâmetro [nome_campo] não obedece as regras de formatação esperadas.
                // • ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                // • NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
                // • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
                // • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // • PARAMETRO_INVALIDO: Parâmetro inválido.
                // • ERRO_IDEMPOTENCIA: Erro idempotência.
                // • NAO_INFORMADO: Não informado.
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreateConsentErrorsCode Códigos de erros previstos na criação de consentimento para a iniciação de pagamentos:
// • FORMA_PAGAMENTO_INVALIDA: Forma de pagamento inválida.
// • DATA_PAGAMENTO_INVALIDA: Data de pagamento inválida.
// • DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// • PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// • PARAMETRO_INVALIDO: Parâmetro inválido.
// • ERRO_IDEMPOTENCIA: Erro idempotência.
// • NAO_INFORMADO: Não informado.
type N422ResponseErrorCreateConsentErrorsCode string

// N422ResponseErrorCreatePixPayment defines model for 422ResponseErrorCreatePixPayment.
type N422ResponseErrorCreatePixPayment struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação da iniciação de pagamento:
                //
                // • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
                Code EnumErrorsCreatePixPayment `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                //
                // • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                //
                // • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// N422ResponseErrorCreatePixPayments defines model for 422ResponseErrorCreatePixPayments.
type N422ResponseErrorCreatePixPayments struct {
        Errors []struct {
                // Code Códigos de erros previstos na criação da iniciação de pagamento:
                // - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
                // - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
                // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
                // - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
                // - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
                // - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
                // - PARAMETRO_INVALIDO: Parâmetro inválido.
                // - NAO_INFORMADO: Não informada pela detentora de conta.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
                // - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
                Code EnumErrorsCreatePayment `json:"code"`

                // Detail Descrição específica do erro de acordo com o código reportado:
                // - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
                // - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
                // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
                // - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento ou Status Válido.
                // - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
                // - PARAMETRO_NAO_INFORMADO: endToEndId
                // - PARAMETRO_INVALIDO: endToEndId
                // - NAO_INFORMADO: Não reportado/identificado pela instituição detentora de conta.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Parâmetro [nome_campo] não obedece às regras de negócio.
                // - PAGAMENTO_RECUSADO_DETENTORA: [descrição do motivo de recusa].
                // - PAGAMENTO_RECUSADO_SPI: [código de erro conforme tabela de domínios reason PACS.002].
                // - ERRO_IDEMPOTENCIA: Conteúdo da mensagem (claim data) diverge do conteúdo associado a esta chave de idempotência (x-idempotency-key).
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
                Detail string `json:"detail"`

                // Title Título específico do erro reportado, de acordo com o código enviado:
                // - SALDO_INSUFICIENTE: Saldo insuficiente.
                // - VALOR_ACIMA_LIMITE: Acima do limite estabelecido.
                // - VALOR_INVALIDO: Valor inválido.
                // - COBRANCA_INVALIDA: Cobrança inválida.
                // - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
                // - PARAMETRO_NAO_INFORMADO: Parâmetro obrigatório não informado.
                // - PARAMETRO_INVALIDO: Parâmetro com valor inválido.
                // - NAO_INFORMADO: Não informado.
                // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Divergência entre pagamento e consentimento.
                // - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
                // - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
                // - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
                // - ERRO_IDEMPOTENCIA: Erro idempotência.
                // - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”).
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
type BusinessEntity struct {
        Document struct {
                // Identification Número do documento de identificação oficial do titular pessoa jurídica.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do titular pessoa jurídica.
                Rel string `json:"rel"`
        } `json:"document"`
}

// ConsentRejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
//
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
type ConsentRejectionReason struct {
        // Code Define o código da razão pela qual o consentimento foi rejeitado
        // - VALOR_INVALIDO
        // - NAO_INFORMADO
        // - FALHA_INFRAESTRUTURA
        // - TEMPO_EXPIRADO_AUTORIZACAO
        // - TEMPO_EXPIRADO_CONSUMO
        // - REJEITADO_USUARIO
        // - CONTAS_ORIGEM_DESTINO_IGUAIS
        // - CONTA_NAO_PERMITE_PAGAMENTO
        // - SALDO_INSUFICIENTE
        // - VALOR_ACIMA_LIMITE
        // - QRCODE_INVALIDO
        Code EnumConsentRejectionReasonType `json:"code"`

        // Detail Contém informações adicionais ao consentimento rejeitado.
        // - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado;
        // - NAO_INFORMADO: Não informada pela detentora de conta;
        // - FALHA_INFRAESTRUTURA: [Descrição de qual falha na infraestrutura inviabilizou o processamento].
        // - TEMPO_EXPIRADO_AUTORIZACAO: Consentimento expirou antes que o usuário pudesse confirmá-lo.
        // - TEMPO_EXPIRADO_CONSUMO: O usuário não finalizou o fluxo de pagamento e o consentimento expirou;
        // - REJEITADO_USUARIO: O usuário rejeitou a autorização do consentimento
        // - CONTAS_ORIGEM_DESTINO_IGUAIS: A conta selecionada é igual à conta destino e não permite realizar esse pagamento.
        // - CONTA_NAO_PERMITE_PAGAMENTO: A conta selecionada é do tipo [salario/investimento/liquidação/outros] e não permite realizar esse pagamento.
        // - SALDO_INSUFICIENTE: A conta selecionada não possui saldo suficiente para realizar o pagamento.
        // - VALOR_ACIMA_LIMITE: O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
        // - QRCODE_INVALIDO: O QRCode utilizado para a iniciação de pagamento não é válido.
        //
        // [Restrição] Caso consentimento rejeitado de versões nas quais não havia o campo rejectionReason retornar o seguinte detail: Motivo de rejeição inexistente em versões anteriores.
        Detail string `json:"detail"`
}

// ConsentsDebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
// No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
//
// [Restrição]
// - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
// - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
type ConsentsDebtorAccount struct {
        // AccountType Tipos de contas usadas para pagamento.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountPaymentsType `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// CreatePaymentConsent defines model for CreatePaymentConsent.
type CreatePaymentConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // Creditor Objeto contendo os dados do recebedor (creditor).
                Creditor Identification `json:"creditor"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
                DebtorAccount *DebtorAccount `json:"debtorAccount,omitempty"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // Payment Objeto contendo dados de pagamento para consentimento.
                Payment struct {
                        // Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
                        //
                        // Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
                        // Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
                        Amount string `json:"amount"`

                        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
                        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
                        Currency string `json:"currency"`

                        // Date [Restrição] Mutuamente excludente com o objeto schedule.
                        //
                        // Este campo é obrigatório no caso de pagamento único.
                        //
                        // Neste caso, o objeto schedule não deve ser informado.
                        Date *timeutil.BrazilDate `json:"date,omitempty"`

                        // Details Objeto contendo os detalhes do pagamento.
                        Details Details `json:"details"`

                        // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
                        //
                        // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
                        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

                        // Schedule [Restrição] Mutuamente excludente com o campo date.
                        // Este campo é obrigatório no caso de agendamento.
                        // Neste caso, o campo date não deverá ser informado.
                        // O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
                        // Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
                        Schedule *Schedule `json:"schedule,omitempty"`

                        // Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
                        Type EnumPaymentType `json:"type"`
                } `json:"payment"`
        } `json:"data"`
}

// CreatePixPayment defines model for CreatePixPayment.
type CreatePixPayment struct {
        Data []struct {
                // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
                //
                // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
                AuthorisationFlow *CreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

                // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
                CnpjInitiator *string `json:"cnpjInitiator,omitempty"`

                // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                //
                // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
                ConsentID *string `json:"consentId,omitempty"`

                // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
                CreditorAccount *CreditorAccount `json:"creditorAccount,omitempty"`

                // EndToEndID Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
                //
                // • “E” – fixo (1 caractere);
                //
                // • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
                //
                // • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
                //
                // • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
                //
                // Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
                //
                // Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
                //
                // No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
                EndToEndID *EndToEndIDWithoutRestriction `json:"endToEndId,omitempty"`

                // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
                //
                // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
                IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

                // LocalInstrument Especifica a forma de iniciação do pagamento:
                // - MANU - Inserção manual de dados da conta transacional
                // - DICT - Inserção manual de chave Pix
                // - QRDN - QR code dinâmico
                // - QRES - QR code estático
                // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
                //
                // [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
                LocalInstrument *EnumLocalInstrument `json:"localInstrument,omitempty"`

                // Payment Objeto contendo dados do pagameto como moeda e valor.
                Payment *PaymentPix `json:"payment,omitempty"`

                // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
                // No caso de telefone celular deve ser informado no padrão E.1641.
                // Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
                // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
                // Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
                // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
                // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
                // Esta validação é opcional caso o localInstrument for igual a INIC.
                // [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
                Proxy *string `json:"proxy,omitempty"`

                // QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
                // É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
                // Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
                // No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
                // Este campo deverá ser no formato UTF-8.
                // [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
                QrCode *string `json:"qrCode,omitempty"`

                // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
                RemittanceInformation *string `json:"remittanceInformation,omitempty"`

                // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento. Essa informação permitirá ao recebedor identificar e correlacionar a transferência, quando recebida, com a apresentação das instruções ao pagador.
                // Os caracteres permitidos no contexto do Pix para o campo txid (EMV 62-05) são:
                // - Letras minúsculas, de ‘a’ a ‘z’
                // - Letras maiúsculas, de ‘A’ a ‘z’
                // - Dígitos decimais, de ‘0’ a ‘9’
                //
                // [Restrição] Preenchimento condicional de acordo com o conteúdo do campo localInstument:
                //
                // – MANU - O campo transactionIdentification não deve ser preenchido.
                // – DICT - O campo transactionIdentification não deve ser preenchido.
                // – INIC - O campo transactionIdentification deve ser preenchido obrigatoriamente e deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
                // – QRES - Caso o QR Code estático possua o dado &lt;i&gt;&lt;&lt;i/&gt;TxId&lt;i&gt;&gt;&lt;i/&gt; preenchido, o campo transactionIdentification deverá ser preenchido com este valor, caso o QR Code não possua o &lt;i&gt;&lt;&lt;i/&gt;TxId&lt;i&gt;&gt;&lt;i/&gt; o campo transactionIdentification não deverá ser preenchido. O &lt;i&gt;&lt;&lt;i/&gt;TxId&lt;i&gt;&gt;&lt;i/&gt; deve conter até 25 caracteres alfanuméricos ([a-z|A-Z|0-9]).
                // – QRDN - Será obrigatório seu preenchimento com o &lt;i&gt;&lt;&lt;i/&gt;TxId&lt;i&gt;&gt;&lt;i/&gt; do payload JSON do QR Code dinâmico. O &lt;i&gt;&lt;&lt;i/&gt;TxId&lt;i&gt;&gt;&lt;i/&gt; deve conter entre 26 e 35 caracteres alfanuméricos ([a-z|A-Z|0-9]).
                //
                // A detentora de conta deve validar se a condicionalidade e o formato do campo foram atendidas pela iniciadora de pagamento.
                TransactionIdentification *string `json:"transactionIdentification,omitempty"`
        } `json:"data"`
}

// CreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type CreatePixPaymentDataAuthorisationFlow string

// CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
type CreditorAccount struct {
        // AccountType Tipos de contas usadas para pagamento.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountPaymentsType `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta do usuário recebedor, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
// As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
type DebtorAccount struct {
        // AccountType Tipos de contas usadas para pagamento.
        // Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
        // conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
        // Segue descrição de cada valor do ENUM.
        //
        // - CACC - Current - Conta Corrente.
        // - SVGS - Savings - Conta de Poupança.
        // - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
        AccountType EnumAccountPaymentsType `json:"accountType"`

        // Ispb Deve ser preenchido com o ISPB (Identificador do Sistema de Pagamentos Brasileiros) do participante do SPI (Sistema de pagamentos instantâneos) somente com números.
        Ispb string `json:"ispb"`

        // Issuer Código da Agência emissora da conta sem dígito.
        // (Agência é a dependência destinada ao atendimento aos clientes, ao público em geral e aos associados de cooperativas de crédito,
        // no exercício de atividades da instituição, não podendo ser móvel ou transitória).
        //
        // [Restrição] Preenchimento obrigatório para os seguintes tipos de conta: CACC (CONTA_DEPOSITO_A_VISTA) e SVGS (CONTA_POUPANCA).
        Issuer *string `json:"issuer,omitempty"`

        // Number Deve ser preenchido com o número da conta transacional do usuário pagador, com dígito verificador (se este existir),
        // se houver valor alfanumérico, este deve ser convertido para 0.
        Number string `json:"number"`
}

// Details Objeto contendo os detalhes do pagamento.
type Details struct {
        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        CreditorAccount CreditorAccount `json:"creditorAccount"`

        // LocalInstrument Especifica a forma de iniciação do pagamento:
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - QRDN - QR code dinâmico
        // - QRES - QR code estático
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
        //
        // [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
        LocalInstrument EnumLocalInstrument `json:"localInstrument"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641.
        // Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
        // Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
        // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
        // Esta validação é opcional caso o localInstrument for igual a INIC.
        // [Restrição]
        // Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido.
        // Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
        Proxy *string `json:"proxy,omitempty"`

        // QrCode Sequência de caracteres que corresponde ao QR Code disponibilizado para o pagador.
        // É a sequência de caracteres que seria lida pelo leitor de QR Code, e deve propiciar o retorno dos dados do pagador após consulta na DICT.
        // Essa funcionalidade é possível tanto para QR Code estático quanto para QR Code dinâmico.
        // No arranjo do Pix esta é a mesma sequência gerada e/ou lida pela funcionalidade Pix Copia e Cola.
        // Este campo deverá ser no formato UTF-8.
        // [Restrição] Preenchimento obrigatório para pagamentos por QR Code, observado o tamanho máximo de 512 bytes.
        QrCode *string `json:"qrCode,omitempty"`
}

// EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
//
// [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
type EndToEndID = string

// EndToEndIDWithoutRestriction Deve ser preenchido no formato padrão ExxxxxxxxyyyyMMddHHmmkkkkkkkkkkk (32 caracteres; “case sensitive”, isso é, diferencia letras maiúsculas e minúsculas), sendo:
//
// • “E” – fixo (1 caractere);
//
// • xxxxxxxx – identificação do agente que gerou o ´EndToEndId´, podendo ser: o ISPB do participante direto ou o ISPB do participante indireto (8 caracteres numéricos [0-9]);
//
// • yyyyMMddHHmm – data, hora e minuto (12 caracteres), seguindo o horário UTC, da submissão da ordem de pagamento, caso a liquidação seja prioritária, ou prevista para o envio da ordem ao sistema de liquidação, caso seja realizado um agendamento. Para ordens prioritárias e não prioritárias, aceita-se o preenchimento, pelo agente que gerou o ´EndToEndId´, com uma tolerância máxima de 12 horas, para o futuro e para o passado, em relação ao horário efetivo de processamento da ordem pelo SPI;
//
// • kkkkkkkkkkk – sequencial criado pelo agente que gerou o ´EndToEndId´ (11 caracteres alfanuméricos [a-z/A-Z/0-9]). Deve ser único dentro de cada “yyyyMMddHHmm”.
//
// Admite-se que o ´EndToEndId´ seja gerado pelo participante direto, pelo participante indireto ou pelo iniciador de pagamento.
//
// Ele deve ser único, não podendo ser repetido em qualquer outra operação enviada ao SPI.
//
// No caso de Pix agendamento, a iniciadora deverá, no que tange a composição do endToEndId, utilizar a data para a qual o Pix está sendo agendado e horário fixo 15:00 UTC, que dará para a detentora a janela de efetivação de 00:00 e 23:59 do horário de Brasília.
type EndToEndIDWithoutRestriction = string

// EnumAccountPaymentsType Tipos de contas usadas para pagamento.
// Modalidades tradicionais previstas pela Resolução 4.753, não contemplando contas vinculadas,
// conta de domiciliados no exterior, contas em moedas estrangeiras e conta correspondente moeda eletrônica.
// Segue descrição de cada valor do ENUM.
//
// - CACC - Current - Conta Corrente.
// - SVGS - Savings - Conta de Poupança.
// - TRAN - TransactingAccount - Conta de Pagamento pré-paga.
type EnumAccountPaymentsType string

// EnumAuthorisationStatusType Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
//
// Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
//
// Estados possíveis:
//
// AWAITING_AUTHORISATION - Aguardando autorização
//
// PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
//
// # AUTHORISED - Autorizado
//
// # REJECTED - Rejeitado
//
// CONSUMED - Consumido
type EnumAuthorisationStatusType string

// EnumConsentRejectionReasonType Define o código da razão pela qual o consentimento foi rejeitado
// - VALOR_INVALIDO
// - NAO_INFORMADO
// - FALHA_INFRAESTRUTURA
// - TEMPO_EXPIRADO_AUTORIZACAO
// - TEMPO_EXPIRADO_CONSUMO
// - REJEITADO_USUARIO
// - CONTAS_ORIGEM_DESTINO_IGUAIS
// - CONTA_NAO_PERMITE_PAGAMENTO
// - SALDO_INSUFICIENTE
// - VALOR_ACIMA_LIMITE
// - QRCODE_INVALIDO
type EnumConsentRejectionReasonType string

// EnumErrorsCreatePayment Códigos de erros previstos na criação da iniciação de pagamento:
// - SALDO_INSUFICIENTE: Esta conta não possui saldo suficiente para realizar o pagamento.
// - VALOR_ACIMA_LIMITE: O valor (ou quantidade de transações) ultrapassa a faixa de limite parametrizada na detentora para permitir a realização de transações pelo cliente.
// - VALOR_INVALIDO: O valor enviado não é válido para o QR Code informado.
// - COBRANCA_INVALIDA: Validação de expiração, validação de vencimento, Status Válido.
// - CONSENTIMENTO_INVALIDO – Consentimento inválido (em status final).
// - PARAMETRO_NAO_INFORMADO: Parâmetro não informado.
// - PARAMETRO_INVALIDO: Parâmetro inválido.
// - NAO_INFORMADO: Não informada pela detentora de conta.
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO: Dados do pagamento divergentes dos dados do consentimento.
// - DETALHE_PAGAMENTO_INVALIDO: Detalhe do pagamento inválido.
// - PAGAMENTO_RECUSADO_DETENTORA: Pagamento recusado pela detentora de conta.
// - PAGAMENTO_RECUSADO_SPI: Pagamento recusado no Sistema de Pagamentos Instantâneos (SPI).
// - ERRO_IDEMPOTENCIA: Erro idempotência.
// - CONSENTIMENTO_PENDENTE_AUTORIZACAO: Consentimento pendente autorização de múltiplas alçadas (status “PARTIALLY_ACCEPTED”)
type EnumErrorsCreatePayment string

// EnumErrorsCreatePixPayment Códigos de erros previstos na criação da iniciação de pagamento:
//
// • PAGAMENTO_NAO_PERMITE_CANCELAMENTO: Pagamento não permite cancelamento
type EnumErrorsCreatePixPayment string

// EnumLocalInstrument Especifica a forma de iniciação do pagamento:
// - MANU - Inserção manual de dados da conta transacional
// - DICT - Inserção manual de chave Pix
// - QRDN - QR code dinâmico
// - QRES - QR code estático
// - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
//
// [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
type EnumLocalInstrument string

// EnumPaymentCancellationFromType Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
//
// Valores possíveis:
//
// # INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
//
// DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
type EnumPaymentCancellationFromType string

// EnumPaymentCancellationReasonType O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
//
// Valores possíveis:
//
// CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
//
// CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
//
// CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
type EnumPaymentCancellationReasonType string

// EnumPaymentCancellationStatusType Utilizado para informar para qual estado deve ir o pagamento.
// Atualmente o único valor possível é CANC.
type EnumPaymentCancellationStatusType string

// EnumPaymentPersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
type EnumPaymentPersonType string

// EnumPaymentStatusType Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
//
// 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
//
// 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
//
// 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
//
// 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
//
// 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
//
// 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
//
// 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
//
// 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
//
// Em caso insucesso:
//
// RJCT (REJECTED) - Instrução de pagamento rejeitada.
type EnumPaymentStatusType string

// EnumPaymentType Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
type EnumPaymentType string

// EnumRejectionReasonType Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonType string

// EnumRejectionReasonTypeGetPix Define o código da razão pela qual o pagamento foi rejeitado
//
// - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
//
// - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
//
// - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
//
// - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
//
// - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
//
// - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
//
// - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
//
// - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
//
// - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
//
// - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
//
// - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
//
// - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
//
// - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
//
// - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
//
// - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
//
// - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
//
// - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
//
// O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
type EnumRejectionReasonTypeGetPix string

// Identification Objeto contendo os dados do recebedor (creditor).
type Identification struct {
        // CpfCnpj Identificação da pessoa envolvida na transação.
        // Preencher com o CPF ou CNPJ, de acordo com o valor escolhido no campo type.
        // O CPF será utilizado com 11 números e deverá ser informado sem pontos ou traços.
        // O CNPJ será utilizado com 14 números e deverá ser informado sem pontos ou traços.
        CpfCnpj string `json:"cpfCnpj"`

        // Name Em caso de pessoa natural deve ser informado o nome completo do titular da conta do recebedor.
        // Em caso de pessoa jurídica deve ser informada a razão social ou o nome fantasia da conta do recebedor.
        Name string `json:"name"`

        // PersonType Titular, pessoa natural ou juridica a quem se referem os dados de recebedor (creditor).
        PersonType EnumPaymentPersonType `json:"personType"`
}

// LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
type LoggedUser struct {
        Document struct {
                // Identification Número do documento de identificação oficial do usuário.
                Identification string `json:"identification"`

                // Rel Tipo do documento de identificação oficial do usuário.
                Rel string `json:"rel"`
        } `json:"document"`
}

// PatchPixPayment defines model for PatchPixPayment.
type PatchPixPayment struct {
        Data PatchPixPaymentData `json:"data"`
}

// PatchPixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
type PatchPixPaymentCancellation struct {
        // CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
        CancelledAt timeutil.DateTime `json:"cancelledAt"`

        // CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
        CancelledBy struct {
                // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                Document struct {
                        // Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
                        Identification string `json:"identification"`

                        // Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
                        Rel string `json:"rel"`
                } `json:"document"`
        } `json:"cancelledBy"`

        // CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
        //
        // Valores possíveis:
        //
        // INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
        //
        // DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
        CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

        // Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
        //
        // Valores possíveis:
        //
        // CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
        //
        // CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
        //
        // CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
        Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// PatchPixPaymentData defines model for PatchPixPaymentData.
type PatchPixPaymentData struct {
        // Cancellation Objeto que agrupa as informações de qual foi o usuário pagador que solicitou o cancelamento da transação.
        // Observação: este campo é necessário porque, em casos de múltiplas alçadas de autorização, é possível que o pagamento seja solicitado por um usuário pagador e cancelado por outro.
        Cancellation struct {
                // CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
                CancelledBy struct {
                        // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                        Document struct {
                                // Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
                                Identification string `json:"identification"`

                                // Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
                                Rel string `json:"rel"`
                        } `json:"document"`
                } `json:"cancelledBy"`
        } `json:"cancellation"`

        // Status Utilizado para informar para qual estado deve ir o pagamento.
        // Atualmente o único valor possível é CANC.
        Status EnumPaymentCancellationStatusType `json:"status"`
}

// PaymentConsent Objeto contendo dados de pagamento para consentimento.
type PaymentConsent struct {
        // Amount Valor da transação com 2 casas decimais.
        Amount string `json:"amount"`

        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
        Currency string `json:"currency"`

        // Date [Restrição] Mutuamente excludente com o objeto schedule.
        //
        // Este campo é obrigatório no caso de pagamento único.
        //
        // Neste caso, o objeto schedule não deve ser informado.
        Date *timeutil.BrazilDate `json:"date,omitempty"`

        // Details Objeto contendo os detalhes do pagamento.
        Details Details `json:"details"`

        // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
        //
        // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

        // Schedule [Restrição] Mutuamente excludente com o campo date.
        // Este campo é obrigatório no caso de agendamento.
        // Neste caso, o campo date não deverá ser informado.
        // O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
        // Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
        Schedule *Schedule `json:"schedule,omitempty"`

        // Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
        Type EnumPaymentType `json:"type"`
}

// PaymentPix Objeto contendo dados do pagameto como moeda e valor.
type PaymentPix struct {
        // Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
        //
        // Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
        // Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
        Amount string `json:"amount"`

        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
        Currency string `json:"currency"`
}

// PixPaymentCancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
//
// [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
type PixPaymentCancellation struct {
        // CancelledAt Data e hora que foi realizado o cancelamento, conforme especificação RFC-3339, formato UTC.
        CancelledAt timeutil.DateTime `json:"cancelledAt"`

        // CancelledBy Informação relacionada ao usuário pagador que solicitou o cancelamento do pagamento.
        CancelledBy struct {
                // Document Objeto que consolida os dados do documento do usuário que solicitou o cancelamento.
                Document struct {
                        // Identification Número do documento do usuário pagador responsável pelo cancelamento do pagamento.
                        Identification string `json:"identification"`

                        // Rel Tipo do documento do usuário pagador responsável pelo cancelamento do pagamento.
                        Rel string `json:"rel"`
                } `json:"document"`
        } `json:"cancelledBy"`

        // CancelledFrom Campo utilizado para informar o meio pelo qual foi realizado o cancelamento.
        //
        // Valores possíveis:
        //
        // INICIADORA - Pagamento cancelado pelo usuário pagador nos canais da iniciadora
        //
        // DETENTORA - Pagamento cancelado pelo usuário pagador nos canais da detentora
        CancelledFrom EnumPaymentCancellationFromType `json:"cancelledFrom"`

        // Reason O preenchimento desse campo para retorno, deve ocorrer pela detentora de contas a partir do status em que o pagamento estiver no momento da solicitação do cancelamento (ex. Status de pagamento = PDNG, campo deve ser preenchido com enum CANCELADO_PENDENCIA)
        //
        // Valores possíveis:
        //
        // CANCELADO_PENDENCIA - Pagamento cancelado enquanto estava na situação PDNG
        //
        // CANCELADO_AGENDAMENTO - Pagamento cancelado enquanto estava na situação SCHD
        //
        // CANCELADO_MULTIPLAS_ALCADAS - Pagamento cancelado enquanto estava na situação PATC
        Reason EnumPaymentCancellationReasonType `json:"reason"`
}

// RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReason struct {
        // Code Define o código da razão pela qual o pagamento foi rejeitado
        //
        // - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
        //
        // - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
        //
        // - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
        //
        // - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
        //
        // - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
        //
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
        //
        // - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
        //
        // - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
        //
        // - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
        //
        // - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
        //
        // - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
        //
        // - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
        //
        // - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
        //
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
        //
        // - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
        //
        // - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
        //
        // O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
        Code EnumRejectionReasonType `json:"code"`

        // Detail Contém informações adicionais ao pagamento rejeitado
        Detail string `json:"detail"`
}

// RejectionReasonGetPix Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
// [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
type RejectionReasonGetPix struct {
        // Code Define o código da razão pela qual o pagamento foi rejeitado
        //
        // - SALDO_INSUFICIENTE - A conta selecionada não possui saldo suficiente para realizar o pagamento.
        //
        // - VALOR_ACIMA_LIMITE - O valor ultrapassa o limite estabelecido [na instituição/no arranjo/outro] para permitir a realização de transações pelo cliente.
        //
        // - VALOR_INVALIDO - O valor enviado não é válido para o QR Code informado.
        //
        // - COBRANCA_INVALIDA - Validação de expiração, validação de vencimento ou Status Válido.
        //
        // - NAO_INFORMADO - Não reportado/identificado pela instituição detentora de conta.
        //
        // - PAGAMENTO_DIVERGENTE_CONSENTIMENTO - Dados do pagamento divergentes dos dados do consentimento.
        //
        // - DETALHE_PAGAMENTO_INVALIDO - Parâmetro [nome_campo] não obedecer às regras de negócio.
        //
        // - PAGAMENTO_RECUSADO_DETENTORA - [Descrição do motivo de recusa].
        //
        // - PAGAMENTO_RECUSADO_SPI - [Código de erro conforme tabela de domínios reason PACS.002].
        //
        // - FALHA_INFRAESTRUTURA - [Descrição de qual falha na infraestrutura inviabilizou o processamento].
        //
        // - FALHA_INFRAESTRUTURA_SPI - Indica uma falha no Sistema de Pagamentos Instantâneos (SPI).
        //
        // - FALHA_INFRAESTRUTURA_DICT - Indica uma falha no Diretório de Identificadores de Contas Transacionais (DICT).
        //
        // - FALHA_INFRAESTRUTURA_ICP - Indica uma falha na Infraestrutura de Chaves Públicas (ICP).
        //
        // - FALHA_INFRAESTRUTURA_PSP_RECEBEDOR - Indica uma falha na infraestrutura do Prestador de Serviço de Pagamento (PSP) que recebe o pagamento.
        //
        // - FALHA_INFRAESTRUTURA_DETENTORA - indica uma falha na infraestrutura da instituição detentora das informações ou recursos.
        //
        // - CONTAS_ORIGEM_DESTINO_IGUAIS - Indica uma tentativa de pagamento onde a conta origem e a conta de destino são iguais.
        //
        // - FALHA_AGENDAMENTO_PAGAMENTOS - Falha ao agendar pagamentos.
        //
        // O rejectionReason FALHA_INFRAESTRUTURA não será excluído, apenas deixará de ser utilizado, permitindo assim, retrocompatibilidade e integridade entre os participantes.
        Code EnumRejectionReasonTypeGetPix `json:"code"`

        // Detail Contém informações adicionais ao pagamento rejeitado
        Detail string `json:"detail"`
}

// ResponseCreatePaymentConsent defines model for ResponseCreatePaymentConsent.
type ResponseCreatePaymentConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentID string `json:"consentId"`

                // CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // Creditor Objeto contendo os dados do recebedor (creditor).
                Creditor Identification `json:"creditor"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
                // No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
                //
                // [Restrição]
                // - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
                // - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
                DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
                // Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
                // Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
                // Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
                // Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
                // Caso não seja consumido, deve ser movido para o status REJECTED.
                ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // Payment Objeto contendo dados de pagamento para consentimento.
                Payment struct {
                        // Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
                        //
                        // Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
                        // Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
                        Amount string `json:"amount"`

                        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
                        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
                        Currency string `json:"currency"`

                        // Date [Restrição] Mutuamente excludente com o objeto schedule.
                        //
                        // Este campo é obrigatório no caso de pagamento único.
                        //
                        // Neste caso, o objeto schedule não deve ser informado.
                        Date *timeutil.BrazilDate `json:"date,omitempty"`

                        // Details Objeto contendo os detalhes do pagamento.
                        Details Details `json:"details"`

                        // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
                        //
                        // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
                        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

                        // Schedule [Restrição] Mutuamente excludente com o campo date.
                        // Este campo é obrigatório no caso de agendamento.
                        // Neste caso, o campo date não deverá ser informado.
                        // O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
                        // Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
                        Schedule *Schedule `json:"schedule,omitempty"`

                        // Type Este campo define o tipo de pagamento que será iniciado após a autorização do consentimento.
                        Type EnumPaymentType `json:"type"`
                } `json:"payment"`

                // Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
                //
                // Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
                //
                //
                // Estados possíveis:
                //
                // AWAITING_AUTHORISATION - Aguardando autorização
                //
                // PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
                //
                // AUTHORISED - Autorizado
                //
                // REJECTED - Rejeitado
                //
                // CONSUMED - Consumido
                Status EnumAuthorisationStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPayment defines model for ResponseCreatePixPayment.
type ResponseCreatePixPayment struct {
        Data []struct {
                // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
                //
                // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
                AuthorisationFlow *ResponseCreatePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

                // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
                CnpjInitiator string `json:"cnpjInitiator"`

                // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                //
                // [Restrição] Este campo é de preenchimento obrigatório quando o valor do campo authorisationFlow for igual a FIDO_FLOW.
                ConsentID *string `json:"consentId,omitempty"`

                // CreationDateTime Data e hora em que o recurso foi criado.
                // Uma string com data e hora conforme especificação RFC-3339,
                // sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
                CreditorAccount CreditorAccount `json:"creditorAccount"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
                DebtorAccount DebtorAccount `json:"debtorAccount"`

                // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
                //
                // [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
                EndToEndID EndToEndID `json:"endToEndId"`

                // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
                //
                // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
                IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

                // LocalInstrument Especifica a forma de iniciação do pagamento:
                // - MANU - Inserção manual de dados da conta transacional
                // - DICT - Inserção manual de chave Pix
                // - QRDN - QR code dinâmico
                // - QRES - QR code estático
                // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
                //
                // [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
                LocalInstrument EnumLocalInstrument `json:"localInstrument"`

                // Payment Objeto contendo dados do pagameto como moeda e valor.
                Payment struct {
                        // Amount Valor da transação com 2 casas decimais. O valor deve ser o mesmo enviado no consentimento.
                        //
                        // Para QR Code estático com valor pré-determinado no QR Code ou para QR Code dinâmico com indicação de que o valor não pode ser alterado: O campo amount deve ser preenchido com o valor estabelecido no QR Code.
                        // Caso seja preenchido com valor divergente do QR Code, deve ser retornado um erro HTTP Status 422.
                        Amount string `json:"amount"`

                        // Currency Código da moeda nacional segundo modelo ISO-4217, ou seja, 'BRL'.
                        // Todos os valores monetários informados estão representados com a moeda vigente do Brasil.
                        Currency string `json:"currency"`
                } `json:"payment"`

                // PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
                // a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
                // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
                PaymentID string `json:"paymentId"`

                // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
                // No caso de telefone celular deve ser informado no padrão E.1641.
                // Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
                // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
                // Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
                // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
                // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
                // Esta validação é opcional caso o localInstrument for igual a INIC.
                // [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
                Proxy *string `json:"proxy,omitempty"`

                // RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
                // [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
                RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

                // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
                RemittanceInformation *string `json:"remittanceInformation,omitempty"`

                // Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
                //
                // 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
                //
                // 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
                //
                // 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
                //
                // 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
                //
                // 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
                //
                // 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
                //
                // 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
                //
                // 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
                //
                // Em caso insucesso:
                //
                // RJCT (REJECTED) - Instrução de pagamento rejeitada.
                Status EnumPaymentStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
                // Uma string com data e hora conforme especificação RFC-3339,
                // sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

                // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
                //
                // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
                TransactionIdentification *string `json:"transactionIdentification,omitempty"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseCreatePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponseCreatePixPaymentDataAuthorisationFlow string

// ResponseError defines model for ResponseError.
type ResponseError struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`

        // Meta Meta informações referente à API requisitada.
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponsePatchPixConsent defines model for ResponsePatchPixConsent.
type ResponsePatchPixConsent struct {
        Data []struct {
                // PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
                // a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
                // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
                PaymentID string `json:"paymentId"`

                // StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
                // Uma string com data e hora conforme especificação RFC-3339,
                // sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponsePatchPixPayment defines model for ResponsePatchPixPayment.
type ResponsePatchPixPayment struct {
        // Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
        Data  ResponsePatchPixPaymentData `json:"data"`
        Links api.Links                   `json:"links"`
        Meta  api.Meta                    `json:"meta"`
}

// ResponsePatchPixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePatchPixPaymentData struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *ResponsePatchPixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
        Cancellation PatchPixPaymentCancellation `json:"cancellation"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transnmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        ConsentID string `json:"consentId"`

        // CreationDateTime Data e hora em que o recurso foi criado.
        // Uma string com data e hora conforme especificação RFC-3339,
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        CreditorAccount CreditorAccount `json:"creditorAccount"`

        // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
        // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
        DebtorAccount DebtorAccount `json:"debtorAccount"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
        EndToEndID EndToEndID `json:"endToEndId"`

        // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
        //
        // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

        // LocalInstrument Especifica a forma de iniciação do pagamento:
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - QRDN - QR code dinâmico
        // - QRES - QR code estático
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
        //
        // [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
        LocalInstrument EnumLocalInstrument `json:"localInstrument"`

        // Payment Objeto contendo dados do pagameto como moeda e valor.
        Payment PaymentPix `json:"payment"`

        // PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
        // a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        PaymentID string `json:"paymentId"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641.
        // Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
        // Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
        // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
        // Esta validação é opcional caso o localInstrument for igual a INIC.
        // [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
        Proxy *string `json:"proxy,omitempty"`

        // RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
        // [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
        RejectionReason *RejectionReason `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
        //
        // 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        //
        // 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        //
        // 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        //
        // 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        //
        // 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        //
        // 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        //
        // 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
        //
        // 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        //
        // Em caso insucesso:
        //
        // RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
        // Uma string com data e hora conforme especificação RFC-3339,
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePatchPixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePatchPixPaymentDataAuthorisationFlow string

// ResponsePaymentConsent defines model for ResponsePaymentConsent.
type ResponsePaymentConsent struct {
        // Data Objeto contendo as informações de consentimento para a iniciação de pagamento.
        Data struct {
                // BusinessEntity Usuário (pessoa jurídica) que encontra-se logado na instituição Iniciadora de Pagamento. [Restrição] Preenchimento obrigatório se usuário logado na instituição Iniciadora de Pagamento for um CNPJ (pessoa jurídica).
                BusinessEntity *BusinessEntity `json:"businessEntity,omitempty"`

                // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
                // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
                // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
                // seja um identificador de recurso persistente e independente da localização.
                // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
                // - o namespace(urn)
                // - o identificador associado ao namespace da instituição transnmissora (bancoex)
                // - o identificador específico dentro do namespace (C1DD33123).
                // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
                ConsentID string `json:"consentId"`

                // CreationDateTime Data e hora em que o consentimento foi criado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                CreationDateTime timeutil.DateTime `json:"creationDateTime"`

                // Creditor Objeto contendo os dados do recebedor (creditor).
                Creditor Identification `json:"creditor"`

                // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
                // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente.
                // No caso em que o cliente não preenche os dados na iniciadora, a detentora deverá persistir as informações da conta selecionada seguindo as condições abaixo.
                //
                // [Restrição]
                // - AUTHORISED e CONSUMED: Para esses dois status, o preenchimento do campo deverá ser obrigatório.
                // - REJECTED: Para este status o preenchimento é condicional, dado que há cenários em que a detentora também não terá conhecimento da conta origem, pois a mesma não foi selecionada pelo usuário. Nos casos em que houver seleção, a conta deve ser preenchida obrigatoriamente.
                DebtorAccount *ConsentsDebtorAccount `json:"debtorAccount,omitempty"`

                // ExpirationDateTime Data e hora em que o consentimento da iniciação de pagamento expira.
                // Para consentimentos em status AWAITING_AUTHORISATION, deve ser sempre “creationDateTime + 5 minutos”.
                // Após esse tempo, não sendo aprovado (seja a aprovação única ou primeiro aprovador), o consentimento deve ir para REJECTED.
                // Para consentimentos em status PARTIALLY_ACCEPTED, deve assumir o valor da política de aprovação de cada instituição.
                // Para consentimentos em status AUTHORISED, devem assumir o valor de “statusUpdateDateTime + 60 minutos”, sendo esse o tempo máximo permitido para o consumo do consentimento.
                // Caso não seja consumido, deve ser movido para o status REJECTED.
                ExpirationDateTime timeutil.DateTime `json:"expirationDateTime"`

                // LoggedUser Usuário (pessoa natural) que encontra-se logado na instituição Iniciadora de Pagamento.
                LoggedUser LoggedUser `json:"loggedUser"`

                // Payment Objeto contendo dados de pagamento para consentimento.
                Payment PaymentConsent `json:"payment"`

                // RejectionReason Motivo da rejeição do consentimento. Informações complementares sobre o motivo do status.
                //
                // [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a REJECTED.
                RejectionReason *ConsentRejectionReason `json:"rejectionReason,omitempty"`

                // Status Retorna o estado do consentimento, o qual no momento de sua criação será AWAITING_AUTHORISATION. Na situação de múltiplas alçadas PARTIALLY_ACCEPTED, indica que consentimento precisa da confirmação de mais autorizadores. Este estado será alterado depois da(s) autorização(ões) do(s) consentimento(s) na detentora da conta do pagador (Debtor) para AUTHORISED ou REJECTED. O consentimento fica no estado CONSUMED após ocorrer a iniciação do pagamento referente ao consentimento.
                //
                // Em caso de consentimento expirado a detentora deverá retornar o status REJECTED.
                //
                //
                // Estados possíveis:
                //
                // AWAITING_AUTHORISATION - Aguardando autorização
                //
                // PARTIALLY_ACCEPTED – Aguardando múltiplas alçadas
                //
                // AUTHORISED - Autorizado
                //
                // REJECTED - Rejeitado
                //
                // CONSUMED - Consumido
                Status EnumAuthorisationStatusType `json:"status"`

                // StatusUpdateDateTime Data e hora em que o recurso foi atualizado. Uma string com data e hora conforme especificação RFC-3339, sempre com a utilização de timezone UTC(UTC time format).
                StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponsePixPayment defines model for ResponsePixPayment.
type ResponsePixPayment struct {
        // Data Objeto contendo dados do pagamento e da conta do recebedor (creditor).
        Data  ResponsePixPaymentData `json:"data"`
        Links api.Links              `json:"links"`
        Meta  api.Meta               `json:"meta"`
}

// ResponsePixPaymentData Objeto contendo dados do pagamento e da conta do recebedor (creditor).
type ResponsePixPaymentData struct {
        // AuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
        //
        // [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
        AuthorisationFlow *ResponsePixPaymentDataAuthorisationFlow `json:"authorisationFlow,omitempty"`

        // Cancellation Objeto que contém os dados referentes ao usuário pagador que solicitou o cancelamento, o canal utilizado por ele e o motivo.
        //
        // [Restrição] O objeto cancellation será obrigatório apenas quando o valor do campo status for igual a CANC.
        Cancellation *PixPaymentCancellation `json:"cancellation,omitempty"`

        // CnpjInitiator CNPJ do Iniciador de Pagamento devidamente habilitado para a prestação de Serviço de Iniciação no Pix.
        CnpjInitiator string `json:"cnpjInitiator"`

        // ConsentID Identificador único do consentimento criado para a iniciação de pagamento solicitada. Deverá ser um URN - Uniform Resource Name.
        // Um URN, conforme definido na [RFC8141](https://tools.ietf.org/html/rfc8141) é um Uniform Resource
        // Identifier - URI - que é atribuído sob o URI scheme "urn" e um namespace URN específico, com a intenção de que o URN
        // seja um identificador de recurso persistente e independente da localização.
        // Considerando a string urn:bancoex:C1DD33123 como exemplo para consentId temos:
        // - o namespace(urn)
        // - o identificador associado ao namespace da instituição transnmissora (bancoex)
        // - o identificador específico dentro do namespace (C1DD33123).
        // Informações mais detalhadas sobre a construção de namespaces devem ser consultadas na [RFC8141](https://tools.ietf.org/html/rfc8141).
        ConsentID string `json:"consentId"`

        // CreationDateTime Data e hora em que o recurso foi criado.
        // Uma string com data e hora conforme especificação RFC-3339,
        // sempre com a utilização de timezone UTC(UTC time format).
        CreationDateTime timeutil.DateTime `json:"creationDateTime"`

        // CreditorAccount Objeto que contém a identificação da conta de destino do beneficiário/recebedor.
        CreditorAccount CreditorAccount `json:"creditorAccount"`

        // DebtorAccount Objeto que contém a identificação da conta de origem do pagador.
        // As informações quanto à conta de origem do pagador poderão ser trazidas no consentimento para a detentora, caso a iniciadora tenha coletado essas informações do cliente. Do contrário, será coletada na detentora e trazida para a iniciadora como resposta à criação do pagamento.
        DebtorAccount DebtorAccount `json:"debtorAccount"`

        // EndToEndID Trata-se de um identificador único, gerado na instituição iniciadora de pagamento e recebido na instituição detentora de conta, permeando toda a jornada do pagamento Pix.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo Com o mesmo valor recebido da iniciadora.
        EndToEndID EndToEndID `json:"endToEndId"`

        // IbgeTownCode O campo ibgetowncode no arranjo PIX, tem o mesmo comportamento que o campo codMun descrito no item 1.6.6 do manual do PIX, conforme segue:
        //
        // 1. Caso a informação referente ao município não seja enviada; o PSP do recebedor assumirá que não existem feriados estaduais e municipais no período em questão;
        IbgeTownCode *string `json:"ibgeTownCode,omitempty"`

        // LocalInstrument Especifica a forma de iniciação do pagamento:
        // - MANU - Inserção manual de dados da conta transacional
        // - DICT - Inserção manual de chave Pix
        // - QRDN - QR code dinâmico
        // - QRES - QR code estático
        // - INIC - Indica que o recebedor (creditor) contratou o Iniciador de Pagamentos especificamente para realizar iniciações de pagamento em que o beneficiário é previamente conhecido.
        //
        // [Restrição] Se /data/payment/schedule enviado com valor diferente de single durante a criação do consentimento, apenas os métodos MANU, DICT ou QRES são permitidos.
        LocalInstrument EnumLocalInstrument `json:"localInstrument"`

        // Payment Objeto contendo dados do pagameto como moeda e valor.
        Payment PaymentPix `json:"payment"`

        // PaymentID Código ou identificador único informado pela instituição detentora da conta para representar
        // a iniciação de pagamento individual. O `paymentId` deve ser diferente do `endToEndId`.
        // Este é o identificador que deverá ser utilizado na consulta ao status da iniciação de pagamento efetuada.
        PaymentID string `json:"paymentId"`

        // Proxy Chave cadastrada no DICT pertencente ao recebedor. Os tipos de chaves podem ser: telefone, e-mail, cpf/cnpj ou chave aleatória.
        // No caso de telefone celular deve ser informado no padrão E.1641.
        // Para e-mail deve ter o formato xxxxxxxx@xxxxxxx.xxx(.xx) e no máximo 77 caracteres.
        // No caso de CPF deverá ser informado com 11 números, sem pontos ou traços.
        // Para o caso de CNPJ deverá ser informado com 14 números, sem pontos ou traços.
        // No caso de chave aleatória deve ser informado o UUID gerado pelo DICT, conforme formato especificado na RFC41223.
        // Se informado, a detentora da conta deve validar o proxy no DICT quando localInstrument for igual a DICT, QRDN ou QRES e validar o campo creditorAccount.
        // Esta validação é opcional caso o localInstrument for igual a INIC.
        // [Restrição] Se localInstrument for igual a MANU, o campo proxy não deve ser preenchido. Se localInstrument for igual INIC, DICT, QRDN ou QRES, o campo proxy deve ser sempre preenchido com a chave Pix.
        Proxy *string `json:"proxy,omitempty"`

        // RejectionReason Motivo da rejeição do pagamento. Informações complementares sobre o motivo do status
        // [Restrição] Esse motivo deverá ser enviado quando o campo /data/status for igual a RJCT (REJECTED).
        RejectionReason *RejectionReasonGetPix `json:"rejectionReason,omitempty"`

        // RemittanceInformation Deve ser preenchido sempre que o usuário pagador inserir alguma informação adicional em um pagamento, a ser enviada ao recebedor.
        RemittanceInformation *string `json:"remittanceInformation,omitempty"`

        // Status Estado atual da iniciação de pagamento. O estado evolui na seguinte ordem:
        //
        // 1.  RCVD (Received) - Indica que a requisição de pagamento foi recebida com sucesso pela detentora, mas ainda há validações a serem feitas antes de ser submetida para liquidação.
        //
        // 2.  CANC (Cancelled) - Indica que a transação Pix pendente foi cancelada com sucesso pelo usuário antes que fosse confirmada (ACCP) ou rejeitada (RJCT) pela detentora.
        //
        // 3.  ACCP( Accepted Customer Profile) - Indica que todas as verificações necessárias já foram realizadas pela detentora e que a transação está pronta para ser enviada para liquidação (no SPI se for Pix para outra instituição ou internamente se for para outra conta na mesma instituição).
        //
        // 4.  ACPD (Accepted Clearing Processed) - Indica que a detentora já submeteu a transação para liquidação, mas ainda não tem a confirmação se foi liquidada ou rejeitada.
        //
        // 5.  RJCT (Rejected) Indica que a transação foi rejeitada pela detentora ou pelo SPI.
        //
        // 6.  ACSC (Accepted Settlement Completed Debitor Account) - Indica que a transação foi efetivada pela detentora ou pelo SPI.
        //
        // 7.  PDNG (Pending) - Indica que a detentora reteve temporariamente a transação Pix para análise.
        //
        // 8.  SCHD (Scheduled) - Indica que a transação Pix foi agendada com sucesso na detentora.
        //
        // Em caso insucesso:
        //
        // RJCT (REJECTED) - Instrução de pagamento rejeitada.
        Status EnumPaymentStatusType `json:"status"`

        // StatusUpdateDateTime Data e hora da última atualização da iniciação de pagamento.
        // Uma string com data e hora conforme especificação RFC-3339,
        // sempre com a utilização de timezone UTC(UTC time format).
        StatusUpdateDateTime timeutil.DateTime `json:"statusUpdateDateTime"`

        // TransactionIdentification Trata-se de um identificador de transação que deve ser retransmitido intacto pelo PSP do pagador ao gerar a ordem de pagamento.
        //
        // [Restrição] A detentora deve obrigatoriamente retornar o campo com o mesmo valor recebido da iniciadora, caso ele tenha sido enviado na requisição da iniciação do pagamento.
        TransactionIdentification *string `json:"transactionIdentification,omitempty"`
}

// ResponsePixPaymentDataAuthorisationFlow Campo condicional utilizado para identificar o fluxo de autorização em que o pagamento foi solicitado.
//
// [Restrição] Se CIBA ou FIDO, preenchimento obrigatório. Caso o campo não esteja presente no payload, subentende-se que o fluxo de autorização utilizado é o HYBRID_FLOW.
type ResponsePixPaymentDataAuthorisationFlow string

// Schedule [Restrição] Mutuamente excludente com o campo date.
// Este campo é obrigatório no caso de agendamento.
// Neste caso, o campo date não deverá ser informado.
// O prazo máximo para o consentimento deverá ser de dois anos, contando a partir da data de criação do consentimento retornada na criação do mesmo (campo /data/creationDateTime).
// Agendamento de pagamento único deve utilizar exclusivamente o objeto "single".
type Schedule = payment.Schedule

// ScheduleCustom defines model for ScheduleCustom.
type ScheduleCustom struct {
        // Custom [Restrição] As datas enviadas na lista de datas (array “dates”) não podem ser repetidas.
        // Caso datas repetidas sejam enviadas, o detentor deve rejeitar a criação do consentimento, informando o erro PARAMETRO_INVALIDO.
        Custom struct {
                // AdditionalInformation Texto livre para Iniciador preencher de forma compreensível pelo usuário aprovador/pagador.
                // O texto pode ser utilizado pelo detentor para exibição do resumo da transação durante aprovação do usuário aprovador/pagador.
                AdditionalInformation string `json:"additionalInformation"`

                // Dates Define os dias em que estão planejadas as ocorrências das liquidações.
                Dates []timeutil.BrazilDate `json:"dates"`
        } `json:"custom"`
}

// ScheduleDaily defines model for ScheduleDaily.
type ScheduleDaily struct {
        Daily struct {
                // Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
                Quantity int32 `json:"quantity"`

                // StartDate Define o início da vigência da recorrência.
                StartDate timeutil.BrazilDate `json:"startDate"`
        } `json:"daily"`
}

// ScheduleMonthly defines model for ScheduleMonthly.
type ScheduleMonthly struct {
        Monthly struct {
                // DayOfMonth Define o dia do mês planejado para a ocorrência das liquidações.
                DayOfMonth int `json:"dayOfMonth"`

                // Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
                Quantity int32 `json:"quantity"`

                // StartDate Define o início da vigência da recorrência.
                StartDate timeutil.BrazilDate `json:"startDate"`
        } `json:"monthly"`
}

// ScheduleSingle defines model for ScheduleSingle.
type ScheduleSingle struct {
        // Single Define a política de agendamento único.
        Single struct {
                // Date Define a data alvo da liquidação do pagamento.
                // O fuso horário de Brasília deve ser utilizado para criação e racionalização sobre os dados deste campo.
                //
                // [Restrição] Esse campo deverá sempre ser no mínimo D+1 corrido, ou seja, a data imediatamente posterior em
                // relação a data do consentimento considerando o fuso horário de Brasília e deverá ser no máximo D+730 corridos a
                // partir da data do consentimento, também considerando o fuso horário de Brasília.
                Date timeutil.BrazilDate `json:"date"`
        } `json:"single"`
}

// ScheduleWeekly defines model for ScheduleWeekly.
type ScheduleWeekly struct {
        Weekly struct {
                // DayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
                DayOfWeek ScheduleWeeklyWeeklyDayOfWeek `json:"dayOfWeek"`

                // Quantity Define a quantidade de pagamentos que serão enviados para liquidação.
                Quantity int32 `json:"quantity"`

                // StartDate Define o início da vigência da recorrência.
                StartDate timeutil.BrazilDate `json:"startDate"`
        } `json:"weekly"`
}

// ScheduleWeeklyWeeklyDayOfWeek Define o dia da semana planejado para a ocorrência das liquidações.
type ScheduleWeeklyWeeklyDayOfWeek string

// Authorization defines model for Authorization.
type Authorization = string

// XIdempotencyKey defines model for XIdempotencyKey.
type XIdempotencyKey = string

// ConsentID defines model for consentId.
type ConsentID = string

// PaymentID defines model for paymentId.
type PaymentID = string

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// N200PatchPixConsents defines model for 200PatchPixConsents.
type N200PatchPixConsents = ResponsePatchPixConsent

// N200PatchPixPayments defines model for 200PatchPixPayments.
type N200PatchPixPayments = ResponsePatchPixPayment

// N200PaymentsConsentsConsentIDRead defines model for 200PaymentsConsentsConsentIdRead.
type N200PaymentsConsentsConsentIDRead = ResponsePaymentConsent

// N200PaymentsInitiationPixPaymentIDRead defines model for 200PaymentsInitiationPixPaymentIdRead.
type N200PaymentsInitiationPixPaymentIDRead = ResponsePixPayment

// N201PaymentsConsentsConsentCreated defines model for 201PaymentsConsentsConsentCreated.
type N201PaymentsConsentsConsentCreated = ResponseCreatePaymentConsent

// N201PaymentsInitiationPixPaymentCreated defines model for 201PaymentsInitiationPixPaymentCreated.
type N201PaymentsInitiationPixPaymentCreated = ResponseCreatePixPayment

// BadRequest defines model for BadRequest.
type BadRequest = ResponseError

// BadRequestPayments defines model for BadRequestPayments.
type BadRequestPayments = ResponseError

// BadRequestPixPayments defines model for BadRequestPixPayments.
type BadRequestPixPayments = ResponseError

// Forbidden defines model for Forbidden.
type Forbidden = ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseError

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseError

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseError

// NotFound defines model for NotFound.
type NotFound = ResponseError

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseError

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseError

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = ResponseError

// PaymentsPostConsentsParams defines parameters for PaymentsPostConsents.
type PaymentsPostConsentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetConsentsConsentIDParams defines parameters for PaymentsGetConsentsConsentID.
type PaymentsGetConsentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostPixPaymentsParams defines parameters for PaymentsPostPixPayments.
type PaymentsPostPixPaymentsParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsPatchPixPaymentsConsentIDParams defines parameters for PaymentsPatchPixPaymentsConsentID.
type PaymentsPatchPixPaymentsConsentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`

        // XIdempotencyKey Cabeçalho HTTP personalizado. Identificador de solicitação exclusivo para suportar a idempotência.
        XIdempotencyKey XIdempotencyKey `json:"x-idempotency-key"`
}

// PaymentsGetPixPaymentsPaymentIDParams defines parameters for PaymentsGetPixPaymentsPaymentID.
type PaymentsGetPixPaymentsPaymentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPatchPixPaymentsPaymentIDParams defines parameters for PaymentsPatchPixPaymentsPaymentID.
type PaymentsPatchPixPaymentsPaymentIDParams struct {
        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela iniciadora (client) e o seu valor deve ser “espelhado” pela detentora (server) no cabeçalho de resposta. Caso não seja enviado pela iniciadora, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400. Caso recebido um valor inválido, a detentora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP status code 400 ou 422 (com o código PARAMETRO_INVALIDO). A iniciadora deve acatar o valor gerado pelo detentor e recebido na resposta.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// PaymentsPostConsentsJSONRequestBody defines body for PaymentsPostConsents for application/json ContentType.
type PaymentsPostConsentsJSONRequestBody = CreatePaymentConsent

// PaymentsPostPixPaymentsJSONRequestBody defines body for PaymentsPostPixPayments for application/json ContentType.
type PaymentsPostPixPaymentsJSONRequestBody = CreatePixPayment

// PaymentsPatchPixPaymentsConsentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsConsentID for application/json ContentType.
type PaymentsPatchPixPaymentsConsentIDJSONRequestBody = PatchPixPayment

// PaymentsPatchPixPaymentsPaymentIDJSONRequestBody defines body for PaymentsPatchPixPaymentsPaymentID for application/json ContentType.
type PaymentsPatchPixPaymentsPaymentIDJSONRequestBody = PatchPixPayment

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Criar consentimento para a iniciação de pagamento.
        // (POST /consents)
        PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams)
        // Consultar consentimento para iniciação de pagamento.
        // (GET /consents/{consentId})
        PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams)
        // Criar iniciação de pagamento.
        // (POST /pix/payments)
        PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams)
        // Cancelar todos os pagamentos referentes ao mesmo Consentimento.
        // (PATCH /pix/payments/consents/{consentId})
        PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams)
        // Consultar iniciação de pagamento.
        // (GET /pix/payments/{paymentId})
        PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams)
        // Cancelar iniciação de pagamento.
        // (PATCH /pix/payments/{paymentId})
        PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// PaymentsPostConsents operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostConsents(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsPostConsentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsPostConsents(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PaymentsGetConsentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsGetConsentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsGetConsentsConsentID(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PaymentsPostPixPayments operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2AuthorizationCodeScopes, []string{"openid", "consent:consentId", "payments"})

        ctx = context.WithValue(ctx, NonRedirectAuthorizationCodeScopes, []string{"openid", "enrollment:enrollmentId", "payments", "nrp-consents"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsPostPixPaymentsParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsPostPixPayments(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "consentId" -------------
        var consentID ConsentID

        err = runtime.BindStyledParameterWithOptions("simple", "consentId", r.PathValue("consentId"), &amp;consentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "consentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsPatchPixPaymentsConsentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        // ------------- Required header parameter "x-idempotency-key" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-idempotency-key")]; found </span><span class="cov0" title="0">{
                var XIdempotencyKey XIdempotencyKey
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-idempotency-key", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-idempotency-key", valueList[0], &amp;XIdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-idempotency-key", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XIdempotencyKey = XIdempotencyKey</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-idempotency-key is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-idempotency-key", Err: err})
                return
        }</span>

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsPatchPixPaymentsConsentID(w, r, consentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "paymentId" -------------
        var paymentID PaymentID

        err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &amp;paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "paymentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsGetPixPaymentsPaymentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsGetPixPaymentsPaymentID(w, r, paymentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (siw *ServerInterfaceWrapper) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        // ------------- Path parameter "paymentId" -------------
        var paymentID PaymentID

        err = runtime.BindStyledParameterWithOptions("simple", "paymentId", r.PathValue("paymentId"), &amp;paymentID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "paymentId", Err: err})
                return
        }</span>

        <span class="cov0" title="0">ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2ClientCredentialsScopes, []string{"payments"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params PaymentsPatchPixPaymentsPaymentIDParams

        headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.PaymentsPatchPixPaymentsPaymentID(w, r, paymentID, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("POST "+options.BaseURL+"/consents", wrapper.PaymentsPostConsents)
        m.HandleFunc("GET "+options.BaseURL+"/consents/{consentId}", wrapper.PaymentsGetConsentsConsentID)
        m.HandleFunc("POST "+options.BaseURL+"/pix/payments", wrapper.PaymentsPostPixPayments)
        m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/consents/{consentId}", wrapper.PaymentsPatchPixPaymentsConsentID)
        m.HandleFunc("GET "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsGetPixPaymentsPaymentID)
        m.HandleFunc("PATCH "+options.BaseURL+"/pix/payments/{paymentId}", wrapper.PaymentsPatchPixPaymentsPaymentID)

        return m</span>
}

type N200PatchPixConsentsJSONResponse ResponsePatchPixConsent

type N200PatchPixPaymentsJSONResponse ResponsePatchPixPayment

type N200PaymentsConsentsConsentIDReadJSONResponse ResponsePaymentConsent

type N200PaymentsInitiationPixPaymentIDReadJSONResponse ResponsePixPayment

type N201PaymentsConsentsConsentCreatedJSONResponse ResponseCreatePaymentConsent

type N201PaymentsInitiationPixPaymentCreatedJSONResponse ResponseCreatePixPayment

type BadRequestApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPaymentsApplicationJSONCharsetUTF8Response ResponseError

type BadRequestPixPaymentsApplicationJSONCharsetUTF8Response ResponseError

type ForbiddenApplicationJSONCharsetUTF8Response ResponseError

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseError

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseError

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseError

type NotFoundApplicationJSONCharsetUTF8Response ResponseError

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseError

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseError

type UnprocessableEntityConsentsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityPixPaymentApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnprocessableEntityPixPaymentsApplicationJwtResponse struct {
        Body io.Reader

        ContentLength int64
}

type UnsupportedMediaTypeApplicationJSONCharsetUTF8Response ResponseError

type PaymentsPostConsentsRequestObject struct {
        Params PaymentsPostConsentsParams
        Body   *PaymentsPostConsentsJSONRequestBody
}

type PaymentsPostConsentsResponseObject interface {
        VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error
}

type PaymentsPostConsents201JSONResponse struct {
        N201PaymentsConsentsConsentCreatedJSONResponse
}

func (response PaymentsPostConsents201JSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents400ApplicationJSONCharsetUTF8Response struct {
        BadRequestPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents422ApplicationJwtResponse struct {
        UnprocessableEntityConsentsApplicationJwtResponse
}

func (response PaymentsPostConsents422ApplicationJwtResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type PaymentsPostConsents500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsents529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostConsents529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostConsentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsPostConsentsdefaultJSONResponse) VisitPaymentsPostConsentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PaymentsGetConsentsConsentIDRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    PaymentsGetConsentsConsentIDParams
}

type PaymentsGetConsentsConsentIDResponseObject interface {
        VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetConsentsConsentID200JSONResponse struct {
        N200PaymentsConsentsConsentIDReadJSONResponse
}

func (response PaymentsGetConsentsConsentID200JSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetConsentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetConsentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsGetConsentsConsentIDdefaultJSONResponse) VisitPaymentsGetConsentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PaymentsPostPixPaymentsRequestObject struct {
        Params PaymentsPostPixPaymentsParams
        Body   *PaymentsPostPixPaymentsJSONRequestBody
}

type PaymentsPostPixPaymentsResponseObject interface {
        VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error
}

type PaymentsPostPixPayments201JSONResponse struct {
        N201PaymentsInitiationPixPaymentCreatedJSONResponse
}

func (response PaymentsPostPixPayments201JSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(201)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response struct {
        BadRequestPixPaymentsApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments400ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments401ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments403ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments404ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments405ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments406ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response struct {
        UnsupportedMediaTypeApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments415ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(415)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments422ApplicationJwtResponse struct {
        UnprocessableEntityPixPaymentApplicationJwtResponse
}

func (response PaymentsPostPixPayments422ApplicationJwtResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments500ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPostPixPayments529ApplicationJSONCharsetUTF8Response) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPostPixPaymentsdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsPostPixPaymentsdefaultJSONResponse) VisitPaymentsPostPixPaymentsResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PaymentsPatchPixPaymentsConsentIDRequestObject struct {
        ConsentID ConsentID `json:"consentId"`
        Params    PaymentsPatchPixPaymentsConsentIDParams
        Body      *PaymentsPatchPixPaymentsConsentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsConsentIDResponseObject interface {
        VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsConsentID200JSONResponse struct {
        N200PatchPixConsentsJSONResponse
}

func (response PaymentsPatchPixPaymentsConsentID200JSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse struct {
        UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsConsentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsConsentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsPatchPixPaymentsConsentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsConsentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PaymentsGetPixPaymentsPaymentIDRequestObject struct {
        PaymentID PaymentID `json:"paymentId"`
        Params    PaymentsGetPixPaymentsPaymentIDParams
}

type PaymentsGetPixPaymentsPaymentIDResponseObject interface {
        VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsGetPixPaymentsPaymentID200JSONResponse struct {
        N200PaymentsInitiationPixPaymentIDReadJSONResponse
}

func (response PaymentsGetPixPaymentsPaymentID200JSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsGetPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsGetPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsGetPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

type PaymentsPatchPixPaymentsPaymentIDRequestObject struct {
        PaymentID PaymentID `json:"paymentId"`
        Params    PaymentsPatchPixPaymentsPaymentIDParams
        Body      *PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
}

type PaymentsPatchPixPaymentsPaymentIDResponseObject interface {
        VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error
}

type PaymentsPatchPixPaymentsPaymentID200JSONResponse struct {
        N200PatchPixPaymentsJSONResponse
}

func (response PaymentsPatchPixPaymentsPaymentID200JSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID400ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID401ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID403ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID404ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID405ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID406ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse struct {
        UnprocessableEntityPixPaymentsApplicationJwtResponse
}

func (response PaymentsPatchPixPaymentsPaymentID422ApplicationJwtResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/jwt")
        if response.ContentLength != 0 </span><span class="cov0" title="0">{
                w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
        }</span>
        <span class="cov0" title="0">w.WriteHeader(422)

        if closer, ok := response.Body.(io.ReadCloser); ok </span><span class="cov0" title="0">{
                defer closer.Close()
        }</span>
        <span class="cov0" title="0">_, err := io.Copy(w, response.Body)
        return err</span>
}

type PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID500ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response PaymentsPatchPixPaymentsPaymentID529ApplicationJSONCharsetUTF8Response) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse struct {
        Body       ResponseError
        StatusCode int
}

func (response PaymentsPatchPixPaymentsPaymentIDdefaultJSONResponse) VisitPaymentsPatchPixPaymentsPaymentIDResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Criar consentimento para a iniciação de pagamento.
        // (POST /consents)
        PaymentsPostConsents(ctx context.Context, request PaymentsPostConsentsRequestObject) (PaymentsPostConsentsResponseObject, error)
        // Consultar consentimento para iniciação de pagamento.
        // (GET /consents/{consentId})
        PaymentsGetConsentsConsentID(ctx context.Context, request PaymentsGetConsentsConsentIDRequestObject) (PaymentsGetConsentsConsentIDResponseObject, error)
        // Criar iniciação de pagamento.
        // (POST /pix/payments)
        PaymentsPostPixPayments(ctx context.Context, request PaymentsPostPixPaymentsRequestObject) (PaymentsPostPixPaymentsResponseObject, error)
        // Cancelar todos os pagamentos referentes ao mesmo Consentimento.
        // (PATCH /pix/payments/consents/{consentId})
        PaymentsPatchPixPaymentsConsentID(ctx context.Context, request PaymentsPatchPixPaymentsConsentIDRequestObject) (PaymentsPatchPixPaymentsConsentIDResponseObject, error)
        // Consultar iniciação de pagamento.
        // (GET /pix/payments/{paymentId})
        PaymentsGetPixPaymentsPaymentID(ctx context.Context, request PaymentsGetPixPaymentsPaymentIDRequestObject) (PaymentsGetPixPaymentsPaymentIDResponseObject, error)
        // Cancelar iniciação de pagamento.
        // (PATCH /pix/payments/{paymentId})
        PaymentsPatchPixPaymentsPaymentID(ctx context.Context, request PaymentsPatchPixPaymentsPaymentIDRequestObject) (PaymentsPatchPixPaymentsPaymentIDResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// PaymentsPostConsents operation middleware
func (sh *strictHandler) PaymentsPostConsents(w http.ResponseWriter, r *http.Request, params PaymentsPostConsentsParams) <span class="cov0" title="0">{
        var request PaymentsPostConsentsRequestObject

        request.Params = params

        var body PaymentsPostConsentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsPostConsents(ctx, request.(PaymentsPostConsentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsPostConsents")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsPostConsentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsPostConsentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PaymentsGetConsentsConsentID operation middleware
func (sh *strictHandler) PaymentsGetConsentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsGetConsentsConsentIDParams) <span class="cov0" title="0">{
        var request PaymentsGetConsentsConsentIDRequestObject

        request.ConsentID = consentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsGetConsentsConsentID(ctx, request.(PaymentsGetConsentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsGetConsentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsGetConsentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsGetConsentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PaymentsPostPixPayments operation middleware
func (sh *strictHandler) PaymentsPostPixPayments(w http.ResponseWriter, r *http.Request, params PaymentsPostPixPaymentsParams) <span class="cov0" title="0">{
        var request PaymentsPostPixPaymentsRequestObject

        request.Params = params

        var body PaymentsPostPixPaymentsJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsPostPixPayments(ctx, request.(PaymentsPostPixPaymentsRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsPostPixPayments")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsPostPixPaymentsResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsPostPixPaymentsResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PaymentsPatchPixPaymentsConsentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsConsentID(w http.ResponseWriter, r *http.Request, consentID ConsentID, params PaymentsPatchPixPaymentsConsentIDParams) <span class="cov0" title="0">{
        var request PaymentsPatchPixPaymentsConsentIDRequestObject

        request.ConsentID = consentID
        request.Params = params

        var body PaymentsPatchPixPaymentsConsentIDJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsPatchPixPaymentsConsentID(ctx, request.(PaymentsPatchPixPaymentsConsentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsPatchPixPaymentsConsentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsPatchPixPaymentsConsentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsPatchPixPaymentsConsentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PaymentsGetPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsGetPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsGetPixPaymentsPaymentIDParams) <span class="cov0" title="0">{
        var request PaymentsGetPixPaymentsPaymentIDRequestObject

        request.PaymentID = paymentID
        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsGetPixPaymentsPaymentID(ctx, request.(PaymentsGetPixPaymentsPaymentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsGetPixPaymentsPaymentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsGetPixPaymentsPaymentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsGetPixPaymentsPaymentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// PaymentsPatchPixPaymentsPaymentID operation middleware
func (sh *strictHandler) PaymentsPatchPixPaymentsPaymentID(w http.ResponseWriter, r *http.Request, paymentID PaymentID, params PaymentsPatchPixPaymentsPaymentIDParams) <span class="cov0" title="0">{
        var request PaymentsPatchPixPaymentsPaymentIDRequestObject

        request.PaymentID = paymentID
        request.Params = params

        var body PaymentsPatchPixPaymentsPaymentIDJSONRequestBody
        if err := json.NewDecoder(r.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
                return
        }</span>
        <span class="cov0" title="0">request.Body = &amp;body

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.PaymentsPatchPixPaymentsPaymentID(ctx, request.(PaymentsPatchPixPaymentsPaymentIDRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "PaymentsPatchPixPaymentsPaymentID")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(PaymentsPatchPixPaymentsPaymentIDResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitPaymentsPatchPixPaymentsPaymentIDResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
        "6jRPk+UmEbDGsl8+ffn/BQAA//8Qw93OYw0CAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file23" style="display: none">//go:generate oapi-codegen -config=./config.yml -package=resourcev3 -o=./api_gen.go ./swagger.yml
package resourcev3

import (
        "context"
        "net/http"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/api/middleware"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/resource"
)

var _ StrictServerInterface = Server{}

type Server struct {
        baseURL        string
        service        resource.Service
        consentService consent.Service
        op             *provider.Provider
}

func NewServer(host string, service resource.Service, consentService consent.Service, op *provider.Provider) Server <span class="cov0" title="0">{
        return Server{
                baseURL:        host + "/open-banking/resources/v3",
                service:        service,
                consentService: consentService,
                op:             op,
        }
}</span>

func (s Server) RegisterRoutes(mux *http.ServeMux) <span class="cov0" title="0">{
        resourceMux := http.NewServeMux()

        swaggerMiddleware, _ := middleware.Swagger(GetSwagger, func(err error) string </span><span class="cov0" title="0">{ return "INVALID_REQUEST" }</span>)

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler: NewStrictHandlerWithOptions(s, nil, StrictHTTPServerOptions{
                        ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                                writeResponseError(w, r, err)
                        }</span>,
                }),
                HandlerMiddlewares: []MiddlewareFunc{
                        swaggerMiddleware,
                        middleware.FAPIID(nil),
                },
                ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        api.WriteError(w, r, api.NewError("INVALID_REQUEST", http.StatusBadRequest, err.Error()))
                }</span>,
        }

        <span class="cov0" title="0">var handler http.Handler

        handler = http.HandlerFunc(wrapper.ResourcesGetResources)
        handler = middleware.Permission(s.consentService, consent.PermissionResourcesRead)(handler)
        handler = middleware.Auth(s.op, goidc.GrantAuthorizationCode, goidc.ScopeOpenID, consent.ScopeID)(handler)
        resourceMux.Handle("GET /resources", handler)

        mux.Handle("/open-banking/resources/v3/", http.StripPrefix("/open-banking/resources/v3", resourceMux))</span>
}

func (s Server) ResourcesGetResources(ctx context.Context, req ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error) <span class="cov0" title="0">{
        consentID := ctx.Value(api.CtxKeyConsentID).(string)
        orgID := ctx.Value(api.CtxKeyOrgID).(string)
        pag := page.NewPagination(req.Params.Page, req.Params.PageSize)
        resources, err := s.service.Resources(ctx, orgID, resource.Filter{ConsentID: consentID}, pag)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp := ResponseResourceList{
                Data: []struct {
                        ResourceID string                         `json:"resourceId"`
                        Status     ResponseResourceListDataStatus `json:"status"`
                        Type       ResponseResourceListDataType   `json:"type"`
                }{},
                Links: *api.NewPaginatedLinks(s.baseURL+"/resources", resources),
                Meta:  *api.NewPaginatedMeta(resources),
        }
        for _, r := range resources.Records </span><span class="cov0" title="0">{
                resp.Data = append(resp.Data, struct {
                        ResourceID string                         `json:"resourceId"`
                        Status     ResponseResourceListDataStatus `json:"status"`
                        Type       ResponseResourceListDataType   `json:"type"`
                }{
                        ResourceID: r.ResourceID,
                        Status:     ResponseResourceListDataStatus(r.Status),
                        Type:       ResponseResourceListDataType(r.Type),
                })
        }</span>

        <span class="cov0" title="0">return ResourcesGetResources200JSONResponse{OKResponseResourceListJSONResponse(resp)}, nil</span>
}

func writeResponseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
        api.WriteError(w, r, err)
}</span>
</pre>

		<pre class="file" id="file24" style="display: none">//go:build go1.22

// Package resourcev3 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package resourcev3

import (
        "bytes"
        "compress/gzip"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strings"

        "github.com/getkin/kin-openapi/openapi3"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/oapi-codegen/runtime"
        strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
        openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
        OAuth2SecurityScopes = "OAuth2Security.Scopes"
        OpenIdScopes         = "OpenId.Scopes"
)

// Defines values for ResponseResourceListDataStatus.
const (
        AVAILABLE              ResponseResourceListDataStatus = "AVAILABLE"
        PENDINGAUTHORISATION   ResponseResourceListDataStatus = "PENDING_AUTHORISATION"
        TEMPORARILYUNAVAILABLE ResponseResourceListDataStatus = "TEMPORARILY_UNAVAILABLE"
        UNAVAILABLE            ResponseResourceListDataStatus = "UNAVAILABLE"
)

// Defines values for ResponseResourceListDataType.
const (
        ACCOUNT                    ResponseResourceListDataType = "ACCOUNT"
        BANKFIXEDINCOME            ResponseResourceListDataType = "BANK_FIXED_INCOME"
        CREDITCARDACCOUNT          ResponseResourceListDataType = "CREDIT_CARD_ACCOUNT"
        CREDITFIXEDINCOME          ResponseResourceListDataType = "CREDIT_FIXED_INCOME"
        EXCHANGE                   ResponseResourceListDataType = "EXCHANGE"
        FINANCING                  ResponseResourceListDataType = "FINANCING"
        FUND                       ResponseResourceListDataType = "FUND"
        INVOICEFINANCING           ResponseResourceListDataType = "INVOICE_FINANCING"
        LOAN                       ResponseResourceListDataType = "LOAN"
        TREASURETITLE              ResponseResourceListDataType = "TREASURE_TITLE"
        UNARRANGEDACCOUNTOVERDRAFT ResponseResourceListDataType = "UNARRANGED_ACCOUNT_OVERDRAFT"
        VARIABLEINCOME             ResponseResourceListDataType = "VARIABLE_INCOME"
)

// ResponseErrorWithAbleAdditionalProperties defines model for ResponseErrorWithAbleAdditionalProperties.
type ResponseErrorWithAbleAdditionalProperties struct {
        Errors []struct {
                // Code Código de erro específico do endpoint
                Code string `json:"code"`

                // Detail Descrição legível por humanos deste erro específico
                Detail string `json:"detail"`

                // Title Título legível por humanos deste erro específico
                Title string `json:"title"`
        } `json:"errors"`
        Meta *api.Meta `json:"meta,omitempty"`
}

// ResponseResourceList defines model for ResponseResourceList.
type ResponseResourceList struct {
        // Data Lista de recursos e seus respectivos status.
        Data []struct {
                // ResourceID Identifica o recurso reportado pelo participante do Open Finance, no caso de:
                // - Contas de depósito à vista, de poupança ou de pagamento pré-paga : corresponde ao accountId;
                // - Conta de pagamento pós-paga: corresponde ao  creditCardAccountId;
                // - Empréstimos, Financiamentos, Direitos creditórios descontados e Adiantamento a depositantes: corresponde ao contractId
                // - Renda Fixa Bancária, Renda Fixa Crédito, Renda Variável, Título do Tesouro Direto e Fundo de Investimento: corresponde ao investmentId;
                // - Câmbio: corresponde ao operationId.
                ResourceID string `json:"resourceId"`

                // Status Tipo de status de recurso (vide Enum):
                // Available - Disponível
                // Unavailable - Indisponível
                // Temporarily Unavailable - Temporariamente Indisponível
                // Pending Authorisation - Pendente de Autorização
                Status ResponseResourceListDataStatus `json:"status"`

                // Type Tipo de recurso (vide Enum):
                //   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
                //   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
                //   - Loan - Empréstimo
                //   - Financing - Financiamento
                //   - Unarranged Account Overdraft - Cheque Especial
                //   - Invoice Financing - Financiamento de Fatura
                //   - Bank Fixed Income - Renda Fixa Bancária
                //   - Credit Fixed Income - Renda Fixa Crédito
                //   - Variabel Income - Renda Variável
                //   - Treasure Title - Título do Tesouro Direto
                //   - Fund - Fundo de Investimento
                //   - Exchange - Câmbio
                Type ResponseResourceListDataType `json:"type"`
        } `json:"data"`
        Links api.Links `json:"links"`
        Meta  api.Meta  `json:"meta"`
}

// ResponseResourceListDataStatus Tipo de status de recurso (vide Enum):
// Available - Disponível
// Unavailable - Indisponível
// Temporarily Unavailable - Temporariamente Indisponível
// Pending Authorisation - Pendente de Autorização
type ResponseResourceListDataStatus string

// ResponseResourceListDataType Tipo de recurso (vide Enum):
//   - Account - Conta de depósito à vista, poupança ou pagamento pré-paga
//   - Credit Card Account - Conta de pagamento pós-paga (Cartão de Crédito)
//   - Loan - Empréstimo
//   - Financing - Financiamento
//   - Unarranged Account Overdraft - Cheque Especial
//   - Invoice Financing - Financiamento de Fatura
//   - Bank Fixed Income - Renda Fixa Bancária
//   - Credit Fixed Income - Renda Fixa Crédito
//   - Variabel Income - Renda Variável
//   - Treasure Title - Título do Tesouro Direto
//   - Fund - Fundo de Investimento
//   - Exchange - Câmbio
type ResponseResourceListDataType string

// Authorization defines model for Authorization.
type Authorization = string

// Page defines model for page.
type Page = int32

// PageSize defines model for pageSize.
type PageSize = int32

// XCustomerUserAgent defines model for xCustomerUserAgent.
type XCustomerUserAgent = string

// XFapiAuthDate defines model for xFapiAuthDate.
type XFapiAuthDate = string

// XFapiCustomerIPAddress defines model for xFapiCustomerIpAddress.
type XFapiCustomerIPAddress = string

// XFapiInteractionID defines model for xFapiInteractionId.
type XFapiInteractionID = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = ResponseErrorWithAbleAdditionalProperties

// Default defines model for Default.
type Default = ResponseErrorWithAbleAdditionalProperties

// Forbidden defines model for Forbidden.
type Forbidden = ResponseErrorWithAbleAdditionalProperties

// GatewayTimeout defines model for GatewayTimeout.
type GatewayTimeout = ResponseErrorWithAbleAdditionalProperties

// InternalServerError defines model for InternalServerError.
type InternalServerError = ResponseErrorWithAbleAdditionalProperties

// MethodNotAllowed defines model for MethodNotAllowed.
type MethodNotAllowed = ResponseErrorWithAbleAdditionalProperties

// NotAcceptable defines model for NotAcceptable.
type NotAcceptable = ResponseErrorWithAbleAdditionalProperties

// NotFound defines model for NotFound.
type NotFound = ResponseErrorWithAbleAdditionalProperties

// OKResponseResourceList defines model for OKResponseResourceList.
type OKResponseResourceList = ResponseResourceList

// SiteIsOverloaded defines model for SiteIsOverloaded.
type SiteIsOverloaded = ResponseErrorWithAbleAdditionalProperties

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = ResponseErrorWithAbleAdditionalProperties

// Unauthorized defines model for Unauthorized.
type Unauthorized = ResponseErrorWithAbleAdditionalProperties

// ResourcesGetResourcesParams defines parameters for ResourcesGetResources.
type ResourcesGetResourcesParams struct {
        // Page Número da página que está sendo requisitada (o valor da primeira página é 1).
        Page *Page `form:"page,omitempty" json:"page,omitempty"`

        // PageSize Quantidade total de registros por páginas.
        // A transmissora deve considerar entrada como 25, caso seja informado algum valor menor pela receptora.
        // Enquanto houver mais que 25 registros a enviar, a transmissora deve considerar o mínimo por página como 25.
        // Somente a última página retornada (ou primeira, no caso de página única) pode conter menos de 25 registros.
        // Mais informações, acesse Especificações de APIs &gt; Padrões &gt; Paginação.
        PageSize *PageSize `form:"page-size,omitempty" json:"page-size,omitempty"`

        // Authorization Cabeçalho HTTP padrão. Permite que as credenciais sejam fornecidas dependendo do tipo de recurso solicitado
        Authorization Authorization `json:"Authorization"`

        // XFapiAuthDate Data em que o usuário logou pela última vez com o receptor. Representada de acordo com a [RFC7231](https://tools.ietf.org/html/rfc7231).Exemplo: Sun, 10 Sep 2017 19:43:31 UTC
        XFapiAuthDate *XFapiAuthDate `json:"x-fapi-auth-date,omitempty"`

        // XFapiCustomerIPAddress O endereço IP do usuário se estiver atualmente logado com o receptor.
        XFapiCustomerIPAddress *XFapiCustomerIPAddress `json:"x-fapi-customer-ip-address,omitempty"`

        // XFapiInteractionID Um UUID [RFC4122](https://tools.ietf.org/html/rfc4122) usado como um ID de correlação entre request e response. Campo de geração e envio obrigatório pela receptora (client) e o seu valor deve ser “espelhado” pela transmissora (server) no cabeçalho de resposta. Caso não seja recebido ou se for recebido um valor inválido, a transmissora deve gerar um x-fapi-interaction-id e retorná-lo na resposta com o HTTP Status Code 400. A receptora deve acatar o valor recebido da transmissora.
        XFapiInteractionID XFapiInteractionID `json:"x-fapi-interaction-id"`

        // XCustomerUserAgent Indica o user-agent que o usuário utiliza.
        XCustomerUserAgent *XCustomerUserAgent `json:"x-customer-user-agent,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
        // Obtém a lista de recursos consentidos pelo cliente.
        // (GET /resources)
        ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler            ServerInterface
        HandlerMiddlewares []MiddlewareFunc
        ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ResourcesGetResources operation middleware
func (siw *ServerInterfaceWrapper) ResourcesGetResources(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{

        var err error

        ctx := r.Context()

        ctx = context.WithValue(ctx, OAuth2SecurityScopes, []string{"consent:consentId", "resources"})

        ctx = context.WithValue(ctx, OpenIdScopes, []string{"openid"})

        r = r.WithContext(ctx)

        // Parameter object where we will unmarshal all parameters from the context
        var params ResourcesGetResourcesParams

        // ------------- Optional query parameter "page" -------------

        err = runtime.BindQueryParameter("form", true, false, "page", r.URL.Query(), &amp;params.Page)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page", Err: err})
                return
        }</span>

        // ------------- Optional query parameter "page-size" -------------

        <span class="cov0" title="0">err = runtime.BindQueryParameter("form", true, false, "page-size", r.URL.Query(), &amp;params.PageSize)
        if err != nil </span><span class="cov0" title="0">{
                siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "page-size", Err: err})
                return
        }</span>

        <span class="cov0" title="0">headers := r.Header

        // ------------- Required header parameter "Authorization" -------------
        if valueList, found := headers[http.CanonicalHeaderKey("Authorization")]; found </span><span class="cov0" title="0">{
                var Authorization Authorization
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "Authorization", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "Authorization", valueList[0], &amp;Authorization, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "Authorization", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.Authorization = Authorization</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter Authorization is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "Authorization", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-fapi-auth-date" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-auth-date")]; found </span><span class="cov0" title="0">{
                var XFapiAuthDate XFapiAuthDate
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-auth-date", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-auth-date", valueList[0], &amp;XFapiAuthDate, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-auth-date", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiAuthDate = &amp;XFapiAuthDate</span>

        }

        // ------------- Optional header parameter "x-fapi-customer-ip-address" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-customer-ip-address")]; found </span><span class="cov0" title="0">{
                var XFapiCustomerIPAddress XFapiCustomerIPAddress
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-customer-ip-address", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-customer-ip-address", valueList[0], &amp;XFapiCustomerIPAddress, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-customer-ip-address", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiCustomerIPAddress = &amp;XFapiCustomerIPAddress</span>

        }

        // ------------- Required header parameter "x-fapi-interaction-id" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-fapi-interaction-id")]; found </span><span class="cov0" title="0">{
                var XFapiInteractionID XFapiInteractionID
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-fapi-interaction-id", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-fapi-interaction-id", valueList[0], &amp;XFapiInteractionID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-fapi-interaction-id", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XFapiInteractionID = XFapiInteractionID</span>

        } else<span class="cov0" title="0"> {
                err := fmt.Errorf("Header parameter x-fapi-interaction-id is required, but not found")
                siw.ErrorHandlerFunc(w, r, &amp;RequiredHeaderError{ParamName: "x-fapi-interaction-id", Err: err})
                return
        }</span>

        // ------------- Optional header parameter "x-customer-user-agent" -------------
        <span class="cov0" title="0">if valueList, found := headers[http.CanonicalHeaderKey("x-customer-user-agent")]; found </span><span class="cov0" title="0">{
                var XCustomerUserAgent XCustomerUserAgent
                n := len(valueList)
                if n != 1 </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;TooManyValuesForParamError{ParamName: "x-customer-user-agent", Count: n})
                        return
                }</span>

                <span class="cov0" title="0">err = runtime.BindStyledParameterWithOptions("simple", "x-customer-user-agent", valueList[0], &amp;XCustomerUserAgent, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
                if err != nil </span><span class="cov0" title="0">{
                        siw.ErrorHandlerFunc(w, r, &amp;InvalidParamFormatError{ParamName: "x-customer-user-agent", Err: err})
                        return
                }</span>

                <span class="cov0" title="0">params.XCustomerUserAgent = &amp;XCustomerUserAgent</span>

        }

        <span class="cov0" title="0">handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                siw.Handler.ResourcesGetResources(w, r, params)
        }</span>))

        <span class="cov0" title="0">for _, middleware := range siw.HandlerMiddlewares </span><span class="cov0" title="0">{
                handler = middleware(handler)
        }</span>

        <span class="cov0" title="0">handler.ServeHTTP(w, r)</span>
}

type UnescapedCookieParamError struct {
        ParamName string
        Err       error
}

func (e *UnescapedCookieParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}</span>

func (e *UnescapedCookieParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type UnmarshalingParamError struct {
        ParamName string
        Err       error
}

func (e *UnmarshalingParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}</span>

func (e *UnmarshalingParamError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type RequiredParamError struct {
        ParamName string
}

func (e *RequiredParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}</span>

type RequiredHeaderError struct {
        ParamName string
        Err       error
}

func (e *RequiredHeaderError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}</span>

func (e *RequiredHeaderError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type InvalidParamFormatError struct {
        ParamName string
        Err       error
}

func (e *InvalidParamFormatError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}</span>

func (e *InvalidParamFormatError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

type TooManyValuesForParamError struct {
        ParamName string
        Count     int
}

func (e *TooManyValuesForParamError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}</span>

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{})
}</span>

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
        HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
        ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
        BaseURL          string
        BaseRouter       ServeMux
        Middlewares      []MiddlewareFunc
        ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseRouter: m,
        })
}</span>

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler <span class="cov0" title="0">{
        return HandlerWithOptions(si, StdHTTPServerOptions{
                BaseURL:    baseURL,
                BaseRouter: m,
        })
}</span>

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler <span class="cov0" title="0">{
        m := options.BaseRouter

        if m == nil </span><span class="cov0" title="0">{
                m = http.NewServeMux()
        }</span>
        <span class="cov0" title="0">if options.ErrorHandlerFunc == nil </span><span class="cov0" title="0">{
                options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>
        }

        <span class="cov0" title="0">wrapper := ServerInterfaceWrapper{
                Handler:            si,
                HandlerMiddlewares: options.Middlewares,
                ErrorHandlerFunc:   options.ErrorHandlerFunc,
        }

        m.HandleFunc("GET "+options.BaseURL+"/resources", wrapper.ResourcesGetResources)

        return m</span>
}

type N202ResponseResourceResponse struct {
}

type BadRequestApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type DefaultApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ForbiddenApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type GatewayTimeoutApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type InternalServerErrorApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type MethodNotAllowedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotAcceptableApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type NotFoundApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type OKResponseResourceListJSONResponse ResponseResourceList

type SiteIsOverloadedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type TooManyRequestsApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type UnauthorizedApplicationJSONCharsetUTF8Response ResponseErrorWithAbleAdditionalProperties

type ResourcesGetResourcesRequestObject struct {
        Params ResourcesGetResourcesParams
}

type ResourcesGetResourcesResponseObject interface {
        VisitResourcesGetResourcesResponse(w http.ResponseWriter) error
}

type ResourcesGetResources200JSONResponse struct {
        OKResponseResourceListJSONResponse
}

func (response ResourcesGetResources200JSONResponse) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(200)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources202Response = N202ResponseResourceResponse

func (response ResourcesGetResources202Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(202)
        return nil
}</span>

type ResourcesGetResources400ApplicationJSONCharsetUTF8Response struct {
        BadRequestApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources400ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(400)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources401ApplicationJSONCharsetUTF8Response struct {
        UnauthorizedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources401ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(401)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources403ApplicationJSONCharsetUTF8Response struct {
        ForbiddenApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources403ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(403)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources404ApplicationJSONCharsetUTF8Response struct {
        NotFoundApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources404ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(404)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources405ApplicationJSONCharsetUTF8Response struct {
        MethodNotAllowedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources405ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(405)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources406ApplicationJSONCharsetUTF8Response struct {
        NotAcceptableApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources406ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(406)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources429ApplicationJSONCharsetUTF8Response struct {
        TooManyRequestsApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources429ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(429)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources500ApplicationJSONCharsetUTF8Response struct {
        InternalServerErrorApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources500ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(500)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources504ApplicationJSONCharsetUTF8Response struct {
        GatewayTimeoutApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources504ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(504)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResources529ApplicationJSONCharsetUTF8Response struct {
        SiteIsOverloadedApplicationJSONCharsetUTF8Response
}

func (response ResourcesGetResources529ApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(529)

        return json.NewEncoder(w).Encode(response)
}</span>

type ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response struct {
        Body       ResponseErrorWithAbleAdditionalProperties
        StatusCode int
}

func (response ResourcesGetResourcesdefaultApplicationJSONCharsetUTF8Response) VisitResourcesGetResourcesResponse(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(response.StatusCode)

        return json.NewEncoder(w).Encode(response.Body)
}</span>

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
        // Obtém a lista de recursos consentidos pelo cliente.
        // (GET /resources)
        ResourcesGetResources(ctx context.Context, request ResourcesGetResourcesRequestObject) (ResourcesGetResourcesResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHTTPHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHTTPMiddlewareFunc

type StrictHTTPServerOptions struct {
        RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
        ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
                RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                }</span>,
                ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) <span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusInternalServerError)
                }</span>,
        }}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface <span class="cov0" title="0">{
        return &amp;strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}</span>

type strictHandler struct {
        ssi         StrictServerInterface
        middlewares []StrictMiddlewareFunc
        options     StrictHTTPServerOptions
}

// ResourcesGetResources operation middleware
func (sh *strictHandler) ResourcesGetResources(w http.ResponseWriter, r *http.Request, params ResourcesGetResourcesParams) <span class="cov0" title="0">{
        var request ResourcesGetResourcesRequestObject

        request.Params = params

        handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return sh.ssi.ResourcesGetResources(ctx, request.(ResourcesGetResourcesRequestObject))
        }</span>
        <span class="cov0" title="0">for _, middleware := range sh.middlewares </span><span class="cov0" title="0">{
                handler = middleware(handler, "ResourcesGetResources")
        }</span>

        <span class="cov0" title="0">response, err := handler(r.Context(), w, r, request)

        if err != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, err)
        }</span> else<span class="cov0" title="0"> if validResponse, ok := response.(ResourcesGetResourcesResponseObject); ok </span><span class="cov0" title="0">{
                if err := validResponse.VisitResourcesGetResourcesResponse(w); err != nil </span><span class="cov0" title="0">{
                        sh.options.ResponseErrorHandlerFunc(w, r, err)
                }</span>
        } else<span class="cov0" title="0"> if response != nil </span><span class="cov0" title="0">{
                sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
        }</span>
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

        "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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) <span class="cov0" title="0">{
        zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error base64 decoding spec: %w", err)
        }</span>
        <span class="cov0" title="0">zr, err := gzip.NewReader(bytes.NewReader(zipped))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        _, err = buf.ReadFrom(zr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decompressing spec: %w", err)
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) <span class="cov0" title="0">{
        data, err := decodeSpec()
        return func() ([]byte, error) </span><span class="cov0" title="0">{
                return data, err
        }</span>
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) <span class="cov0" title="0">{
        res := make(map[string]func() ([]byte, error))
        if len(pathToFile) &gt; 0 </span><span class="cov0" title="0">{
                res[pathToFile] = rawSpec
        }</span>

        <span class="cov0" title="0">return res</span>
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) <span class="cov0" title="0">{
        resolvePath := PathToRawSpec("")

        loader := openapi3.NewLoader()
        loader.IsExternalRefsAllowed = true
        loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) </span><span class="cov0" title="0">{
                pathToFile := url.String()
                pathToFile = path.Clean(pathToFile)
                getSpec, ok := resolvePath[pathToFile]
                if !ok </span><span class="cov0" title="0">{
                        err1 := fmt.Errorf("path not found: %s", pathToFile)
                        return nil, err1
                }</span>
                <span class="cov0" title="0">return getSpec()</span>
        }
        <span class="cov0" title="0">var specData []byte
        specData, err = rawSpec()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">swagger, err = loader.LoadFromData(specData)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">package api

import (
        "encoding/json"
        "net/http"
)

func WriteJSON(w http.ResponseWriter, data any, status int) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        _ = json.NewEncoder(w).Encode(data)
}</span>
</pre>

		<pre class="file" id="file26" style="display: none">package autopayment

import (
        "strings"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

const (
        ConsentURNPrefix = "urn:mockbank:recurring-consent:"
)

var (
        ScopeConsentID = goidc.NewDynamicScope("recurring-consent", func(requestedScope string) bool <span class="cov0" title="0">{
                return strings.HasPrefix(requestedScope, "recurring-consent:")
        }</span>)
        Scope = goidc.NewScope("recurring-payments")
)

type Payment struct {
        ID                        uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        ConsentID                 uuid.UUID
        EnrollmentID              *uuid.UUID
        EndToEndID                string
        Date                      timeutil.BrazilDate
        Status                    payment.Status
        StatusUpdatedAt           timeutil.DateTime
        Amount                    string
        Currency                  string
        CreditorAccountISBP       string
        CreditorAccountIssuer     *string
        CreditorAccountNumber     string
        CreditorAccountType       payment.AccountType
        RemittanceInformation     *string
        CNPJInitiator             string
        IBGETownCode              *string
        AuthorisationFlow         *payment.AuthorisationFlow
        LocalInstrument           payment.LocalInstrument
        Proxy                     *string
        TransactionIdentification *string
        DocumentIdentification    string
        DocumentRel               consent.Relation
        OriginalID                *uuid.UUID
        Reference                 *string
        RiskSignals               *map[string]any `gorm:"serializer:json"`
        ClientID                  string
        DebtorAccountID           *uuid.UUID `gorm:"column:account_id"`
        DebtorAccount             *account.Account
        Rejection                 *Rejection            `gorm:"serializer:json"`
        Cancellation              *payment.Cancellation `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Payment) TableName() string <span class="cov0" title="0">{
        return "recurring_payments"
}</span>

func (p Payment) PaymentAmount() string <span class="cov0" title="0">{
        return p.Amount
}</span>

type Consent struct {
        ID                         uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Status                     ConsentStatus
        StatusUpdatedAt            timeutil.DateTime
        AuthorizedAt               *timeutil.DateTime
        ApprovalDueAt              *timeutil.BrazilDate
        ExpiresAt                  *timeutil.DateTime
        UserIdentification         string
        UserRel                    consent.Relation
        BusinessIdentification     *string
        BusinessRel                *consent.Relation
        OwnerID                    uuid.UUID
        Creditors                  []Creditor `gorm:"serializer:json"`
        AdditionalInfo             *string
        Configuration              Configuration   `gorm:"serializer:json"`
        RiskSignals                *map[string]any `gorm:"serializer:json"`
        DebtorAccountID            *uuid.UUID      `gorm:"column:account_id"`
        DebtorAccount              *account.Account
        Rejection                  *ConsentRejection  `gorm:"serializer:json"`
        Revocation                 *ConsentRevocation `gorm:"serializer:json"`
        ClientID                   string
        EnrollmentID               *uuid.UUID
        EnrollmentChallenge        *string
        EnrollmentTransactionLimit *string
        EnrollmentDailyLimit       *string

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Consent) TableName() string <span class="cov0" title="0">{
        return "recurring_payment_consents"
}</span>

func (c Consent) URN() string <span class="cov0" title="0">{
        return ConsentURN(c.ID)
}</span>

type ConsentStatus string

const (
        ConsentStatusAwaitingAuthorization ConsentStatus = "AWAITING_AUTHORISATION"
        ConsentStatusAuthorized            ConsentStatus = "AUTHORISED"
        ConsentStatusRejected              ConsentStatus = "REJECTED"
        ConsentStatusRevoked               ConsentStatus = "REVOKED"
        ConsentStatusPartiallyAccepted     ConsentStatus = "PARTIALLY_ACCEPTED"
        ConsentStatusConsumed              ConsentStatus = "CONSUMED"
)

type Configuration struct {
        Automatic *struct {
                ContractID            string   `json:"contractId"`
                FixedAmount           *string  `json:"fixedAmount,omitempty"`
                MaximumVariableAmount *string  `json:"maximumVariableAmount,omitempty"`
                Interval              Interval `json:"interval"`
                ContractDebtor        struct {
                        Name     string           `json:"name"`
                        Document consent.Document `json:"document"`
                } `json:"contractDebtor,omitempty"`
                FirstPayment *struct {
                        Type                  payment.Type        `json:"type"`
                        Date                  timeutil.BrazilDate `json:"date"`
                        Currency              string              `json:"currency"`
                        Amount                string              `json:"amount"`
                        RemittanceInformation string              `json:"remittanceInformation,omitempty"`
                        CreditorAccount       payment.Account     `json:"creditorAccount"`
                } `json:"firstPayment,omitempty"`
                MinimumVariableAmount *string             `json:"minimumVariableAmount,omitempty"`
                IsRetryAccepted       bool                `json:"isRetryAccepted"`
                UseOverdraftLimit     bool                `json:"useOverdraftLimit"`
                ReferenceStartDate    timeutil.BrazilDate `json:"referenceStartDate"`
        } `json:"automatic,omitempty"`
        Sweeping *struct {
                TotalAllowedAmount *string            `json:"totalAllowedAmount,omitempty"`
                TransactionLimit   *string            `json:"transactionLimit,omitempty"`
                PeriodicLimits     *PeriodicLimits    `json:"periodicLimits,omitempty"`
                UseOverdraftLimit  bool               `json:"useOverdraftLimit"`
                StartDateTime      *timeutil.DateTime `json:"startDateTime"`
        } `json:"sweeping,omitempty"`
        VRP *struct {
                TransactionLimit *string         `json:"transactionLimit,omitempty"`
                GlobalLimits     *Limit          `json:"globalLimits,omitempty"`
                PeriodicLimits   *PeriodicLimits `json:"periodicLimits,omitempty"`
        } `json:"vrp,omitempty"`
}

type Interval string

const (
        IntervalWeekly     Interval = "SEMANAL"
        IntervalMonthly    Interval = "MENSAL"
        IntervalAnnually   Interval = "ANUAL"
        IntervalSemiannual Interval = "SEMESTRAL"
        IntervalQuarterly  Interval = "TRIMESTRAL"
)

type PeriodicLimits struct {
        Day   *Limit `json:"day,omitempty"`
        Week  *Limit `json:"week,omitempty"`
        Month *Limit `json:"month,omitempty"`
        Year  *Limit `json:"year,omitempty"`
}

type Limit struct {
        Quantity         *int    `json:"quantityLimit"`
        TransactionLimit *string `json:"transactionLimit,omitempty"`
}

type Rejection struct {
        Code   RejectionReasonCode `json:"code"`
        Detail string              `json:"detail"`
}

type RejectionReasonCode string

const (
        RejectionInsufficientBalance            RejectionReasonCode = "SALDO_INSUFICIENTE"
        RejectionExceedsLimit                   RejectionReasonCode = "VALOR_ACIMA_LIMITE"
        RejectionInvalidAmount                  RejectionReasonCode = "VALOR_INVALIDO"
        RejectionNotInformed                    RejectionReasonCode = "NAO_INFORMADO"
        RejectionPaymentConsentMismatch         RejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        RejectionRefusedByHolder                RejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
        RejectionRefusedBySPI                   RejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
        RejectionInvalidConsent                 RejectionReasonCode = "CONSENTIMENTO_INVALIDO"
        RejectionSPIFailure                     RejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
        RejectionICPFailure                     RejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
        RejectionReceiverPSPFailure             RejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        RejectionHolderInstitutionFailure       RejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
        RejectionPeriodValueLimitExceeded       RejectionReasonCode = "LIMITE_PERIODO_VALOR_EXCEDIDO"
        RejectionPeriodQuantityLimitExceeded    RejectionReasonCode = "LIMITE_PERIODO_QUANTIDADE_EXCEDIDO"
        RejectionInconsistentOwnership          RejectionReasonCode = "TITULARIDADE_INCONSISTENTE"
        RejectionTotalConsentValueLimitExceeded RejectionReasonCode = "LIMITE_VALOR_TOTAL_CONSENTIMENTO_EXCEDIDO"
        RejectionTransactionValueLimitExceeded  RejectionReasonCode = "LIMITE_VALOR_TRANSACAO_CONSENTIMENTO_EXCEDIDO" // O valor da transação ultrapassar o limite de valor por transação
        RejectionRevokedConsent                 RejectionReasonCode = "CONSENTIMENTO_REVOGADO"
        RejectionAttemptLimitExceeded           RejectionReasonCode = "LIMITE_TENTATIVAS_EXCEDIDO"
        RejectionOutOfAllowedPeriod             RejectionReasonCode = "FORA_PRAZO_PERMITIDO"
        RejectionInvalidAttemptDetail           RejectionReasonCode = "DETALHE_TENTATIVA_INVALIDO"
        RejectionInvalidPaymentDetail           RejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
)

type ConsentEdition struct {
        RiskSignals *map[string]any `json:"riskSignals,omitempty"`
        Creditors   []struct {
                Name string `json:"name"`
        } `json:"creditors"`
        ExpiresAt              *timeutil.DateTime `json:"expirationDateTime,omitempty"`
        RecurringConfiguration *struct {
                Automatic *struct {
                        MaximumVariableAmount *string `json:"maximumVariableAmount,omitempty"`
                } `json:"automatic,omitempty"`
        } `json:"recurringConfiguration,omitempty"`
        LoggedUser     *consent.Document `json:"loggedUser,omitempty"`
        BusinessEntity *consent.Document `json:"businessEntity,omitempty"`
}

type ConsentRejection struct {
        By     TerminatedBy         `json:"by"`
        From   TerminatedFrom       `json:"from"`
        Code   ConsentRejectionCode `json:"code"`
        Detail string               `json:"detail"`
}

type ConsentRejectionCode string

const (
        ConsentRejectionNotProvided                 ConsentRejectionCode = "NAO_INFORMADO"
        ConsentRejectionInfrastructureFailure       ConsentRejectionCode = "FALHA_INFRAESTRUTURA"
        ConsentRejectionAuthorizationTimeout        ConsentRejectionCode = "TEMPO_EXPIRADO_AUTORIZACAO"
        ConsentRejectionRejectedByUser              ConsentRejectionCode = "REJEITADO_USUARIO"
        ConsentRejectionSourceAndTargetAccountsSame ConsentRejectionCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        ConsentRejectionAccountDoesNotAllowPayment  ConsentRejectionCode = "CONTA_NAO_PERMITE_PAGAMENTO"
        ConsentRejectionInsufficientFunds           ConsentRejectionCode = "SALDO_INSUFICIENTE"
        ConsentRejectionAmountAboveLimit            ConsentRejectionCode = "VALOR_ACIMA_LIMITE"
        ConsentRejectionAuthenticationMismatch                           = "AUTENTICACAO_DIVERGENTE"
)

type ConsentRevocation struct {
        By     TerminatedBy          `json:"by"`
        From   TerminatedFrom        `json:"from"`
        Code   ConsentRevocationCode `json:"code"`
        Detail string                `json:"detail"`
}

type ConsentRevocationCode string

const (
        ConsentRevocationNotProvided ConsentRevocationCode = "NAO_INFORMADO"
        ConsentRevocationByUser      ConsentRevocationCode = "REVOGADO_USUARIO"
        ConsentRevocationByCreditor  ConsentRevocationCode = "REVOGADO_RECEBEDOR"
)

type TerminatedFrom string

const (
        TerminatedFromInitiator TerminatedFrom = "INICIADORA"
        TerminatedFromHolder    TerminatedFrom = "DETENTORA"
)

type TerminatedBy string

const (
        TerminatedByInitiator TerminatedBy = "INICIADORA"
        TerminatedByHolder    TerminatedBy = "DETENTORA"
        TerminatedByUser      TerminatedBy = "USUARIO"
)

type Creditor struct {
        Type    payment.CreditorType `json:"type"`
        CPFCNPJ string               `json:"cpf_cnpj"`
        Name    string               `json:"name"`
}

type Query struct {
        ID        string
        ConsentID string
        Order     string
        // DebtorAccount indicates whether the DebtorAccount will be preloaded.
        DebtorAccount bool
        Statuses      []payment.Status
}

type Filter struct {
        ConsentID    string
        EnrollmentID string
        Statuses     []payment.Status
        From         *timeutil.BrazilDate
        To           *timeutil.BrazilDate
}

// URLQuery returns a URL query string with the filter parameters.
// If parameters are present, the returned string includes a '?' prefix.
// Returns an empty string if no parameters are set.
func (f Filter) URLQuery() string <span class="cov0" title="0">{
        var params []string

        if f.ConsentID != "" </span><span class="cov0" title="0">{
                params = append(params, "recurringConsentId="+f.ConsentID)
        }</span>

        <span class="cov0" title="0">if f.From != nil </span><span class="cov0" title="0">{
                params = append(params, "from="+f.From.String())
        }</span>

        <span class="cov0" title="0">if f.To != nil </span><span class="cov0" title="0">{
                params = append(params, "to="+f.To.String())
        }</span>

        <span class="cov0" title="0">if len(params) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return "?" + strings.Join(params, "&amp;")</span>
}
</pre>

		<pre class="file" id="file27" style="display: none">package autopayment

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "reflect"
        "slices"
        "strings"
        "time"

        "github.com/luikyv/mock-bank/internal/webhook"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "gorm.io/gorm"
)

type BankConfig interface {
        CNPJ() string
}

type Service struct {
        db             *gorm.DB
        bankConfig     BankConfig
        userService    user.Service
        accountService account.Service
        webhookService webhook.Service
        version        string
}

func NewService(
        db *gorm.DB,
        bankConfig BankConfig,
        userService user.Service,
        accountService account.Service,
        webhookService webhook.Service,
) Service <span class="cov0" title="0">{
        return Service{db: db, userService: userService, accountService: accountService, webhookService: webhookService, version: "v0", bankConfig: bankConfig}
}</span>

func (s Service) WithTx(tx *gorm.DB) Service <span class="cov0" title="0">{
        return NewService(tx, s.bankConfig, s.userService, s.accountService, s.webhookService)
}</span>

func (s Service) WithVersion(version string) Service <span class="cov0" title="0">{
        s.version = version
        return s
}</span>

func (s Service) CreateConsent(ctx context.Context, c *Consent, debtorAcc *payment.Account) error <span class="cov0" title="0">{
        c.Status = ConsentStatusAwaitingAuthorization
        now := timeutil.DateTimeNow()
        c.StatusUpdatedAt = now
        c.CreatedAt = now
        c.UpdatedAt = now
        if sweeping := c.Configuration.Sweeping; sweeping != nil &amp;&amp; sweeping.StartDateTime == nil </span><span class="cov0" title="0">{
                sweeping.StartDateTime = &amp;now
        }</span>

        <span class="cov0" title="0">if err := s.validateConsent(ctx, c, debtorAcc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u, err := s.userService.User(ctx, user.Query{CPF: c.UserIdentification}, c.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.OwnerID = u.ID

        if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                business, err := s.userService.User(ctx, user.Query{CNPJ: *c.BusinessIdentification}, c.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.OwnerID = business.ID</span>
        }

        <span class="cov0" title="0">if debtorAcc == nil </span><span class="cov0" title="0">{
                return s.db.WithContext(ctx).Create(c).Error
        }</span>

        <span class="cov0" title="0">acc, err := s.accountService.Account(ctx, account.Query{Number: debtorAcc.Number}, c.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if acc.OwnerID != c.OwnerID </span><span class="cov0" title="0">{
                return ErrUserDoesntMatchAccount
        }</span>

        <span class="cov0" title="0">c.DebtorAccountID = &amp;acc.ID
        if err := s.runConsentPreCreationAutomations(ctx, c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.db.WithContext(ctx).Create(c).Error</span>
}

func (s Service) AuthorizeConsent(ctx context.Context, c *Consent) error <span class="cov0" title="0">{

        if c.Status != ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                return errorutil.Format("%w: consent is not awaiting authorization", ErrInvalidConsentStatus)
        }</span>

        // Load debtor account if not already loaded.
        <span class="cov0" title="0">if c.DebtorAccount == nil &amp;&amp; c.DebtorAccountID != nil </span><span class="cov0" title="0">{
                accID := *c.DebtorAccountID
                acc, err := s.accountService.Account(ctx, account.Query{ID: accID.String()}, c.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.DebtorAccount = acc</span>
        }

        <span class="cov0" title="0">if c.DebtorAccount != nil &amp;&amp; c.DebtorAccount.SubType == account.SubTypeJointSimple </span><span class="cov0" title="0">{
                return s.updateConsentStatus(ctx, c, ConsentStatusPartiallyAccepted)
        }</span>

        <span class="cov0" title="0">return s.updateConsentStatus(ctx, c, ConsentStatusAuthorized)</span>
}

func (s Service) EnrollConsent(ctx context.Context, id, orgID string, opts payment.EnrollmentOptions) error <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if c.Status != ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                return errorutil.Format("%w: consent is not awaiting authorization", ErrInvalidConsentStatus)
        }</span>

        <span class="cov0" title="0">if c.UserIdentification != opts.UserIdentification </span><span class="cov0" title="0">{
                return errorutil.New("consent user identification mismatch")
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(c.BusinessIdentification, opts.BusinessIdentification) </span><span class="cov0" title="0">{
                return errorutil.New("consent business identification mismatch")
        }</span>

        <span class="cov0" title="0">if c.EnrollmentID != nil </span><span class="cov0" title="0">{
                return errorutil.New("consent already has an enrollment")
        }</span>

        <span class="cov0" title="0">c.EnrollmentID = &amp;opts.EnrollmentID
        c.DebtorAccountID = opts.DebtorAccountID
        c.EnrollmentChallenge = &amp;opts.Challenge
        c.EnrollmentTransactionLimit = &amp;opts.TransactionLimit
        c.EnrollmentDailyLimit = &amp;opts.DailyLimit
        return s.updateConsent(ctx, c)</span>
}

func (s Service) Consent(ctx context.Context, id, orgID string) (*Consent, error) <span class="cov0" title="0">{
        c, err := s.consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c, s.runConsentPostCreationAutomations(ctx, c)</span>
}

func (s Service) RejectConsentByID(ctx context.Context, id, orgID string, rejection ConsentRejection) (*Consent, error) <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span>{<span class="cov0" title="0">
        }</span>

        <span class="cov0" title="0">return c, s.RejectConsent(ctx, c, rejection)</span>
}

func (s Service) RejectConsent(ctx context.Context, c *Consent, rejection ConsentRejection) error <span class="cov0" title="0">{
        if !slices.Contains([]ConsentStatus{
                ConsentStatusAwaitingAuthorization,
                ConsentStatusPartiallyAccepted,
        }, c.Status) </span><span class="cov0" title="0">{
                return ErrCannotRejectConsent
        }</span>

        <span class="cov0" title="0">c.Rejection = &amp;rejection
        return s.updateConsentStatus(ctx, c, ConsentStatusRejected)</span>
}

func (s Service) RevokeConsent(ctx context.Context, id, orgID string, revocation ConsentRevocation) (*Consent, error) <span class="cov0" title="0">{
        var revoked *Consent
        err := s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                txService := s.WithTx(tx)
                c, err := txService.Consent(ctx, id, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := txService.revokeConsent(ctx, c, revocation); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">payments, err := txService.Payments(ctx, orgID, &amp;Filter{ConsentID: id})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, p := range payments </span><span class="cov0" title="0">{
                        if err := txService.reject(ctx, p, RejectionRevokedConsent, "the consent was revoked"); err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, ErrRejectionNotAllowed) </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">return err</span>
                        }
                }

                <span class="cov0" title="0">revoked = c
                return nil</span>
        })

        <span class="cov0" title="0">return revoked, err</span>
}

func (s Service) EditConsent(ctx context.Context, id, orgID string, edition ConsentEdition) (*Consent, error) <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.validateConsentEdition(ctx, c, edition); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.RiskSignals = edition.RiskSignals
        for i := range c.Creditors </span><span class="cov0" title="0">{
                c.Creditors[i].Name = edition.Creditors[0].Name
        }</span>
        <span class="cov0" title="0">c.ExpiresAt = edition.ExpiresAt
        var maxAmount *string
        if edition.RecurringConfiguration != nil &amp;&amp; edition.RecurringConfiguration.Automatic != nil </span><span class="cov0" title="0">{
                maxAmount = edition.RecurringConfiguration.Automatic.MaximumVariableAmount
        }</span>
        <span class="cov0" title="0">c.Configuration.Automatic.MaximumVariableAmount = maxAmount

        return c, s.updateConsent(ctx, c)</span>
}

func (s Service) Create(ctx context.Context, p *Payment) error <span class="cov0" title="0">{

        if p.ConsentID == uuid.Nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: could not infer consent id", ErrMissingValue)
        }</span>

        <span class="cov0" title="0">c, err := s.Consent(ctx, p.ConsentID.String(), p.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if c.Status == ConsentStatusPartiallyAccepted </span><span class="cov0" title="0">{
                return ErrConsentPartiallyAccepted
        }</span>

        <span class="cov0" title="0">if c.Status != ConsentStatusAuthorized </span><span class="cov0" title="0">{
                return ErrInvalidConsentStatus
        }</span>

        <span class="cov0" title="0">p.Status = payment.StatusRCVD
        p.StatusUpdatedAt = timeutil.DateTimeNow()
        p.DebtorAccountID = c.DebtorAccountID
        p.DebtorAccount = c.DebtorAccount
        date, _ := payment.ParseEndToEndDate(p.EndToEndID)
        p.Date = date.BrazilDate()
        p.CreatedAt = timeutil.DateTimeNow()
        p.UpdatedAt = timeutil.DateTimeNow()

        if err := s.validate(ctx, c, p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.runPreCreationAutomations(ctx, p); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.db.WithContext(ctx).Create(p).Error</span>
}

func (s Service) Payment(ctx context.Context, id, orgID string) (*Payment, error) <span class="cov0" title="0">{
        p, err := s.payment(ctx, Query{ID: id, DebtorAccount: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, s.runPostCreationAutomations(ctx, p)</span>
}

func (s Service) Payments(ctx context.Context, orgID string, opts *Filter) ([]*Payment, error) <span class="cov0" title="0">{
        payments, err := s.payments(ctx, orgID, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, p := range payments </span><span class="cov0" title="0">{
                if clientID := ctx.Value(api.CtxKeyClientID); clientID != nil &amp;&amp; clientID != p.ClientID </span><span class="cov0" title="0">{
                        return nil, ErrClientNotAllowed
                }</span>

                <span class="cov0" title="0">if err := s.runPostCreationAutomations(ctx, p); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return payments, nil</span>
}

func (s Service) Cancel(ctx context.Context, id, orgID string, doc consent.Document) (*Payment, error) <span class="cov0" title="0">{
        p, err := s.Payment(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c, err := s.Consent(ctx, p.ConsentID.String(), orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if doc.Rel != c.UserRel </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid rel", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">if doc.Identification != c.UserIdentification </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid identification", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">if err := s.cancel(ctx, p, payment.CancelledFromInitiator, c.UserIdentification); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (s Service) validateConsent(_ context.Context, c *Consent, debtorAccount *payment.Account) error <span class="cov0" title="0">{
        if c.UserRel != consent.RelationCPF </span><span class="cov0" title="0">{
                return errorutil.Format("%w: only CPF is allowed for logged user document relation", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if c.BusinessRel != nil &amp;&amp; *c.BusinessRel != consent.RelationCNPJ </span><span class="cov0" title="0">{
                return errorutil.Format("%w: only CNPJ is allowed for business document relation", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if automatic := c.Configuration.Automatic; automatic != nil </span><span class="cov0" title="0">{
                today := timeutil.BrazilDateNow()
                if automatic.ReferenceStartDate.Before(today) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: reference start date cannot be in the past", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if len(c.Creditors) != 1 </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: only one creditor is allowed for automatic pix", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if c.Creditors[0].Type == payment.CreditorTypeIndividual </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: only creditor of type PESSOA_JURIDICA is allowed for automatic pix", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if exp := c.ExpiresAt; exp != nil </span><span class="cov0" title="0">{
                        now := timeutil.DateTimeNow()
                        if c.ExpiresAt.Before(now) </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: expiration cannot be in the past", ErrInvalidPayment)
                        }</span>

                        <span class="cov0" title="0">if exp.Hour() != 23 || exp.Minute() != 59 || exp.Second() != 59 </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: expiration time for automatic pix must be at 23:59:59 (UTC)", ErrInvalidPayment)
                        }</span>
                }

                <span class="cov0" title="0">if automatic.FixedAmount != nil &amp;&amp; automatic.MaximumVariableAmount != nil </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: at most one of fixed amount and maximum variable amount can be informed", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if automatic.FixedAmount != nil &amp;&amp; automatic.MinimumVariableAmount != nil </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: mininum variable amount cannot be informed if fixed amount is present", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if automatic.MaximumVariableAmount != nil &amp;&amp; automatic.MinimumVariableAmount != nil &amp;&amp; payment.ConvertAmount(*automatic.MinimumVariableAmount) &gt; payment.ConvertAmount(*automatic.MaximumVariableAmount) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: maximum variable amount cannot be lower than minimum variable amount", ErrInvalidPayment)
                }</span>

                <span class="cov0" title="0">if firstPayment := automatic.FirstPayment; firstPayment != nil </span><span class="cov0" title="0">{
                        if firstPayment.Currency != "BRL" </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: only BRL currency is allowed", ErrInvalidDate)
                        }</span>

                        <span class="cov0" title="0">if slices.Contains([]payment.AccountType{
                                payment.AccountTypeCACC,
                                payment.AccountTypeSVGS,
                        }, firstPayment.CreditorAccount.Type) &amp;&amp; firstPayment.CreditorAccount.Issuer == nil </span><span class="cov0" title="0">{
                                return errorutil.New("first payment creditor account issuer is required for account types CACC or SVGS")
                        }</span>

                        <span class="cov0" title="0">if firstPayment.Date.Before(today) </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: first payment date cannot be in the past", ErrInvalidDate)
                        }</span>
                }
        }

        <span class="cov0" title="0">if sweeping := c.Configuration.Sweeping; sweeping != nil </span><span class="cov0" title="0">{
                if businessCNPJ := c.BusinessIdentification; businessCNPJ != nil </span><span class="cov0" title="0">{
                        baseRootCNPJ := (*businessCNPJ)[:8]
                        for _, creditor := range c.Creditors </span><span class="cov0" title="0">{
                                if creditor.Type != payment.CreditorTypeCompany </span><span class="cov0" title="0">{
                                        return errorutil.Format("%w: sweeping requires all creditors to be companies when the user is PESSOA_JURIDICA", ErrInvalidPayment)
                                }</span>

                                <span class="cov0" title="0">if !strings.HasPrefix(creditor.CPFCNPJ, baseRootCNPJ) </span><span class="cov0" title="0">{
                                        return errorutil.Format("%w: sweeping requires all creditor CNPJs to share the same root as the user's business CNPJ", ErrInvalidPayment)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        if len(c.Creditors) != 1 </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: sweeping requires exactly one creditor when the user is PESSOA_NATURAL", ErrInvalidPayment)
                        }</span>

                        <span class="cov0" title="0">creditor := c.Creditors[0]
                        if creditor.Type != payment.CreditorTypeIndividual </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: sweeping requires the creditor to be of type PESSOA_NATURAL when the user is a person", ErrInvalidPayment)
                        }</span>

                        <span class="cov0" title="0">if creditor.CPFCNPJ != c.UserIdentification </span><span class="cov0" title="0">{
                                return errorutil.Format("%w: sweeping requires the creditor's CPF to match the logged user's CPF", ErrInvalidPayment)
                        }</span>
                }

                // Check if start date is after expiration date with leeway of 5 seconds.
                <span class="cov0" title="0">if sweeping.StartDateTime != nil &amp;&amp; c.ExpiresAt != nil &amp;&amp; sweeping.StartDateTime.After(c.ExpiresAt.Add(-5*time.Second).Time) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: sweeping start date cannot be after expiration date", ErrInvalidData)
                }</span>
        }

        <span class="cov0" title="0">if debtorAccount != nil &amp;&amp; slices.Contains([]payment.AccountType{
                payment.AccountTypeCACC,
                payment.AccountTypeSVGS,
        }, debtorAccount.Type) &amp;&amp; debtorAccount.Issuer == nil </span><span class="cov0" title="0">{
                return errorutil.New("debtor account issuer is required for account types CACC or SVGS")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) validateConsentEdition(_ context.Context, c *Consent, edition ConsentEdition) error <span class="cov0" title="0">{
        if c.Status != ConsentStatusAuthorized </span><span class="cov0" title="0">{
                return errorutil.Format("%w: consent is not authorized", ErrInvalidConsentStatus)
        }</span>

        <span class="cov0" title="0">if c.Status != ConsentStatusAuthorized </span><span class="cov0" title="0">{
                return ErrInvalidConsentStatus
        }</span>

        <span class="cov0" title="0">if c.Configuration.Automatic == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: edition is only allowed for automatic pix", ErrFieldNotAllowed)
        }</span>

        <span class="cov0" title="0">if edition.LoggedUser.Identification != c.UserIdentification </span><span class="cov0" title="0">{
                return errorutil.Format("%w: logged user identification doesn't match the consent", ErrInvalidEdition)
        }</span>

        <span class="cov0" title="0">if edition.RiskSignals == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: edition risk signals are required for automatic pix edition", ErrInvalidEdition)
        }</span>

        <span class="cov0" title="0">if len(edition.Creditors) != 1 </span><span class="cov0" title="0">{
                return errorutil.New("only one creditor is allowed for automatic pix edition")
        }</span>

        <span class="cov0" title="0">if edition.ExpiresAt != nil &amp;&amp; edition.ExpiresAt.Before(timeutil.DateTimeNow()) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: edition expiration cannot be in the past", ErrInvalidEdition)
        }</span>

        <span class="cov0" title="0">if c.Configuration.Automatic.FixedAmount != nil &amp;&amp;
                edition.RecurringConfiguration != nil &amp;&amp;
                edition.RecurringConfiguration.Automatic != nil &amp;&amp;
                edition.RecurringConfiguration.Automatic.MaximumVariableAmount != nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: maximum variable amount is not allowed for fixed amount consents", ErrInvalidEdition)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) runConsentPreCreationAutomations(_ context.Context, _ *Consent) error <span class="cov0" title="0">{
        return nil
}</span>

func (s Service) runConsentPostCreationAutomations(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        switch c.Status </span>{
        case ConsentStatusAwaitingAuthorization:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(c.CreatedAt.Add(60 * time.Minute).Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "recurring consent awaiting authorization for too long, moving to rejected")
                        return s.RejectConsent(ctx, c, ConsentRejection{
                                By:     TerminatedByHolder,
                                From:   TerminatedFromHolder,
                                Code:   ConsentRejectionAuthorizationTimeout,
                                Detail: "consent awaiting authorization for too long",
                        })
                }</span>
        case ConsentStatusAuthorized:<span class="cov0" title="0">
                if c.ExpiresAt != nil &amp;&amp; timeutil.DateTimeNow().After(c.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "recurring consent is authorized, but expired, moving to consumed")
                        return s.updateConsentStatus(ctx, c, ConsentStatusConsumed)
                }</span>

                <span class="cov0" title="0">if sweeping := c.Configuration.Sweeping; sweeping != nil </span><span class="cov0" title="0">{
                        if totalAllowedAmount := sweeping.TotalAllowedAmount; totalAllowedAmount != nil </span><span class="cov0" title="0">{
                                payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                        ConsentID: c.ID.String(),
                                        Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if payment.SumPayments(payments) &gt;= payment.ConvertAmount(*totalAllowedAmount) </span><span class="cov0" title="0">{
                                        return s.updateConsentStatus(ctx, c, ConsentStatusConsumed)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) revokeConsent(ctx context.Context, c *Consent, revocation ConsentRevocation) error <span class="cov0" title="0">{
        if c.Status != ConsentStatusAuthorized </span><span class="cov0" title="0">{
                return ErrInvalidConsentStatus
        }</span>

        <span class="cov0" title="0">c.Revocation = &amp;revocation
        return s.updateConsentStatus(ctx, c, ConsentStatusRevoked)</span>
}

func (s Service) consent(ctx context.Context, id, orgID string) (*Consent, error) <span class="cov0" title="0">{
        id = strings.TrimPrefix(id, ConsentURNPrefix)
        c := &amp;Consent{}
        if err := s.db.WithContext(ctx).Preload("DebtorAccount").First(c, "id = ? AND org_id = ?", id, orgID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if ctx.Value(api.CtxKeyClientID) != nil &amp;&amp; ctx.Value(api.CtxKeyClientID) != c.ClientID </span><span class="cov0" title="0">{
                return nil, ErrClientNotAllowed
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

func (s Service) validate(_ context.Context, c *Consent, p *Payment) error <span class="cov0" title="0">{
        if !reflect.DeepEqual(c.EnrollmentID, p.EnrollmentID) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment enrollment id doesn't match the consent", ErrPaymentDoesNotMatchConsent)
        }</span>

        <span class="cov0" title="0">if p.EnrollmentID != nil &amp;&amp; (p.AuthorisationFlow == nil || *p.AuthorisationFlow != payment.AuthorisationFlowFIDOFlow) </span><span class="cov0" title="0">{
                return errorutil.New("payment enrollment id is set but authorisation flow is not FIDO")
        }</span>

        <span class="cov0" title="0">if sweeping := c.Configuration.Sweeping; sweeping != nil </span><span class="cov0" title="0">{
                if p.RiskSignals == nil </span><span class="cov0" title="0">{
                        return errorutil.New("risk signals is required for sweeping payments")
                }</span>

                <span class="cov0" title="0">if sweeping.StartDateTime != nil &amp;&amp; p.Date.Before(sweeping.StartDateTime.BrazilDate()) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: payment date cannot be after sweeping start date", ErrPaymentDoesNotMatchConsent)
                }</span>
        }

        <span class="cov0" title="0">if c.Configuration.Automatic != nil </span><span class="cov0" title="0">{
                if p.LocalInstrument != payment.LocalInstrumentMANU </span><span class="cov0" title="0">{
                        return errorutil.New("local instrument must be MANU for automatic payments")
                }</span>

                <span class="cov0" title="0">if p.Reference == nil </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: payment reference is required for automatic payments", ErrInvalidPayment)
                }</span>
        }

        <span class="cov0" title="0">endToEndDate, err := payment.ParseEndToEndDate(p.EndToEndID)
        if err != nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: invalid end to end id date: %w", ErrInvalidEndToEndID, err)
        }</span>

        <span class="cov0" title="0">if p.Date != endToEndDate.BrazilDate() </span><span class="cov0" title="0">{
                return errorutil.Format("%w: end to end id date doesn't match the payment date", ErrInvalidEndToEndID)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]payment.AccountType{
                payment.AccountTypeCACC,
                payment.AccountTypeSVGS,
        }, p.CreditorAccountType) &amp;&amp; p.CreditorAccountIssuer == nil </span><span class="cov0" title="0">{
                return errorutil.New("creditor account issuer is required for account types CACC or SVGS")
        }</span>

        <span class="cov0" title="0">if p.LocalInstrument == payment.LocalInstrumentMANU &amp;&amp; p.Proxy != nil </span><span class="cov0" title="0">{
                return errorutil.New("proxy must not be set when using local instrument MANU")
        }</span>

        <span class="cov0" title="0">if slices.Contains([]payment.LocalInstrument{
                payment.LocalInstrumentMANU,
                payment.LocalInstrumentDICT,
        }, p.LocalInstrument) &amp;&amp; p.TransactionIdentification != nil </span><span class="cov0" title="0">{
                return errorutil.New("transaction identification is not allowed if local instrument is MANU or DICT")
        }</span>

        <span class="cov0" title="0">if p.LocalInstrument == payment.LocalInstrumentINIC &amp;&amp; p.TransactionIdentification == nil </span><span class="cov0" title="0">{
                return errorutil.New("transaction identification must be informed if local instrument is INIC")
        }</span>

        <span class="cov0" title="0">creditorFound := false
        for _, creditor := range c.Creditors </span><span class="cov0" title="0">{
                if creditor.CPFCNPJ == p.DocumentIdentification </span><span class="cov0" title="0">{
                        creditorFound = true
                }</span>
        }
        <span class="cov0" title="0">if !creditorFound </span><span class="cov0" title="0">{
                return errorutil.Format("%w: document doesn't match any creditor", ErrPaymentDoesNotMatchConsent)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) runPreCreationAutomations(_ context.Context, p *Payment) error <span class="cov0" title="0">{
        switch p.Amount </span>{
        case "20422.01":<span class="cov0" title="0">
                return ErrInvalidPayment</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (s Service) runPostCreationAutomations(ctx context.Context, p *Payment) error <span class="cov0" title="0">{
        now := timeutil.DateTimeNow()
        if now.Before(p.UpdatedAt.Add(5 * time.Second)) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "payment was updated less than 5 secs ago, skipping transitions", "updated_at", p.UpdatedAt.String())
                return nil
        }</span>

        <span class="cov0" title="0">slog.DebugContext(ctx, "evaluating payment automations", "id", p.ID, "status", p.Status, "amount", p.Amount)

        c, err := s.Consent(ctx, p.ConsentID.String(), p.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch p.Status </span>{
        case payment.StatusRCVD:<span class="cov0" title="0">
                if c.ExpiresAt != nil &amp;&amp; p.Date.After(c.ExpiresAt.BrazilDate()) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment cannot be received after the consent expiration date")
                }</span>

                <span class="cov0" title="0">if automatic := c.Configuration.Automatic; automatic != nil </span><span class="cov0" title="0">{

                        if firstPaymentConfig := automatic.FirstPayment; firstPaymentConfig != nil </span><span class="cov0" title="0">{
                                firstPayment, err := s.payment(ctx, Query{ConsentID: c.ID.String(), Order: "created_at ASC"}, c.OrgID)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if p.ID == firstPayment.ID </span><span class="cov0" title="0">{
                                        if !p.Date.Equal(firstPaymentConfig.Date) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment date does not match the configured first payment date in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.Amount != firstPaymentConfig.Amount </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment amount does not match the configured first payment amount in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.Currency != firstPaymentConfig.Currency </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment currency does not match the configured first payment currency in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.CreditorAccountISBP != firstPaymentConfig.CreditorAccount.ISPB </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment creditor account isbp does not match the configured first payment creditor account isbp in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.CreditorAccountType != firstPaymentConfig.CreditorAccount.Type </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment creditor account type does not match the configured first payment creditor account type in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if !reflect.DeepEqual(p.CreditorAccountIssuer, firstPaymentConfig.CreditorAccount.Issuer) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment creditor account issuer does not match the configured first payment creditor account issuer in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.CreditorAccountNumber != firstPaymentConfig.CreditorAccount.Number </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment creditor account number does not match the configured first payment creditor account number in the consent")
                                        }</span>

                                        <span class="cov0" title="0">if p.Reference == nil || *p.Reference != "zero" </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionNotInformed, "payment reference must be 'zero' for the first payment")
                                        }</span>

                                        <span class="cov0" title="0">return s.updateStatus(ctx, p, payment.StatusACCP)</span>
                                }
                        }

                        <span class="cov0" title="0">if p.Date.Before(automatic.ReferenceStartDate) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment date is before the allowed start date")
                        }</span>

                        <span class="cov0" title="0">now := timeutil.BrazilDateNow()
                        if p.Date.Before(now.AddDate(0, 0, 2)) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment must be scheduled at least 2 days in advance")
                        }</span>

                        <span class="cov0" title="0">if p.Date.After(now.AddDate(0, 0, 10)) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment cannot be scheduled more than 10 days in advance")
                        }</span>

                        <span class="cov0" title="0">if automatic.FixedAmount != nil &amp;&amp; p.Amount != *automatic.FixedAmount </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionPaymentConsentMismatch, "payment amount does not match the configured fixed amount in the consent")
                        }</span>

                        <span class="cov0" title="0">if maxAmount := automatic.MaximumVariableAmount; maxAmount != nil &amp;&amp; payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*maxAmount) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionTransactionValueLimitExceeded, "payment amount is greater than the configured maximum variable amount in the consent")
                        }</span>

                        <span class="cov0" title="0">if minAmount := automatic.MinimumVariableAmount; minAmount != nil &amp;&amp; payment.ConvertAmount(p.Amount) &lt; payment.ConvertAmount(*minAmount) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionTransactionValueLimitExceeded, "payment amount is less than the configured minimum variable amount in the consent")
                        }</span>

                        <span class="cov0" title="0">lastestSuccessfulPayment, err := s.payment(ctx, Query{
                                ConsentID: c.ID.String(),
                                Statuses:  []payment.Status{payment.StatusSCHD, payment.StatusACSC},
                                Order:     "date DESC",
                        }, c.OrgID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Skip interval validation if the lastest successful payment was the initial one
                        // which means the current payment is the first of the series.
                        <span class="cov0" title="0">if lastestSuccessfulPayment.Reference != nil &amp;&amp; *lastestSuccessfulPayment.Reference != "zero" </span><span class="cov0" title="0">{
                                // TODO: Validate reference against the date.
                                if automatic.Interval == IntervalWeekly &amp;&amp; lastestSuccessfulPayment.Date.StartOfWeek().Equal(p.Date.StartOfWeek()) </span><span class="cov0" title="0">{
                                        return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment cannot be scheduled more than once a week")
                                }</span>

                                <span class="cov0" title="0">if automatic.Interval == IntervalMonthly &amp;&amp; lastestSuccessfulPayment.Date.StartOfMonth().Equal(p.Date.StartOfMonth()) </span><span class="cov0" title="0">{
                                        return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment cannot be scheduled more than once a month")
                                }</span>

                                <span class="cov0" title="0">if automatic.Interval == IntervalAnnually &amp;&amp; lastestSuccessfulPayment.Date.StartOfYear().Equal(p.Date.StartOfYear()) </span><span class="cov0" title="0">{
                                        return s.reject(ctx, p, RejectionOutOfAllowedPeriod, "payment cannot be scheduled more than once a year")
                                }</span>
                                // TODO: Implement the other intervals.
                        }
                }

                <span class="cov0" title="0">if sweeping := c.Configuration.Sweeping; sweeping != nil </span><span class="cov0" title="0">{
                        if sweeping.TransactionLimit != nil &amp;&amp; payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*sweeping.TransactionLimit) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionTransactionValueLimitExceeded, "sweeping payment amount is greater than the configured transaction limit in the consent")
                        }</span>

                        <span class="cov0" title="0">if sweeping.TotalAllowedAmount != nil </span><span class="cov0" title="0">{
                                payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                        ConsentID: c.ID.String(),
                                        Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov0" title="0">if payment.SumPayments(payments)+payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*sweeping.TotalAllowedAmount) </span><span class="cov0" title="0">{
                                        return s.reject(ctx, p, RejectionTotalConsentValueLimitExceeded, "sweeping payment amount is greater than the configured total allowed amount in the consent")
                                }</span>
                        }

                        <span class="cov0" title="0">if periodicLimits := sweeping.PeriodicLimits; periodicLimits != nil </span><span class="cov0" title="0">{
                                if dayLimit := periodicLimits.Day; dayLimit != nil </span><span class="cov0" title="0">{
                                        today := timeutil.BrazilDateNow()
                                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                                ConsentID: c.ID.String(),
                                                Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                                From:      &amp;today,
                                                To:        &amp;today,
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if dayLimit.Quantity != nil &amp;&amp; len(payments)+1 &gt; *dayLimit.Quantity </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodQuantityLimitExceeded, "sweeping payment amount is greater than the configured daily limit quantity in the consent")
                                        }</span>
                                        <span class="cov0" title="0">if dayLimit.TransactionLimit != nil &amp;&amp; payment.SumPayments(payments)+payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*dayLimit.TransactionLimit) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodValueLimitExceeded, "sweeping payment amount is greater than the configured daily limit amount in the consent")
                                        }</span>
                                }

                                <span class="cov0" title="0">if weekLimit := periodicLimits.Week; weekLimit != nil </span><span class="cov0" title="0">{
                                        today := timeutil.BrazilDateNow()
                                        startOfWeek := today.StartOfWeek()
                                        endOfWeek := today.EndOfWeek()
                                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                                ConsentID: c.ID.String(),
                                                Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                                From:      &amp;startOfWeek,
                                                To:        &amp;endOfWeek,
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if weekLimit.Quantity != nil &amp;&amp; len(payments)+1 &gt; *weekLimit.Quantity </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodQuantityLimitExceeded, "sweeping payment amount is greater than the configured weekly limit quantity in the consent")
                                        }</span>
                                        <span class="cov0" title="0">if weekLimit.TransactionLimit != nil &amp;&amp; payment.SumPayments(payments)+payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*weekLimit.TransactionLimit) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodValueLimitExceeded, "sweeping payment amount is greater than the configured weekly limit amount in the consent")
                                        }</span>
                                }

                                <span class="cov0" title="0">if monthLimit := periodicLimits.Month; monthLimit != nil </span><span class="cov0" title="0">{
                                        today := timeutil.BrazilDateNow()
                                        startOfMonth := today.StartOfMonth()
                                        endOfMonth := today.EndOfMonth()
                                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                                ConsentID: c.ID.String(),
                                                Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                                From:      &amp;startOfMonth,
                                                To:        &amp;endOfMonth,
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if monthLimit.Quantity != nil &amp;&amp; len(payments)+1 &gt; *monthLimit.Quantity </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodQuantityLimitExceeded, "sweeping payment amount is greater than the configured monthly limit quantity in the consent")
                                        }</span>
                                        <span class="cov0" title="0">if monthLimit.TransactionLimit != nil &amp;&amp; payment.SumPayments(payments)+payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*monthLimit.TransactionLimit) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodValueLimitExceeded, "sweeping payment amount is greater than the configured monthly limit amount in the consent")
                                        }</span>
                                }

                                <span class="cov0" title="0">if yearLimit := periodicLimits.Year; yearLimit != nil </span><span class="cov0" title="0">{
                                        today := timeutil.BrazilDateNow()
                                        startOfYear := today.StartOfYear()
                                        endOfYear := today.EndOfYear()
                                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                                ConsentID: c.ID.String(),
                                                Statuses:  []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                                From:      &amp;startOfYear,
                                                To:        &amp;endOfYear,
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">if yearLimit.Quantity != nil &amp;&amp; len(payments)+1 &gt; *yearLimit.Quantity </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodQuantityLimitExceeded, "sweeping payment amount is greater than the configured yearly limit quantity in the consent")
                                        }</span>
                                        <span class="cov0" title="0">if yearLimit.TransactionLimit != nil &amp;&amp; payment.SumPayments(payments)+payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*yearLimit.TransactionLimit) </span><span class="cov0" title="0">{
                                                return s.reject(ctx, p, RejectionPeriodValueLimitExceeded, "sweeping payment amount is greater than the configured yearly limit amount in the consent")
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if c.EnrollmentTransactionLimit != nil &amp;&amp; payment.ConvertAmount(p.Amount) &gt; payment.ConvertAmount(*c.EnrollmentTransactionLimit) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionTransactionValueLimitExceeded, "payment amount is greater than the configured transaction limit in the consent")
                }</span>

                <span class="cov0" title="0">if c.EnrollmentDailyLimit != nil </span><span class="cov0" title="0">{
                        today := timeutil.BrazilDateNow()
                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                EnrollmentID: p.EnrollmentID.String(),
                                Statuses:     []payment.Status{payment.StatusACSC, payment.StatusSCHD},
                                From:         &amp;today,
                                To:           &amp;today,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if payment.ConvertAmount(p.Amount)+payment.SumPayments(payments) &gt; payment.ConvertAmount(*c.EnrollmentDailyLimit) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionTransactionValueLimitExceeded, "payment amount goes beyond the configured daily limit in the consent")
                        }</span>
                }

                <span class="cov0" title="0">return s.updateStatus(ctx, p, payment.StatusACCP)</span>

        case payment.StatusACCP:<span class="cov0" title="0">
                if p.Date.After(timeutil.BrazilDateNow()) </span><span class="cov0" title="0">{
                        return s.updateStatus(ctx, p, payment.StatusSCHD)
                }</span>
                <span class="cov0" title="0">return s.updateStatus(ctx, p, payment.StatusACPD)</span>

        case payment.StatusSCHD:<span class="cov0" title="0">
                if c.ExpiresAt != nil &amp;&amp; p.Date.After(c.ExpiresAt.BrazilDate()) </span><span class="cov0" title="0">{
                        return s.cancel(ctx, p, payment.CancelledFromHolder, s.bankConfig.CNPJ())
                }</span>
                <span class="cov0" title="0">if p.Date.After(timeutil.BrazilDateNow()) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return s.updateStatus(ctx, p, payment.StatusACPD)</span>

        case payment.StatusACPD:<span class="cov0" title="0">
                return s.updateStatus(ctx, p, payment.StatusACSC)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) payment(ctx context.Context, query Query, orgID string) (*Payment, error) <span class="cov0" title="0">{
        dbQuery := s.db.WithContext(ctx).Where("org_id = ?", orgID)
        if query.ID != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("id = ?", query.ID)
        }</span>
        <span class="cov0" title="0">if query.ConsentID != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("consent_id = ?", query.ConsentID)
        }</span>
        <span class="cov0" title="0">if query.Statuses != nil </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("status IN ?", query.Statuses)
        }</span>
        <span class="cov0" title="0">if query.DebtorAccount </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Preload("DebtorAccount")
        }</span>
        <span class="cov0" title="0">if query.Order != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Order(query.Order)
        }</span>
        <span class="cov0" title="0">p := &amp;Payment{}
        if err := dbQuery.First(p).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if clientID := ctx.Value(api.CtxKeyClientID); clientID != nil &amp;&amp; clientID != p.ClientID </span><span class="cov0" title="0">{
                return nil, ErrClientNotAllowed
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (s Service) reject(ctx context.Context, p *Payment, code RejectionReasonCode, detail string) error <span class="cov0" title="0">{
        if !slices.Contains([]payment.Status{
                payment.StatusRCVD,
                payment.StatusPDNG,
                payment.StatusACCP,
                payment.StatusACPD,
                payment.StatusSCHD}, p.Status) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment in status %s cannot be rejected", ErrRejectionNotAllowed, p.Status)
        }</span>

        <span class="cov0" title="0">tomorrow := timeutil.BrazilDateNow().AddDate(0, 0, 1)
        if p.Status == payment.StatusSCHD &amp;&amp; !p.Date.After(tomorrow) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: scheduled payments until 23:59 of the next day must be maintained", ErrRejectionNotAllowed)
        }</span>

        <span class="cov0" title="0">p.Rejection = &amp;Rejection{
                Code:   code,
                Detail: detail,
        }
        return s.updateStatus(ctx, p, payment.StatusRJCT)</span>
}

func (s Service) payments(ctx context.Context, orgID string, opts *Filter) ([]*Payment, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;Filter{}
        }</span>
        <span class="cov0" title="0">query := s.db.WithContext(ctx).Where("org_id = ?", orgID)
        if opts.ConsentID != "" </span><span class="cov0" title="0">{
                query = query.Where("consent_id = ?", strings.TrimPrefix(opts.ConsentID, consent.URNPrefix))
        }</span>
        <span class="cov0" title="0">if opts.Statuses != nil </span><span class="cov0" title="0">{
                query = query.Where("status IN ?", opts.Statuses)
        }</span>
        <span class="cov0" title="0">if opts.From != nil </span><span class="cov0" title="0">{
                query = query.Where("date &gt;= ?", opts.From)
        }</span>
        <span class="cov0" title="0">if opts.To != nil </span><span class="cov0" title="0">{
                query = query.Where("date &lt;= ?", opts.To)
        }</span>

        <span class="cov0" title="0">var payments []*Payment
        if err := query.Find(&amp;payments).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not find payments: %w", err)
        }</span>

        <span class="cov0" title="0">return payments, nil</span>
}

func (s Service) cancel(ctx context.Context, p *Payment, from payment.CancelledFrom, by string) error <span class="cov0" title="0">{
        if !slices.Contains([]payment.Status{payment.StatusPDNG, payment.StatusSCHD}, p.Status) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment with status %s cannot be cancelled, only payments with status PDNG or SCHD can be cancelled", ErrCancelNotAllowed, p.Status)
        }</span>

        <span class="cov0" title="0">if p.Status == payment.StatusSCHD &amp;&amp; !timeutil.BrazilDateNow().Before(p.Date) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: scheduled payments can only be cancelled until 23:59 (BRT) of the day before the payment date (%s)", ErrCancelNotAllowed, p.Date.String())
        }</span>

        <span class="cov0" title="0">reason := payment.CancellationReasonPending
        if p.Status == payment.StatusSCHD </span><span class="cov0" title="0">{
                reason = payment.CancellationReasonScheduled
        }</span>
        <span class="cov0" title="0">p.Cancellation = &amp;payment.Cancellation{
                At:     timeutil.DateTimeNow(),
                Reason: reason,
                From:   from,
                By:     by,
        }
        return s.updateStatus(ctx, p, payment.StatusCANC)</span>
}

func (s Service) updateStatus(ctx context.Context, p *Payment, status payment.Status) error <span class="cov0" title="0">{
        slog.DebugContext(ctx, "updating payment status", "current_status", p.Status, "new_status", status)

        p.Status = status
        p.StatusUpdatedAt = timeutil.DateTimeNow()
        p.UpdatedAt = timeutil.DateTimeNow()
        err := s.db.WithContext(ctx).
                Model(&amp;Payment{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", p.ID, p.OrgID).
                Updates(p).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update payment status: %w", err)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]payment.Status{
                payment.StatusPDNG,
                payment.StatusSCHD,
                payment.StatusACSC,
                payment.StatusRJCT,
                payment.StatusCANC,
        }, status) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "notifying client about recurring payment status change")
                s.webhookService.Notify(ctx, p.ClientID, "/automatic-payments/"+s.version+"/pix/recurring-payments/"+p.ID.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) updateConsentStatus(ctx context.Context, c *Consent, status ConsentStatus) error <span class="cov0" title="0">{
        oldStatus := c.Status
        slog.DebugContext(ctx, "updating recurring payment consent status", "current_status", oldStatus, "new_status", status)

        c.Status = status
        c.StatusUpdatedAt = timeutil.DateTimeNow()
        if status == ConsentStatusAuthorized </span><span class="cov0" title="0">{
                now := timeutil.DateTimeNow()
                c.AuthorizedAt = &amp;now
        }</span>

        <span class="cov0" title="0">if err := s.updateConsent(ctx, c); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update consent status: %w", err)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]ConsentStatus{
                ConsentStatusRejected,
                ConsentStatusRevoked,
                ConsentStatusConsumed,
        }, status) || (oldStatus == ConsentStatusPartiallyAccepted &amp;&amp; status == ConsentStatusAuthorized) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "notifying client about recurring payment consent status change")
                s.webhookService.Notify(ctx, c.ClientID, "/automatic-payments/"+s.version+"/recurring-consents/"+c.URN())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) updateConsent(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        c.UpdatedAt = timeutil.DateTimeNow()
        err := s.db.WithContext(ctx).
                Model(&amp;Consent{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", c.ID, c.OrgID).
                Updates(c).Error
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update consent: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file28" style="display: none">package autopayment

import (
        "strings"

        "github.com/google/uuid"
)

func ConsentURN(id uuid.UUID) string <span class="cov0" title="0">{
        return ConsentURNPrefix + id.String()
}</span>

func ConsentIDFromScopes(scopes string) (string, bool) <span class="cov0" title="0">{
        for _, s := range strings.Split(scopes, " ") </span><span class="cov0" title="0">{
                if ScopeConsentID.Matches(s) </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(s, "recurring-consent:"+ConsentURNPrefix), true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}
</pre>

		<pre class="file" id="file29" style="display: none">package client

import (
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type Client struct {
        ID          string       `gorm:"primaryKey"`
        Data        goidc.Client `gorm:"serializer:json"`
        WebhookURIs []string     `gorm:"serializer:json"`
        Name        string
        OriginURIs  []string `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Client) TableName() string <span class="cov0" title="0">{
        return "oauth_clients"
}</span>
</pre>

		<pre class="file" id="file30" style="display: none">package client

import (
        "context"

        "gorm.io/gorm"
)

type Service struct {
        db *gorm.DB
}

func NewService(db *gorm.DB) Service <span class="cov0" title="0">{
        return Service{db: db}
}</span>

func (s Service) Save(ctx context.Context, client *Client) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Omit("CreatedAt").Save(client).Error
}</span>

func (s Service) Client(ctx context.Context, id string) (*Client, error) <span class="cov0" title="0">{
        var client Client
        if err := s.db.WithContext(ctx).First(&amp;client, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;client, nil</span>
}

func (s Service) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Delete(&amp;Client{}, "id = ?", id).Error
}</span>
</pre>

		<pre class="file" id="file31" style="display: none">package consent

import (
        "slices"
        "strings"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

const (
        DefaultUserDocumentRelation = "CPF"
        URNPrefix                   = "urn:mockbank:consent:"
)

var (
        ScopeID = goidc.NewDynamicScope("consent", func(requestedScope string) bool <span class="cov0" title="0">{
                return strings.HasPrefix(requestedScope, "consent:")
        }</span>)
        Scope = goidc.NewScope("consents")
)

type Consent struct {
        ID                     uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Status                 Status
        Permissions            Permissions `gorm:"serializer:json"`
        StatusUpdatedAt        timeutil.DateTime
        ExpiresAt              *timeutil.DateTime
        UserIdentification     string
        UserRel                Relation
        OwnerID                *uuid.UUID
        BusinessIdentification *string
        BusinessRel            *Relation
        ClientID               string
        Rejection              *Rejection `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (c Consent) URN() string <span class="cov0" title="0">{
        return URN(c.ID)
}</span>

func (c Consent) HasPermissions(permissions []Permission) bool <span class="cov0" title="0">{
        for _, p := range permissions </span><span class="cov0" title="0">{
                if !slices.Contains(c.Permissions, p) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

type Status string

const (
        StatusAwaitingAuthorization Status = "AWAITING_AUTHORISATION"
        StatusAuthorized            Status = "AUTHORISED"
        StatusRejected              Status = "REJECTED"
)

type Permission string

const (
        PermissionAccountsBalanceRead                                 Permission = "ACCOUNTS_BALANCES_READ"
        PermissionAccountsOverdraftLimitsRead                         Permission = "ACCOUNTS_OVERDRAFT_LIMITS_READ"
        PermissionAccountsRead                                        Permission = "ACCOUNTS_READ"
        PermissionAccountsTransactionsRead                            Permission = "ACCOUNTS_TRANSACTIONS_READ"
        PermissionBankFixedIncomesRead                                Permission = "BANK_FIXED_INCOMES_READ"
        PermissionCreditCardsAccountsBillsRead                        Permission = "CREDIT_CARDS_ACCOUNTS_BILLS_READ"
        PermissionCreditCardsAccountsBillsTransactionsRead            Permission = "CREDIT_CARDS_ACCOUNTS_BILLS_TRANSACTIONS_READ"
        PermissionCreditCardsAccountsLimitsRead                       Permission = "CREDIT_CARDS_ACCOUNTS_LIMITS_READ"
        PermissionCreditCardsAccountsRead                             Permission = "CREDIT_CARDS_ACCOUNTS_READ"
        PermissionCreditCardsAccountsTransactionsRead                 Permission = "CREDIT_CARDS_ACCOUNTS_TRANSACTIONS_READ"
        PermissionCreditFixedIncomesRead                              Permission = "CREDIT_FIXED_INCOMES_READ"
        PermissionCustomersBusinessAdittionalInfoRead                 Permission = "CUSTOMERS_BUSINESS_ADITTIONALINFO_READ"
        PermissionCustomersBusinessIdentificationsRead                Permission = "CUSTOMERS_BUSINESS_IDENTIFICATIONS_READ"
        PermissionCustomersPersonalAdittionalInfoRead                 Permission = "CUSTOMERS_PERSONAL_ADITTIONALINFO_READ"
        PermissionCustomersPersonalIdentificationsRead                Permission = "CUSTOMERS_PERSONAL_IDENTIFICATIONS_READ"
        PermissionExchangesRead                                       Permission = "EXCHANGES_READ"
        PermissionFinancingsPaymentsRead                              Permission = "FINANCINGS_PAYMENTS_READ"
        PermissionFinancingsRead                                      Permission = "FINANCINGS_READ"
        PermissionFinancingsScheduledInstalmentsRead                  Permission = "FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        PermissionFinancingsWarrantiesRead                            Permission = "FINANCINGS_WARRANTIES_READ"
        PermissionFundsRead                                           Permission = "FUNDS_READ"
        PermissionInvoiceFinancingsPaymentsRead                       Permission = "INVOICE_FINANCINGS_PAYMENTS_READ"
        PermissionInvoiceFinancingsRead                               Permission = "INVOICE_FINANCINGS_READ"
        PermissionInvoiceFinancingsScheduledInstalmentsRead           Permission = "INVOICE_FINANCINGS_SCHEDULED_INSTALMENTS_READ"
        PermissionInvoiceFinancingsWarrantiesRead                     Permission = "INVOICE_FINANCINGS_WARRANTIES_READ"
        PermissionLoansPaymentsRead                                   Permission = "LOANS_PAYMENTS_READ"
        PermissionLoansRead                                           Permission = "LOANS_READ"
        PermissionLoansScheduledInstalmentsRead                       Permission = "LOANS_SCHEDULED_INSTALMENTS_READ"
        PermissionLoansWarrantiesRead                                 Permission = "LOANS_WARRANTIES_READ"
        PermissionResourcesRead                                       Permission = "RESOURCES_READ"
        PermissionTreasureTitlesRead                                  Permission = "TREASURE_TITLES_READ"
        PermissionUnarrangedAccountsOverdraftPaymentsRead             Permission = "UNARRANGED_ACCOUNTS_OVERDRAFT_PAYMENTS_READ"
        PermissionUnarrangedAccountsOverdraftRead                     Permission = "UNARRANGED_ACCOUNTS_OVERDRAFT_READ"
        PermissionUnarrangedAccountsOverdraftScheduledInstalmentsRead Permission = "UNARRANGED_ACCOUNTS_OVERDRAFT_SCHEDULED_INSTALMENTS_READ"
        PermissionUnarrangedAccountsOverdraftWarrantiesRead           Permission = "UNARRANGED_ACCOUNTS_OVERDRAFT_WARRANTIES_READ"
        PermissionVariableIncomesRead                                 Permission = "VARIABLE_INCOMES_READ"
)

type Permissions []Permission

func (p Permissions) HasAccountPermissions() bool <span class="cov0" title="0">{
        return slices.ContainsFunc(p, func(permission Permission) bool </span><span class="cov0" title="0">{
                return strings.HasPrefix(string(permission), "ACCOUNTS_")
        }</span>)
}

var (
        PermissionGroupPersonalRegistrationData = []Permission{
                PermissionCustomersPersonalIdentificationsRead,
                PermissionResourcesRead,
        }
        PermissionGroupPersonalAdditionalInfo Permissions = []Permission{
                PermissionCustomersPersonalAdittionalInfoRead,
                PermissionResourcesRead,
        }
        PermissionGroupBusinessRegistrationData Permissions = []Permission{
                PermissionCustomersBusinessIdentificationsRead,
                PermissionResourcesRead,
        }
        PermissionGroupBusinessAdditionalInfo Permissions = []Permission{
                PermissionCustomersBusinessAdittionalInfoRead,
                PermissionResourcesRead,
        }
        PermissionGroupBalances Permissions = []Permission{
                PermissionAccountsRead,
                PermissionAccountsBalanceRead,
                PermissionResourcesRead,
        }
        PermissionGroupLimits Permissions = []Permission{
                PermissionAccountsRead,
                PermissionAccountsOverdraftLimitsRead,
                PermissionResourcesRead,
        }
        PermissionGroupStatements Permissions = []Permission{
                PermissionAccountsRead,
                PermissionAccountsTransactionsRead,
                PermissionResourcesRead,
        }
        PermissionGroupCreditCardLimits Permissions = []Permission{
                PermissionCreditCardsAccountsRead,
                PermissionCreditCardsAccountsLimitsRead,
                PermissionResourcesRead,
        }
        PermissionGroupCreditCardTransactions Permissions = []Permission{
                PermissionCreditCardsAccountsRead,
                PermissionCreditCardsAccountsTransactionsRead,
                PermissionResourcesRead,
        }
        PermissionGroupCreditCardBills Permissions = []Permission{
                PermissionCreditCardsAccountsRead,
                PermissionCreditCardsAccountsBillsRead,
                PermissionCreditCardsAccountsBillsTransactionsRead,
                PermissionResourcesRead,
        }
        PermissionGroupContractData Permissions = []Permission{
                PermissionLoansRead,
                PermissionLoansWarrantiesRead,
                PermissionLoansScheduledInstalmentsRead,
                PermissionLoansPaymentsRead,
                PermissionFinancingsRead,
                PermissionFinancingsWarrantiesRead,
                PermissionFinancingsScheduledInstalmentsRead,
                PermissionFinancingsPaymentsRead,
                PermissionUnarrangedAccountsOverdraftRead,
                PermissionUnarrangedAccountsOverdraftWarrantiesRead,
                PermissionUnarrangedAccountsOverdraftScheduledInstalmentsRead,
                PermissionUnarrangedAccountsOverdraftPaymentsRead,
                PermissionInvoiceFinancingsRead,
                PermissionInvoiceFinancingsWarrantiesRead,
                PermissionInvoiceFinancingsScheduledInstalmentsRead,
                PermissionInvoiceFinancingsPaymentsRead,
                PermissionResourcesRead,
        }
        PermissionGroupInvestimentOperationalData Permissions = []Permission{
                PermissionBankFixedIncomesRead,
                PermissionCreditFixedIncomesRead,
                PermissionFundsRead,
                PermissionVariableIncomesRead,
                PermissionTreasureTitlesRead,
                PermissionResourcesRead,
        }
        PermissionGroupExchangeOperationalData Permissions = []Permission{
                PermissionExchangesRead,
                PermissionResourcesRead,
        }
        PermissionGroupAll = []Permission{
                PermissionAccountsBalanceRead,
                PermissionAccountsOverdraftLimitsRead,
                PermissionAccountsRead,
                PermissionAccountsTransactionsRead,
                PermissionBankFixedIncomesRead,
                PermissionCreditCardsAccountsBillsRead,
                PermissionCreditCardsAccountsBillsTransactionsRead,
                PermissionCreditCardsAccountsLimitsRead,
                PermissionCreditCardsAccountsRead,
                PermissionCreditCardsAccountsTransactionsRead,
                PermissionCreditFixedIncomesRead,
                PermissionCustomersBusinessAdittionalInfoRead,
                PermissionCustomersBusinessIdentificationsRead,
                PermissionCustomersPersonalAdittionalInfoRead,
                PermissionCustomersPersonalIdentificationsRead,
                PermissionExchangesRead,
                PermissionFinancingsPaymentsRead,
                PermissionFinancingsRead,
                PermissionFinancingsScheduledInstalmentsRead,
                PermissionFinancingsWarrantiesRead,
                PermissionFundsRead,
                PermissionInvoiceFinancingsPaymentsRead,
                PermissionInvoiceFinancingsRead,
                PermissionInvoiceFinancingsScheduledInstalmentsRead,
                PermissionInvoiceFinancingsWarrantiesRead,
                PermissionLoansPaymentsRead,
                PermissionLoansRead,
                PermissionLoansScheduledInstalmentsRead,
                PermissionLoansWarrantiesRead,
                PermissionResourcesRead,
                PermissionTreasureTitlesRead,
                PermissionUnarrangedAccountsOverdraftPaymentsRead,
                PermissionUnarrangedAccountsOverdraftRead,
                PermissionUnarrangedAccountsOverdraftScheduledInstalmentsRead,
                PermissionUnarrangedAccountsOverdraftWarrantiesRead,
                PermissionVariableIncomesRead,
        }
)

var PermissionGroups = []Permissions{
        PermissionGroupPersonalRegistrationData,
        PermissionGroupPersonalAdditionalInfo,
        PermissionGroupBusinessRegistrationData,
        PermissionGroupBusinessAdditionalInfo,
        PermissionGroupBalances,
        PermissionGroupLimits,
        PermissionGroupStatements,
        PermissionGroupCreditCardLimits,
        PermissionGroupCreditCardTransactions,
        PermissionGroupCreditCardBills,
        PermissionGroupContractData,
        PermissionGroupInvestimentOperationalData,
        PermissionGroupExchangeOperationalData,
}

type Rejection struct {
        By     RejectedBy
        Reason RejectionReason
}

type RejectedBy string

const (
        RejectedByUser  RejectedBy = "USER"
        RejectedByASPSP RejectedBy = "ASPSP"
        RejectedByTPP   RejectedBy = "TPP"
)

type RejectionReason string

const (
        RejectionReasonConsentExpired           RejectionReason = "CONSENT_EXPIRED"
        RejectionReasonCustomerManuallyRejected RejectionReason = "CUSTOMER_MANUALLY_REJECTED"
        RejectionReasonCustomerManuallyRevoked  RejectionReason = "CUSTOMER_MANUALLY_REVOKED"
        RejectionReasonConsentMaxDateReached    RejectionReason = "CONSENT_MAX_DATE_REACHED"
        RejectionReasonConsentTechnicalIssue    RejectionReason = "CONSENT_TECHNICAL_ISSUE"
        RejectionReasonInternalSecurityReason   RejectionReason = "INTERNAL_SECURITY_REASON"
)

type Extension struct {
        ID                uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        ConsentID         uuid.UUID
        UserCPF           string
        BusinessCNPJ      *string
        ExpiresAt         *timeutil.DateTime
        PreviousExpiresAt *timeutil.DateTime
        RequestedAt       timeutil.DateTime
        UserIPAddress     string
        UserAgent         string
}

func (Extension) TableName() string <span class="cov0" title="0">{
        return "consent_extensions"
}</span>

type Document struct {
        Identification string   `json:"identification"`
        Rel            Relation `json:"rel"`
}

type Relation string

const (
        RelationCPF  Relation = "CPF"
        RelationCNPJ Relation = "CNPJ"
)
</pre>

		<pre class="file" id="file32" style="display: none">package consent

import (
        "context"
        "errors"
        "log/slog"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "gorm.io/gorm"
)

type Service struct {
        db          *gorm.DB
        userService user.Service
}

func NewService(db *gorm.DB, userService user.Service) Service <span class="cov0" title="0">{
        return Service{
                db:          db,
                userService: userService,
        }
}</span>

func (s Service) Create(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        c.Status = StatusAwaitingAuthorization
        now := timeutil.DateTimeNow()
        c.StatusUpdatedAt = now
        c.CreatedAt = now
        c.UpdatedAt = now

        if err := s.validate(ctx, c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if u, err := s.userService.User(ctx, user.Query{CPF: c.UserIdentification}, c.OrgID); err == nil </span><span class="cov0" title="0">{
                c.OwnerID = &amp;u.ID
        }</span>

        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                if u, err := s.userService.User(ctx, user.Query{CNPJ: *c.BusinessIdentification}, c.OrgID); err == nil </span><span class="cov0" title="0">{
                        c.OwnerID = &amp;u.ID
                }</span>
        }

        <span class="cov0" title="0">return s.db.WithContext(ctx).Create(c).Error</span>
}

func (s Service) Authorize(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        if c.Status != StatusAwaitingAuthorization </span><span class="cov0" title="0">{
                return errorutil.New("consent is not in the awaiting authorization status")
        }</span>

        <span class="cov0" title="0">return s.updateStatus(ctx, c, StatusAuthorized)</span>
}

func (s Service) Consent(ctx context.Context, id, orgID string) (*Consent, error) <span class="cov0" title="0">{
        id = strings.TrimPrefix(id, URNPrefix)
        c := &amp;Consent{}
        if err := s.db.WithContext(ctx).Where("id = ? AND org_id = ?", id, orgID).First(c).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if ctx.Value(api.CtxKeyClientID) != nil &amp;&amp; ctx.Value(api.CtxKeyClientID) != c.ClientID </span><span class="cov0" title="0">{
                return nil, ErrAccessNotAllowed
        }</span>

        <span class="cov0" title="0">return c, s.runPostCreationAutomations(ctx, c)</span>
}

func (s Service) Consents(ctx context.Context, ownerID uuid.UUID, orgID string, pag page.Pagination) (page.Page[*Consent], error) <span class="cov0" title="0">{
        query := s.db.WithContext(ctx).Model(&amp;Consent{}).Where("owner_id = ? AND org_id = ?", ownerID, orgID)

        var consents []*Consent
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;consents).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Consent]{}, err
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Consent]{}, err
        }</span>

        <span class="cov0" title="0">for _, c := range consents </span><span class="cov0" title="0">{
                if err := s.runPostCreationAutomations(ctx, c); err != nil </span><span class="cov0" title="0">{
                        return page.Page[*Consent]{}, err
                }</span>
        }

        <span class="cov0" title="0">return page.New(consents, pag, int(total)), nil</span>
}

func (s Service) Reject(ctx context.Context, id, orgID string, by RejectedBy, reason RejectionReason) error <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.reject(ctx, c, by, reason)</span>
}

func (s Service) Delete(ctx context.Context, id, orgID string) error <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rejectedBy := RejectedByUser
        rejectionReason := RejectionReasonCustomerManuallyRejected
        if c.Status == StatusAuthorized </span><span class="cov0" title="0">{
                rejectionReason = RejectionReasonCustomerManuallyRevoked
        }</span>

        <span class="cov0" title="0">return s.Reject(ctx, id, orgID, rejectedBy, rejectionReason)</span>
}

func (s Service) runPostCreationAutomations(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        switch c.Status </span>{
        case StatusAwaitingAuthorization:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(c.CreatedAt.Add(3600 * time.Second).Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "consent awaiting authorization for too long, moving to rejected")
                        return s.reject(ctx, c, RejectedByUser, RejectionReasonConsentExpired)
                }</span>
        case StatusAuthorized:<span class="cov0" title="0">
                if c.ExpiresAt != nil &amp;&amp; timeutil.DateTimeNow().After(c.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "consent reached expiration, moving to rejected")
                        return s.reject(ctx, c, RejectedByASPSP, RejectionReasonConsentMaxDateReached)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) Extend(ctx context.Context, id, orgID string, ext *Extension) (*Consent, error) <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := validateExtension(c, ext); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.ExpiresAt = ext.ExpiresAt
        if err := s.update(ctx, c); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ext.PreviousExpiresAt = c.ExpiresAt
        return c, s.db.WithContext(ctx).Create(ext).Error</span>
}

func (s Service) Extensions(ctx context.Context, consentURN, orgID string, pag page.Pagination) (page.Page[*Extension], error) <span class="cov0" title="0">{
        consentID := strings.TrimPrefix(consentURN, URNPrefix)
        query := s.db.WithContext(ctx).Model(&amp;Extension{}).Where("consent_id = ? AND org_id = ?", consentID, orgID)

        var extensions []*Extension
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;extensions).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Extension]{}, err
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Extension]{}, err
        }</span>

        <span class="cov0" title="0">return page.New(extensions, pag, int(total)), nil</span>
}

func (s Service) validate(_ context.Context, c *Consent) error <span class="cov0" title="0">{
        if err := validatePermissions(c.Permissions); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">now := timeutil.DateTimeNow()
        if c.ExpiresAt != nil &amp;&amp; (c.ExpiresAt.After(now.AddDate(1, 0, 0)) || c.ExpiresAt.Before(now)) </span><span class="cov0" title="0">{
                return ErrInvalidExpiration
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) reject(ctx context.Context, c *Consent, by RejectedBy, reason RejectionReason) error <span class="cov0" title="0">{
        if c.Status == StatusRejected </span><span class="cov0" title="0">{
                return ErrAlreadyRejected
        }</span>

        <span class="cov0" title="0">c.Rejection = &amp;Rejection{
                By:     by,
                Reason: reason,
        }
        return s.updateStatus(ctx, c, StatusRejected)</span>
}

func (s Service) updateStatus(ctx context.Context, c *Consent, status Status) error <span class="cov0" title="0">{
        c.Status = status
        c.StatusUpdatedAt = timeutil.DateTimeNow()
        return s.update(ctx, c)
}</span>

func (s Service) update(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        c.UpdatedAt = timeutil.DateTimeNow()
        return s.db.WithContext(ctx).
                Model(&amp;Consent{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", c.ID, c.OrgID).
                Updates(c).Error
}</span>
</pre>

		<pre class="file" id="file33" style="display: none">package consent

import (
        "reflect"
        "slices"
        "strings"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

func URN(id uuid.UUID) string <span class="cov0" title="0">{
        return URNPrefix + id.String()
}</span>

func IDFromScopes(scopes string) (string, bool) <span class="cov0" title="0">{
        for _, s := range strings.Split(scopes, " ") </span><span class="cov0" title="0">{
                if ScopeID.Matches(s) </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(s, "consent:"+URNPrefix), true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func validatePermissions(requestedPermissions []Permission) error <span class="cov0" title="0">{

permissionsLoop:
        // Make sure if a permission is requested, at least one group of permissions
        // containing it is requested as well.
        for _, requestedPermission := range requestedPermissions </span><span class="cov0" title="0">{
                for _, group := range PermissionGroups </span><span class="cov0" title="0">{

                        if slices.Contains(group, requestedPermission) &amp;&amp; containsAll(requestedPermissions, group...) </span><span class="cov0" title="0">{
                                continue permissionsLoop</span>
                        }

                }

                // Return an error if there is no group that contains requestedPermission
                // and is fully present in requestedPermissions.
                <span class="cov0" title="0">return ErrInvalidPermissionGroup</span>
        }

        <span class="cov0" title="0">return validatePersonalAndBusinessPermissions(requestedPermissions)</span>
}

func validatePersonalAndBusinessPermissions(requestedPermissions []Permission) error <span class="cov0" title="0">{
        isPersonal := containsAny(requestedPermissions,
                PermissionCustomersPersonalIdentificationsRead,
                PermissionCustomersPersonalAdittionalInfoRead,
        )
        isBusiness := containsAny(requestedPermissions,
                PermissionCustomersBusinessIdentificationsRead,
                PermissionCustomersBusinessAdittionalInfoRead,
        )

        if isPersonal &amp;&amp; isBusiness </span><span class="cov0" title="0">{
                return ErrPersonalAndBusinessPermissionsTogether
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func validateExtension(c *Consent, ext *Extension) error <span class="cov0" title="0">{
        if c.Status != StatusAuthorized </span><span class="cov0" title="0">{
                return ErrCannotExtendConsentNotAuthorized
        }</span>

        <span class="cov0" title="0">if c.UserIdentification != ext.UserCPF </span><span class="cov0" title="0">{
                return ErrExtensionNotAllowed
        }</span>

        <span class="cov0" title="0">if c.BusinessIdentification != nil &amp;&amp; reflect.DeepEqual(c.BusinessIdentification, ext.BusinessCNPJ) </span><span class="cov0" title="0">{
                return ErrExtensionNotAllowed
        }</span>

        <span class="cov0" title="0">if ext.ExpiresAt == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">now := timeutil.DateTimeNow()
        if ext.ExpiresAt.Before(now) || ext.ExpiresAt.After(now.AddDate(1, 0, 0)) </span><span class="cov0" title="0">{
                return ErrInvalidExpiration
        }</span>

        <span class="cov0" title="0">if c.ExpiresAt != nil &amp;&amp; !ext.ExpiresAt.After(c.ExpiresAt.Time) </span><span class="cov0" title="0">{
                return ErrInvalidExpiration
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func containsAll[T comparable](superSet []T, subSet ...T) bool <span class="cov0" title="0">{
        for _, t := range subSet </span><span class="cov0" title="0">{
                if !slices.Contains(superSet, t) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func containsAny[T comparable](slice1 []T, slice2 ...T) bool <span class="cov0" title="0">{
        for _, t := range slice2 </span><span class="cov0" title="0">{
                if slices.Contains(slice1, t) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}
</pre>

		<pre class="file" id="file34" style="display: none">package directory

import (
        "context"
        "crypto"
        "crypto/rand"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/go-jose/go-jose/v4"
        "github.com/go-jose/go-jose/v4/jwt"
        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/jwtutil"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var (
        cacheTime = 1 * time.Hour

        directoryWellKnownMu            sync.Mutex
        directoryWellKnownCache         *directoryWellKnown
        directoryWellKnownLastFetchedAt timeutil.DateTime

        directoryJWKSMu            sync.Mutex
        directoryJWKSCache         *goidc.JSONWebKeySet
        directoryJWKSLastFetchedAt timeutil.DateTime
)

type Service struct {
        issuer      string
        clientID    string
        redirectURI string
        jwtSigner   crypto.Signer
        mtlsClient  *http.Client
}

func NewService(issuer, clientID, redirectURI string, jwtSigner crypto.Signer, mtlsClient *http.Client) Service <span class="cov0" title="0">{
        return Service{
                issuer:      issuer,
                clientID:    clientID,
                redirectURI: redirectURI,
                jwtSigner:   jwtSigner,
                mtlsClient:  mtlsClient,
        }
}</span>

func (ds Service) AuthURL(ctx context.Context) (uri, codeVerifier string, err error) <span class="cov0" title="0">{
        codeVerifier, codeChallenge := generateCodeVerifierAndChallenge()
        reqURI, err := ds.requestURI(ctx, codeChallenge)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">wellKnown, err := ds.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">authURL, _ := url.Parse(wellKnown.AuthEndpoint)
        query := authURL.Query()
        query.Set("client_id", ds.clientID)
        query.Set("request_uri", reqURI)
        query.Set("response_type", "code")
        query.Set("scope", "openid trust_framework_profile")
        query.Set("redirect_uri", ds.redirectURI)
        authURL.RawQuery = query.Encode()
        return authURL.String(), codeVerifier, nil</span>
}

func (s Service) IDToken(ctx context.Context, authCode, codeVerifier string) (IDToken, error) <span class="cov0" title="0">{
        idTkn, err := s.idToken(ctx, authCode, codeVerifier)
        if err != nil </span><span class="cov0" title="0">{
                return IDToken{}, err
        }</span>

        <span class="cov0" title="0">wellKnown, err := s.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return IDToken{}, fmt.Errorf("failed to fetch the directory well known for decoding id token: %w", err)
        }</span>

        <span class="cov0" title="0">parsedIDTkn, err := jwt.ParseSigned(idTkn, wellKnown.IDTokenSigAlgs)
        if err != nil </span><span class="cov0" title="0">{
                return IDToken{}, fmt.Errorf("failed to parse id token: %w", err)
        }</span>

        <span class="cov0" title="0">jwks, err := s.jwks()
        if err != nil </span><span class="cov0" title="0">{
                return IDToken{}, fmt.Errorf("failed to fetch jwks for verifying id token: %w", err)
        }</span>

        <span class="cov0" title="0">var idToken IDToken
        var idTokenClaims jwt.Claims
        if err := parsedIDTkn.Claims(jwks.ToJOSE(), &amp;idToken, &amp;idTokenClaims); err != nil </span><span class="cov0" title="0">{
                return IDToken{}, fmt.Errorf("invalid id token signature: %w", err)
        }</span>

        <span class="cov0" title="0">if idTokenClaims.IssuedAt == nil </span><span class="cov0" title="0">{
                return IDToken{}, errors.New("id token iat claim is missing")
        }</span>

        <span class="cov0" title="0">if idTokenClaims.Expiry == nil </span><span class="cov0" title="0">{
                return IDToken{}, errors.New("id token exp claim is missing")
        }</span>

        <span class="cov0" title="0">if err := idTokenClaims.Validate(jwt.Expected{
                Issuer:      s.issuer,
                AnyAudience: []string{s.clientID},
        }); err != nil </span><span class="cov0" title="0">{
                return IDToken{}, fmt.Errorf("invalid id token claims: %w", err)
        }</span>

        <span class="cov0" title="0">return idToken, nil</span>
}

func (s Service) idToken(ctx context.Context, authCode, codeVerifier string) (string, error) <span class="cov0" title="0">{
        wellKnown, err := s.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to fetch the directory well known for requesting an id token: %w", err)
        }</span>

        <span class="cov0" title="0">assertion, err := s.clientAssertion()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">form := url.Values{}
        form.Set("client_id", s.clientID)
        form.Set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer")
        form.Set("client_assertion", assertion)
        form.Set("grant_type", "authorization_code")
        form.Set("code", authCode)
        form.Set("redirect_uri", s.redirectURI)
        form.Set("code_verifier", codeVerifier)

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, wellKnown.MTLS.TokenEndpoint, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating token request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := s.mtlsClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("token request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                bodyBytes, _ := io.ReadAll(resp.Body)
                slog.Debug("error calling the token endpoint", "status_code", resp.StatusCode, "body", string(bodyBytes))
                return "", fmt.Errorf("token endpoint returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result struct {
                IDToken string `json:"id_token"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error decoding token response: %w", err)
        }</span>

        <span class="cov0" title="0">return result.IDToken, nil</span>
}

func (ds Service) requestURI(ctx context.Context, codeChallenge string) (string, error) <span class="cov0" title="0">{
        wellKnown, err := ds.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">assertion, err := ds.clientAssertion()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">form := url.Values{}
        form.Set("client_id", ds.clientID)
        form.Set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer")
        form.Set("client_assertion", assertion)
        form.Set("response_type", "code")
        form.Set("scope", "openid trust_framework_profile")
        form.Set("redirect_uri", ds.redirectURI)
        form.Set("code_challenge", codeChallenge)
        form.Set("code_challenge_method", "S256")

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, wellKnown.MTLS.PushedAuthEndpoint, strings.NewReader(form.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error creating par request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := ds.mtlsClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("par request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return "", fmt.Errorf("par endpoint returned status %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var result struct {
                RequestURI string `json:"request_uri"`
                ExpiresIn  int    `json:"expires_in"`
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error decoding par response: %w", err)
        }</span>

        <span class="cov0" title="0">return result.RequestURI, nil</span>
}

func (s Service) clientAssertion() (string, error) <span class="cov0" title="0">{
        wellKnown, err := s.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">now := timeutil.Timestamp()
        claims := map[string]any{
                "iss": s.clientID,
                "sub": s.clientID,
                "aud": wellKnown.TokenEndpoint,
                "jti": uuid.NewString(),
                "iat": now,
                "exp": now + 300,
        }

        assertion, err := jwtutil.Sign(claims, s.jwtSigner)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not sign the client assertion: %w", err)
        }</span>

        <span class="cov0" title="0">return assertion, nil</span>
}

func (ds Service) wellKnown() (directoryWellKnown, error) <span class="cov0" title="0">{

        directoryWellKnownMu.Lock()
        defer directoryWellKnownMu.Unlock()

        if directoryWellKnownCache != nil &amp;&amp; timeutil.DateTimeNow().Before(directoryWellKnownLastFetchedAt.Add(cacheTime)) </span><span class="cov0" title="0">{
                return *directoryWellKnownCache, nil
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/.well-known/openid-configuration", ds.issuer)
        resp, err := ds.mtlsClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return directoryWellKnown{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return directoryWellKnown{}, fmt.Errorf("directory well known unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var config directoryWellKnown
        if err := json.NewDecoder(resp.Body).Decode(&amp;config); err != nil </span><span class="cov0" title="0">{
                return directoryWellKnown{}, fmt.Errorf("failed to decode directory well known response: %w", err)
        }</span>

        <span class="cov0" title="0">directoryWellKnownCache = &amp;config
        directoryWellKnownLastFetchedAt = timeutil.DateTimeNow()
        return config, nil</span>
}

func (ds Service) jwks() (goidc.JSONWebKeySet, error) <span class="cov0" title="0">{

        directoryJWKSMu.Lock()
        defer directoryJWKSMu.Unlock()

        if directoryJWKSCache != nil &amp;&amp; timeutil.DateTimeNow().Before(directoryJWKSLastFetchedAt.Add(cacheTime)) </span><span class="cov0" title="0">{
                return *directoryJWKSCache, nil
        }</span>

        <span class="cov0" title="0">wellKnown, err := ds.wellKnown()
        if err != nil </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, err
        }</span>

        <span class="cov0" title="0">resp, err := ds.mtlsClient.Get(wellKnown.JWKSURI)
        if err != nil </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, fmt.Errorf("directory jwks unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var jwks goidc.JSONWebKeySet
        if err := json.NewDecoder(resp.Body).Decode(&amp;jwks); err != nil </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, fmt.Errorf("failed to decode directory jwks response: %w", err)
        }</span>

        <span class="cov0" title="0">directoryJWKSCache = &amp;jwks
        directoryJWKSLastFetchedAt = timeutil.DateTimeNow()
        return jwks, nil</span>
}

func (ds Service) PublicJWKS() jose.JSONWebKeySet <span class="cov0" title="0">{
        return jose.JSONWebKeySet{
                Keys: []jose.JSONWebKey{{
                        KeyID:     "signer",
                        Algorithm: string(jose.PS256),
                        Key:       ds.jwtSigner.Public(),
                }},
        }
}</span>

func generateCodeVerifierAndChallenge() (verifier, challenge string) <span class="cov0" title="0">{
        b := make([]byte, 32)
        if _, err := rand.Read(b); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">verifier = base64.RawURLEncoding.EncodeToString(b)
        hash := sha256.Sum256([]byte(verifier))
        challenge = base64.RawURLEncoding.EncodeToString(hash[:])
        return verifier, challenge</span>
}
</pre>

		<pre class="file" id="file35" style="display: none">package enrollment

import (
        "strings"
        "time"

        "github.com/go-webauthn/webauthn/protocol"
        "github.com/go-webauthn/webauthn/protocol/webauthncose"
        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/client"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
)

const (
        CredentialRegistrationTimeout = 300 * time.Second
        URNPrefix                     = "urn:mockbank:enrollment:"
        defaultDailyLimit             = "500.00"
        defaultTransactionLimit       = "100.00"
)

var (
        ScopeID = goidc.NewDynamicScope("enrollment", func(s string) bool <span class="cov0" title="0">{
                return strings.HasPrefix(s, "enrollment:")
        }</span>)
        ScopeConsent = goidc.NewScope("nrp-consents")
)

var PublicKeyCredentialParameters = []protocol.CredentialParameter{
        {Type: protocol.PublicKeyCredentialType, Algorithm: webauthncose.AlgRS256},
        {Type: protocol.PublicKeyCredentialType, Algorithm: webauthncose.AlgPS256},
        {Type: protocol.PublicKeyCredentialType, Algorithm: webauthncose.AlgES256},
}

type Enrollment struct {
        ID                     uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Status                 Status
        StatusUpdatedAt        timeutil.DateTime
        Permissions            []Permission `gorm:"serializer:json"`
        ExpiresAt              *timeutil.DateTime
        UserIdentification     string
        UserRel                consent.Relation
        BusinessIdentification *string
        BusinessRel            *consent.Relation
        OwnerID                uuid.UUID
        Owner                  *user.User
        DebtorAccountID        *uuid.UUID `gorm:"column:account_id"`
        DebtorAccount          *account.Account
        Name                   *string
        TransactionLimit       *string
        DailyLimit             *string
        RiskSignals            *map[string]any `gorm:"serializer:json"`
        Cancellation           *Cancellation   `gorm:"serializer:json"`
        ClientID               string
        Client                 *client.Client
        RelyingParty           string
        Challenge              *string
        PublicKey              *string

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Enrollment) TableName() string <span class="cov0" title="0">{
        return "enrollments"
}</span>

func (e Enrollment) URN() string <span class="cov0" title="0">{
        return URN(e.ID)
}</span>

type Status string

const (
        StatusAwaitingRiskSignals             Status = "AWAITING_RISK_SIGNALS"
        StatusAwaitingAccountHolderValidation Status = "AWAITING_ACCOUNT_HOLDER_VALIDATION"
        StatusAwaitingEnrollment              Status = "AWAITING_ENROLLMENT"
        StatusAuthorized                      Status = "AUTHORISED"
        StatusRevoked                         Status = "REVOKED"
        StatusRejected                        Status = "REJECTED"
)

type Permission string

const (
        PermissionPaymentsInitiate Permission = "PAYMENTS_INITIATE"
)

type Cancellation struct {
        RejectionReason  *RejectionReason      `json:"rejection_reason,omitempty"`
        RevocationReason *RevocationReason     `json:"revocation_reason,omitempty"`
        From             payment.CancelledFrom `json:"cancellation_from"`
        At               *timeutil.DateTime    `json:"cancelled_at,omitempty"`
        By               *string               `json:"cancelled_by,omitempty"`
        AdditionalInfo   *string               `json:"additional_info,omitempty"`
}

type RejectionReason string

const (
        RejectionReasonAwaitingRiskSignals             RejectionReason = "REJEITADO_TEMPO_EXPIRADO_RISK_SIGNALS"
        RejectionReasonAwaitingAccountHolderValidation RejectionReason = "REJEITADO_TEMPO_EXPIRADO_ACCOUNT_HOLDER_VALIDATION"
        RejectionReasonAwaitingEnrollment              RejectionReason = "REJEITADO_TEMPO_EXPIRADO_ENROLLMENT"
        RejectionReasonMaxChallengesReached            RejectionReason = "REJEITADO_MAXIMO_CHALLENGES_ATINGIDO"
        RejectionReasonManualRejection                 RejectionReason = "REJEITADO_MANUALMENTE"
        RejectionReasonDeviceIncompatible              RejectionReason = "REJEITADO_DISPOSITIVO_INCOMPATIVEL"
        RejectionReasonInfrastructureFailure           RejectionReason = "REJEITADO_FALHA_INFRAESTRUTURA"
        RejectionReasonHybridFlowFailure               RejectionReason = "REJEITADO_FALHA_HYBRID_FLOW"
        RejectionReasonFidoFailure                     RejectionReason = "REJEITADO_FALHA_FIDO"
        RejectionReasonInternalSecurityFailure         RejectionReason = "REJEITADO_SEGURANCA_INTERNA"
        RejectionReasonOther                           RejectionReason = "REJEITADO_OUTRO"
)

type RevocationReason string

const (
        RevocationReasonManualRevocation        RevocationReason = "REVOGADO_MANUALMENTE"
        RevocationReasonExpiredRevocation       RevocationReason = "REVOGADO_VALIDADE_EXPIRADA"
        RevocationReasonInfrastructureFailure   RevocationReason = "REVOGADO_FALHA_INFRAESTRUTURA"
        RevocationReasonInternalSecurityFailure RevocationReason = "REVOGADO_SEGURANCA_INTERNA"
        RevocationReasonOther                   RevocationReason = "REVOGADO_OUTRO"
)

type Query struct {
        ID                string
        LoadDebtorAccount bool
        LoadOwner         bool
        LoadClient        bool
}

type FIDOOptions struct {
        RelyingParty string
}

type Platform string

const (
        PlatformAndroid       Platform = "ANDROID"
        PlatformIOS           Platform = "IOS"
        PlatformBrowser       Platform = "BROWSER"
        PlatformCrossPlatform Platform = "CROSS_PLATFORM"
)

type Credential struct {
        ID       string `json:"id"`
        RawID    string `json:"rawId"`
        Type     string `json:"type"`
        Response struct {
                ClientDataJSON    string `json:"clientDataJSON,omitempty"`
                AttestationObject string `json:"attestationObject,omitempty"`
        } `json:"response,omitempty"`
}

type FIDOAssertion struct {
        ID       string `json:"id"`
        RawID    string `json:"rawId"`
        Type     string `json:"type"`
        Response struct {
                ClientDataJSON    string `json:"clientDataJSON,omitempty"`
                AuthenticatorData string `json:"authenticatorData,omitempty"`
                Signature         string `json:"signature,omitempty"`
                UserHandle        string `json:"userHandle,omitempty"`
        } `json:"response,omitempty"`
}
</pre>

		<pre class="file" id="file36" style="display: none">package enrollment

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "slices"
        "strings"
        "time"

        "github.com/go-webauthn/webauthn/protocol"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "github.com/luikyv/mock-bank/internal/webhook"
        "gorm.io/gorm"
)

type Service struct {
        db                 *gorm.DB
        userService        user.Service
        accountService     account.Service
        paymentService     payment.Service
        autopaymentService autopayment.Service
        webhookService     webhook.Service
        version            string
}

func NewService(
        db *gorm.DB,
        userService user.Service,
        accountService account.Service,
        paymentService payment.Service,
        autopaymentService autopayment.Service,
        webhookService webhook.Service,
) Service <span class="cov0" title="0">{
        return Service{
                db:                 db,
                userService:        userService,
                accountService:     accountService,
                paymentService:     paymentService,
                autopaymentService: autopaymentService,
                webhookService:     webhookService,
                version:            "v0",
        }
}</span>

func (s Service) WithVersion(version string) Service <span class="cov0" title="0">{
        s.version = version
        return s
}</span>

func (s Service) Create(ctx context.Context, e *Enrollment, debtorAcc *payment.Account) error <span class="cov0" title="0">{
        e.Status = StatusAwaitingRiskSignals
        now := timeutil.DateTimeNow()
        e.StatusUpdatedAt = now
        e.CreatedAt = now
        e.UpdatedAt = now

        if err := s.validate(ctx, e, debtorAcc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u, err := s.userService.User(ctx, user.Query{CPF: e.UserIdentification}, e.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">e.OwnerID = u.ID

        if e.BusinessIdentification != nil </span><span class="cov0" title="0">{
                business, err := s.userService.User(ctx, user.Query{CNPJ: *e.BusinessIdentification}, e.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">e.OwnerID = business.ID</span>
        }

        <span class="cov0" title="0">if debtorAcc == nil </span><span class="cov0" title="0">{
                return s.db.WithContext(ctx).Create(e).Error
        }</span>

        <span class="cov0" title="0">acc, err := s.accountService.Account(ctx, account.Query{Number: debtorAcc.Number}, e.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if acc.OwnerID != e.OwnerID </span><span class="cov0" title="0">{
                return ErrUserDoesntMatchAccount
        }</span>

        <span class="cov0" title="0">e.DebtorAccountID = &amp;acc.ID
        return s.db.WithContext(ctx).Create(e).Error</span>
}

func (s Service) AddRiskSignals(ctx context.Context, id, orgID string, riskSignals map[string]any) error <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: id}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if e.Status != StatusAwaitingRiskSignals </span><span class="cov0" title="0">{
                return errorutil.New("enrollment is not in awaiting risk signals status")
        }</span>

        <span class="cov0" title="0">e.RiskSignals = &amp;riskSignals
        return s.updateStatus(ctx, e, StatusAwaitingAccountHolderValidation)</span>
}

func (s Service) AllowEnrollment(ctx context.Context, e *Enrollment) error <span class="cov0" title="0">{
        if e.Status != StatusAwaitingAccountHolderValidation </span><span class="cov0" title="0">{
                return errorutil.New("enrollment is not in awaiting account holder validation status")
        }</span>

        <span class="cov0" title="0">if e.DailyLimit == nil </span><span class="cov0" title="0">{
                dailyLimit := defaultDailyLimit
                e.DailyLimit = &amp;dailyLimit
        }</span>

        <span class="cov0" title="0">if e.TransactionLimit == nil </span><span class="cov0" title="0">{
                transactionLimit := defaultTransactionLimit
                e.TransactionLimit = &amp;transactionLimit
        }</span>

        <span class="cov0" title="0">return s.updateStatus(ctx, e, StatusAwaitingEnrollment)</span>
}

func (s Service) InitRegistration(ctx context.Context, id, orgID string, opts FIDOOptions) (*Enrollment, error) <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: id, LoadOwner: true, LoadClient: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if e.Status != StatusAwaitingEnrollment </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: enrollment is not in awaiting enrollment status", ErrInvalidStatus)
        }</span>

        <span class="cov0" title="0">if opts.RelyingParty != e.RelyingParty </span><span class="cov0" title="0">{
                reason := RejectionReasonFidoFailure
                _ = s.Cancel(ctx, e, Cancellation{From: payment.CancelledFromHolder, RejectionReason: &amp;reason})
                return nil, errorutil.Format("%w: relying party mismatch", ErrInvalidRelyingParty)
        }</span>

        <span class="cov0" title="0">challenge := generateChallenge()
        e.Challenge = &amp;challenge
        return e, s.update(ctx, e)</span>
}

func (s Service) RegisterCredential(ctx context.Context, id, orgID string, credential Credential) error <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: id, LoadClient: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if e.Status != StatusAwaitingEnrollment </span><span class="cov0" title="0">{
                return errorutil.New("enrollment is not in awaiting enrollment status")
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(credential)
        if err != nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: invalid credential: %w", ErrInvalidPublicKey, err)
        }</span>

        <span class="cov0" title="0">parsed, err := protocol.ParseCredentialCreationResponseBody(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                reason := RejectionReasonFidoFailure
                _ = s.Cancel(ctx, e, Cancellation{From: payment.CancelledFromHolder, RejectionReason: &amp;reason})
                return errorutil.Format("%w: invalid credential: %w", ErrInvalidPublicKey, err)
        }</span>

        <span class="cov0" title="0">if !slices.Contains(e.Client.OriginURIs, parsed.Response.CollectedClientData.Origin) </span><span class="cov0" title="0">{
                reason := RejectionReasonFidoFailure
                _ = s.Cancel(ctx, e, Cancellation{From: payment.CancelledFromHolder, RejectionReason: &amp;reason})
                return errorutil.Format("%w: invalid credential: %w", ErrInvalidOrigin, err)
        }</span>

        <span class="cov0" title="0">_, err = parsed.Verify(*e.Challenge, true, e.RelyingParty, e.Client.OriginURIs, nil,
                protocol.TopOriginIgnoreVerificationMode, nil, PublicKeyCredentialParameters)
        if err != nil </span><span class="cov0" title="0">{
                reason := RejectionReasonFidoFailure
                _ = s.Cancel(ctx, e, Cancellation{From: payment.CancelledFromHolder, RejectionReason: &amp;reason})
                return errorutil.Format("%w: invalid credential: %w", ErrInvalidPublicKey, err)
        }</span>

        <span class="cov0" title="0">publicKey := base64.RawStdEncoding.EncodeToString(parsed.Response.AttestationObject.AuthData.AttData.CredentialPublicKey)
        e.PublicKey = &amp;publicKey
        e.Challenge = nil
        return s.updateStatus(ctx, e, StatusAuthorized)</span>
}

func (s Service) InitAuthorization(
        ctx context.Context,
        consentID, enrollmentID, orgID string,
        opts FIDOOptions,
) (string, error) <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: enrollmentID, LoadClient: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if e.Status != StatusAuthorized </span><span class="cov0" title="0">{
                return "", errorutil.Format("%w: enrollment is not in authorized status", ErrInvalidStatus)
        }</span>

        <span class="cov0" title="0">if opts.RelyingParty != e.RelyingParty </span><span class="cov0" title="0">{
                return "", errorutil.Format("%w: relying party mismatch", ErrInvalidRelyingParty)
        }</span>

        <span class="cov0" title="0">var enrollConsent func(ctx context.Context, consentID, orgID string, opts payment.EnrollmentOptions) error
        if strings.HasPrefix(consentID, payment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                enrollConsent = s.paymentService.EnrollConsent
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(consentID, autopayment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                enrollConsent = s.autopaymentService.EnrollConsent
        }</span> else<span class="cov0" title="0"> {
                return "", errorutil.New("invalid consent id")
        }</span>

        <span class="cov0" title="0">challenge := generateChallenge()
        enrollmentOpts := payment.EnrollmentOptions{
                EnrollmentID:           e.ID,
                DebtorAccountID:        e.DebtorAccountID,
                UserIdentification:     e.UserIdentification,
                BusinessIdentification: e.BusinessIdentification,
                Challenge:              challenge,
        }
        if e.TransactionLimit != nil </span><span class="cov0" title="0">{
                enrollmentOpts.TransactionLimit = *e.TransactionLimit
        }</span>
        <span class="cov0" title="0">if e.DailyLimit != nil </span><span class="cov0" title="0">{
                enrollmentOpts.DailyLimit = *e.DailyLimit
        }</span>

        <span class="cov0" title="0">return challenge, enrollConsent(ctx, consentID, orgID, enrollmentOpts)</span>
}

func (s Service) AuthorizeConsent(ctx context.Context, consentID, id, orgID string, assertion FIDOAssertion) error <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: id, LoadClient: true}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if e.Status != StatusAuthorized </span><span class="cov0" title="0">{
                _ = s.rejectConsent(ctx, consentID, orgID, "enrollment is not in authorized status")
                return errorutil.Format("%w: enrollment is not in authorized status", ErrInvalidStatus)
        }</span>

        <span class="cov0" title="0">data, err := json.Marshal(assertion)
        if err != nil </span><span class="cov0" title="0">{
                return errorutil.New("invalid assertion")
        }</span>

        <span class="cov0" title="0">parsed, err := protocol.ParseCredentialRequestResponseBody(bytes.NewReader(data))
        if err != nil </span><span class="cov0" title="0">{
                return errorutil.New("invalid assertion")
        }</span>

        <span class="cov0" title="0">publicKey, _ := base64.RawStdEncoding.DecodeString(*e.PublicKey)
        var verify = func(challenge *string) error </span><span class="cov0" title="0">{
                if challenge == nil </span><span class="cov0" title="0">{
                        return errorutil.New("challenge was not initialized")
                }</span>

                <span class="cov0" title="0">if err := parsed.Verify(*challenge, e.RelyingParty, e.Client.OriginURIs, nil,
                        protocol.TopOriginIgnoreVerificationMode, "", true, publicKey); err != nil </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: %w", ErrInvalidAssertion, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">if strings.HasPrefix(consentID, payment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                c, err := s.paymentService.Consent(ctx, consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := verify(c.EnrollmentChallenge); err != nil </span><span class="cov0" title="0">{
                        _ = s.rejectConsent(ctx, consentID, orgID, "error verifying enrollment challenge")
                        return err
                }</span>
                <span class="cov0" title="0">return s.paymentService.AuthorizeConsent(ctx, c)</span>
        }
        <span class="cov0" title="0">if strings.HasPrefix(consentID, autopayment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                c, err := s.autopaymentService.Consent(ctx, consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := verify(c.EnrollmentChallenge); err != nil </span><span class="cov0" title="0">{
                        _ = s.rejectConsent(ctx, consentID, orgID, "error verifying enrollment challenge")
                        return err
                }</span>
                <span class="cov0" title="0">return s.autopaymentService.AuthorizeConsent(ctx, c)</span>
        }

        <span class="cov0" title="0">return errorutil.New("invalid consent ID")</span>
}

func (s Service) rejectConsent(ctx context.Context, id, orgID, detail string) error <span class="cov0" title="0">{
        if strings.HasPrefix(id, payment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                _, err := s.paymentService.RejectConsentByID(ctx, id, orgID, payment.ConsentRejectionNotProvided, detail)
                return err
        }</span>
        <span class="cov0" title="0">if strings.HasPrefix(id, autopayment.ConsentURNPrefix) </span><span class="cov0" title="0">{
                _, err := s.autopaymentService.RejectConsentByID(ctx, id, orgID, autopayment.ConsentRejection{
                        By:     autopayment.TerminatedByHolder,
                        From:   autopayment.TerminatedFromHolder,
                        Code:   autopayment.ConsentRejectionNotProvided,
                        Detail: detail,
                })
                return err
        }</span>
        <span class="cov0" title="0">return errorutil.New("invalid consent ID")</span>
}

func (s Service) Enrollment(ctx context.Context, query Query, orgID string) (*Enrollment, error) <span class="cov0" title="0">{
        dbQuery := s.db.WithContext(ctx).Where("org_id = ?", orgID)
        if query.ID != "" </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Where("id = ?", strings.TrimPrefix(query.ID, URNPrefix))
        }</span>
        <span class="cov0" title="0">if query.LoadDebtorAccount </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Preload("DebtorAccount")
        }</span>
        <span class="cov0" title="0">if query.LoadOwner </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Preload("Owner")
        }</span>
        <span class="cov0" title="0">if query.LoadClient </span><span class="cov0" title="0">{
                dbQuery = dbQuery.Preload("Client")
        }</span>

        <span class="cov0" title="0">e := &amp;Enrollment{}
        if err := dbQuery.First(e).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if clientID := ctx.Value(api.CtxKeyClientID); clientID != nil &amp;&amp; clientID != e.ClientID </span><span class="cov0" title="0">{
                return nil, ErrClientNotAllowed
        }</span>

        <span class="cov0" title="0">return e, s.runPostCreationAutomations(ctx, e)</span>
}

func (s Service) CancelByID(ctx context.Context, id, orgID string, cancellation Cancellation) error <span class="cov0" title="0">{
        e, err := s.Enrollment(ctx, Query{ID: id}, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.Cancel(ctx, e, cancellation)</span>
}

func (s Service) Cancel(ctx context.Context, e *Enrollment, cancellation Cancellation) error <span class="cov0" title="0">{
        if e.Status == StatusRejected || e.Status == StatusRevoked </span><span class="cov0" title="0">{
                return errorutil.New("enrollment is already cancelled")
        }</span>

        <span class="cov0" title="0">status := StatusRejected
        if cancellation.RevocationReason != nil </span><span class="cov0" title="0">{
                status = StatusRevoked
        }</span>

        <span class="cov0" title="0">if cancellation.From == payment.CancelledFromHolder </span><span class="cov0" title="0">{
                now := timeutil.DateTimeNow()
                cancellation.At = &amp;now
        }</span>

        <span class="cov0" title="0">e.Cancellation = &amp;cancellation
        return s.updateStatus(ctx, e, status)</span>
}

func (s Service) validate(_ context.Context, e *Enrollment, debtorAccount *payment.Account) error <span class="cov0" title="0">{
        for _, p := range e.Permissions </span><span class="cov0" title="0">{
                if p != PermissionPaymentsInitiate </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: permission %s is not allowed", ErrInvalidPermissions, p)
                }</span>
        }

        <span class="cov0" title="0">if e.RelyingParty == "" </span><span class="cov0" title="0">{
                return errorutil.Format("%w: relying party is required", ErrMissingValue)
        }</span>

        <span class="cov0" title="0">if e.UserRel != consent.RelationCPF </span><span class="cov0" title="0">{
                return errorutil.Format("%w: only CPF is allowed for logged user document relation", ErrInvalidData)
        }</span>

        <span class="cov0" title="0">if e.BusinessRel != nil &amp;&amp; *e.BusinessRel != consent.RelationCNPJ </span><span class="cov0" title="0">{
                return errorutil.Format("%w: only CNPJ is allowed for business document relation", ErrInvalidData)
        }</span>

        <span class="cov0" title="0">if debtorAccount != nil &amp;&amp; slices.Contains([]payment.AccountType{
                payment.AccountTypeCACC,
                payment.AccountTypeSVGS,
        }, debtorAccount.Type) &amp;&amp; debtorAccount.Issuer == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: debtor account issuer is required for account types CACC or SVGS", ErrMissingValue)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) runPostCreationAutomations(ctx context.Context, e *Enrollment) error <span class="cov0" title="0">{
        switch e.Status </span>{
        case StatusAwaitingRiskSignals:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(e.CreatedAt.Add(5 * time.Minute).Time) </span><span class="cov0" title="0">{
                        reason := RejectionReasonAwaitingRiskSignals
                        return s.Cancel(ctx, e, Cancellation{RejectionReason: &amp;reason, From: payment.CancelledFromHolder})
                }</span>
        case StatusAwaitingAccountHolderValidation:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(e.StatusUpdatedAt.Add(15 * time.Minute).Time) </span><span class="cov0" title="0">{
                        reason := RejectionReasonAwaitingAccountHolderValidation
                        return s.Cancel(ctx, e, Cancellation{RejectionReason: &amp;reason, From: payment.CancelledFromHolder})
                }</span>
        case StatusAwaitingEnrollment:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(e.StatusUpdatedAt.Add(CredentialRegistrationTimeout).Time) </span><span class="cov0" title="0">{
                        reason := RejectionReasonAwaitingEnrollment
                        return s.Cancel(ctx, e, Cancellation{RejectionReason: &amp;reason, From: payment.CancelledFromHolder})
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s Service) updateStatus(ctx context.Context, e *Enrollment, status Status) error <span class="cov0" title="0">{
        e.Status = status
        e.StatusUpdatedAt = timeutil.DateTimeNow()
        if err := s.update(ctx, e); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update enrollment status: %w", err)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]Status{StatusRejected, StatusRevoked}, status) </span><span class="cov0" title="0">{
                s.webhookService.Notify(ctx, e.ClientID, "/enrollments/"+s.version+"/enrollments/"+e.URN())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) update(ctx context.Context, e *Enrollment) error <span class="cov0" title="0">{
        e.UpdatedAt = timeutil.DateTimeNow()
        return s.db.WithContext(ctx).
                Model(&amp;Enrollment{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", e.ID, e.OrgID).
                Updates(e).Error
}</span>
</pre>

		<pre class="file" id="file37" style="display: none">package enrollment

import (
        "crypto/rand"
        "encoding/base64"
        "strings"

        "github.com/google/uuid"
)

func URN(id uuid.UUID) string <span class="cov0" title="0">{
        return URNPrefix + id.String()
}</span>

func IDFromScopes(scopes string) (string, bool) <span class="cov0" title="0">{
        for _, s := range strings.Split(scopes, " ") </span><span class="cov0" title="0">{
                if ScopeID.Matches(s) </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(s, "enrollment:"+URNPrefix), true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func generateChallenge() string <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return base64.RawURLEncoding.EncodeToString(bytes)</span>
}
</pre>

		<pre class="file" id="file38" style="display: none">package errorutil

import (
        "errors"
        "fmt"
)

type Error struct {
        error
}

func (e Error) Unwrap() error <span class="cov0" title="0">{
        return e.error
}</span>

func New(msg string) error <span class="cov0" title="0">{
        return Error{
                error: errors.New(msg),
        }
}</span>

func Format(format string, args ...any) error <span class="cov0" title="0">{
        return Error{
                error: fmt.Errorf(format, args...),
        }
}</span>
</pre>

		<pre class="file" id="file39" style="display: none">package idempotency

import "time"

type Record struct {
        ID         string `gorm:"primaryKey"`
        StatusCode int
        Request    string
        Response   string

        OrgID     string
        CreatedAt time.Time
        UpdatedAt time.Time
}

func (Record) TableName() string <span class="cov0" title="0">{
        return "idempotency_records"
}</span>
</pre>

		<pre class="file" id="file40" style="display: none">package idempotency

import (
        "context"
        "errors"
        "fmt"

        "gorm.io/gorm"
)

type Service struct {
        db *gorm.DB
}

func NewService(db *gorm.DB) Service <span class="cov0" title="0">{
        return Service{db: db}
}</span>

func (s Service) Response(ctx context.Context, id string) (*Record, error) <span class="cov0" title="0">{
        record := Record{}
        err := s.db.WithContext(ctx).Where("id = ?", id).First(&amp;record).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("error fetching the idempotency record: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;record, nil</span>
}

func (s Service) Create(ctx context.Context, rec *Record) error <span class="cov0" title="0">{
        if err := s.db.WithContext(ctx).Create(rec).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not save the idempotency record: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file41" style="display: none">package jwtutil

import (
        "crypto"
        "crypto/rand"
        "crypto/rsa"

        "github.com/go-jose/go-jose/v4"
        "github.com/go-jose/go-jose/v4/jwt"
)

func Sign(claims any, signer crypto.Signer) (string, error) <span class="cov0" title="0">{
        key := jose.SigningKey{
                Algorithm: jose.PS256,
                Key: OpaqueSigner{
                        ID:     "signer",
                        Signer: signer,
                },
        }
        opts := (&amp;jose.SignerOptions{}).WithType("JWT")

        joseSigner, err := jose.NewSigner(key, opts)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">jws, err := jwt.Signed(joseSigner).Claims(claims).Serialize()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return jws, nil</span>
}

var _ jose.OpaqueSigner = OpaqueSigner{}

type OpaqueSigner struct {
        ID     string
        Signer crypto.Signer
}

func (s OpaqueSigner) Public() *jose.JSONWebKey <span class="cov0" title="0">{
        return &amp;jose.JSONWebKey{
                KeyID:     s.ID,
                Key:       s.Signer.Public(),
                Algorithm: string(jose.PS256),
                Use:       "sig",
        }
}</span>

func (s OpaqueSigner) Algs() []jose.SignatureAlgorithm <span class="cov0" title="0">{
        return []jose.SignatureAlgorithm{jose.PS256}
}</span>

func (s OpaqueSigner) SignPayload(payload []byte, _ jose.SignatureAlgorithm) ([]byte, error) <span class="cov0" title="0">{
        hasher := crypto.SHA256.New()
        hasher.Write(payload)
        digest := hasher.Sum(nil)

        opts := &amp;rsa.PSSOptions{
                SaltLength: rsa.PSSSaltLengthEqualsHash,
                Hash:       crypto.SHA256,
        }
        return s.Signer.Sign(rand.Reader, digest, opts)
}</span>
</pre>

		<pre class="file" id="file42" style="display: none">package oidc

import (
        "context"
        "errors"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

type AuthnSessionManager struct {
        db *gorm.DB
}

func NewAuthnSessionManager(db *gorm.DB) AuthnSessionManager <span class="cov0" title="0">{
        return AuthnSessionManager{db: db}
}</span>

func (m AuthnSessionManager) Save(ctx context.Context, as *goidc.AuthnSession) error <span class="cov0" title="0">{
        session := &amp;Session{
                ID:              as.ID,
                CallbackID:      as.CallbackID,
                AuthCode:        as.AuthCode,
                PushedAuthReqID: as.PushedAuthReqID,
                ExpiresAt:       timeutil.ParseTimestamp(as.ExpiresAtTimestamp),
                Data:            *as,
                UpdatedAt:       timeutil.DateTimeNow(),
                OrgID:           as.StoredParameter(OrgIDKey).(string),
        }

        return m.db.WithContext(ctx).Save(session).Error
}</span>

func (m AuthnSessionManager) SessionByCallbackID(ctx context.Context, callbackID string) (*goidc.AuthnSession, error) <span class="cov0" title="0">{
        return m.session(ctx, m.db.Where("callback_id = ?", callbackID))
}</span>

func (m AuthnSessionManager) SessionByAuthCode(ctx context.Context, code string) (*goidc.AuthnSession, error) <span class="cov0" title="0">{
        return m.session(ctx, m.db.Where("auth_code = ?", code))
}</span>

func (m AuthnSessionManager) SessionByPushedAuthReqID(ctx context.Context, id string) (*goidc.AuthnSession, error) <span class="cov0" title="0">{
        return m.session(ctx, m.db.Where("pushed_auth_req_id = ?", id))
}</span>

func (m AuthnSessionManager) SessionByCIBAAuthID(ctx context.Context, id string) (*goidc.AuthnSession, error) <span class="cov0" title="0">{
        return nil, errors.ErrUnsupported
}</span>

func (m AuthnSessionManager) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return m.db.WithContext(ctx).Where("id = ?", id).Delete(&amp;Session{}).Error
}</span>

func (m AuthnSessionManager) session(ctx context.Context, tx *gorm.DB) (*goidc.AuthnSession, error) <span class="cov0" title="0">{

        var as Session
        if err := tx.WithContext(ctx).First(&amp;as).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;as.Data, nil</span>
}

type Session struct {
        ID              string `gorm:"primaryKey"`
        CallbackID      string
        AuthCode        string
        PushedAuthReqID string
        ExpiresAt       timeutil.DateTime
        Data            goidc.AuthnSession `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Session) TableName() string <span class="cov0" title="0">{
        return "oauth_sessions"
}</span>
</pre>

		<pre class="file" id="file43" style="display: none">package oidc

import (
        "context"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/client"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type ClientManager struct {
        service client.Service
}

func NewClientManager(service client.Service) ClientManager <span class="cov0" title="0">{
        return ClientManager{service: service}
}</span>

func (cm ClientManager) Save(ctx context.Context, oidcClient *goidc.Client) error <span class="cov0" title="0">{
        c := &amp;client.Client{
                ID:        oidcClient.ID,
                Data:      *oidcClient,
                Name:      oidcClient.Name,
                UpdatedAt: timeutil.DateTimeNow(),
                OrgID:     oidcClient.CustomAttribute(OrgIDKey).(string),
        }
        if webhookURIs, ok := oidcClient.CustomAttribute(WebhookURIsKey).([]string); ok </span><span class="cov0" title="0">{
                c.WebhookURIs = webhookURIs
        }</span>
        <span class="cov0" title="0">if originURIs, ok := oidcClient.CustomAttribute(OriginURIsKey).([]string); ok </span><span class="cov0" title="0">{
                c.OriginURIs = originURIs
        }</span>
        <span class="cov0" title="0">return cm.service.Save(ctx, c)</span>
}

func (cm ClientManager) Client(ctx context.Context, id string) (*goidc.Client, error) <span class="cov0" title="0">{
        c, err := cm.service.Client(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;c.Data, nil</span>
}

func (cm ClientManager) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return cm.service.Delete(ctx, id)
}</span>
</pre>

		<pre class="file" id="file44" style="display: none">package oidc

import (
        "crypto/x509"
        "encoding/json"
        "fmt"
        "net/http"
        "slices"
        "strings"
        "sync"
        "time"

        "github.com/go-jose/go-jose/v4"
        "github.com/go-jose/go-jose/v4/jwt"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

const (
        oidUID = "2.5.4.45"
)

var (
        ssJWKSCacheTime     = 1 * time.Hour
        ssJWKSMu            sync.Mutex
        ssJWKSCache         *goidc.JSONWebKeySet
        ssJWKSLastFetchedAt timeutil.DateTime
)

type DCRConfig struct {
        Scopes       []goidc.Scope
        KeyStoreHost string
        SSIssuer     string
}

func DCRFunc(config DCRConfig) goidc.HandleDynamicClientFunc <span class="cov0" title="0">{
        var scopeIDs []string
        for _, scope := range config.Scopes </span><span class="cov0" title="0">{
                scopeIDs = append(scopeIDs, scope.ID)
        }</span>

        <span class="cov0" title="0">return func(r *http.Request, _ string, c *goidc.ClientMeta) error </span><span class="cov0" title="0">{
                clientCert, err := ClientCert(r)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.WrapError(goidc.ErrorCodeInvalidClientMetadata, "certificate not informed", err)
                }</span>

                <span class="cov0" title="0">ssa, ok := c.CustomAttribute("software_statement").(string)
                if !ok || ssa == "" </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "software statement is required")
                }</span>

                <span class="cov0" title="0">jwks, err := fetchSoftwareStatementJWKS(config.KeyStoreHost)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInternalError, "could not fetch the keystore jwks")
                }</span>

                <span class="cov0" title="0">parsedSSA, err := jwt.ParseSigned(ssa, []jose.SignatureAlgorithm{goidc.PS256})
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.WrapError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement", err)
                }</span>

                <span class="cov0" title="0">var claims jwt.Claims
                var ss SoftwareStatement
                if err := parsedSSA.Claims(jwks.ToJOSE(), &amp;claims, &amp;ss); err != nil </span><span class="cov0" title="0">{
                        return goidc.WrapError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement signature", err)
                }</span>

                <span class="cov0" title="0">if claims.IssuedAt == nil || timeutil.DateTimeNow().After(claims.IssuedAt.Time().Add(5*time.Minute)) </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement iat claim")
                }</span>

                <span class="cov0" title="0">if err := claims.Validate(jwt.Expected{
                        Issuer: config.SSIssuer,
                }); err != nil </span><span class="cov0" title="0">{
                        return goidc.WrapError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement claims", err)
                }</span>

                <span class="cov0" title="0">if extractUID(clientCert) != ss.SoftwareID &amp;&amp; clientCert.Subject.CommonName != ss.SoftwareID </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement, software id doesn't match certificate cn nor uid")
                }</span>

                <span class="cov0" title="0">if ss.OrgStatus != "Active" </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement, organization is not active")
                }</span>

                <span class="cov0" title="0">if len(ss.SoftwareRoles) == 0 </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "invalid software statement, no regulatory roles defined")
                }</span>

                <span class="cov0" title="0">if sID := c.CustomAttribute(SoftwareIDKey); sID != nil &amp;&amp; sID != ss.SoftwareID </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "software id mismatch")
                }</span>

                <span class="cov0" title="0">if orgID := c.CustomAttribute(OrgIDKey); orgID != nil &amp;&amp; orgID != ss.OrgID </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "organization id mismatch")
                }</span>

                <span class="cov0" title="0">if c.PublicJWKSURI != ss.SoftwareJWKSURI </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "jwks uri mismatch")
                }</span>

                <span class="cov0" title="0">for _, ru := range c.RedirectURIs </span><span class="cov0" title="0">{
                        if !slices.Contains(ss.SoftwareRedirectURIs, ru) </span><span class="cov0" title="0">{
                                return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "redirect uri not allowed")
                        }</span>
                }

                <span class="cov0" title="0">if c.PublicJWKS != nil </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "jwks cannot be informed by value")
                }</span>

                <span class="cov0" title="0">if c.ScopeIDs == "" </span><span class="cov0" title="0">{
                        c.ScopeIDs = strings.Join(scopeIDs, " ")
                }</span>

                <span class="cov0" title="0">if webhookURIs, ok := c.CustomAttribute(WebhookURIsKey).([]string); ok </span><span class="cov0" title="0">{
                        for _, webhookURI := range webhookURIs </span><span class="cov0" title="0">{
                                if !slices.Contains(ss.SoftwareAPIWebhookURIs, webhookURI) </span><span class="cov0" title="0">{
                                        return goidc.NewError(goidc.ErrorCodeInvalidClientMetadata, "webhook uri not allowed")
                                }</span>
                        }
                }

                <span class="cov0" title="0">c.Name = ss.SoftwareClientName
                c.CustomAttributes = map[string]any{
                        OrgIDKey:      ss.OrgID,
                        SoftwareIDKey: ss.SoftwareID,
                }
                if ss.SoftwareOriginURIs != nil </span><span class="cov0" title="0">{
                        c.SetCustomAttribute(OriginURIsKey, ss.SoftwareOriginURIs)
                }</span>
                <span class="cov0" title="0">if webhookURIs := c.CustomAttribute(WebhookURIsKey); webhookURIs != nil </span><span class="cov0" title="0">{
                        c.SetCustomAttribute(WebhookURIsKey, webhookURIs)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
}

func extractUID(cert *x509.Certificate) string <span class="cov0" title="0">{
        for _, name := range cert.Subject.Names </span><span class="cov0" title="0">{
                if name.Type.String() == oidUID </span><span class="cov0" title="0">{
                        return fmt.Sprintf("%v", name.Value)
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func fetchSoftwareStatementJWKS(keystoreHost string) (goidc.JSONWebKeySet, error) <span class="cov0" title="0">{
        ssJWKSMu.Lock()
        defer ssJWKSMu.Unlock()

        if ssJWKSCache != nil &amp;&amp; timeutil.DateTimeNow().Before(ssJWKSLastFetchedAt.Add(ssJWKSCacheTime)) </span><span class="cov0" title="0">{
                return *ssJWKSCache, nil
        }</span>

        <span class="cov0" title="0">resp, err := http.Get(keystoreHost + "/openbanking.jwks")
        if err != nil </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, fmt.Errorf("keystore jwks unexpected status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var jwks goidc.JSONWebKeySet
        if err := json.NewDecoder(resp.Body).Decode(&amp;jwks); err != nil </span><span class="cov0" title="0">{
                return goidc.JSONWebKeySet{}, fmt.Errorf("failed to decode keystore jwks response: %w", err)
        }</span>

        <span class="cov0" title="0">ssJWKSCache = &amp;jwks
        ssJWKSLastFetchedAt = timeutil.DateTimeNow()
        return jwks, nil</span>
}
</pre>

		<pre class="file" id="file45" style="display: none">package oidc

import (
        "context"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

type GrantSessionManager struct {
        db *gorm.DB
}

func NewGrantSessionManager(db *gorm.DB) GrantSessionManager <span class="cov0" title="0">{
        return GrantSessionManager{db: db}
}</span>

func (m GrantSessionManager) Save(ctx context.Context, gs *goidc.GrantSession) error <span class="cov0" title="0">{
        grant := &amp;Grant{
                ID:             gs.ID,
                TokenID:        gs.TokenID,
                RefreshTokenID: gs.RefreshTokenID,
                AuthCode:       gs.AuthCode,
                ExpiresAt:      timeutil.ParseTimestamp(gs.ExpiresAtTimestamp),
                Data:           *gs,
                UpdatedAt:      timeutil.DateTimeNow(),
                OrgID:          gs.AdditionalTokenClaims[OrgIDKey].(string),
        }
        return m.db.WithContext(ctx).Save(grant).Error
}</span>

func (m GrantSessionManager) SessionByTokenID(ctx context.Context, id string) (*goidc.GrantSession, error) <span class="cov0" title="0">{
        return m.grant(ctx, m.db.Where("token_id = ?", id))
}</span>

func (m GrantSessionManager) SessionByRefreshTokenID(ctx context.Context, id string) (*goidc.GrantSession, error) <span class="cov0" title="0">{
        return m.grant(ctx, m.db.Where("refresh_token_id = ?", id))
}</span>

func (m GrantSessionManager) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return m.db.WithContext(ctx).Where("id = ?", id).Delete(&amp;Grant{}).Error
}</span>

func (m GrantSessionManager) DeleteByAuthCode(ctx context.Context, code string) error <span class="cov0" title="0">{
        return m.db.WithContext(ctx).Where("auth_code = ?", code).Delete(&amp;Grant{}).Error
}</span>

func (m GrantSessionManager) grant(ctx context.Context, tx *gorm.DB) (*goidc.GrantSession, error) <span class="cov0" title="0">{
        var grant Grant
        if err := tx.WithContext(ctx).First(&amp;grant).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;grant.Data, nil</span>
}

type Grant struct {
        ID             string `gorm:"primaryKey"`
        TokenID        string
        RefreshTokenID string
        AuthCode       string
        ExpiresAt      timeutil.DateTime
        Data           goidc.GrantSession `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Grant) TableName() string <span class="cov0" title="0">{
        return "oauth_grants"
}</span>
</pre>

		<pre class="file" id="file46" style="display: none">package oidc

import (
        "errors"
        "fmt"
        "html/template"
        "log/slog"
        "net/http"
        "slices"
        "strings"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/enrollment"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/templates"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/payment"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "github.com/unrolled/secure"
)

const (
        sessionParamConsentID    = "consent_id"
        sessionParamEnrollmentID = "enrollment_id"
        sessionParamCPF          = "cpf"
        sessionParamUserID       = "user_id"
        sessionParamBusinessID   = "business_id"

        formParamUsername       = "username"
        formParamPassword       = "password"
        formParamLogin          = "login"
        formParamConsent        = "consent"
        formParamAccountIDs     = "accounts"
        formParamAccountID      = "account"
        formParamOverdraftLimit = "use_overdraft_limit"

        correctPassword = "P@ssword01"
)

// TODO: Validate that the resources (accounts, ...) sent belong to the user.
// TODO: For auto payments: Mesmo se enviado pela ITP, o usuário pagador pode alterar durante a autorização do consentimento.

// TODO: Pass the template as a parameter.
func Policies(
        baseURL string,
        userService user.Service,
        consentService consent.Service,
        accountService account.Service,
        paymentService payment.Service,
        autoPaymentService autopayment.Service,
        enrollmentService enrollment.Service,
) []goidc.AuthnPolicy <span class="cov0" title="0">{
        tmpl := template.Must(template.ParseFS(templates.Templates, "*.html"))
        return []goidc.AuthnPolicy{
                goidc.NewPolicyWithSteps(
                        "enrollment",
                        func(r *http.Request, c *goidc.Client, as *goidc.AuthnSession) bool </span><span class="cov0" title="0">{
                                enrollmentID, ok := enrollment.IDFromScopes(as.Scopes)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov0" title="0">as.StoreParameter(sessionParamEnrollmentID, enrollmentID)
                                as.StoreParameter(OrgIDKey, c.CustomAttribute(OrgIDKey))
                                return true</span>
                        },
                        goidc.NewAuthnStep("setup", validateEnrollmentStep(enrollmentService)),
                        goidc.NewAuthnStep("login", loginStep(baseURL, tmpl, userService)),
                        goidc.NewAuthnStep("enrollment", grantEnrollmentStep(baseURL, tmpl, userService, enrollmentService, accountService)),
                        goidc.NewAuthnStep("finish", grantAuthorizationStep()),
                ),
                goidc.NewPolicyWithSteps(
                        "auto_payment",
                        func(r *http.Request, c *goidc.Client, as *goidc.AuthnSession) bool <span class="cov0" title="0">{
                                consentID, ok := autopayment.ConsentIDFromScopes(as.Scopes)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov0" title="0">as.StoreParameter(sessionParamConsentID, consentID)
                                as.StoreParameter(OrgIDKey, c.CustomAttribute(OrgIDKey))
                                return true</span>
                        },
                        goidc.NewAuthnStep("setup", validateAutoPaymentConsentStep(autoPaymentService)),
                        goidc.NewAuthnStep("login", loginStep(baseURL, tmpl, userService)),
                        goidc.NewAuthnStep("payment", grantAutoPaymentStep(baseURL, tmpl, userService, autoPaymentService, accountService)),
                        goidc.NewAuthnStep("finish", grantAuthorizationStep()),
                ),
                goidc.NewPolicyWithSteps(
                        "payment",
                        func(r *http.Request, c *goidc.Client, as *goidc.AuthnSession) bool <span class="cov0" title="0">{
                                if !strings.Contains(as.Scopes, payment.Scope.ID) </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov0" title="0">consentID, ok := consent.IDFromScopes(as.Scopes)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov0" title="0">as.StoreParameter(sessionParamConsentID, consentID)
                                as.StoreParameter(OrgIDKey, c.CustomAttribute(OrgIDKey))
                                return true</span>
                        },
                        goidc.NewAuthnStep("setup", validatePaymentConsentStep(paymentService)),
                        goidc.NewAuthnStep("login", loginStep(baseURL, tmpl, userService)),
                        goidc.NewAuthnStep("payment", grantPaymentStep(baseURL, tmpl, userService, paymentService, accountService)),
                        goidc.NewAuthnStep("finish", grantAuthorizationStep()),
                ),
                goidc.NewPolicyWithSteps(
                        "consent",
                        func(r *http.Request, c *goidc.Client, as *goidc.AuthnSession) bool <span class="cov0" title="0">{
                                consentID, ok := consent.IDFromScopes(as.Scopes)
                                if !ok </span><span class="cov0" title="0">{
                                        return false
                                }</span>

                                <span class="cov0" title="0">as.StoreParameter(sessionParamConsentID, consentID)
                                as.StoreParameter(OrgIDKey, c.CustomAttribute(OrgIDKey))
                                return true</span>
                        },
                        goidc.NewAuthnStep("setup", validateConsentStep(consentService)),
                        goidc.NewAuthnStep("login", loginStep(baseURL, tmpl, userService)),
                        goidc.NewAuthnStep("consent", grantConsentStep(baseURL, tmpl, userService, consentService, accountService)),
                        goidc.NewAuthnStep("finish", grantAuthorizationStep()),
                ),
        }
}

func loginStep(baseURL string, tmpl *template.Template, userService user.Service) goidc.AuthnFunc <span class="cov0" title="0">{
        type Page struct {
                BaseURL    string
                CallbackID string
                Nonce      string
                Error      string
        }

        renderLoginPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                return renderPage(w, tmpl, "login", Page{
                        BaseURL:    baseURL,
                        CallbackID: as.CallbackID,
                        Nonce:      secure.CSPNonce(r.Context()),
                })
        }</span>

        <span class="cov0" title="0">renderLoginErrorPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession, err string) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                return renderPage(w, tmpl, "login", Page{
                        BaseURL:    baseURL,
                        CallbackID: as.CallbackID,
                        Nonce:      secure.CSPNonce(r.Context()),
                        Error:      err,
                })
        }</span>

        <span class="cov0" title="0">return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                slog.InfoContext(r.Context(), "starting login step")

                isLogin := r.PostFormValue(formParamLogin)
                if isLogin == "" </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "rendering login page")
                        return renderLoginPage(w, r, as)
                }</span>

                <span class="cov0" title="0">if isLogin != "true" </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "user cancelled login")
                        return goidc.StatusFailure, errors.New("user cancelled login")
                }</span>

                <span class="cov0" title="0">orgID := as.StoredParameter(OrgIDKey).(string)
                username := r.PostFormValue(formParamUsername)
                u, err := userService.User(r.Context(), user.Query{Username: username}, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "could not fetch user", "error", err)
                        return renderLoginErrorPage(w, r, as, "invalid username")
                }</span>

                <span class="cov0" title="0">password := r.PostFormValue(formParamPassword)
                if password != correctPassword </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "invalid password")
                        return renderLoginErrorPage(w, r, as, "invalid credentials")
                }</span>

                <span class="cov0" title="0">slog.InfoContext(r.Context(), "login step finished successfully", "user_id", u.ID, "user_cpf", u.CPF)
                as.StoreParameter(sessionParamUserID, u.ID.String())
                as.StoreParameter(sessionParamCPF, u.CPF)
                return goidc.StatusSuccess, nil</span>
        }
}

func validateConsentStep(consentService consent.Service) goidc.AuthnFunc <span class="cov0" title="0">{
        return func(_ http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := consentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "could not fetch the consent", "error", err)
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">if c.Status != consent.StatusAwaitingAuthorization </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "consent is not awaiting authorization", "status", c.Status)
                        return goidc.StatusFailure, errors.New("consent is not awaiting authorization")
                }</span>

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func grantConsentStep(
        baseURL string,
        tmpl *template.Template,
        userService user.Service,
        consentService consent.Service,
        accountService account.Service,
) goidc.AuthnFunc <span class="cov0" title="0">{
        type Page struct {
                BaseURL      string
                CallbackID   string
                UserCPF      string
                BusinessCNPJ string
                Accounts     []*account.Account
                Nonce        string
        }

        renderConsentPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession, c *consent.Consent) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                consentPage := Page{
                        BaseURL:    baseURL,
                        UserCPF:    c.UserIdentification,
                        CallbackID: as.CallbackID,
                        Nonce:      secure.CSPNonce(r.Context()),
                }

                userID := as.StoredParameter(sessionParamUserID).(string)
                orgID := as.StoredParameter(OrgIDKey).(string)
                if c.Permissions.HasAccountPermissions() </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "rendering consent page with accounts")
                        accs, err := accountService.Accounts(r.Context(), userID, orgID, page.NewPagination(nil, nil))
                        if err != nil </span><span class="cov0" title="0">{
                                slog.ErrorContext(r.Context(), "could not load the user accounts", "error", err)
                                return goidc.StatusFailure, fmt.Errorf("could not load the user accounts")
                        }</span>
                        <span class="cov0" title="0">consentPage.Accounts = accs.Records</span>
                }

                <span class="cov0" title="0">return renderPage(w, tmpl, "consent", consentPage)</span>
        }

        <span class="cov0" title="0">return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := consentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">isConsented := r.PostFormValue(formParamConsent)
                if isConsented == "" </span><span class="cov0" title="0">{
                        if as.StoredParameter(sessionParamCPF) != c.UserIdentification </span><span class="cov0" title="0">{
                                slog.InfoContext(r.Context(), "consent was not created for the correct user")
                                _ = consentService.Reject(r.Context(), consentID, orgID, consent.RejectedByASPSP, consent.RejectionReasonInternalSecurityReason)
                                return goidc.StatusFailure, errors.New("consent not created for the correct user")
                        }</span>

                        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                                userID := as.StoredParameter(sessionParamUserID).(string)
                                business, err := userService.UserBusiness(r.Context(), userID, *c.BusinessIdentification, orgID)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.InfoContext(r.Context(), "could not fetch the business", "error", err)
                                        _ = consentService.Reject(r.Context(), consentID, orgID, consent.RejectedByASPSP, consent.RejectionReasonInternalSecurityReason)
                                        return goidc.StatusFailure, errors.New("user has no access to the business")
                                }</span>
                                <span class="cov0" title="0">as.StoreParameter(sessionParamBusinessID, business.ID.String())</span>
                        }

                        <span class="cov0" title="0">slog.InfoContext(r.Context(), "rendering consent page")
                        return renderConsentPage(w, r, as, c)</span>
                }

                <span class="cov0" title="0">if isConsented != "true" </span><span class="cov0" title="0">{
                        _ = consentService.Reject(r.Context(), consentID, orgID, consent.RejectedByUser, consent.RejectionReasonCustomerManuallyRejected)
                        return goidc.StatusFailure, errors.New("consent not granted")
                }</span>

                <span class="cov0" title="0">slog.InfoContext(r.Context(), "authorizing consent")
                if err := consentService.Authorize(r.Context(), c); err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">if c.Permissions.HasAccountPermissions() </span><span class="cov0" title="0">{
                        accountIDs := r.Form[formParamAccountIDs]
                        slog.InfoContext(r.Context(), "authorizing accounts", "accounts", accountIDs)
                        if err := accountService.Authorize(r.Context(), accountIDs, c.ID.String(), orgID); err != nil </span><span class="cov0" title="0">{
                                slog.InfoContext(r.Context(), "could not authorize accounts", "error", err)
                                return goidc.StatusFailure, err
                        }</span>
                }

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func validatePaymentConsentStep(paymentService payment.Service) goidc.AuthnFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := paymentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "could not fetch payment consent", "error", err)
                        return goidc.StatusFailure, errors.New("could not fetch payment consent")
                }</span>

                <span class="cov0" title="0">if c.Status != payment.ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "payment consent is not awaiting authorization", "status", c.Status)
                        return goidc.StatusFailure, errors.New("payment consent is not awaiting authorization")
                }</span>

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func grantPaymentStep(
        baseURL string,
        tmpl *template.Template,
        userService user.Service,
        paymentService payment.Service,
        accountService account.Service,
) goidc.AuthnFunc <span class="cov0" title="0">{
        type Page struct {
                BaseURL                 string
                CallbackID              string
                UserCPF                 string
                BusinessCNPJ            string
                Account                 *account.Account
                Accounts                []*account.Account
                OverdraftLimit          bool
                Nonce                   string
                OverdraftLimitIsEnabled bool
        }

        renderPaymentPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                userID := as.StoredParameter(sessionParamUserID).(string)
                c, err := paymentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">paymentPage := Page{
                        BaseURL:    baseURL,
                        CallbackID: as.CallbackID,
                        UserCPF:    c.UserIdentification,
                        Nonce:      secure.CSPNonce(r.Context()),
                }

                if cnpj := c.BusinessIdentification; cnpj != nil </span><span class="cov0" title="0">{
                        paymentPage.BusinessCNPJ = *cnpj
                }</span>

                <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                        paymentPage.Account = c.DebtorAccount
                        return renderPage(w, tmpl, "payment", paymentPage)
                }</span>

                <span class="cov0" title="0">accs, err := accountService.Accounts(r.Context(), userID, orgID, page.NewPagination(nil, nil))
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "could not load the user accounts", "error", err)
                        return goidc.StatusFailure, errors.New("could not load the user accounts")
                }</span>
                <span class="cov0" title="0">paymentPage.Accounts = accs.Records

                return renderPage(w, tmpl, "payment", paymentPage)</span>
        }

        <span class="cov0" title="0">return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := paymentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">isConsented := r.PostFormValue(formParamConsent)
                if isConsented == "" </span><span class="cov0" title="0">{
                        if as.StoredParameter(sessionParamCPF) != c.UserIdentification </span><span class="cov0" title="0">{
                                slog.InfoContext(r.Context(), "consent was not created for the correct user")
                                _ = paymentService.RejectConsent(r.Context(), c, payment.ConsentRejectionNotProvided, "payment consent not created for the correct user")
                                return goidc.StatusFailure, errors.New("consent not created for the correct user")
                        }</span>

                        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                                userID := as.StoredParameter(sessionParamUserID).(string)
                                business, err := userService.UserBusiness(r.Context(), userID, *c.BusinessIdentification, orgID)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.InfoContext(r.Context(), "could not fetch the business", "error", err)
                                        _ = paymentService.RejectConsent(r.Context(), c, payment.ConsentRejectionNotProvided, "user has no access to the business")
                                        return goidc.StatusFailure, errors.New("user has no access to the business")
                                }</span>
                                <span class="cov0" title="0">as.StoreParameter(sessionParamBusinessID, business.ID.String())</span>
                        }

                        <span class="cov0" title="0">slog.InfoContext(r.Context(), "rendering payment consent page")
                        return renderPaymentPage(w, r, as)</span>
                }

                <span class="cov0" title="0">if isConsented != "true" </span><span class="cov0" title="0">{
                        _ = paymentService.RejectConsent(r.Context(), c, payment.ConsentRejectionRejectedByUser, "payment consent not granted")
                        return goidc.StatusFailure, errors.New("consent not granted")
                }</span>

                <span class="cov0" title="0">accountID := uuid.MustParse(r.PostFormValue(formParamAccountID))
                c.DebtorAccountID = &amp;accountID
                slog.InfoContext(r.Context(), "authorizing payment consent", "consent_id", c.ID)
                if err := paymentService.AuthorizeConsent(r.Context(), c); err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>
                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func validateAutoPaymentConsentStep(paymentService autopayment.Service) goidc.AuthnFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                slog.InfoContext(r.Context(), "setting up auto payment step")
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := paymentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "could not fetch recurring payment consent", "error", err)
                        return goidc.StatusFailure, errors.New("could not fetch recurring payment consent")
                }</span>

                <span class="cov0" title="0">if c.Status != autopayment.ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "recurring payment consent is not awaiting authorization", "status", c.Status)
                        return goidc.StatusFailure, errors.New("recurring payment consent is not awaiting authorization")
                }</span>

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func grantAutoPaymentStep(
        baseURL string,
        tmpl *template.Template,
        userService user.Service,
        paymentService autopayment.Service,
        accountService account.Service,
) goidc.AuthnFunc <span class="cov0" title="0">{
        type Page struct {
                BaseURL                 string
                CallbackID              string
                UserCPF                 string
                BusinessCNPJ            string
                Account                 *account.Account
                Accounts                []*account.Account
                OverdraftLimitIsEnabled bool
                Nonce                   string
        }

        renderPaymentPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession, c *autopayment.Consent) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{

                paymentPage := Page{
                        BaseURL:    baseURL,
                        CallbackID: as.CallbackID,
                        UserCPF:    c.UserIdentification,
                        Nonce:      secure.CSPNonce(r.Context()),
                }

                if c.Configuration.Automatic != nil </span><span class="cov0" title="0">{
                        paymentPage.OverdraftLimitIsEnabled = true
                }</span>

                <span class="cov0" title="0">if cnpj := c.BusinessIdentification; cnpj != nil </span><span class="cov0" title="0">{
                        paymentPage.BusinessCNPJ = *cnpj
                }</span>

                <span class="cov0" title="0">if c.DebtorAccount != nil </span><span class="cov0" title="0">{
                        paymentPage.Account = c.DebtorAccount
                        return renderPage(w, tmpl, "payment", paymentPage)
                }</span>

                <span class="cov0" title="0">orgID := as.StoredParameter(OrgIDKey).(string)
                userID := as.StoredParameter(sessionParamUserID).(string)
                accs, err := accountService.Accounts(r.Context(), userID, orgID, page.NewPagination(nil, nil))
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "could not load the user accounts", "error", err)
                        return goidc.StatusFailure, errors.New("could not load the user accounts")
                }</span>
                <span class="cov0" title="0">paymentPage.Accounts = accs.Records

                return renderPage(w, tmpl, "payment", paymentPage)</span>
        }

        <span class="cov0" title="0">return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                consentID := as.StoredParameter(sessionParamConsentID).(string)
                c, err := paymentService.Consent(r.Context(), consentID, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">isConsented := r.PostFormValue(formParamConsent)
                if isConsented == "" </span><span class="cov0" title="0">{
                        if as.StoredParameter(sessionParamCPF) != c.UserIdentification </span><span class="cov0" title="0">{
                                slog.InfoContext(r.Context(), "consent was not created for the correct user")
                                _ = paymentService.RejectConsent(r.Context(), c, autopayment.ConsentRejection{
                                        By:     autopayment.TerminatedByHolder,
                                        From:   autopayment.TerminatedFromHolder,
                                        Code:   autopayment.ConsentRejectionAuthenticationMismatch,
                                        Detail: "payment consent not created for the correct user",
                                })
                                return goidc.StatusFailure, errors.New("consent not created for the correct user")
                        }</span>

                        <span class="cov0" title="0">if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                                userID := as.StoredParameter(sessionParamUserID).(string)
                                business, err := userService.UserBusiness(r.Context(), userID, *c.BusinessIdentification, orgID)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.InfoContext(r.Context(), "could not fetch the business", "error", err)
                                        _ = paymentService.RejectConsent(r.Context(), c, autopayment.ConsentRejection{
                                                By:     autopayment.TerminatedByHolder,
                                                From:   autopayment.TerminatedFromHolder,
                                                Code:   autopayment.ConsentRejectionAuthenticationMismatch,
                                                Detail: "user has no access to the business",
                                        })
                                        return goidc.StatusFailure, errors.New("user has no access to the business")
                                }</span>
                                <span class="cov0" title="0">as.StoreParameter(sessionParamBusinessID, business.ID.String())</span>
                        }

                        <span class="cov0" title="0">slog.InfoContext(r.Context(), "rendering payment consent page")
                        return renderPaymentPage(w, r, as, c)</span>
                }

                <span class="cov0" title="0">if isConsented != "true" </span><span class="cov0" title="0">{
                        _ = paymentService.RejectConsent(r.Context(), c, autopayment.ConsentRejection{
                                From:   autopayment.TerminatedFromHolder,
                                By:     autopayment.TerminatedByUser,
                                Code:   autopayment.ConsentRejectionRejectedByUser,
                                Detail: "payment consent not granted",
                        })
                        return goidc.StatusFailure, errors.New("consent not granted")
                }</span>

                <span class="cov0" title="0">slog.InfoContext(r.Context(), "authorizing payment consent", "consent_id", consentID)

                accountID := uuid.MustParse(r.PostFormValue(formParamAccountID))
                c.DebtorAccountID = &amp;accountID

                if c.Configuration.Automatic != nil &amp;&amp; r.PostFormValue(formParamOverdraftLimit) == "true" </span><span class="cov0" title="0">{
                        c.Configuration.Automatic.UseOverdraftLimit = true
                }</span>

                <span class="cov0" title="0">if err := paymentService.AuthorizeConsent(r.Context(), c); err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>
                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func validateEnrollmentStep(enrollmentService enrollment.Service) goidc.AuthnFunc <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                slog.InfoContext(r.Context(), "setting up auto payment step")
                orgID := as.StoredParameter(OrgIDKey).(string)
                enrollmentID := as.StoredParameter(sessionParamEnrollmentID).(string)
                e, err := enrollmentService.Enrollment(r.Context(), enrollment.Query{ID: enrollmentID}, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "could not fetch enrollment", "error", err)
                        return goidc.StatusFailure, errors.New("could not fetch enrollment")
                }</span>

                <span class="cov0" title="0">if e.Status != enrollment.StatusAwaitingAccountHolderValidation </span><span class="cov0" title="0">{
                        slog.InfoContext(r.Context(), "enrollment is not awaiting account holder validation", "status", e.Status)
                        return goidc.StatusFailure, errors.New("enrollment is not awaiting account holder validation")
                }</span>

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func grantEnrollmentStep(
        baseURL string,
        tmpl *template.Template,
        userService user.Service,
        enrollmentService enrollment.Service,
        accountService account.Service,
) goidc.AuthnFunc <span class="cov0" title="0">{
        type Page struct {
                BaseURL      string
                CallbackID   string
                UserCPF      string
                BusinessCNPJ string
                Account      *account.Account
                Accounts     []*account.Account
                Nonce        string
        }

        renderEnrollmentPage := func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession, e *enrollment.Enrollment) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{

                enrollmentPage := Page{
                        BaseURL:    baseURL,
                        CallbackID: as.CallbackID,
                        UserCPF:    e.UserIdentification,
                        Nonce:      secure.CSPNonce(r.Context()),
                }

                if e.BusinessIdentification != nil </span><span class="cov0" title="0">{
                        enrollmentPage.BusinessCNPJ = *e.BusinessIdentification
                }</span>

                <span class="cov0" title="0">if e.DebtorAccount != nil </span><span class="cov0" title="0">{
                        enrollmentPage.Account = e.DebtorAccount
                        return renderPage(w, tmpl, "enrollment", enrollmentPage)
                }</span>

                <span class="cov0" title="0">orgID := as.StoredParameter(OrgIDKey).(string)
                userID := as.StoredParameter(sessionParamUserID).(string)
                accs, err := accountService.Accounts(r.Context(), userID, orgID, page.NewPagination(nil, nil))
                if err != nil </span><span class="cov0" title="0">{
                        slog.ErrorContext(r.Context(), "could not load the user accounts", "error", err)
                        return goidc.StatusFailure, errors.New("could not load the user accounts")
                }</span>
                <span class="cov0" title="0">enrollmentPage.Accounts = accs.Records

                return renderPage(w, tmpl, "enrollment", enrollmentPage)</span>
        }

        <span class="cov0" title="0">return func(w http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                orgID := as.StoredParameter(OrgIDKey).(string)
                enrollmentID := as.StoredParameter(sessionParamEnrollmentID).(string)
                e, err := enrollmentService.Enrollment(r.Context(), enrollment.Query{ID: enrollmentID}, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>

                <span class="cov0" title="0">isConsented := r.PostFormValue(formParamConsent)
                if isConsented == "" </span><span class="cov0" title="0">{
                        if as.StoredParameter(sessionParamCPF) != e.UserIdentification </span><span class="cov0" title="0">{
                                slog.InfoContext(r.Context(), "enrollment was not created for the correct user")
                                info := "enrollment not created for the correct user"
                                reason := enrollment.RejectionReasonHybridFlowFailure
                                _ = enrollmentService.Cancel(r.Context(), e, enrollment.Cancellation{
                                        From:            payment.CancelledFromHolder,
                                        RejectionReason: &amp;reason,
                                        AdditionalInfo:  &amp;info,
                                })
                                return goidc.StatusFailure, errors.New("enrollment not created for the correct user")
                        }</span>

                        <span class="cov0" title="0">if e.BusinessIdentification != nil </span><span class="cov0" title="0">{
                                userID := as.StoredParameter(sessionParamUserID).(string)
                                business, err := userService.UserBusiness(r.Context(), userID, *e.BusinessIdentification, orgID)
                                if err != nil </span><span class="cov0" title="0">{
                                        slog.InfoContext(r.Context(), "could not fetch the business", "error", err)
                                        info := "user has no access to the business"
                                        reason := enrollment.RejectionReasonHybridFlowFailure
                                        _ = enrollmentService.Cancel(r.Context(), e, enrollment.Cancellation{
                                                From:            payment.CancelledFromHolder,
                                                RejectionReason: &amp;reason,
                                                AdditionalInfo:  &amp;info,
                                        })
                                        return goidc.StatusFailure, errors.New("user has no access to the business")
                                }</span>
                                <span class="cov0" title="0">as.StoreParameter(sessionParamBusinessID, business.ID.String())</span>
                        }

                        <span class="cov0" title="0">slog.InfoContext(r.Context(), "rendering enrollment page")
                        return renderEnrollmentPage(w, r, as, e)</span>
                }

                <span class="cov0" title="0">if isConsented != "true" </span><span class="cov0" title="0">{
                        info := "enrollment not granted"
                        reason := enrollment.RejectionReasonManualRejection
                        _ = enrollmentService.Cancel(r.Context(), e, enrollment.Cancellation{
                                From:            payment.CancelledFromHolder,
                                By:              &amp;e.UserIdentification,
                                RejectionReason: &amp;reason,
                                AdditionalInfo:  &amp;info,
                        })
                        return goidc.StatusFailure, errors.New("enrollment not granted")
                }</span>

                <span class="cov0" title="0">slog.InfoContext(r.Context(), "allowing enrollment", "enrollment_id", enrollmentID)

                accountID := uuid.MustParse(r.PostFormValue(formParamAccountID))
                e.DebtorAccountID = &amp;accountID

                if err := enrollmentService.AllowEnrollment(r.Context(), e); err != nil </span><span class="cov0" title="0">{
                        return goidc.StatusFailure, err
                }</span>
                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func grantAuthorizationStep() goidc.AuthnFunc <span class="cov0" title="0">{
        return func(_ http.ResponseWriter, r *http.Request, as *goidc.AuthnSession) (goidc.AuthnStatus, error) </span><span class="cov0" title="0">{
                slog.InfoContext(r.Context(), "auth flow finished, filling oauth session")

                sub := as.StoredParameter(sessionParamUserID).(string)
                if businessID := as.StoredParameter(sessionParamBusinessID); businessID != nil </span><span class="cov0" title="0">{
                        sub = businessID.(string)
                }</span>
                <span class="cov0" title="0">as.SetUserID(sub)
                as.GrantScopes(as.Scopes)
                as.SetIDTokenClaimACR(ACROpenBankingLOA2)
                as.SetIDTokenClaimAuthTime(timeutil.Timestamp())

                if as.Claims != nil </span><span class="cov0" title="0">{
                        if slices.Contains(as.Claims.IDTokenEssentials(), goidc.ClaimACR) </span><span class="cov0" title="0">{
                                as.SetIDTokenClaimACR(ACROpenBankingLOA2)
                        }</span>

                        <span class="cov0" title="0">if slices.Contains(as.Claims.UserInfoEssentials(), goidc.ClaimACR) </span><span class="cov0" title="0">{
                                as.SetUserInfoClaimACR(ACROpenBankingLOA2)
                        }</span>
                }

                <span class="cov0" title="0">return goidc.StatusSuccess, nil</span>
        }
}

func renderPage(w http.ResponseWriter, tmpl *template.Template, name string, data any) (goidc.AuthnStatus, error) <span class="cov0" title="0">{
        if !strings.HasSuffix(name, ".html") </span><span class="cov0" title="0">{
                name = name + ".html"
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        // TODO: What happens when an error occurs?
        if err := tmpl.ExecuteTemplate(w, name, data); err != nil </span><span class="cov0" title="0">{
                return goidc.StatusFailure, fmt.Errorf("could not render template: %w", err)
        }</span>
        <span class="cov0" title="0">return goidc.StatusInProgress, nil</span>
}
</pre>

		<pre class="file" id="file47" style="display: none">package oidc

import (
        "context"
        "crypto/x509"
        "encoding/pem"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "net/url"
        "slices"
        "strings"

        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/go-oidc/pkg/provider"
        "github.com/luikyv/mock-bank/internal/autopayment"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/enrollment"
        "github.com/luikyv/mock-bank/internal/payment"
)

const (
        HeaderClientCert = "X-Client-Cert"
)

func TokenOptionsFunc() goidc.TokenOptionsFunc <span class="cov0" title="0">{
        return func(gi goidc.GrantInfo, c *goidc.Client) goidc.TokenOptions </span><span class="cov0" title="0">{
                return goidc.NewJWTTokenOptions(goidc.PS256, 900)
        }</span>
}

func HandleGrantFunc(
        op *provider.Provider,
        consentService consent.Service,
        paymentService payment.Service,
        autoPaymentService autopayment.Service,
        enrollmentService enrollment.Service,
) goidc.HandleGrantFunc <span class="cov0" title="0">{

        verifyEnrollment := func(ctx context.Context, id, orgID string) error </span><span class="cov0" title="0">{
                e, err := enrollmentService.Enrollment(ctx, enrollment.Query{ID: id}, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not fetch enrollment for verifying grant: %w", err)
                }</span>

                <span class="cov0" title="0">if !slices.Contains([]enrollment.Status{
                        enrollment.StatusAwaitingEnrollment,
                        enrollment.StatusAuthorized,
                }, e.Status) </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidGrant, "enrollment is not in awaiting enrollment or authorized status")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">verifyRecurringPaymentConsent := func(ctx context.Context, id, orgID string) error </span><span class="cov0" title="0">{
                c, err := autoPaymentService.Consent(ctx, id, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not fetch payment consent for verifying grant: %w", err)
                }</span>

                <span class="cov0" title="0">if !slices.Contains([]autopayment.ConsentStatus{
                        autopayment.ConsentStatusAuthorized,
                        autopayment.ConsentStatusPartiallyAccepted,
                }, c.Status) </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidGrant, "payment consent is not authorized")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">verifyPaymentConsent := func(ctx context.Context, id, orgID string) error </span><span class="cov0" title="0">{
                c, err := paymentService.Consent(ctx, id, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not fetch payment consent for verifying grant: %w", err)
                }</span>

                <span class="cov0" title="0">if !slices.Contains([]payment.ConsentStatus{
                        payment.ConsentStatusAuthorized,
                        payment.ConsentStatusPartiallyAccepted,
                }, c.Status) </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidGrant, "payment consent is not authorized")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">verifyConsent := func(ctx context.Context, id, orgID string) error </span><span class="cov0" title="0">{
                c, err := consentService.Consent(ctx, id, orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not fetch consent for verifying grant: %w", err)
                }</span>

                <span class="cov0" title="0">if c.Status != consent.StatusAuthorized </span><span class="cov0" title="0">{
                        return goidc.NewError(goidc.ErrorCodeInvalidGrant, "consent is not authorized")
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return func(r *http.Request, gi *goidc.GrantInfo) error </span><span class="cov0" title="0">{
                if gi.AdditionalTokenClaims == nil </span><span class="cov0" title="0">{
                        gi.AdditionalTokenClaims = make(map[string]any)
                }</span>
                <span class="cov0" title="0">client, err := op.Client(r.Context(), gi.ClientID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("could not get client for verifying grant: %w", err)
                }</span>

                <span class="cov0" title="0">orgID := client.CustomAttribute(OrgIDKey).(string)
                gi.AdditionalTokenClaims[OrgIDKey] = orgID

                if enrollmentID, _ := enrollment.IDFromScopes(gi.ActiveScopes); enrollmentID != "" </span><span class="cov0" title="0">{
                        return verifyEnrollment(r.Context(), enrollmentID, orgID)
                }</span>

                <span class="cov0" title="0">if recurringConsentID, _ := autopayment.ConsentIDFromScopes(gi.ActiveScopes); recurringConsentID != "" </span><span class="cov0" title="0">{
                        return verifyRecurringPaymentConsent(r.Context(), recurringConsentID, orgID)
                }</span>

                <span class="cov0" title="0">if consentID, _ := consent.IDFromScopes(gi.ActiveScopes); consentID != "" </span><span class="cov0" title="0">{
                        if strings.Contains(gi.ActiveScopes, payment.Scope.ID) </span><span class="cov0" title="0">{
                                return verifyPaymentConsent(r.Context(), consentID, orgID)
                        }</span>
                        <span class="cov0" title="0">return verifyConsent(r.Context(), consentID, orgID)</span>
                }

                <span class="cov0" title="0">return nil</span>
        }
}

func HandlePARSessionFunc() goidc.HandleSessionFunc <span class="cov0" title="0">{
        return func(r *http.Request, as *goidc.AuthnSession, c *goidc.Client) error </span><span class="cov0" title="0">{
                as.StoreParameter(OrgIDKey, c.CustomAttribute(OrgIDKey))
                return nil
        }</span>
}

func ShouldIssueRefreshTokenFunc() goidc.ShouldIssueRefreshTokenFunc <span class="cov0" title="0">{
        return func(client *goidc.Client, grantInfo goidc.GrantInfo) bool </span><span class="cov0" title="0">{
                return slices.Contains(client.GrantTypes, goidc.GrantRefreshToken) &amp;&amp;
                        (grantInfo.GrantType == goidc.GrantAuthorizationCode || grantInfo.GrantType == goidc.GrantRefreshToken)
        }</span>
}

func ClientCert(r *http.Request) (*x509.Certificate, error) <span class="cov0" title="0">{
        rawClientCert := r.Header.Get(HeaderClientCert)
        if rawClientCert == "" </span><span class="cov0" title="0">{
                return nil, errors.New("the client certificate was not informed")
        }</span>

        // Apply URL decoding.
        <span class="cov0" title="0">rawClientCert, err := url.QueryUnescape(rawClientCert)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not url decode the client certificate: %w", err)
        }</span>

        <span class="cov0" title="0">clientCertPEM, _ := pem.Decode([]byte(rawClientCert))
        if clientCertPEM == nil </span><span class="cov0" title="0">{
                return nil, errors.New("could not decode the client certificate")
        }</span>

        <span class="cov0" title="0">clientCert, err := x509.ParseCertificate(clientCertPEM.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse the client certificate: %w", err)
        }</span>

        <span class="cov0" title="0">return clientCert, nil</span>
}

func LogError(ctx context.Context, err error) <span class="cov0" title="0">{
        slog.InfoContext(ctx, "error during request", slog.String("error", err.Error()))
}</span>
</pre>

		<pre class="file" id="file48" style="display: none">package page

const (
        defaultPageSize = 25
)

type Page[T any] struct {
        // Records are the records found for the page requested.
        Records []T
        // TotalRecords is the total number of records available.
        TotalRecords int
        // TotalPages is the total number of pages based on Size and TotalRecords.
        TotalPages int
        Pagination
}

func New[T any](records []T, pagination Pagination, totalRecords int) Page[T] <span class="cov0" title="0">{
        return Page[T]{
                Records:      records,
                TotalRecords: totalRecords,
                // Adding (pagination.Size - 1) ensures a correct rounding up for partial pages.
                TotalPages: (totalRecords + pagination.Size - 1) / pagination.Size,
                Pagination: pagination,
        }
}</span>

type Pagination struct {
        // Number is the page number requested starting from 1.
        Number int
        // Size is the page size requested.
        Size int
}

// Offset returns the zero-based offset.
func (p Pagination) Offset() int <span class="cov0" title="0">{
        if p.Number &lt;= 1 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return (p.Number - 1) * p.Size</span>
}

// Limit returns the number of items to retrieve.
func (p Pagination) Limit() int <span class="cov0" title="0">{
        return p.Size
}</span>

func NewPagination(pageNumber *int32, pageSize *int32) Pagination <span class="cov0" title="0">{
        pagination := Pagination{
                Number: 1,
                Size:   defaultPageSize,
        }

        if pageNumber != nil &amp;&amp; *pageNumber &gt; 0 </span><span class="cov0" title="0">{
                pagination.Number = int(*pageNumber)
        }</span>

        <span class="cov0" title="0">if pageSize != nil &amp;&amp; *pageSize &gt; 0 &amp;&amp; *pageSize &lt;= 1000 </span><span class="cov0" title="0">{
                pagination.Size = int(*pageSize)
        }</span>

        <span class="cov0" title="0">return pagination</span>
}
</pre>

		<pre class="file" id="file49" style="display: none">package payment

import (
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

const (
        ConsentURNPrefix = "urn:mockbank:consent:"
)

var (
        Scope = goidc.NewScope("payments")
)

type Payment struct {
        ID                        uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Status                    Status
        StatusUpdatedAt           timeutil.DateTime
        EndToEndID                string
        LocalInstrument           LocalInstrument
        Amount                    string
        Currency                  string
        CreditorAccountISBP       string
        CreditorAccountIssuer     *string
        CreditorAccountNumber     string
        CreditorAccountType       AccountType
        RemittanceInformation     *string
        QRCode                    *string
        Proxy                     *string
        CNPJInitiator             string
        TransactionIdentification *string
        IBGETownCode              *string
        AuthorisationFlow         *AuthorisationFlow
        ConsentID                 uuid.UUID
        EnrollmentID              *uuid.UUID
        ClientID                  string
        DebtorAccountID           *uuid.UUID `gorm:"column:account_id"`
        DebtorAccount             *account.Account
        Date                      timeutil.BrazilDate
        Rejection                 *Rejection    `gorm:"serializer:json"`
        Cancellation              *Cancellation `gorm:"serializer:json"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Payment) TableName() string <span class="cov0" title="0">{
        return "payments"
}</span>

func (p Payment) PaymentAmount() string <span class="cov0" title="0">{
        return p.Amount
}</span>

type Status string

const (
        StatusRCVD Status = "RCVD" // Received.
        StatusCANC Status = "CANC" // Cancelled.
        StatusACCP Status = "ACCP" // Accepted Customer Profile.
        StatusACPD Status = "ACPD" // Accepted Clearing Processed.
        StatusRJCT Status = "RJCT" // Rejected.
        StatusACSC Status = "ACSC" // Accepted Settlement Completed Debitor Account.
        StatusPDNG Status = "PDNG" // Pending.
        StatusSCHD Status = "SCHD" // Scheduled.
)

type Rejection struct {
        Code   RejectionReasonCode `json:"code"`
        Detail string              `json:"detail"`
}

type RejectionReasonCode string

const (
        RejectionInsufficientBalance             RejectionReasonCode = "SALDO_INSUFICIENTE"
        RejectionExceedsLimit                    RejectionReasonCode = "VALOR_ACIMA_LIMITE"
        RejectionInvalidAmount                   RejectionReasonCode = "VALOR_INVALIDO"
        RejectionInvalidCharge                   RejectionReasonCode = "COBRANCA_INVALIDA"
        RejectionNotInformed                     RejectionReasonCode = "NAO_INFORMADO"
        RejectionPaymentConsentMismatch          RejectionReasonCode = "PAGAMENTO_DIVERGENTE_CONSENTIMENTO"
        RejectionInvalidPaymentDetail            RejectionReasonCode = "DETALHE_PAGAMENTO_INVALIDO"
        RejectionRefusedByHolder                 RejectionReasonCode = "PAGAMENTO_RECUSADO_DETENTORA"
        RejectionRefusedBySPI                    RejectionReasonCode = "PAGAMENTO_RECUSADO_SPI"
        RejectionInfrastructureFailure           RejectionReasonCode = "FALHA_INFRAESTRUTURA"
        RejectionSPIFailure                      RejectionReasonCode = "FALHA_INFRAESTRUTURA_SPI"
        RejectionDICTFailure                     RejectionReasonCode = "FALHA_INFRAESTRUTURA_DICT"
        RejectionICPFailure                      RejectionReasonCode = "FALHA_INFRAESTRUTURA_ICP"
        RejectionReceiverPSPFailure              RejectionReasonCode = "FALHA_INFRAESTRUTURA_PSP_RECEBEDOR"
        RejectionHolderInstitutionFailure        RejectionReasonCode = "FALHA_INFRAESTRUTURA_DETENTORA"
        RejectionSameOriginAndDestinationAccount RejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        RejectionPaymentSchedulingFailure        RejectionReasonCode = "FALHA_AGENDAMENTO_PAGAMENTOS"
)

type Cancellation struct {
        Reason CancellationReason `json:"cancellation_reason"`
        From   CancelledFrom      `json:"cancellation_from"`
        At     timeutil.DateTime  `json:"cancelled_at"`
        By     string             `json:"cancelled_by"`
}

type CancellationReason string

const (
        CancellationReasonPending   CancellationReason = "CANCELADO_PENDENCIA"
        CancellationReasonScheduled CancellationReason = "CANCELADO_AGENDAMENTO"
)

type CancelledFrom string

const (
        CancelledFromInitiator CancelledFrom = "INICIADORA"
        CancelledFromHolder    CancelledFrom = "DETENTORA"
)

type Consent struct {
        ID                         uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Status                     ConsentStatus
        StatusUpdatedAt            timeutil.DateTime
        ExpiresAt                  timeutil.DateTime
        OwnerID                    uuid.UUID
        UserIdentification         string
        UserRel                    consent.Relation
        BusinessIdentification     *string
        BusinessRel                *consent.Relation
        ClientID                   string
        CreditorType               CreditorType
        CreditorCPFCNPJ            string `gorm:"column:creditor_cpf_cnpj"`
        CreditorName               string
        CreditorAccountISBP        string
        CreditorAccountIssuer      *string
        CreditorAccountNumber      string
        CreditorAccountType        AccountType
        PaymentType                Type
        PaymentSchedule            *Schedule `gorm:"serializer:json"`
        PaymentDate                *timeutil.BrazilDate
        PaymentCurrency            string
        PaymentAmount              string
        IBGETownCode               *string
        LocalInstrument            LocalInstrument
        QRCode                     *string
        Proxy                      *string
        DebtorAccountID            *uuid.UUID `gorm:"column:account_id"`
        DebtorAccount              *account.Account
        Rejection                  *ConsentRejection `gorm:"serializer:json"`
        EnrollmentID               *uuid.UUID
        EnrollmentChallenge        *string
        EnrollmentTransactionLimit *string
        EnrollmentDailyLimit       *string

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Consent) TableName() string <span class="cov0" title="0">{
        return "payment_consents"
}</span>

func (c Consent) URN() string <span class="cov0" title="0">{
        return ConsentURN(c.ID)
}</span>

func (c Consent) PaymentDates() []timeutil.BrazilDate <span class="cov0" title="0">{
        if c.PaymentDate != nil </span><span class="cov0" title="0">{
                return []timeutil.BrazilDate{*c.PaymentDate}
        }</span>

        <span class="cov0" title="0">schedule := c.PaymentSchedule
        switch </span>{
        case schedule.Single != nil:<span class="cov0" title="0">
                return []timeutil.BrazilDate{schedule.Single.Date}</span>

        case schedule.Daily != nil:<span class="cov0" title="0">
                start := schedule.Daily.StartDate
                var dates []timeutil.BrazilDate
                for i := range schedule.Daily.Quantity </span><span class="cov0" title="0">{
                        dates = append(dates, start.AddDate(0, 0, i))
                }</span>
                <span class="cov0" title="0">return dates</span>

        case schedule.Weekly != nil:<span class="cov0" title="0">
                // TODO: Use DayOfWeek to find the first occurrence of the target weekday on or after the start date.
                start := schedule.Weekly.StartDate
                var dates []timeutil.BrazilDate
                for i := range schedule.Weekly.Quantity </span><span class="cov0" title="0">{
                        dates = append(dates, start.AddDate(0, 0, i*7))
                }</span>
                <span class="cov0" title="0">return dates</span>

        case schedule.Monthly != nil:<span class="cov0" title="0">
                // TODO: Use DayOfMonth to find the first occurrence of the target day of month on or after the start date.
                start := schedule.Monthly.StartDate
                var dates []timeutil.BrazilDate
                for i := range schedule.Monthly.Quantity </span><span class="cov0" title="0">{
                        dates = append(dates, start.AddDate(0, i, 0))
                }</span>
                <span class="cov0" title="0">return dates</span>

        case schedule.Custom != nil:<span class="cov0" title="0">
                return schedule.Custom.Dates</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type ConsentStatus string

const (
        ConsentStatusAwaitingAuthorization ConsentStatus = "AWAITING_AUTHORISATION"
        ConsentStatusAuthorized            ConsentStatus = "AUTHORISED"
        ConsentStatusRejected              ConsentStatus = "REJECTED"
        ConsentStatusPartiallyAccepted     ConsentStatus = "PARTIALLY_ACCEPTED"
        ConsentStatusConsumed              ConsentStatus = "CONSUMED"
)

type CreditorType string

const (
        CreditorTypeIndividual CreditorType = "PESSOA_NATURAL"
        CreditorTypeCompany    CreditorType = "PESSOA_JURIDICA"
)

type Type string

const (
        TypePIX Type = "PIX"
)

type DayOfWeek string

const (
        DayOfWeekMonday    DayOfWeek = "SEGUNDA_FEIRA"
        DayOfWeekTuesday   DayOfWeek = "TERCA_FEIRA"
        DayOfWeekWednesday DayOfWeek = "QUARTA_FEIRA"
        DayOfWeekThursday  DayOfWeek = "QUINTA_FEIRA"
        DayOfWeekFriday    DayOfWeek = "SEXTA_FEIRA"
        DayOfWeekSaturday  DayOfWeek = "SABADO"
        DayOfWeekSunday    DayOfWeek = "DOMINGO"
)

type LocalInstrument string

const (
        LocalInstrumentMANU LocalInstrument = "MANU" // Manual.
        LocalInstrumentDICT LocalInstrument = "DICT" // PIX key.
        LocalInstrumentQRDN LocalInstrument = "QRDN" // Dynamic QR code.
        LocalInstrumentQRES LocalInstrument = "QRES" // Static QR code.
        LocalInstrumentINIC LocalInstrument = "INIC" // Initiator.
)

type AccountType string

const (
        AccountTypeCACC AccountType = "CACC" // Current.
        AccountTypeSVGS AccountType = "SVGS" // Savings.
        AccountTypeTRAN AccountType = "TRAN" // Transacting account.
)

func ConvertAccountType(accType account.Type) AccountType <span class="cov0" title="0">{
        switch accType </span>{
        case account.TypeCheckingAccount:<span class="cov0" title="0">
                return AccountTypeCACC</span>
        case account.TypeSavingsAccount:<span class="cov0" title="0">
                return AccountTypeSVGS</span>
        case account.TypePrepaidPayment:<span class="cov0" title="0">
                return AccountTypeTRAN</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

type Schedule struct {
        Single *struct {
                Date timeutil.BrazilDate `json:"date"`
        } `json:"single,omitempty"`
        Daily *struct {
                StartDate timeutil.BrazilDate `json:"startDate"`
                Quantity  int                 `json:"quantity"`
        } `json:"daily,omitempty"`
        Weekly *struct {
                DayOfWeek DayOfWeek           `json:"dayOfWeek"`
                StartDate timeutil.BrazilDate `json:"startDate"`
                Quantity  int                 `json:"quantity"`
        } `json:"weekly,omitempty"`
        Monthly *struct {
                DayOfMonth int                 `json:"dayOfMonth"`
                StartDate  timeutil.BrazilDate `json:"startDate"`
                Quantity   int                 `json:"quantity"`
        } `json:"monthly,omitempty"`
        Custom *struct {
                Dates          []timeutil.BrazilDate `json:"dates"`
                AdditionalInfo string                `json:"additionalInformation,omitempty"`
        } `json:"custom,omitempty"`
}

type ConsentRejection struct {
        Code   ConsentRejectionReasonCode `json:"code"`
        Detail string                     `json:"detail"`
}

type ConsentRejectionReasonCode string

const (
        ConsentRejectionInvalidAmount               ConsentRejectionReasonCode = "VALOR_INVALIDO"
        ConsentRejectionNotProvided                 ConsentRejectionReasonCode = "NAO_INFORMADO"
        ConsentRejectionInfrastructureFailure       ConsentRejectionReasonCode = "FALHA_INFRAESTRUTURA"
        ConsentRejectionAuthorizationTimeout        ConsentRejectionReasonCode = "TEMPO_EXPIRADO_AUTORIZACAO"
        ConsentRejectionConsumptionTimeout          ConsentRejectionReasonCode = "TEMPO_EXPIRADO_CONSUMO"
        ConsentRejectionRejectedByUser              ConsentRejectionReasonCode = "REJEITADO_USUARIO"
        ConsentRejectionSourceAndTargetAccountsSame ConsentRejectionReasonCode = "CONTAS_ORIGEM_DESTINO_IGUAIS"
        ConsentRejectionAccountDoesNotAllowPayment  ConsentRejectionReasonCode = "CONTA_NAO_PERMITE_PAGAMENTO"
        ConsentRejectionInsufficientFunds           ConsentRejectionReasonCode = "SALDO_INSUFICIENTE"
        ConsentRejectionAmountAboveLimit            ConsentRejectionReasonCode = "VALOR_ACIMA_LIMITE"
        ConsentRejectionInvalidQRCode               ConsentRejectionReasonCode = "QRCODE_INVALIDO"
)

type Account struct {
        ISPB   string      `json:"ispb"`
        Issuer *string     `json:"issuer,omitempty"`
        Number string      `json:"number"`
        Type   AccountType `json:"accountType"`
}

type AuthorisationFlow string

const (
        AuthorisationFlowHybridFlow AuthorisationFlow = "HYBRID_FLOW"
        AuthorisationFlowCIBAFlow   AuthorisationFlow = "CIBA_FLOW"
        AuthorisationFlowFIDOFlow   AuthorisationFlow = "FIDO_FLOW"
)

type EnrollmentOptions struct {
        EnrollmentID           uuid.UUID
        UserIdentification     string
        BusinessIdentification *string
        DebtorAccountID        *uuid.UUID
        Challenge              string
        TransactionLimit       string
        DailyLimit             string
}

func parseWeekday(weekDay DayOfWeek) time.Weekday <span class="cov0" title="0">{
        switch weekDay </span>{
        case "DOMINGO":<span class="cov0" title="0">
                return time.Sunday</span>
        case "SEGUNDA_FEIRA":<span class="cov0" title="0">
                return time.Monday</span>
        case "TERCA_FEIRA":<span class="cov0" title="0">
                return time.Tuesday</span>
        case "QUARTA_FEIRA":<span class="cov0" title="0">
                return time.Wednesday</span>
        case "QUINTA_FEIRA":<span class="cov0" title="0">
                return time.Thursday</span>
        case "SEXTA_FEIRA":<span class="cov0" title="0">
                return time.Friday</span>
        case "SABADO":<span class="cov0" title="0">
                return time.Saturday</span>
        default:<span class="cov0" title="0">
                return time.Sunday</span>
        }
}

type Filter struct {
        ConsentID    string
        EnrollmentID string
        Statuses     []Status
        From         *timeutil.BrazilDate
        To           *timeutil.BrazilDate
}
</pre>

		<pre class="file" id="file50" style="display: none">package payment

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "reflect"
        "slices"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/account"
        "github.com/luikyv/mock-bank/internal/api"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/errorutil"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "github.com/luikyv/mock-bank/internal/user"
        "github.com/luikyv/mock-bank/internal/webhook"
        "gorm.io/gorm"
)

const endToEndTimeFormat = "200601021504" // yyyyMMddHHmm.

type Service struct {
        db             *gorm.DB
        userService    user.Service
        accountService account.Service
        webhookService webhook.Service
        version        string
}

func NewService(db *gorm.DB, userService user.Service, accountService account.Service, webhookService webhook.Service) Service <span class="cov0" title="0">{
        return Service{db: db, userService: userService, accountService: accountService, webhookService: webhookService, version: "v0"}
}</span>

func (s Service) WithVersion(version string) Service <span class="cov0" title="0">{
        s.version = version
        return s
}</span>

func (s Service) CreateConsent(ctx context.Context, c *Consent, debtorAcc *Account) error <span class="cov0" title="0">{
        if err := s.validateConsent(ctx, c, debtorAcc); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.Status = ConsentStatusAwaitingAuthorization
        c.StatusUpdatedAt = timeutil.DateTimeNow()
        c.ExpiresAt = timeutil.DateTimeNow().Add(5 * time.Minute)

        u, err := s.userService.User(ctx, user.Query{CPF: c.UserIdentification}, c.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.OwnerID = u.ID

        if c.BusinessIdentification != nil </span><span class="cov0" title="0">{
                business, err := s.userService.User(ctx, user.Query{CNPJ: *c.BusinessIdentification}, c.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.OwnerID = business.ID</span>
        }

        <span class="cov0" title="0">if debtorAcc == nil </span><span class="cov0" title="0">{
                return s.db.WithContext(ctx).Create(c).Error
        }</span>

        <span class="cov0" title="0">acc, err := s.accountService.Account(ctx, account.Query{Number: debtorAcc.Number}, c.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if acc.OwnerID != c.OwnerID </span><span class="cov0" title="0">{
                return ErrUserDoesntMatchAccount
        }</span>

        <span class="cov0" title="0">c.DebtorAccountID = &amp;acc.ID

        if err := s.runConsentPreCreationAutomations(ctx, c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.db.WithContext(ctx).Create(c).Error</span>
}

func (s Service) AuthorizeConsent(ctx context.Context, c *Consent) error <span class="cov0" title="0">{

        if c.Status != ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                return errorutil.Format("%w: consent is not awaiting authorization", ErrInvalidConsentStatus)
        }</span>

        <span class="cov0" title="0">c.ExpiresAt = timeutil.DateTimeNow().Add(60 * time.Minute)

        // Load debtor account if not already loaded.
        if c.DebtorAccount == nil &amp;&amp; c.DebtorAccountID != nil </span><span class="cov0" title="0">{
                accID := *c.DebtorAccountID
                acc, err := s.accountService.Account(ctx, account.Query{ID: accID.String()}, c.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">c.DebtorAccount = acc</span>
        }

        <span class="cov0" title="0">if c.DebtorAccount != nil &amp;&amp; c.DebtorAccount.SubType == account.SubTypeJointSimple </span><span class="cov0" title="0">{
                return s.updateConsentStatus(ctx, c, ConsentStatusPartiallyAccepted)
        }</span>
        <span class="cov0" title="0">return s.updateConsentStatus(ctx, c, ConsentStatusAuthorized)</span>
}

func (s Service) Consent(ctx context.Context, id, orgID string) (*Consent, error) <span class="cov0" title="0">{
        id = strings.TrimPrefix(id, ConsentURNPrefix)
        c := &amp;Consent{}
        if err := s.db.WithContext(ctx).Preload("DebtorAccount").First(c, "id = ? AND org_id = ?", id, orgID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if ctx.Value(api.CtxKeyClientID) != nil &amp;&amp; ctx.Value(api.CtxKeyClientID) != c.ClientID </span><span class="cov0" title="0">{
                return nil, ErrClientNotAllowed
        }</span>

        <span class="cov0" title="0">if err := s.runConsentPostCreationAutomations(ctx, c); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

func (s Service) EnrollConsent(ctx context.Context, id, orgID string, opts EnrollmentOptions) error <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if c.Status != ConsentStatusAwaitingAuthorization </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment consent is not in awaiting authorization status", ErrInvalidConsentStatus)
        }</span>

        <span class="cov0" title="0">if c.UserIdentification != opts.UserIdentification </span><span class="cov0" title="0">{
                return errorutil.New("payment consent user identification mismatch")
        }</span>

        <span class="cov0" title="0">if !reflect.DeepEqual(c.BusinessIdentification, opts.BusinessIdentification) </span><span class="cov0" title="0">{
                return errorutil.New("payment consent business identification mismatch")
        }</span>

        <span class="cov0" title="0">if c.EnrollmentID != nil </span><span class="cov0" title="0">{
                return errorutil.New("payment consent already has an enrollment")
        }</span>

        <span class="cov0" title="0">c.EnrollmentID = &amp;opts.EnrollmentID
        c.DebtorAccountID = opts.DebtorAccountID
        c.EnrollmentChallenge = &amp;opts.Challenge
        c.EnrollmentTransactionLimit = &amp;opts.TransactionLimit
        c.EnrollmentDailyLimit = &amp;opts.DailyLimit
        return s.updateConsent(ctx, c)</span>
}

func (s Service) CreatePayments(ctx context.Context, payments []*Payment) error <span class="cov0" title="0">{

        firstPayment := payments[0]
        consentID := firstPayment.ConsentID
        if consentID == uuid.Nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: could not infer consent id", ErrMissingValue)
        }</span>

        <span class="cov0" title="0">orgID := firstPayment.OrgID
        c, err := s.Consent(ctx, consentID.String(), orgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if c.Status == ConsentStatusPartiallyAccepted </span><span class="cov0" title="0">{
                return ErrConsentPartiallyAccepted
        }</span>

        <span class="cov0" title="0">if c.Status != ConsentStatusAuthorized </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment consent is not in authorized status", ErrInvalidConsentStatus)
        }</span>

        <span class="cov0" title="0">if err := s.updateConsentStatus(ctx, c, ConsentStatusConsumed); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.validatePayments(ctx, c, payments); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, p := range payments </span><span class="cov0" title="0">{
                p.Status = StatusRCVD
                p.DebtorAccountID = c.DebtorAccountID
                p.DebtorAccount = c.DebtorAccount
                date, _ := ParseEndToEndDate(p.EndToEndID)
                p.Date = date.BrazilDate()

                if err := s.runPreCreationAutomations(ctx, p); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return s.db.Create(&amp;payments).Error</span>
}

func (s Service) Payment(ctx context.Context, id, orgID string) (*Payment, error) <span class="cov0" title="0">{
        p := &amp;Payment{}
        if err := s.db.WithContext(ctx).Preload("DebtorAccount").First(p, "id = ? AND org_id = ?", id, orgID).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if clientID := ctx.Value(api.CtxKeyClientID); clientID != nil &amp;&amp; clientID != p.ClientID </span><span class="cov0" title="0">{
                return nil, ErrClientNotAllowed
        }</span>

        <span class="cov0" title="0">if err := s.runPostCreationAutomations(ctx, p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (s Service) Payments(ctx context.Context, orgID string, filter *Filter) ([]*Payment, error) <span class="cov0" title="0">{
        payments, err := s.payments(ctx, orgID, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, p := range payments </span><span class="cov0" title="0">{
                if err := s.runPostCreationAutomations(ctx, p); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return payments, nil</span>
}

func (s Service) Cancel(ctx context.Context, id, orgID string, doc consent.Document) (*Payment, error) <span class="cov0" title="0">{
        p, err := s.Payment(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c, err := s.Consent(ctx, p.ConsentID.String(), orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if doc.Rel != consent.RelationCPF </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid rel", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">if c.UserIdentification != doc.Identification </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid identification", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">if err := s.cancel(ctx, p, CancelledFromInitiator, c.UserIdentification); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return p, nil</span>
}

func (s Service) CancelAll(ctx context.Context, consentID, orgID string, doc consent.Document) ([]*Payment, error) <span class="cov0" title="0">{
        c, err := s.Consent(ctx, consentID, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if doc.Rel != consent.RelationCPF </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid rel", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">if c.UserIdentification != doc.Identification </span><span class="cov0" title="0">{
                return nil, errorutil.Format("%w: invalid identification", ErrCancelNotAllowed)
        }</span>

        <span class="cov0" title="0">payments, err := s.payments(ctx, orgID, &amp;Filter{ConsentID: c.ID.String()})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cancelled []*Payment
        var cancelErrs error
        for _, p := range payments </span><span class="cov0" title="0">{
                if err := s.cancel(ctx, p, CancelledFromInitiator, c.UserIdentification); err != nil </span><span class="cov0" title="0">{
                        if !errors.Is(err, ErrCancelNotAllowed) </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">cancelErrs = errors.Join(cancelErrs, err)
                        continue</span>
                }
                <span class="cov0" title="0">cancelled = append(cancelled, p)</span>
        }

        <span class="cov0" title="0">if len(cancelled) == 0 </span><span class="cov0" title="0">{
                return nil, errorutil.Format("no payment could be cancelled: %w", cancelErrs)
        }</span>

        <span class="cov0" title="0">return cancelled, nil</span>
}

func (s Service) RejectConsentByID(ctx context.Context, id, orgID string, code ConsentRejectionReasonCode, detail string) (*Consent, error) <span class="cov0" title="0">{
        c, err := s.Consent(ctx, id, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return c, s.RejectConsent(ctx, c, code, detail)</span>
}

func (s Service) RejectConsent(ctx context.Context, c *Consent, code ConsentRejectionReasonCode, detail string) error <span class="cov0" title="0">{
        if c.Status == ConsentStatusRejected </span><span class="cov0" title="0">{
                return ErrConsentAlreadyRejected
        }</span>

        <span class="cov0" title="0">c.Rejection = &amp;ConsentRejection{
                Code:   code,
                Detail: detail,
        }
        return s.updateConsentStatus(ctx, c, ConsentStatusRejected)</span>
}

func (s Service) cancel(ctx context.Context, p *Payment, from CancelledFrom, by string) error <span class="cov0" title="0">{
        if !slices.Contains([]Status{StatusPDNG, StatusSCHD}, p.Status) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment with status %s cannot be cancelled, only payments with status PDNG or SCHD can be cancelled", ErrCancelNotAllowed, p.Status)
        }</span>

        <span class="cov0" title="0">if p.Status == StatusSCHD &amp;&amp; !timeutil.BrazilDateNow().Before(p.Date) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: scheduled payments can only be cancelled until 23:59 (BRT) of the day before the payment date (%s)", ErrCancelNotAllowed, p.Date.String())
        }</span>

        <span class="cov0" title="0">reason := CancellationReasonPending
        if p.Status == StatusSCHD </span><span class="cov0" title="0">{
                reason = CancellationReasonScheduled
        }</span>
        <span class="cov0" title="0">p.Cancellation = &amp;Cancellation{
                At:     timeutil.DateTimeNow(),
                Reason: reason,
                From:   from,
                By:     by,
        }
        return s.updateStatus(ctx, p, StatusCANC)</span>
}

func (s Service) reject(ctx context.Context, p *Payment, code RejectionReasonCode, detail string) error <span class="cov0" title="0">{
        p.Rejection = &amp;Rejection{
                Code:   code,
                Detail: detail,
        }
        return s.updateStatus(ctx, p, StatusRJCT)
}</span>

func (s Service) validateConsent(_ context.Context, c *Consent, debtorAccount *Account) error <span class="cov0" title="0">{
        if debtorAccount != nil &amp;&amp; c.CreditorAccountISBP == debtorAccount.ISPB &amp;&amp; c.CreditorAccountNumber == debtorAccount.Number </span><span class="cov0" title="0">{
                return ErrCreditorAndDebtorAccountsAreEqual
        }</span>

        <span class="cov0" title="0">if c.PaymentDate != nil &amp;&amp; c.PaymentDate.Before(timeutil.BrazilDateNow()) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment date must be in the future", ErrInvalidDate)
        }</span>

        <span class="cov0" title="0">if c.PaymentDate == nil &amp;&amp; c.PaymentSchedule == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: must provide either date or schedule", ErrMissingValue)
        }</span>

        <span class="cov0" title="0">if (c.PaymentDate != nil &amp;&amp; c.PaymentSchedule != nil) || (c.PaymentDate == nil &amp;&amp; c.PaymentSchedule == nil) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: cannot provide both date and schedule", ErrInvalidDate)
        }</span>

        <span class="cov0" title="0">if c.PaymentSchedule != nil </span><span class="cov0" title="0">{
                today := timeutil.BrazilDateNow()
                twoYearsLater := today.AddDate(2, 0, 0)

                startDate := today
                lastPaymentDate := twoYearsLater
                if single := c.PaymentSchedule.Single; single != nil </span><span class="cov0" title="0">{
                        startDate = single.Date
                        lastPaymentDate = single.Date
                }</span>

                <span class="cov0" title="0">if daily := c.PaymentSchedule.Daily; daily != nil </span><span class="cov0" title="0">{
                        startDate = daily.StartDate
                        lastPaymentDate = daily.StartDate.AddDate(0, 0, daily.Quantity-1)
                }</span>

                <span class="cov0" title="0">if weekly := c.PaymentSchedule.Weekly; weekly != nil </span><span class="cov0" title="0">{
                        startDate = weekly.StartDate
                        lastPaymentDate = weekly.StartDate.AddDate(0, 0, 7*(weekly.Quantity-1))
                }</span>

                <span class="cov0" title="0">if monthly := c.PaymentSchedule.Monthly; monthly != nil </span><span class="cov0" title="0">{
                        startDate = monthly.StartDate
                        lastPaymentDate = monthly.StartDate.AddDate(0, monthly.Quantity-1, 0)
                }</span>

                <span class="cov0" title="0">if custom := c.PaymentSchedule.Custom; custom != nil </span><span class="cov0" title="0">{
                        seenDates := map[string]struct{}{}
                        for _, date := range custom.Dates </span><span class="cov0" title="0">{
                                dateStr := date.String()

                                if _, exists := seenDates[dateStr]; exists </span><span class="cov0" title="0">{
                                        return errorutil.Format("%w: custom schedule contains duplicate date: %s", ErrInvalidData, dateStr)
                                }</span>
                                <span class="cov0" title="0">seenDates[dateStr] = struct{}{}

                                if date.Before(startDate) </span><span class="cov0" title="0">{
                                        startDate = date
                                }</span>
                                <span class="cov0" title="0">if date.After(lastPaymentDate) </span><span class="cov0" title="0">{
                                        lastPaymentDate = date
                                }</span>
                        }
                }

                <span class="cov0" title="0">if startDate.Before(today) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: schedule cannot start in the past", ErrInvalidDate)
                }</span>
                <span class="cov0" title="0">if lastPaymentDate.After(twoYearsLater) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: schedule cannot end more than 2 years from now", ErrInvalidDate)
                }</span>

        }

        <span class="cov0" title="0">if c.PaymentSchedule != nil &amp;&amp; c.PaymentSchedule.Single == nil &amp;&amp; !slices.Contains([]LocalInstrument{
                LocalInstrumentMANU,
                LocalInstrumentDICT,
                LocalInstrumentQRES,
        }, c.LocalInstrument) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: only MANU, DICT or QRES are allowed when using schedule other than single", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if c.LocalInstrument == LocalInstrumentMANU &amp;&amp; c.Proxy != nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: proxy must not be set when using local instrument MANU", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if c.LocalInstrument == LocalInstrumentDICT &amp;&amp; c.QRCode != nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: qr code is not allowed when using local instrument DICT", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]LocalInstrument{
                LocalInstrumentINIC,
                LocalInstrumentDICT,
                LocalInstrumentQRDN,
                LocalInstrumentQRES,
        }, c.LocalInstrument) &amp;&amp; c.Proxy == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: proxy must be set when using localInstrument INIC, DICT, QRDN or QRES", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]AccountType{
                AccountTypeCACC,
                AccountTypeSVGS,
        }, c.CreditorAccountType) &amp;&amp; c.CreditorAccountIssuer == nil </span><span class="cov0" title="0">{
                return errorutil.Format("%w: creditor account issuer is required for account types CACC or SVGS", ErrInvalidPayment)
        }</span>

        <span class="cov0" title="0">if debtorAccount != nil &amp;&amp; slices.Contains([]AccountType{
                AccountTypeCACC,
                AccountTypeSVGS,
        }, debtorAccount.Type) &amp;&amp; debtorAccount.Issuer == nil </span><span class="cov0" title="0">{
                return errorutil.New("debtor account issuer is required for account types CACC or SVGS")
        }</span>

        <span class="cov0" title="0">if c.PaymentCurrency != "BRL" </span><span class="cov0" title="0">{
                return errorutil.Format("%w: payment currency must be BRL", ErrInvalidData)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) runConsentPreCreationAutomations(_ context.Context, c *Consent) error <span class="cov0" title="0">{
        switch c.PaymentAmount </span>{
        case "10422.00":<span class="cov0" title="0">
                return ErrInvalidPayment</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (s Service) runConsentPostCreationAutomations(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        switch c.Status </span>{
        case ConsentStatusAwaitingAuthorization:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(c.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "payment consent awaiting authorization for too long, moving to rejected")
                        return s.RejectConsent(ctx, c, ConsentRejectionAuthorizationTimeout, "consent awaiting authorization for too long")
                }</span>

                <span class="cov0" title="0">switch c.PaymentAmount </span>{
                case "300.01":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionInvalidAmount, "forced rejection")</span>
                case "300.02":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionNotProvided, "forced rejection")</span>
                case "300.03":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionInfrastructureFailure, "forced rejection")</span>
                case "300.04":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionConsumptionTimeout, "forced rejection")</span>
                case "300.05":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionAccountDoesNotAllowPayment, "forced rejection")</span>
                case "300.06":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionInsufficientFunds, "forced rejection")</span>
                case "300.07":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionAmountAboveLimit, "forced rejection")</span>
                case "300.08":<span class="cov0" title="0">
                        return s.RejectConsent(ctx, c, ConsentRejectionInvalidQRCode, "forced rejection")</span>
                }
        case ConsentStatusPartiallyAccepted:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(c.StatusUpdatedAt.Add(3 * time.Minute).Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "payment consent partially accepted for more than 3 minutes, moving to authorized")
                        return s.updateConsentStatus(ctx, c, ConsentStatusAuthorized)
                }</span>
        case ConsentStatusAuthorized:<span class="cov0" title="0">
                if timeutil.DateTimeNow().After(c.ExpiresAt.Time) </span><span class="cov0" title="0">{
                        slog.DebugContext(ctx, "payment consent reached expiration, moving to rejected")
                        return s.RejectConsent(ctx, c, ConsentRejectionConsumptionTimeout, "payment consent authorization reached expiration")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) validatePayments(_ context.Context, c *Consent, payments []*Payment) error <span class="cov0" title="0">{
        dates := c.PaymentDates()
        if len(dates) != len(payments) </span><span class="cov0" title="0">{
                return errorutil.Format("%w: number of payments doesn't match schedule. got %d, expected %d", ErrPaymentDoesNotMatchConsent, len(payments), len(dates))
        }</span>

        <span class="cov0" title="0">consentID := payments[0].ConsentID

        for _, p := range payments </span><span class="cov0" title="0">{
                if p.ConsentID != consentID </span><span class="cov0" title="0">{
                        return errorutil.New("invalid payment: invalid consent id")
                }</span>

                <span class="cov0" title="0">if !reflect.DeepEqual(p.EnrollmentID, c.EnrollmentID) </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: payment enrollment id doesn't match the consent", ErrPaymentDoesNotMatchConsent)
                }</span>

                <span class="cov0" title="0">if p.EnrollmentID != nil &amp;&amp; (p.AuthorisationFlow == nil || *p.AuthorisationFlow != AuthorisationFlowFIDOFlow) </span><span class="cov0" title="0">{
                        return errorutil.New("payment enrollment id is set but authorisation flow is not FIDO")
                }</span>

                <span class="cov0" title="0">if p.EndToEndID == "" </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: end to end id is required", ErrMissingValue)
                }</span>

                <span class="cov0" title="0">endToEndDate, err := ParseEndToEndDate(p.EndToEndID)
                if err != nil </span><span class="cov0" title="0">{
                        return errorutil.Format("%w: invalid end to end id date: %w", ErrInvalidEndToEndID, err)
                }</span>

                // TODO: What if all end to end dates are for a same date and don't respect the schedule?
                <span class="cov0" title="0">if !slices.ContainsFunc(dates, func(d timeutil.BrazilDate) bool </span><span class="cov0" title="0">{
                        return endToEndDate.BrazilDate().Equal(d)
                }</span>) <span class="cov0" title="0">{
                        return errorutil.Format("%w: end to end id date doesn't match any of the scheduled dates", ErrInvalidEndToEndID)
                }</span>

                <span class="cov0" title="0">if slices.Contains([]LocalInstrument{
                        LocalInstrumentMANU,
                        LocalInstrumentDICT,
                }, p.LocalInstrument) &amp;&amp; p.TransactionIdentification != nil </span><span class="cov0" title="0">{
                        return errorutil.New("invalid consent: transaction identification is not allowed if local instrument is MANU or DICT")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) runPreCreationAutomations(_ context.Context, p *Payment) error <span class="cov0" title="0">{
        switch p.Amount </span>{
        case "20422.01":<span class="cov0" title="0">
                return ErrInvalidPayment</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

func (s Service) runPostCreationAutomations(ctx context.Context, p *Payment) error <span class="cov0" title="0">{
        now := timeutil.DateTimeNow()
        if now.Before(p.UpdatedAt.Add(5 * time.Second)) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "payment was updated less than 5 secs ago, skipping transitions", "updated_at", p.UpdatedAt.String())
                return nil
        }</span>

        <span class="cov0" title="0">slog.DebugContext(ctx, "evaluating payment automations", "status", p.Status, "amount", p.Amount)

        c, err := s.Consent(ctx, p.ConsentID.String(), p.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">switch p.Status </span>{
        case StatusRCVD:<span class="cov0" title="0">
                if p.LocalInstrument != c.LocalInstrument </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "local instrument does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if p.LocalInstrument == LocalInstrumentQRES &amp;&amp; p.TransactionIdentification != nil </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionInvalidPaymentDetail, "transaction identification is not allowed when using local instrument QRES")
                }</span>

                <span class="cov0" title="0">if p.Amount != c.PaymentAmount </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "amount does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if p.Currency != c.PaymentCurrency </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "currency does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if p.CreditorAccountISBP != c.CreditorAccountISBP </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "creditor account isbp does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if !reflect.DeepEqual(p.CreditorAccountIssuer, c.CreditorAccountIssuer) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "creditor account issuer does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if p.CreditorAccountNumber != c.CreditorAccountNumber </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "creditor account number does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if p.CreditorAccountType != c.CreditorAccountType </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "creditor account type does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if !reflect.DeepEqual(p.QRCode, c.QRCode) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "qr code does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if !reflect.DeepEqual(p.Proxy, c.Proxy) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionPaymentConsentMismatch, "proxy does not match the value specified in the consent")
                }</span>

                <span class="cov0" title="0">if c.EnrollmentTransactionLimit != nil &amp;&amp; ConvertAmount(p.Amount) &gt; ConvertAmount(*c.EnrollmentTransactionLimit) </span><span class="cov0" title="0">{
                        return s.reject(ctx, p, RejectionExceedsLimit, "payment amount is greater than the configured transaction limit in the consent")
                }</span>

                <span class="cov0" title="0">if c.EnrollmentDailyLimit != nil </span><span class="cov0" title="0">{
                        today := timeutil.BrazilDateNow()
                        payments, err := s.payments(ctx, c.OrgID, &amp;Filter{
                                EnrollmentID: p.EnrollmentID.String(),
                                Statuses:     []Status{StatusACSC, StatusSCHD},
                                From:         &amp;today,
                                To:           &amp;today,
                        })
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if ConvertAmount(p.Amount)+SumPayments(payments) &gt; ConvertAmount(*c.EnrollmentDailyLimit) </span><span class="cov0" title="0">{
                                return s.reject(ctx, p, RejectionExceedsLimit, "payment amount goes beyond the configured daily limit in the consent")
                        }</span>
                }

                <span class="cov0" title="0">return s.updateStatus(ctx, p, StatusACCP)</span>

        case StatusACCP:<span class="cov0" title="0">
                today := timeutil.BrazilDateNow()
                if p.Date.After(today) </span><span class="cov0" title="0">{
                        return s.updateStatus(ctx, p, StatusSCHD)
                }</span>
                <span class="cov0" title="0">return s.updateStatus(ctx, p, StatusACPD)</span>

        case StatusSCHD:<span class="cov0" title="0">
                today := timeutil.BrazilDateNow()
                if p.Date.After(today) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return s.updateStatus(ctx, p, StatusACPD)</span>

        case StatusACPD:<span class="cov0" title="0">
                return s.updateStatus(ctx, p, StatusACSC)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s Service) updateStatus(ctx context.Context, p *Payment, status Status) error <span class="cov0" title="0">{
        slog.DebugContext(ctx, "updating payment status", "current_status", p.Status, "new_status", status)

        p.Status = status
        p.StatusUpdatedAt = timeutil.DateTimeNow()
        if err := s.update(ctx, p); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update payment status: %w", err)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]Status{
                StatusPDNG,
                StatusSCHD,
                StatusACSC,
                StatusRJCT,
                StatusCANC,
        }, status) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "notifying client about payment status change")
                s.webhookService.Notify(ctx, p.ClientID, "/payments/"+s.version+"/pix/payments/"+p.ID.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) update(ctx context.Context, p *Payment) error <span class="cov0" title="0">{
        p.UpdatedAt = timeutil.DateTimeNow()
        return s.db.WithContext(ctx).
                Model(&amp;Payment{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", p.ID, p.OrgID).
                Updates(p).Error
}</span>

func (s Service) updateConsentStatus(ctx context.Context, c *Consent, status ConsentStatus) error <span class="cov0" title="0">{
        oldStatus := c.Status
        slog.DebugContext(ctx, "updating payment consent status", "current_status", oldStatus, "new_status", status)

        c.Status = status
        c.StatusUpdatedAt = timeutil.DateTimeNow()
        if err := s.updateConsent(ctx, c); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not update payment consent status: %w", err)
        }</span>

        <span class="cov0" title="0">if slices.Contains([]ConsentStatus{
                ConsentStatusRejected,
                ConsentStatusConsumed,
        }, status) || (oldStatus == ConsentStatusPartiallyAccepted &amp;&amp; status == ConsentStatusAuthorized) </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "notifying client about payment consent status change")
                s.webhookService.Notify(ctx, c.ClientID, "/payments/"+s.version+"/consents/"+c.URN())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) updateConsent(ctx context.Context, c *Consent) error <span class="cov0" title="0">{
        c.UpdatedAt = timeutil.DateTimeNow()
        return s.db.WithContext(ctx).
                Model(&amp;Consent{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ? AND org_id = ?", c.ID, c.OrgID).
                Updates(c).Error
}</span>

func (s Service) payments(ctx context.Context, orgID string, opts *Filter) ([]*Payment, error) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                opts = &amp;Filter{}
        }</span>

        <span class="cov0" title="0">query := s.db.WithContext(ctx).Where("org_id = ?", orgID)
        if opts.ConsentID != "" </span><span class="cov0" title="0">{
                query = query.Where("consent_id = ?", strings.TrimPrefix(opts.ConsentID, ConsentURNPrefix))
        }</span>
        <span class="cov0" title="0">if opts.EnrollmentID != "" </span><span class="cov0" title="0">{
                query = query.Where("enrollment_id = ?", opts.EnrollmentID)
        }</span>
        <span class="cov0" title="0">if opts.Statuses != nil </span><span class="cov0" title="0">{
                query = query.Where("status IN ?", opts.Statuses)
        }</span>
        <span class="cov0" title="0">if opts.From != nil </span><span class="cov0" title="0">{
                query = query.Where("date &gt;= ?", opts.From)
        }</span>
        <span class="cov0" title="0">if opts.To != nil </span><span class="cov0" title="0">{
                query = query.Where("date &lt;= ?", opts.To)
        }</span>

        <span class="cov0" title="0">var payments []*Payment
        if err := query.Find(&amp;payments).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not find payments: %w", err)
        }</span>

        <span class="cov0" title="0">return payments, nil</span>
}
</pre>

		<pre class="file" id="file51" style="display: none">package payment

import (
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/consent"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

// ParseEndToEndDate extracts and parses the datetime (yyyyMMddHHmm) from an end to end ID.
func ParseEndToEndDate(id string) (timeutil.DateTime, error) <span class="cov0" title="0">{
        dateStr := id[9:21]
        parsed, err := time.ParseInLocation(endToEndTimeFormat, dateStr, time.UTC)
        if err != nil </span><span class="cov0" title="0">{
                return timeutil.DateTime{}, err
        }</span>

        <span class="cov0" title="0">return timeutil.NewDateTime(parsed), nil</span>
}

func ConsentURN(id uuid.UUID) string <span class="cov0" title="0">{
        return ConsentURNPrefix + id.String()
}</span>

func ConsentIDFromScopes(scopes string) (string, bool) <span class="cov0" title="0">{
        for _, s := range strings.Split(scopes, " ") </span><span class="cov0" title="0">{
                if consent.ScopeID.Matches(s) </span><span class="cov0" title="0">{
                        return strings.TrimPrefix(s, "consent:"+ConsentURNPrefix), true
                }</span>
        }
        <span class="cov0" title="0">return "", false</span>
}

func SumPayments[T interface{ PaymentAmount() string }](payments []T) float64 <span class="cov0" title="0">{
        sum := 0.0
        for _, p := range payments </span><span class="cov0" title="0">{
                sum += ConvertAmount(p.PaymentAmount())
        }</span>
        <span class="cov0" title="0">return sum</span>
}

func ConvertAmount(v string) float64 <span class="cov0" title="0">{
        // TODO: Log this error.
        f, _ := strconv.ParseFloat(v, 64)
        return f
}</span>
</pre>

		<pre class="file" id="file52" style="display: none">package resource

import (
        "github.com/luikyv/go-oidc/pkg/goidc"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

var (
        Scope = goidc.NewScope("resources")
)

type Status string

const (
        StatusAvailable            Status = "AVAILABLE"
        StatusUnavailable          Status = "UNAVAILABLE"
        StatusPendingAuthorization Status = "PENDING_AUTHORISATION"
)

type Type string

const (
        TypeAccount Type = "ACCOUNT"
)

type Resource struct {
        ConsentID  string
        ResourceID string
        Status     Status
        Type       Type `gorm:"column:resource_type"`

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (Resource) TableName() string <span class="cov0" title="0">{
        return "consent_resources"
}</span>

type Filter struct {
        OwnerID   string
        ConsentID string
}
</pre>

		<pre class="file" id="file53" style="display: none">package resource

import (
        "context"
        "fmt"
        "time"

        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

type Service struct {
        db *gorm.DB
}

func NewService(db *gorm.DB) Service <span class="cov0" title="0">{
        return Service{
                db: db,
        }
}</span>

func (s Service) Resources(ctx context.Context, orgID string, filter Filter, pag page.Pagination) (page.Page[*Resource], error) <span class="cov0" title="0">{
        query := s.db.WithContext(ctx).Where("org_id = ?", orgID)
        if filter.OwnerID != "" </span><span class="cov0" title="0">{
                query = query.Where("owner_id = ?", filter.OwnerID)
        }</span>
        <span class="cov0" title="0">if filter.ConsentID != "" </span><span class="cov0" title="0">{
                query = query.Where("consent_id = ?", filter.ConsentID)
        }</span>

        <span class="cov0" title="0">var rs []*Resource
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;rs).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Resource]{}, fmt.Errorf("could not find consented resources: %w", err)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*Resource]{}, fmt.Errorf("count failed: %w", err)
        }</span>

        <span class="cov0" title="0">for i, r := range rs </span><span class="cov0" title="0">{
                // Allow access to resource if it is pending authorization for more than 3 minutes.
                if r.Status == StatusPendingAuthorization &amp;&amp; timeutil.DateTimeNow().After(r.UpdatedAt.Add(3*time.Minute).Time) </span><span class="cov0" title="0">{
                        rs[i].Status = StatusAvailable
                }</span>
        }

        <span class="cov0" title="0">return page.New(rs, pag, int(total)), nil</span>
}
</pre>

		<pre class="file" id="file54" style="display: none">package session

import (
        "database/sql/driver"
        "encoding/json"
        "fmt"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type Session struct {
        ID            uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Username      string
        Organizations Organizations `gorm:"type:jsonb"`
        CodeVerifier  string

        CreatedAt timeutil.DateTime
        ExpiresAt timeutil.DateTime
}

func (s Session) IsExpired() bool <span class="cov0" title="0">{
        return s.ExpiresAt.Before(timeutil.DateTimeNow())
}</span>

type Organizations map[string]struct {
        Name string `json:"name"`
}

func (o Organizations) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(o)
}</span>

func (o *Organizations) Scan(value any) error <span class="cov0" title="0">{
        bytes, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to convert value to []byte")
        }</span>
        <span class="cov0" title="0">return json.Unmarshal(bytes, o)</span>
}
</pre>

		<pre class="file" id="file55" style="display: none">package session

import (
        "context"
        "errors"
        "fmt"
        "time"

        "github.com/luikyv/mock-bank/internal/directory"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

type Service struct {
        db               *gorm.DB
        directoryService directory.Service
}

func NewService(db *gorm.DB, directoryService directory.Service) Service <span class="cov0" title="0">{
        return Service{
                db:               db,
                directoryService: directoryService,
        }
}</span>

func (s Service) Create(ctx context.Context) (session *Session, authURL string, err error) <span class="cov0" title="0">{
        authURL, codeVerifier, err := s.directoryService.AuthURL(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">session = &amp;Session{
                CodeVerifier: codeVerifier,
                ExpiresAt:    timeutil.DateTimeNow().Add(10 * time.Minute),
        }
        if err := s.db.WithContext(ctx).Create(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("could not create session: %w", err)
        }</span>

        <span class="cov0" title="0">return session, authURL, nil</span>
}

func (s Service) Authorize(ctx context.Context, sessionID, authCode string) error <span class="cov0" title="0">{
        var session Session
        if err := s.db.WithContext(ctx).First(&amp;session, "id = ?", sessionID).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not find session: %w", err)
        }</span>

        <span class="cov0" title="0">idTkn, err := s.directoryService.IDToken(ctx, authCode, session.CodeVerifier)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">session.Username = idTkn.Sub
        session.ExpiresAt = session.CreatedAt.Add(1 * time.Hour)
        session.CodeVerifier = ""
        session.Organizations = Organizations{}
        for orgID, org := range idTkn.Profile.OrgAccessDetails </span><span class="cov0" title="0">{
                session.Organizations[orgID] = struct {
                        Name string `json:"name"`
                }{
                        Name: org.Name,
                }
        }</span>

        <span class="cov0" title="0">if err := s.db.WithContext(ctx).
                Model(&amp;Session{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ?", sessionID).
                Updates(&amp;session).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not authorize session: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s Service) Session(ctx context.Context, id string) (*Session, error) <span class="cov0" title="0">{
        session := &amp;Session{}
        if err := s.db.WithContext(ctx).First(&amp;session, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("could not fetch session with id %s: %w", id, err)</span>
        }

        <span class="cov0" title="0">if session.IsExpired() </span><span class="cov0" title="0">{
                _ = s.Delete(ctx, id)
                return nil, ErrNotFound
        }</span>
        <span class="cov0" title="0">return session, nil</span>
}

func (s Service) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        if err := s.db.WithContext(ctx).Delete(&amp;Session{}, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not delete session with id %s: %w", id, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>

		<pre class="file" id="file56" style="display: none">package testutil

import (
        "testing"
        "time"

        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

const (
        OrgID = "mock-org-id"
        dsn   = "host=localhost port=5432 user=admin password=pass dbname=mockbank sslmode=disable connect_timeout=5"
)

var testDB *gorm.DB

func NewDB(t testing.TB) *gorm.DB <span class="cov0" title="0">{
        t.Helper()

        if testDB == nil </span><span class="cov0" title="0">{
                testDB = initDB(t)
        }</span>

        <span class="cov0" title="0">tx := testDB.Begin()
        if tx.Error != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to begin transaction: %v", tx.Error)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                if err := tx.Rollback().Error; err != nil </span><span class="cov0" title="0">{
                        t.Fatalf("failed to rollback transaction: %v", err)
                }</span>
        })

        <span class="cov0" title="0">return tx</span>
}

func initDB(t testing.TB) *gorm.DB <span class="cov0" title="0">{
        t.Helper()

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                NowFunc: func() time.Time </span><span class="cov0" title="0">{
                        return timeutil.DateTimeNow().Time
                }</span>,
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to connect to database: %v", err)
        }</span>

        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to get sql.DB from gorm DB: %v", err)
        }</span>
        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to ping database: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}

func PointerOf[T any](v T) *T <span class="cov0" title="0">{
        return &amp;v
}</span>
</pre>

		<pre class="file" id="file57" style="display: none">package timeutil

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"
)

const (
        DateTimeMillisFormat = "2006-01-02T15:04:05.000Z"
        dateTimeFormat       = "2006-01-02T15:04:05Z"
        dateFormat           = "2006-01-02"
)

var (
        brazilLocation, _ = time.LoadLocation("America/Sao_Paulo")
)

type DateTime struct {
        time.Time
}

func (d DateTime) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(d.String())
}</span>

func (d *DateTime) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var dateStr string
        err := json.Unmarshal(data, &amp;dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">parsed, err := time.Parse(dateTimeFormat, dateStr)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">d.Time = parsed.UTC()
        return nil</span>
}

func (d *DateTime) Scan(value any) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                d.Time = time.Time{}
                return nil
        }</span>

        <span class="cov8" title="1">t, ok := value.(time.Time)
        if !ok </span><span class="cov8" title="1">{
                return errors.New("failed to scan DateTime: value is not time.Time")
        }</span>

        <span class="cov8" title="1">d.Time = t.UTC()
        return nil</span>
}

func (d DateTime) Value() (driver.Value, error) <span class="cov8" title="1">{
        return d.Time.UTC(), nil
}</span>

func (d DateTime) String() string <span class="cov8" title="1">{
        return d.Time.Format(dateTimeFormat)
}</span>

func (d DateTime) BrazilDate() BrazilDate <span class="cov8" title="1">{
        return NewBrazilDate(d.Time)
}</span>

func (d DateTime) Add(duration time.Duration) DateTime <span class="cov8" title="1">{
        return DateTime{
                Time: d.Time.Add(duration),
        }
}</span>

func (d DateTime) Before(t DateTime) bool <span class="cov8" title="1">{
        return d.Time.Before(t.Time)
}</span>

// TODO.
// func (d DateTime) After(t DateTime) bool {
//         return d.Time.After(t.Time)
// }

func DateTimeNow() DateTime <span class="cov8" title="1">{
        return NewDateTime(now())
}</span>

func NewDateTime(t time.Time) DateTime <span class="cov8" title="1">{
        return DateTime{
                Time: t.In(time.UTC),
        }
}</span>

type BrazilDate struct {
        time.Time
}

func (d BrazilDate) AddDate(years int, months int, days int) BrazilDate <span class="cov8" title="1">{
        return BrazilDate{
                Time: d.Time.AddDate(years, months, days),
        }
}</span>

func (d BrazilDate) Equal(t BrazilDate) bool <span class="cov8" title="1">{
        return d.Time.Equal(t.Time)
}</span>

func (d BrazilDate) After(t BrazilDate) bool <span class="cov8" title="1">{
        return d.Time.After(t.Time)
}</span>

func (d BrazilDate) Before(t BrazilDate) bool <span class="cov8" title="1">{
        return d.Time.Before(t.Time)
}</span>

func (d BrazilDate) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(d.String())
}</span>

func (d *BrazilDate) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var dateStr string
        if err := json.Unmarshal(data, &amp;dateStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">parsed, err := time.ParseInLocation(dateFormat, dateStr, brazilLocation)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">d.Time = parsed
        return nil</span>
}

func (d BrazilDate) String() string <span class="cov8" title="1">{
        return d.Time.Format(dateFormat)
}</span>

func (d *BrazilDate) Scan(value any) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">t, ok := value.(time.Time)
        if !ok </span><span class="cov8" title="1">{
                return errors.New("failed to scan Date: value is not time.Time")
        }</span>

        <span class="cov8" title="1">d.Time = time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, brazilLocation)
        return nil</span>
}

func (d BrazilDate) Value() (driver.Value, error) <span class="cov8" title="1">{
        t := time.Date(d.Year(), d.Month(), d.Day(), 0, 0, 0, 0, brazilLocation)
        return t, nil
}</span>

// StartOfWeek returns a new BrazilDate representing the start of the current week (Monday).
func (d BrazilDate) StartOfWeek() BrazilDate <span class="cov8" title="1">{
        weekDay := int(d.Weekday())
        if weekDay == 0 </span><span class="cov8" title="1">{
                weekDay = 7
        }</span>
        <span class="cov8" title="1">daysSinceMonday := weekDay - 1
        return d.AddDate(0, 0, -daysSinceMonday)</span>
}

// EndOfWeek returns a new BrazilDate representing the end of the current week (Sunday).
func (d BrazilDate) EndOfWeek() BrazilDate <span class="cov8" title="1">{
        weekDay := int(d.Weekday())
        if weekDay == 0 </span><span class="cov8" title="1">{
                weekDay = 7
        }</span>
        <span class="cov8" title="1">return d.AddDate(0, 0, 7-weekDay)</span>
}

func (d BrazilDate) StartOfMonth() BrazilDate <span class="cov8" title="1">{
        return NewBrazilDate(time.Date(d.Year(), d.Month(), 1, 0, 0, 0, 0, d.Location()))
}</span>

func (d BrazilDate) EndOfMonth() BrazilDate <span class="cov8" title="1">{
        firstOfNextMonth := time.Date(d.Year(), d.Month()+1, 1, 0, 0, 0, 0, d.Location())
        return NewBrazilDate(firstOfNextMonth.AddDate(0, 0, -1))
}</span>

func (d BrazilDate) StartOfYear() BrazilDate <span class="cov8" title="1">{
        return NewBrazilDate(time.Date(d.Year(), 1, 1, 0, 0, 0, 0, d.Location()))
}</span>

func (d BrazilDate) EndOfYear() BrazilDate <span class="cov8" title="1">{
        return NewBrazilDate(time.Date(d.Year(), 12, 31, 0, 0, 0, 0, d.Location()))
}</span>

func BrazilDateNow() BrazilDate <span class="cov8" title="1">{
        return NewBrazilDate(now())
}</span>

func NewBrazilDate(t time.Time) BrazilDate <span class="cov8" title="1">{
        brTime := t.In(brazilLocation)
        return BrazilDate{
                Time: time.Date(brTime.Year(), brTime.Month(), brTime.Day(), 0, 0, 0, 0, brazilLocation),
        }
}</span>

// Now returns the current time in UTC.
func now() time.Time <span class="cov8" title="1">{
        return time.Now().UTC()
}</span>

// Timestamp returns the current Unix timestamp in seconds (UTC).
func Timestamp() int <span class="cov8" title="1">{
        return int(now().Unix())
}</span>

func ParseTimestamp(ts int) DateTime <span class="cov8" title="1">{
        return NewDateTime(time.Unix(int64(ts), 0))
}</span>
</pre>

		<pre class="file" id="file58" style="display: none">package user

import (
        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

type User struct {
        ID          uuid.UUID `gorm:"type:uuid;default:gen_random_uuid();primaryKey"`
        Username    string
        Name        string
        CPF         string
        CNPJ        *string
        Description *string

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (User) TableName() string <span class="cov8" title="1">{
        return "mock_users"
}</span>

type Query struct {
        ID       string
        Username string
        CPF      string
        CNPJ     string
}

type UserBusiness struct {
        UserID         uuid.UUID
        BusinessUserID uuid.UUID

        OrgID     string
        CreatedAt timeutil.DateTime
        UpdatedAt timeutil.DateTime
}

func (UserBusiness) TableName() string <span class="cov8" title="1">{
        return "mock_user_business"
}</span>
</pre>

		<pre class="file" id="file59" style="display: none">package user

import (
        "context"
        "errors"

        "gorm.io/gorm/clause"

        "github.com/google/uuid"
        "github.com/jackc/pgx/v5/pgconn"
        "github.com/luikyv/mock-bank/internal/page"
        "github.com/luikyv/mock-bank/internal/timeutil"
        "gorm.io/gorm"
)

type Service struct {
        db        *gorm.DB
        mockOrgID string
}

func NewService(db *gorm.DB, mockOrgID string) Service <span class="cov8" title="1">{
        return Service{db: db, mockOrgID: mockOrgID}
}</span>

func (s Service) Create(ctx context.Context, u *User) error <span class="cov8" title="1">{
        u.CreatedAt = timeutil.DateTimeNow()
        u.UpdatedAt = timeutil.DateTimeNow()
        if err := s.db.WithContext(ctx).Create(u).Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov8" title="1">var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s Service) Update(ctx context.Context, u *User) error <span class="cov8" title="1">{
        u.UpdatedAt = timeutil.DateTimeNow()
        tx := s.db.WithContext(ctx).
                Model(&amp;User{}).
                Omit("ID", "CreatedAt", "OrgID").
                Where("id = ?", u.ID).
                Updates(u)
        if err := tx.Error; err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrDuplicatedKey) </span><span class="cov0" title="0">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov0" title="0">{
                        return ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s Service) User(ctx context.Context, query Query, orgID string) (*User, error) <span class="cov8" title="1">{
        u := &amp;User{}
        dbQuery := s.db.WithContext(ctx).Where("org_id = ? OR org_id = ?", orgID, s.mockOrgID)
        if query.ID != "" </span><span class="cov8" title="1">{
                dbQuery = dbQuery.Where("id = ?", query.ID)
        }</span>
        <span class="cov8" title="1">if query.CPF != "" </span><span class="cov8" title="1">{
                dbQuery = dbQuery.Where("cpf = ?", query.CPF)
        }</span>
        <span class="cov8" title="1">if query.Username != "" </span><span class="cov8" title="1">{
                dbQuery = dbQuery.Where("username = ?", query.Username)
        }</span>
        <span class="cov8" title="1">if query.CNPJ != "" </span><span class="cov8" title="1">{
                dbQuery = dbQuery.Where("cnpj = ?", query.CNPJ)
        }</span>

        <span class="cov8" title="1">if err := dbQuery.First(u).Error; err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return u, nil</span>
}

func (s Service) Users(ctx context.Context, orgID string, pag page.Pagination) (page.Page[*User], error) <span class="cov8" title="1">{
        query := s.db.WithContext(ctx).Model(&amp;User{}).Where("org_id = ? OR org_id = ?", orgID, s.mockOrgID)

        var users []*User
        if err := query.
                Limit(pag.Limit()).
                Offset(pag.Offset()).
                Order("created_at DESC").
                Find(&amp;users).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*User]{}, err
        }</span>

        <span class="cov8" title="1">var total int64
        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return page.Page[*User]{}, err
        }</span>

        <span class="cov8" title="1">return page.New(users, pag, int(total)), nil</span>
}

func (s Service) Delete(ctx context.Context, id uuid.UUID, orgID string) error <span class="cov8" title="1">{
        return s.db.WithContext(ctx).Where("id = ? AND org_id = ?", id, orgID).Delete(&amp;User{}).Error
}</span>

func (s Service) UserBusiness(ctx context.Context, userID, cnpj, orgID string) (*User, error) <span class="cov8" title="1">{
        business, err := s.User(ctx, Query{CNPJ: cnpj}, orgID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if business.ID.String() == userID </span><span class="cov8" title="1">{
                return business, nil
        }</span>

        <span class="cov8" title="1">err = s.db.WithContext(ctx).
                Where("user_id = ? AND business_user_id = ? AND org_id = ?", userID, business.ID, business.OrgID).
                First(&amp;UserBusiness{}).Error
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, ErrUserDoesNotOwnBusiness
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">return business, nil</span>
}

func (s Service) BindUserToBusiness(ctx context.Context, userID, businessUserID uuid.UUID, orgID string) error <span class="cov8" title="1">{
        business, err := s.User(ctx, Query{ID: businessUserID.String()}, orgID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if business.OrgID != orgID </span><span class="cov8" title="1">{
                return ErrInvalidOrgID
        }</span>
        // TODO: check if business is a company.

        <span class="cov8" title="1">user, err := s.User(ctx, Query{ID: userID.String()}, orgID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if user.OrgID != orgID </span><span class="cov0" title="0">{
                return ErrInvalidOrgID
        }</span>

        <span class="cov8" title="1">userBusiness := &amp;UserBusiness{
                UserID:         userID,
                BusinessUserID: business.ID,
                OrgID:          orgID,
        }
        if err := s.db.WithContext(ctx).
                Clauses(clause.OnConflict{
                        Columns:   []clause.Column{{Name: "user_id"}, {Name: "business_user_id"}},
                        DoNothing: true,
                }).
                Create(userBusiness).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>

		<pre class="file" id="file60" style="display: none">package webhook

import (
        "bytes"
        "context"
        "encoding/json"
        "log/slog"
        "net/http"

        "github.com/google/uuid"
        "github.com/luikyv/mock-bank/internal/client"
        "github.com/luikyv/mock-bank/internal/timeutil"
)

const webhookInteractionIDHeader = "X-Webhook-Interaction-ID"

type Service struct {
        clientService client.Service
}

func NewService(clientService client.Service) Service <span class="cov0" title="0">{
        return Service{clientService: clientService}
}</span>

func (s Service) Notify(ctx context.Context, clientID, path string) <span class="cov0" title="0">{
        client, err := s.clientService.Client(ctx, clientID)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "failed to get client", "error", err)
                return
        }</span>

        <span class="cov0" title="0">if len(client.WebhookURIs) == 0 </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "client has no webhook uris")
                return
        }</span>
        <span class="cov0" title="0">webhookURI := client.WebhookURIs[0]

        data, err := json.Marshal(payload{
                Data: struct {
                        Timestamp timeutil.DateTime `json:"timestamp"`
                }{
                        Timestamp: timeutil.DateTimeNow(),
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "failed to marshal webhook payload", "error", err)
                return
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", webhookURI+path, bytes.NewBuffer(data))
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "failed to create request", "error", err)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set(webhookInteractionIDHeader, uuid.NewString())

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                slog.ErrorContext(ctx, "failed to notify client", "error", err)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode != http.StatusAccepted </span><span class="cov0" title="0">{
                slog.DebugContext(ctx, "failed to notify client", "status", resp.StatusCode)
                return
        }</span>

        <span class="cov0" title="0">slog.InfoContext(ctx, "client was notified", "status", resp.StatusCode)</span>
}

type payload struct {
        Data struct {
                Timestamp timeutil.DateTime `json:"timestamp"`
        } `json:"data"`
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
